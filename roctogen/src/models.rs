#![allow(clippy::all)]
/* 
 * GitHub v3 REST API
 *
 * GitHub's v3 REST API.
 *
 * OpenAPI spec version: 1.1.4
 * 
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 */

use serde::ser::Serializer;
use serde::de::{DeserializeOwned, Deserializer};
use serde::Deserialize;
use serde_json::value::Value;

use std::cmp::Eq;
use std::collections::HashMap;
use std::default::Default;
use std::fmt::{self, Formatter, Display};
use std::hash::Hash;

use chrono::DateTime;
use chrono::Utc;

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct ActionsBillingUsage {
    /// The sum of the free and paid GitHub Actions minutes used.
    #[serde(skip_serializing_if="Option::is_none")]
    pub total_minutes_used: Option<i64>,
    /// The total paid GitHub Actions minutes used.
    #[serde(skip_serializing_if="Option::is_none")]
    pub total_paid_minutes_used: Option<i64>,
    /// The amount of free GitHub Actions minutes available.
    #[serde(skip_serializing_if="Option::is_none")]
    pub included_minutes: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub minutes_used_breakdown: Option<ActionsbillingusageMinutesUsedBreakdown>,
}

/// Repository actions caches
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct ActionsCacheList {
    /// Total number of caches
    #[serde(skip_serializing_if="Option::is_none")]
    pub total_count: Option<i64>,
    /// Array of caches
    #[serde(skip_serializing_if="Option::is_none")]
    pub actions_caches: Option<Vec<ActionscachelistActionsCaches>>,
}

/// GitHub Actions Cache Usage by repository.
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct ActionsCacheUsageByRepository {
    /// The repository owner and name for the cache usage being shown.
    #[serde(skip_serializing_if="Option::is_none")]
    pub full_name: Option<String>,
    /// The sum of the size in bytes of all the active cache items in the repository.
    #[serde(skip_serializing_if="Option::is_none")]
    pub active_caches_size_in_bytes: Option<i64>,
    /// The number of active caches in the repository.
    #[serde(skip_serializing_if="Option::is_none")]
    pub active_caches_count: Option<i64>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct ActionsCacheUsageOrgEnterprise {
    /// The count of active caches across all repositories of an enterprise or an organization.
    #[serde(skip_serializing_if="Option::is_none")]
    pub total_active_caches_count: Option<i64>,
    /// The total size in bytes of all active cache items across all repositories of an enterprise or an organization.
    #[serde(skip_serializing_if="Option::is_none")]
    pub total_active_caches_size_in_bytes: Option<i64>,
}

/// Whether GitHub Actions can approve pull requests. Enabling this can be a security risk.
pub type ActionsCanApprovePullRequestReviews = bool;

/// The default workflow permissions granted to the GITHUB_TOKEN when running workflows.
/// Enumeration of values.
/// Since this enum's variants do not hold data, we can easily define them them as `#[repr(C)]`
/// which helps with FFI.
#[allow(non_camel_case_types)]
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq, PartialOrd, Serialize, Deserialize, Eq, Ord)]
pub enum ActionsDefaultWorkflowPermissions { 
    #[serde(rename = "read")]
    READ,
    #[serde(rename = "write")]
    WRITE,
}

impl Display for ActionsDefaultWorkflowPermissions {
    fn fmt(&self, f: &mut Formatter) -> fmt::Result {
        match *self { 
            ActionsDefaultWorkflowPermissions::READ => write!(f, "{}", "read"),
            ActionsDefaultWorkflowPermissions::WRITE => write!(f, "{}", "write"),
        }
    }
}

impl std::str::FromStr for ActionsDefaultWorkflowPermissions {
    type Err = ();
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s {
            "read" => Ok(ActionsDefaultWorkflowPermissions::READ),
            "write" => Ok(ActionsDefaultWorkflowPermissions::WRITE),
            _ => Err(()),
        }
    }
}

/// Whether GitHub Actions is enabled on the repository.
pub type ActionsEnabled = bool;

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct ActionsGetDefaultWorkflowPermissions {
    #[serde(skip_serializing_if="Option::is_none")]
    pub default_workflow_permissions: Option<ActionsDefaultWorkflowPermissions>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub can_approve_pull_request_reviews: Option<ActionsCanApprovePullRequestReviews>,
}

/// A Github-hosted hosted runner.
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct ActionsHostedRunner {
    /// The unique identifier of the hosted runner.
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<i64>,
    /// The name of the hosted runner.
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,
    /// The unique identifier of the group that the hosted runner belongs to.
    #[serde(skip_serializing_if="Option::is_none")]
    pub runner_group_id: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub image_details: Option<NullableActionsHostedRunnerPoolImage>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub machine_size_details: Option<ActionsHostedRunnerMachineSpec>,
    /// The status of the runner.
    #[serde(skip_serializing_if="Option::is_none")]
    pub status: Option<String>,
    /// The operating system of the image.
    #[serde(skip_serializing_if="Option::is_none")]
    pub platform: Option<String>,
    /// The maximum amount of hosted runners. Runners will not scale automatically above this number. Use this setting to limit your cost.
    #[serde(skip_serializing_if="Option::is_none")]
    pub maximum_runners: Option<i64>,
    /// Whether public IP is enabled for the hosted runners.
    #[serde(skip_serializing_if="Option::is_none")]
    pub public_ip_enabled: Option<bool>,
    /// The public IP ranges when public IP is enabled for the hosted runners.
    #[serde(skip_serializing_if="Option::is_none")]
    pub public_ips: Option<Vec<PublicIp>>,
    /// The time at which the runner was last used, in ISO 8601 format.
    #[serde(skip_serializing_if="Option::is_none")]
    pub last_active_on: Option<chrono::DateTime<chrono::Utc>>,
}

/// Provides details of a hosted runner image
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct ActionsHostedRunnerImage {
    /// The ID of the image. Use this ID for the `image` parameter when creating a new larger runner.
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<String>,
    /// The operating system of the image.
    #[serde(skip_serializing_if="Option::is_none")]
    pub platform: Option<String>,
    /// Image size in GB.
    #[serde(skip_serializing_if="Option::is_none")]
    pub size_gb: Option<i64>,
    /// Display name for this image.
    #[serde(skip_serializing_if="Option::is_none")]
    pub display_name: Option<String>,
    /// The image provider.
    #[serde(skip_serializing_if="Option::is_none")]
    pub source: Option<String>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct ActionsHostedRunnerLimits {
    #[serde(skip_serializing_if="Option::is_none")]
    pub public_ips: Option<StaticPublicIpLimitsForGitHubhostedHostedRunners_>,
}

/// Provides details of a particular machine spec.
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct ActionsHostedRunnerMachineSpec {
    /// The ID used for the `size` parameter when creating a new runner.
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<String>,
    /// The number of cores.
    #[serde(skip_serializing_if="Option::is_none")]
    pub cpu_cores: Option<i64>,
    /// The available RAM for the machine spec.
    #[serde(skip_serializing_if="Option::is_none")]
    pub memory_gb: Option<i64>,
    /// The available SSD storage for the machine spec.
    #[serde(skip_serializing_if="Option::is_none")]
    pub storage_gb: Option<i64>,
}

/// Actions OIDC subject customization for a repository
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct ActionsOidcSubjectCustomizationForARepository {
    /// Whether to use the default template or not. If `true`, the `include_claim_keys` field is ignored.
    #[serde(skip_serializing_if="Option::is_none")]
    pub use_default: Option<bool>,
    /// Array of unique strings. Each claim key can only contain alphanumeric characters and underscores.
    #[serde(skip_serializing_if="Option::is_none")]
    pub include_claim_keys: Option<Vec<String>>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct ActionsOrganizationPermissions {
    #[serde(skip_serializing_if="Option::is_none")]
    pub enabled_repositories: Option<EnabledRepositories>,
    /// The API URL to use to get or set the selected repositories that are allowed to run GitHub Actions, when `enabled_repositories` is set to `selected`.
    #[serde(skip_serializing_if="Option::is_none")]
    pub selected_repositories_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub allowed_actions: Option<AllowedActions>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub selected_actions_url: Option<SelectedActionsUrl>,
}

/// The public key used for setting Actions Secrets.
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct ActionsPublicKey {
    /// The identifier for the key.
    #[serde(skip_serializing_if="Option::is_none")]
    pub key_id: Option<String>,
    /// The Base64 encoded public key.
    #[serde(skip_serializing_if="Option::is_none")]
    pub key: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub title: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub created_at: Option<String>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct ActionsRepositoryPermissions {
    #[serde(skip_serializing_if="Option::is_none")]
    pub enabled: Option<ActionsEnabled>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub allowed_actions: Option<AllowedActions>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub selected_actions_url: Option<SelectedActionsUrl>,
}

/// Set secrets for GitHub Actions.
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct ActionsSecret {
    /// The name of the secret.
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub updated_at: Option<chrono::DateTime<chrono::Utc>>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct PutActionsSetGithubActionsDefaultWorkflowPermissionsRepository {
    #[serde(skip_serializing_if="Option::is_none")]
    pub default_workflow_permissions: Option<ActionsDefaultWorkflowPermissions>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub can_approve_pull_request_reviews: Option<ActionsCanApprovePullRequestReviews>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct ActionsVariable {
    /// The name of the variable.
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,
    /// The value of the variable.
    #[serde(skip_serializing_if="Option::is_none")]
    pub value: Option<String>,
    /// The date and time at which the variable was created, in ISO 8601 format':' YYYY-MM-DDTHH:MM:SSZ.
    #[serde(skip_serializing_if="Option::is_none")]
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The date and time at which the variable was last updated, in ISO 8601 format':' YYYY-MM-DDTHH:MM:SSZ.
    #[serde(skip_serializing_if="Option::is_none")]
    pub updated_at: Option<chrono::DateTime<chrono::Utc>>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct ActionsWorkflowAccessToRepository {
    /// Defines the level of access that workflows outside of the repository have to actions and reusable workflows within the repository.  `none` means the access is only possible from workflows in this repository. `user` level access allows sharing across user owned private repositories only. `organization` level access allows sharing across the organization.
    #[serde(skip_serializing_if="Option::is_none")]
    pub access_level: Option<String>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct ActionsbillingusageMinutesUsedBreakdown {
    /// Total minutes used on Ubuntu runner machines.
    #[serde(rename = "UBUNTU")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub ubuntu: Option<i64>,
    /// Total minutes used on macOS runner machines.
    #[serde(rename = "MACOS")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub macos: Option<i64>,
    /// Total minutes used on Windows runner machines.
    #[serde(rename = "WINDOWS")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub windows: Option<i64>,
    /// Total minutes used on Ubuntu 4 core runner machines.
    #[serde(skip_serializing_if="Option::is_none")]
    pub ubuntu_4_core: Option<i64>,
    /// Total minutes used on Ubuntu 8 core runner machines.
    #[serde(skip_serializing_if="Option::is_none")]
    pub ubuntu_8_core: Option<i64>,
    /// Total minutes used on Ubuntu 16 core runner machines.
    #[serde(skip_serializing_if="Option::is_none")]
    pub ubuntu_16_core: Option<i64>,
    /// Total minutes used on Ubuntu 32 core runner machines.
    #[serde(skip_serializing_if="Option::is_none")]
    pub ubuntu_32_core: Option<i64>,
    /// Total minutes used on Ubuntu 64 core runner machines.
    #[serde(skip_serializing_if="Option::is_none")]
    pub ubuntu_64_core: Option<i64>,
    /// Total minutes used on Windows 4 core runner machines.
    #[serde(skip_serializing_if="Option::is_none")]
    pub windows_4_core: Option<i64>,
    /// Total minutes used on Windows 8 core runner machines.
    #[serde(skip_serializing_if="Option::is_none")]
    pub windows_8_core: Option<i64>,
    /// Total minutes used on Windows 16 core runner machines.
    #[serde(skip_serializing_if="Option::is_none")]
    pub windows_16_core: Option<i64>,
    /// Total minutes used on Windows 32 core runner machines.
    #[serde(skip_serializing_if="Option::is_none")]
    pub windows_32_core: Option<i64>,
    /// Total minutes used on Windows 64 core runner machines.
    #[serde(skip_serializing_if="Option::is_none")]
    pub windows_64_core: Option<i64>,
    /// Total minutes used on macOS 12 core runner machines.
    #[serde(skip_serializing_if="Option::is_none")]
    pub macos_12_core: Option<i64>,
    /// Total minutes used on all runner machines.
    #[serde(skip_serializing_if="Option::is_none")]
    pub total: Option<i64>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct ActionscachelistActionsCaches {
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<i64>,
    #[serde(rename = "ref")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub git_ref: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub key: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub version: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub last_accessed_at: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub size_in_bytes: Option<i64>,
}

/// Activity
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct Activity {
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub node_id: Option<String>,
    /// The SHA of the commit before the activity.
    #[serde(skip_serializing_if="Option::is_none")]
    pub before: Option<String>,
    /// The SHA of the commit after the activity.
    #[serde(skip_serializing_if="Option::is_none")]
    pub after: Option<String>,
    /// The full Git reference, formatted as `refs/heads/<branch name>`.
    #[serde(rename = "ref")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub git_ref: Option<String>,
    /// The time when the activity occurred.
    #[serde(skip_serializing_if="Option::is_none")]
    pub timestamp: Option<chrono::DateTime<chrono::Utc>>,
    /// The type of the activity that was performed.
    #[serde(skip_serializing_if="Option::is_none")]
    pub activity_type: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub actor: Option<NullableSimpleUser>,
}

/// Actor
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct Actor {
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub login: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub display_login: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub gravatar_id: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub avatar_url: Option<String>,
}

/// Added to Project Issue Event
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct AddedToProjectIssueEvent {
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub node_id: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub actor: Option<SimpleUser>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub event: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub commit_id: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub commit_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub created_at: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub performed_via_github_app: Option<NullableIntegration>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub project_card: Option<AddedtoprojectissueeventProjectCard>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct AddedtoprojectissueeventProjectCard {
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub project_id: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub project_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub column_name: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub previous_column_name: Option<String>,
}

#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
#[serde(untagged)]
pub enum Affects { 
    AffectsVariant0(String),
    AffectsVariant1(Vec<String>),
}

impl From<String> for Affects {
    fn from(value: String) -> Self {
        Affects::AffectsVariant0(value)
    }
}

impl From<Vec<String>> for Affects {
    fn from(value: Vec<String>) -> Self {
        Affects::AffectsVariant1(value)
    }
}

/// The time that the alert was auto-dismissed in ISO 8601 format: `YYYY-MM-DDTHH:MM:SSZ`.
pub type AlertAutoDismissedAt = DateTime<Utc>;

/// The time that the alert was created in ISO 8601 format: `YYYY-MM-DDTHH:MM:SSZ`.
pub type AlertCreatedAt = DateTime<Utc>;

/// The time that the alert was dismissed in ISO 8601 format: `YYYY-MM-DDTHH:MM:SSZ`.
pub type AlertDismissedAt = DateTime<Utc>;

/// The time that the alert was no longer detected and was considered fixed in ISO 8601 format: `YYYY-MM-DDTHH:MM:SSZ`.
pub type AlertFixedAt = DateTime<Utc>;

/// The GitHub URL of the alert resource.
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct AlertHtmlUrl {
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct AlertInstance {
    /// Identifies the configuration under which the analysis was executed. For example, in GitHub Actions this includes the workflow filename and job name.
    #[serde(skip_serializing_if="Option::is_none")]
    pub analysis_key: Option<String>,
    /// Identifies the configuration under which the analysis was executed.
    #[serde(skip_serializing_if="Option::is_none")]
    pub category: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub classifications: Option<Vec<String>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub commit_sha: Option<String>,
    /// Identifies the variable values associated with the environment in which the analysis that generated this alert instance was performed, such as the language that was analyzed.
    #[serde(skip_serializing_if="Option::is_none")]
    pub environment: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub location: Option<AlertInstanceLocation>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub message: Option<CodescanningalertinstanceMessage>,
    /// The full Git reference, formatted as `refs/heads/<branch name>`.
    #[serde(rename = "ref")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub git_ref: Option<String>,
    /// State of a code scanning alert.
    #[serde(skip_serializing_if="Option::is_none")]
    pub state: Option<String>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct AlertInstanceLocation {
    #[serde(skip_serializing_if="Option::is_none")]
    pub end_column: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub end_line: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub path: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub start_column: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub start_line: Option<i64>,
}

/// The REST API URL for fetching the list of instances for an alert.
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct AlertInstancesUrl {
}

/// The security alert number.
pub type AlertNumber = i32;

/// The time that the alert was last updated in ISO 8601 format: `YYYY-MM-DDTHH:MM:SSZ`.
pub type AlertUpdatedAt = DateTime<Utc>;

/// The REST API URL of the alert resource.
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct AlertUrl {
}

/// The author of the advisory.
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct AllOfrepositoryAdvisoryAuthor {
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub email: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub login: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub node_id: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub avatar_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub gravatar_id: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub html_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub followers_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub following_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub gists_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub starred_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub subscriptions_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub organizations_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub repos_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub events_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub received_events_url: Option<String>,
    #[serde(rename = "type")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub _type: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub site_admin: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub starred_at: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub user_view_type: Option<String>,
}

/// A temporary private fork of the advisory's repository for collaborating on a fix.
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct AllOfrepositoryAdvisoryPrivateFork {
    /// A unique identifier of the repository.
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<i64>,
    /// The GraphQL identifier of the repository.
    #[serde(skip_serializing_if="Option::is_none")]
    pub node_id: Option<String>,
    /// The name of the repository.
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,
    /// The full, globally unique, name of the repository.
    #[serde(skip_serializing_if="Option::is_none")]
    pub full_name: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub owner: Option<SimpleUser>,
    /// Whether the repository is private.
    #[serde(skip_serializing_if="Option::is_none")]
    pub private: Option<bool>,
    /// The URL to view the repository on GitHub.com.
    #[serde(skip_serializing_if="Option::is_none")]
    pub html_url: Option<String>,
    /// The repository description.
    #[serde(skip_serializing_if="Option::is_none")]
    pub description: Option<String>,
    /// Whether the repository is a fork.
    #[serde(skip_serializing_if="Option::is_none")]
    pub fork: Option<bool>,
    /// The URL to get more information about the repository from the GitHub API.
    #[serde(skip_serializing_if="Option::is_none")]
    pub url: Option<String>,
    /// A template for the API URL to download the repository as an archive.
    #[serde(skip_serializing_if="Option::is_none")]
    pub archive_url: Option<String>,
    /// A template for the API URL to list the available assignees for issues in the repository.
    #[serde(skip_serializing_if="Option::is_none")]
    pub assignees_url: Option<String>,
    /// A template for the API URL to create or retrieve a raw Git blob in the repository.
    #[serde(skip_serializing_if="Option::is_none")]
    pub blobs_url: Option<String>,
    /// A template for the API URL to get information about branches in the repository.
    #[serde(skip_serializing_if="Option::is_none")]
    pub branches_url: Option<String>,
    /// A template for the API URL to get information about collaborators of the repository.
    #[serde(skip_serializing_if="Option::is_none")]
    pub collaborators_url: Option<String>,
    /// A template for the API URL to get information about comments on the repository.
    #[serde(skip_serializing_if="Option::is_none")]
    pub comments_url: Option<String>,
    /// A template for the API URL to get information about commits on the repository.
    #[serde(skip_serializing_if="Option::is_none")]
    pub commits_url: Option<String>,
    /// A template for the API URL to compare two commits or refs.
    #[serde(skip_serializing_if="Option::is_none")]
    pub compare_url: Option<String>,
    /// A template for the API URL to get the contents of the repository.
    #[serde(skip_serializing_if="Option::is_none")]
    pub contents_url: Option<String>,
    /// A template for the API URL to list the contributors to the repository.
    #[serde(skip_serializing_if="Option::is_none")]
    pub contributors_url: Option<String>,
    /// The API URL to list the deployments of the repository.
    #[serde(skip_serializing_if="Option::is_none")]
    pub deployments_url: Option<String>,
    /// The API URL to list the downloads on the repository.
    #[serde(skip_serializing_if="Option::is_none")]
    pub downloads_url: Option<String>,
    /// The API URL to list the events of the repository.
    #[serde(skip_serializing_if="Option::is_none")]
    pub events_url: Option<String>,
    /// The API URL to list the forks of the repository.
    #[serde(skip_serializing_if="Option::is_none")]
    pub forks_url: Option<String>,
    /// A template for the API URL to get information about Git commits of the repository.
    #[serde(skip_serializing_if="Option::is_none")]
    pub git_commits_url: Option<String>,
    /// A template for the API URL to get information about Git refs of the repository.
    #[serde(skip_serializing_if="Option::is_none")]
    pub git_refs_url: Option<String>,
    /// A template for the API URL to get information about Git tags of the repository.
    #[serde(skip_serializing_if="Option::is_none")]
    pub git_tags_url: Option<String>,
    /// A template for the API URL to get information about issue comments on the repository.
    #[serde(skip_serializing_if="Option::is_none")]
    pub issue_comment_url: Option<String>,
    /// A template for the API URL to get information about issue events on the repository.
    #[serde(skip_serializing_if="Option::is_none")]
    pub issue_events_url: Option<String>,
    /// A template for the API URL to get information about issues on the repository.
    #[serde(skip_serializing_if="Option::is_none")]
    pub issues_url: Option<String>,
    /// A template for the API URL to get information about deploy keys on the repository.
    #[serde(skip_serializing_if="Option::is_none")]
    pub keys_url: Option<String>,
    /// A template for the API URL to get information about labels of the repository.
    #[serde(skip_serializing_if="Option::is_none")]
    pub labels_url: Option<String>,
    /// The API URL to get information about the languages of the repository.
    #[serde(skip_serializing_if="Option::is_none")]
    pub languages_url: Option<String>,
    /// The API URL to merge branches in the repository.
    #[serde(skip_serializing_if="Option::is_none")]
    pub merges_url: Option<String>,
    /// A template for the API URL to get information about milestones of the repository.
    #[serde(skip_serializing_if="Option::is_none")]
    pub milestones_url: Option<String>,
    /// A template for the API URL to get information about notifications on the repository.
    #[serde(skip_serializing_if="Option::is_none")]
    pub notifications_url: Option<String>,
    /// A template for the API URL to get information about pull requests on the repository.
    #[serde(skip_serializing_if="Option::is_none")]
    pub pulls_url: Option<String>,
    /// A template for the API URL to get information about releases on the repository.
    #[serde(skip_serializing_if="Option::is_none")]
    pub releases_url: Option<String>,
    /// The API URL to list the stargazers on the repository.
    #[serde(skip_serializing_if="Option::is_none")]
    pub stargazers_url: Option<String>,
    /// A template for the API URL to get information about statuses of a commit.
    #[serde(skip_serializing_if="Option::is_none")]
    pub statuses_url: Option<String>,
    /// The API URL to list the subscribers on the repository.
    #[serde(skip_serializing_if="Option::is_none")]
    pub subscribers_url: Option<String>,
    /// The API URL to subscribe to notifications for this repository.
    #[serde(skip_serializing_if="Option::is_none")]
    pub subscription_url: Option<String>,
    /// The API URL to get information about tags on the repository.
    #[serde(skip_serializing_if="Option::is_none")]
    pub tags_url: Option<String>,
    /// The API URL to list the teams on the repository.
    #[serde(skip_serializing_if="Option::is_none")]
    pub teams_url: Option<String>,
    /// A template for the API URL to create or retrieve a raw Git tree of the repository.
    #[serde(skip_serializing_if="Option::is_none")]
    pub trees_url: Option<String>,
    /// The API URL to list the hooks on the repository.
    #[serde(skip_serializing_if="Option::is_none")]
    pub hooks_url: Option<String>,
}

/// The publisher of the advisory.
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct AllOfrepositoryAdvisoryPublisher {
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub email: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub login: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub node_id: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub avatar_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub gravatar_id: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub html_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub followers_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub following_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub gists_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub starred_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub subscriptions_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub organizations_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub repos_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub events_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub received_events_url: Option<String>,
    #[serde(rename = "type")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub _type: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub site_admin: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub starred_at: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub user_view_type: Option<String>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct AllOfsecretScanningScanHistoryCustomPatternBackfillScansItems {
    /// The type of scan
    #[serde(rename = "type")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub _type: Option<String>,
    /// The state of the scan. Either \"completed\", \"running\", or \"pending\"
    #[serde(skip_serializing_if="Option::is_none")]
    pub status: Option<String>,
    /// The time that the scan was completed. Empty if the scan is running
    #[serde(skip_serializing_if="Option::is_none")]
    pub completed_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The time that the scan was started. Empty if the scan is pending
    #[serde(skip_serializing_if="Option::is_none")]
    pub started_at: Option<chrono::DateTime<chrono::Utc>>,
    /// Name of the custom pattern for custom pattern scans
    #[serde(skip_serializing_if="Option::is_none")]
    pub pattern_name: Option<String>,
    /// Level at which the custom pattern is defined, one of \"repository\", \"organization\", or \"enterprise\"
    #[serde(skip_serializing_if="Option::is_none")]
    pub pattern_scope: Option<String>,
}

/// The created [`repository`](https://docs.github.com/rest/repos/repos#get-a-repository) resource.
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct AllOfwebhookForkForkee {
    #[serde(skip_serializing_if="Option::is_none")]
    pub allow_forking: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub archive_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub archived: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub assignees_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub blobs_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub branches_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub clone_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub collaborators_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub comments_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub commits_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub compare_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub contents_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub contributors_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub created_at: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub default_branch: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub deployments_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub description: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub disabled: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub downloads_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub events_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub fork: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub forks: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub forks_count: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub forks_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub full_name: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub git_commits_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub git_refs_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub git_tags_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub git_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub has_downloads: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub has_issues: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub has_pages: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub has_projects: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub has_wiki: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub homepage: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub hooks_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub html_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub is_template: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub issue_comment_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub issue_events_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub issues_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub keys_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub labels_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub language: Option<Value>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub languages_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub license: Option<HashMap<String, Value>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub merges_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub milestones_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub mirror_url: Option<Value>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub node_id: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub notifications_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub open_issues: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub open_issues_count: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub owner: Option<HashMap<String, Value>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub private: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub public: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub pulls_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub pushed_at: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub releases_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub size: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub ssh_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub stargazers_count: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub stargazers_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub statuses_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub subscribers_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub subscription_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub svn_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub tags_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub teams_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub topics: Option<Vec<Value>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub trees_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub updated_at: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub visibility: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub watchers: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub watchers_count: Option<i64>,
}

/// The [issue](https://docs.github.com/rest/issues/issues#get-an-issue) the comment belongs to.
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct AllOfwebhookIssueCommentCreatedIssue {
    #[serde(skip_serializing_if="Option::is_none")]
    pub active_lock_reason: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub assignee: Option<HashMap<String, Value>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub assignees: Option<Vec<Value>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub author_association: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub body: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub closed_at: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub comments: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub comments_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub created_at: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub events_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub html_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub labels: Option<Vec<Value>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub labels_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub locked: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub milestone: Option<HashMap<String, Value>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub node_id: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub number: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub performed_via_github_app: Option<HashMap<String, Value>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub reactions: Option<HashMap<String, Value>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub repository_url: Option<String>,
    /// State of the issue; either 'open' or 'closed'
    #[serde(skip_serializing_if="Option::is_none")]
    pub state: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub timeline_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub title: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub updated_at: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub user: Option<HashMap<String, Value>>,
}

/// The [issue](https://docs.github.com/rest/issues/issues#get-an-issue) the comment belongs to.
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct AllOfwebhookIssueCommentDeletedIssue {
    #[serde(skip_serializing_if="Option::is_none")]
    pub active_lock_reason: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub assignee: Option<HashMap<String, Value>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub assignees: Option<Vec<Value>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub author_association: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub body: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub closed_at: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub comments: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub comments_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub created_at: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub events_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub html_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub labels: Option<Vec<Value>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub labels_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub locked: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub milestone: Option<HashMap<String, Value>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub node_id: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub number: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub performed_via_github_app: Option<HashMap<String, Value>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub reactions: Option<HashMap<String, Value>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub repository_url: Option<String>,
    /// State of the issue; either 'open' or 'closed'
    #[serde(skip_serializing_if="Option::is_none")]
    pub state: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub timeline_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub title: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub updated_at: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub user: Option<HashMap<String, Value>>,
}

/// The [issue](https://docs.github.com/rest/issues/issues#get-an-issue) the comment belongs to.
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct AllOfwebhookIssueCommentEditedIssue {
    #[serde(skip_serializing_if="Option::is_none")]
    pub active_lock_reason: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub assignee: Option<HashMap<String, Value>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub assignees: Option<Vec<Value>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub author_association: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub body: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub closed_at: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub comments: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub comments_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub created_at: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub events_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub html_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub labels: Option<Vec<Value>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub labels_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub locked: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub milestone: Option<HashMap<String, Value>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub node_id: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub number: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub performed_via_github_app: Option<HashMap<String, Value>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub reactions: Option<HashMap<String, Value>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub repository_url: Option<String>,
    /// State of the issue; either 'open' or 'closed'
    #[serde(skip_serializing_if="Option::is_none")]
    pub state: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub timeline_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub title: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub updated_at: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub user: Option<HashMap<String, Value>>,
}

/// The [issue](https://docs.github.com/rest/issues/issues#get-an-issue) itself.
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct AllOfwebhookIssuesClosedIssue {
    #[serde(skip_serializing_if="Option::is_none")]
    pub active_lock_reason: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub assignee: Option<HashMap<String, Value>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub assignees: Option<Vec<Value>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub author_association: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub body: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub closed_at: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub comments: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub comments_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub created_at: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub events_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub html_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub labels: Option<Vec<Value>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub labels_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub locked: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub milestone: Option<HashMap<String, Value>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub node_id: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub number: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub performed_via_github_app: Option<HashMap<String, Value>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub reactions: Option<HashMap<String, Value>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub repository_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub state: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub timeline_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub title: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub updated_at: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub user: Option<HashMap<String, Value>>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct AllOfwebhookProjectCardMovedProjectCard {
    #[serde(skip_serializing_if="Option::is_none")]
    pub after_id: Option<f64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub archived: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub column_id: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub column_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub created_at: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub creator: Option<HashMap<String, Value>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub node_id: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub note: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub project_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub updated_at: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub url: Option<String>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct AllOfwebhookWorkflowJobCompletedWorkflowJob {
    #[serde(skip_serializing_if="Option::is_none")]
    pub check_run_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub completed_at: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub conclusion: Option<String>,
    /// The time that the job created.
    #[serde(skip_serializing_if="Option::is_none")]
    pub created_at: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub head_sha: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub html_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub labels: Option<Vec<String>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub node_id: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub run_attempt: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub run_id: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub run_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub runner_group_id: Option<f64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub runner_group_name: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub runner_id: Option<f64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub runner_name: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub started_at: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub status: Option<String>,
    /// The name of the current branch.
    #[serde(skip_serializing_if="Option::is_none")]
    pub head_branch: Option<String>,
    /// The name of the workflow.
    #[serde(skip_serializing_if="Option::is_none")]
    pub workflow_name: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub steps: Option<Vec<Value>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub url: Option<String>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct AllOfwebhookWorkflowJobInProgressWorkflowJob {
    #[serde(skip_serializing_if="Option::is_none")]
    pub check_run_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub completed_at: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub conclusion: Option<String>,
    /// The time that the job created.
    #[serde(skip_serializing_if="Option::is_none")]
    pub created_at: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub head_sha: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub html_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub labels: Option<Vec<String>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub node_id: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub run_attempt: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub run_id: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub run_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub runner_group_id: Option<f64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub runner_group_name: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub runner_id: Option<f64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub runner_name: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub started_at: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub status: Option<String>,
    /// The name of the current branch.
    #[serde(skip_serializing_if="Option::is_none")]
    pub head_branch: Option<String>,
    /// The name of the workflow.
    #[serde(skip_serializing_if="Option::is_none")]
    pub workflow_name: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub steps: Option<Vec<Value>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub url: Option<String>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct AllOfwebhookstatusCommit1CommitAuthor {
    #[serde(skip_serializing_if="Option::is_none")]
    pub date: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub email: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct AllOfwebhookstatusCommit1CommitCommitter {
    #[serde(skip_serializing_if="Option::is_none")]
    pub date: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub email: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,
}

/// The permissions policy that controls the actions and reusable workflows that are allowed to run.
/// Enumeration of values.
/// Since this enum's variants do not hold data, we can easily define them them as `#[repr(C)]`
/// which helps with FFI.
#[allow(non_camel_case_types)]
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq, PartialOrd, Serialize, Deserialize, Eq, Ord)]
pub enum AllowedActions { 
    #[serde(rename = "all")]
    ALL,
    #[serde(rename = "local_only")]
    LOCAL_ONLY,
    #[serde(rename = "selected")]
    SELECTED,
}

impl Display for AllowedActions {
    fn fmt(&self, f: &mut Formatter) -> fmt::Result {
        match *self { 
            AllowedActions::ALL => write!(f, "{}", "all"),
            AllowedActions::LOCAL_ONLY => write!(f, "{}", "local_only"),
            AllowedActions::SELECTED => write!(f, "{}", "selected"),
        }
    }
}

impl std::str::FromStr for AllowedActions {
    type Err = ();
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s {
            "all" => Ok(AllowedActions::ALL),
            "local_only" => Ok(AllowedActions::LOCAL_ONLY),
            "selected" => Ok(AllowedActions::SELECTED),
            _ => Err(()),
        }
    }
}

#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AnyOfbody186Source { 
    AnyOfbody186SourceVariant0(String),
    AnyOfbody186SourceVariant1(HashMap<String, Value>),
}

impl From<String> for AnyOfbody186Source {
    fn from(value: String) -> Self {
        AnyOfbody186Source::AnyOfbody186SourceVariant0(value)
    }
}

impl From<HashMap<String, Value>> for AnyOfbody186Source {
    fn from(value: HashMap<String, Value>) -> Self {
        AnyOfbody186Source::AnyOfbody186SourceVariant1(value)
    }
}

#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AnyOfbody233SelectedRepositoryIdsItems { 
    AnyOfbody233SelectedRepositoryIdsItemsVariant0(i32),
    AnyOfbody233SelectedRepositoryIdsItemsVariant1(String),
}

impl From<i32> for AnyOfbody233SelectedRepositoryIdsItems {
    fn from(value: i32) -> Self {
        AnyOfbody233SelectedRepositoryIdsItems::AnyOfbody233SelectedRepositoryIdsItemsVariant0(value)
    }
}

impl From<String> for AnyOfbody233SelectedRepositoryIdsItems {
    fn from(value: String) -> Self {
        AnyOfbody233SelectedRepositoryIdsItems::AnyOfbody233SelectedRepositoryIdsItemsVariant1(value)
    }
}

#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AnyOfenvironmentProtectionRulesItems { 
    AnyOfenvironmentProtectionRulesItemsVariant0(HashMap<String, Value>),
}

impl From<HashMap<String, Value>> for AnyOfenvironmentProtectionRulesItems {
    fn from(value: HashMap<String, Value>) -> Self {
        AnyOfenvironmentProtectionRulesItems::AnyOfenvironmentProtectionRulesItemsVariant0(value)
    }
}

#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AnyOfinstallationAccount { 
    AnyOfinstallationAccountVariant0(SimpleUser),
    AnyOfinstallationAccountVariant1(Enterprise),
}

impl From<SimpleUser> for AnyOfinstallationAccount {
    fn from(value: SimpleUser) -> Self {
        AnyOfinstallationAccount::AnyOfinstallationAccountVariant0(value)
    }
}

impl From<Enterprise> for AnyOfinstallationAccount {
    fn from(value: Enterprise) -> Self {
        AnyOfinstallationAccount::AnyOfinstallationAccountVariant1(value)
    }
}

#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AnyOfintegrationInstallationRequestAccount { 
    AnyOfintegrationInstallationRequestAccountVariant0(SimpleUser),
    AnyOfintegrationInstallationRequestAccountVariant1(Enterprise),
}

impl From<SimpleUser> for AnyOfintegrationInstallationRequestAccount {
    fn from(value: SimpleUser) -> Self {
        AnyOfintegrationInstallationRequestAccount::AnyOfintegrationInstallationRequestAccountVariant0(value)
    }
}

impl From<Enterprise> for AnyOfintegrationInstallationRequestAccount {
    fn from(value: Enterprise) -> Self {
        AnyOfintegrationInstallationRequestAccount::AnyOfintegrationInstallationRequestAccountVariant1(value)
    }
}

#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AnyOfpendingdeploymentReviewersReviewer { 
    AnyOfpendingdeploymentReviewersReviewerVariant0(SimpleUser),
    AnyOfpendingdeploymentReviewersReviewerVariant1(Team),
}

impl From<SimpleUser> for AnyOfpendingdeploymentReviewersReviewer {
    fn from(value: SimpleUser) -> Self {
        AnyOfpendingdeploymentReviewersReviewer::AnyOfpendingdeploymentReviewersReviewerVariant0(value)
    }
}

impl From<Team> for AnyOfpendingdeploymentReviewersReviewer {
    fn from(value: Team) -> Self {
        AnyOfpendingdeploymentReviewersReviewer::AnyOfpendingdeploymentReviewersReviewerVariant1(value)
    }
}

#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AnyOfrepositoryRulesetConditions { 
    AnyOfrepositoryRulesetConditionsVariant0(RepositoryRulesetConditions),
    AnyOfrepositoryRulesetConditionsVariant1(OrgRulesetConditions),
}

impl From<RepositoryRulesetConditions> for AnyOfrepositoryRulesetConditions {
    fn from(value: RepositoryRulesetConditions) -> Self {
        AnyOfrepositoryRulesetConditions::AnyOfrepositoryRulesetConditionsVariant0(value)
    }
}

impl From<OrgRulesetConditions> for AnyOfrepositoryRulesetConditions {
    fn from(value: OrgRulesetConditions) -> Self {
        AnyOfrepositoryRulesetConditions::AnyOfrepositoryRulesetConditionsVariant1(value)
    }
}

/// API Insights usage route stats for an actor
pub type ApiInsightsRouteStats = Vec<ApiinsightsroutestatsInner>;

/// API Insights usage subject stats for an organization
pub type ApiInsightsSubjectStats = Vec<ApiinsightssubjectstatsInner>;

/// API Insights usage summary stats for an organization
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct ApiInsightsSummaryStats {
    /// The total number of requests within the queried time period
    #[serde(skip_serializing_if="Option::is_none")]
    pub total_request_count: Option<i64>,
    /// The total number of requests that were rate limited within the queried time period
    #[serde(skip_serializing_if="Option::is_none")]
    pub rate_limited_request_count: Option<i64>,
}

/// API Insights usage time stats for an organization
pub type ApiInsightsTimeStats = Vec<ApiinsightstimestatsInner>;

/// API Insights usage stats for a user
pub type ApiInsightsUserStats = Vec<ApiinsightsuserstatsInner>;

/// Api Overview
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct ApiOverview {
    #[serde(skip_serializing_if="Option::is_none")]
    pub verifiable_password_authentication: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub ssh_key_fingerprints: Option<ApioverviewSshKeyFingerprints>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub ssh_keys: Option<Vec<String>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub hooks: Option<Vec<String>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub github_enterprise_importer: Option<Vec<String>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub web: Option<Vec<String>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub api: Option<Vec<String>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub git: Option<Vec<String>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub packages: Option<Vec<String>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub pages: Option<Vec<String>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub importer: Option<Vec<String>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub actions: Option<Vec<String>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub actions_macos: Option<Vec<String>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub codespaces: Option<Vec<String>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub dependabot: Option<Vec<String>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub copilot: Option<Vec<String>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub domains: Option<ApioverviewDomains>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct ApiinsightsroutestatsInner {
    /// The HTTP method
    #[serde(skip_serializing_if="Option::is_none")]
    pub http_method: Option<String>,
    /// The API path's route template
    #[serde(skip_serializing_if="Option::is_none")]
    pub api_route: Option<String>,
    /// The total number of requests within the queried time period
    #[serde(skip_serializing_if="Option::is_none")]
    pub total_request_count: Option<i64>,
    /// The total number of requests that were rate limited within the queried time period
    #[serde(skip_serializing_if="Option::is_none")]
    pub rate_limited_request_count: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub last_rate_limited_timestamp: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub last_request_timestamp: Option<String>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct ApiinsightssubjectstatsInner {
    #[serde(skip_serializing_if="Option::is_none")]
    pub subject_type: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub subject_name: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub subject_id: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub total_request_count: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub rate_limited_request_count: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub last_rate_limited_timestamp: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub last_request_timestamp: Option<String>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct ApiinsightstimestatsInner {
    #[serde(skip_serializing_if="Option::is_none")]
    pub timestamp: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub total_request_count: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub rate_limited_request_count: Option<i64>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct ApiinsightsuserstatsInner {
    #[serde(skip_serializing_if="Option::is_none")]
    pub actor_type: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub actor_name: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub actor_id: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub integration_id: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub oauth_application_id: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub total_request_count: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub rate_limited_request_count: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub last_rate_limited_timestamp: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub last_request_timestamp: Option<String>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct ApioverviewDomains {
    #[serde(skip_serializing_if="Option::is_none")]
    pub website: Option<Vec<String>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub codespaces: Option<Vec<String>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub copilot: Option<Vec<String>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub packages: Option<Vec<String>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub actions: Option<Vec<String>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub actions_inbound: Option<ApioverviewDomainsActionsInbound>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub artifact_attestations: Option<ApioverviewDomainsArtifactAttestations>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct ApioverviewDomainsActionsInbound {
    #[serde(skip_serializing_if="Option::is_none")]
    pub full_domains: Option<Vec<String>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub wildcard_domains: Option<Vec<String>>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct ApioverviewDomainsArtifactAttestations {
    #[serde(skip_serializing_if="Option::is_none")]
    pub trust_domain: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub services: Option<Vec<String>>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct ApioverviewSshKeyFingerprints {
    #[serde(rename = "SHA256_RSA")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub sha256_rsa: Option<String>,
    #[serde(rename = "SHA256_DSA")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub sha256_dsa: Option<String>,
    #[serde(rename = "SHA256_ECDSA")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub sha256_ecdsa: Option<String>,
    #[serde(rename = "SHA256_ED25519")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub sha256_ed25519: Option<String>,
}

/// GitHub apps are a new way to extend GitHub. They can be installed directly on organizations and user accounts and granted access to specific repositories. They come with granular permissions and built-in webhooks. GitHub apps are first class actors within GitHub.
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct App {
    #[serde(skip_serializing_if="Option::is_none")]
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub description: Option<String>,
    /// The list of events for the GitHub app
    #[serde(skip_serializing_if="Option::is_none")]
    pub events: Option<Vec<String>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub external_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub html_url: Option<String>,
    /// Unique identifier of the GitHub app
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<i64>,
    /// The name of the GitHub app
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub node_id: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub owner: Option<User1>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub permissions: Option<AppPermissions>,
    /// The slug name of the GitHub app
    #[serde(skip_serializing_if="Option::is_none")]
    pub slug: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub updated_at: Option<chrono::DateTime<chrono::Utc>>,
}

/// GitHub apps are a new way to extend GitHub. They can be installed directly on organizations and user accounts and granted access to specific repositories. They come with granular permissions and built-in webhooks. GitHub apps are first class actors within GitHub.
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct App1 {
    #[serde(skip_serializing_if="Option::is_none")]
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub description: Option<String>,
    /// The list of events for the GitHub app
    #[serde(skip_serializing_if="Option::is_none")]
    pub events: Option<Vec<String>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub external_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub html_url: Option<String>,
    /// Unique identifier of the GitHub app
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<i64>,
    /// The name of the GitHub app
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub node_id: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub owner: Option<User1>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub permissions: Option<App1Permissions>,
    /// The slug name of the GitHub app
    #[serde(skip_serializing_if="Option::is_none")]
    pub slug: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub updated_at: Option<chrono::DateTime<chrono::Utc>>,
}

/// GitHub apps are a new way to extend GitHub. They can be installed directly on organizations and user accounts and granted access to specific repositories. They come with granular permissions and built-in webhooks. GitHub apps are first class actors within GitHub.
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct App10 {
    #[serde(skip_serializing_if="Option::is_none")]
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub description: Option<String>,
    /// The list of events for the GitHub app
    #[serde(skip_serializing_if="Option::is_none")]
    pub events: Option<Vec<String>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub external_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub html_url: Option<String>,
    /// Unique identifier of the GitHub app
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<i64>,
    /// The name of the GitHub app
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub node_id: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub owner: Option<User1>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub permissions: Option<AppPermissions>,
    /// The slug name of the GitHub app
    #[serde(skip_serializing_if="Option::is_none")]
    pub slug: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub updated_at: Option<chrono::DateTime<chrono::Utc>>,
}

/// GitHub apps are a new way to extend GitHub. They can be installed directly on organizations and user accounts and granted access to specific repositories. They come with granular permissions and built-in webhooks. GitHub apps are first class actors within GitHub.
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct App11 {
    #[serde(skip_serializing_if="Option::is_none")]
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub description: Option<String>,
    /// The list of events for the GitHub app
    #[serde(skip_serializing_if="Option::is_none")]
    pub events: Option<Vec<String>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub external_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub html_url: Option<String>,
    /// Unique identifier of the GitHub app
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<i64>,
    /// The name of the GitHub app
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub node_id: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub owner: Option<User1>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub permissions: Option<AppPermissions>,
    /// The slug name of the GitHub app
    #[serde(skip_serializing_if="Option::is_none")]
    pub slug: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub updated_at: Option<chrono::DateTime<chrono::Utc>>,
}

/// GitHub apps are a new way to extend GitHub. They can be installed directly on organizations and user accounts and granted access to specific repositories. They come with granular permissions and built-in webhooks. GitHub apps are first class actors within GitHub.
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct App12 {
    #[serde(skip_serializing_if="Option::is_none")]
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub description: Option<String>,
    /// The list of events for the GitHub app
    #[serde(skip_serializing_if="Option::is_none")]
    pub events: Option<Vec<String>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub external_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub html_url: Option<String>,
    /// Unique identifier of the GitHub app
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<i64>,
    /// The name of the GitHub app
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub node_id: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub owner: Option<User1>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub permissions: Option<App1Permissions>,
    /// The slug name of the GitHub app
    #[serde(skip_serializing_if="Option::is_none")]
    pub slug: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub updated_at: Option<chrono::DateTime<chrono::Utc>>,
}

/// GitHub apps are a new way to extend GitHub. They can be installed directly on organizations and user accounts and granted access to specific repositories. They come with granular permissions and built-in webhooks. GitHub apps are first class actors within GitHub.
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct App13 {
    #[serde(skip_serializing_if="Option::is_none")]
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub description: Option<String>,
    /// The list of events for the GitHub app
    #[serde(skip_serializing_if="Option::is_none")]
    pub events: Option<Vec<String>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub external_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub html_url: Option<String>,
    /// Unique identifier of the GitHub app
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<i64>,
    /// The name of the GitHub app
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub node_id: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub owner: Option<User1>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub permissions: Option<AppPermissions>,
    /// The slug name of the GitHub app
    #[serde(skip_serializing_if="Option::is_none")]
    pub slug: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub updated_at: Option<chrono::DateTime<chrono::Utc>>,
}

/// GitHub apps are a new way to extend GitHub. They can be installed directly on organizations and user accounts and granted access to specific repositories. They come with granular permissions and built-in webhooks. GitHub apps are first class actors within GitHub.
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct App14 {
    #[serde(skip_serializing_if="Option::is_none")]
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub description: Option<String>,
    /// The list of events for the GitHub app
    #[serde(skip_serializing_if="Option::is_none")]
    pub events: Option<Vec<String>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub external_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub html_url: Option<String>,
    /// Unique identifier of the GitHub app
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<i64>,
    /// The name of the GitHub app
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub node_id: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub owner: Option<User1>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub permissions: Option<App2Permissions>,
    /// The slug name of the GitHub app
    #[serde(skip_serializing_if="Option::is_none")]
    pub slug: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub updated_at: Option<chrono::DateTime<chrono::Utc>>,
}

/// The set of permissions for the GitHub app
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct App1Permissions {
    #[serde(skip_serializing_if="Option::is_none")]
    pub actions: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub administration: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub checks: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub content_references: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub contents: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub deployments: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub discussions: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub emails: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub environments: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub issues: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub keys: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub members: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub metadata: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub organization_administration: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub organization_hooks: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub organization_packages: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub organization_plan: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub organization_projects: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub organization_secrets: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub organization_self_hosted_runners: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub organization_user_blocking: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub packages: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub pages: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub pull_requests: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub repository_hooks: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub repository_projects: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub secret_scanning_alerts: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub secrets: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub security_events: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub security_scanning_alert: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub single_file: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub statuses: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub team_discussions: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub vulnerability_alerts: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub workflows: Option<String>,
}

/// GitHub apps are a new way to extend GitHub. They can be installed directly on organizations and user accounts and granted access to specific repositories. They come with granular permissions and built-in webhooks. GitHub apps are first class actors within GitHub.
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct App2 {
    #[serde(skip_serializing_if="Option::is_none")]
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub description: Option<String>,
    /// The list of events for the GitHub app
    #[serde(skip_serializing_if="Option::is_none")]
    pub events: Option<Vec<String>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub external_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub html_url: Option<String>,
    /// Unique identifier of the GitHub app
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<i64>,
    /// The client ID of the GitHub app
    #[serde(skip_serializing_if="Option::is_none")]
    pub client_id: Option<String>,
    /// The name of the GitHub app
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub node_id: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub owner: Option<User1>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub permissions: Option<App2Permissions>,
    /// The slug name of the GitHub app
    #[serde(skip_serializing_if="Option::is_none")]
    pub slug: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub updated_at: Option<chrono::DateTime<chrono::Utc>>,
}

/// The set of permissions for the GitHub app
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct App2Permissions {
    #[serde(skip_serializing_if="Option::is_none")]
    pub actions: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub administration: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub checks: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub content_references: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub contents: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub deployments: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub discussions: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub emails: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub environments: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub issues: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub keys: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub members: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub metadata: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub organization_administration: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub organization_hooks: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub organization_packages: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub organization_plan: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub organization_projects: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub organization_secrets: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub organization_self_hosted_runners: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub organization_user_blocking: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub packages: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub pages: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub pull_requests: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub repository_hooks: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub repository_projects: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub secret_scanning_alerts: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub secrets: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub security_events: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub security_scanning_alert: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub single_file: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub statuses: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub team_discussions: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub vulnerability_alerts: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub workflows: Option<String>,
}

/// GitHub apps are a new way to extend GitHub. They can be installed directly on organizations and user accounts and granted access to specific repositories. They come with granular permissions and built-in webhooks. GitHub apps are first class actors within GitHub.
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct App3 {
    #[serde(skip_serializing_if="Option::is_none")]
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub description: Option<String>,
    /// The list of events for the GitHub app
    #[serde(skip_serializing_if="Option::is_none")]
    pub events: Option<Vec<String>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub external_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub html_url: Option<String>,
    /// Unique identifier of the GitHub app
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<i64>,
    /// Client ID of the GitHub app
    #[serde(skip_serializing_if="Option::is_none")]
    pub client_id: Option<String>,
    /// The name of the GitHub app
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub node_id: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub owner: Option<User1>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub permissions: Option<App2Permissions>,
    /// The slug name of the GitHub app
    #[serde(skip_serializing_if="Option::is_none")]
    pub slug: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub updated_at: Option<chrono::DateTime<chrono::Utc>>,
}

/// GitHub apps are a new way to extend GitHub. They can be installed directly on organizations and user accounts and granted access to specific repositories. They come with granular permissions and built-in webhooks. GitHub apps are first class actors within GitHub.
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct App4 {
    #[serde(skip_serializing_if="Option::is_none")]
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub description: Option<String>,
    /// The list of events for the GitHub app
    #[serde(skip_serializing_if="Option::is_none")]
    pub events: Option<Vec<String>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub external_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub html_url: Option<String>,
    /// Unique identifier of the GitHub app
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<i64>,
    /// The Client ID for the GitHub app
    #[serde(skip_serializing_if="Option::is_none")]
    pub client_id: Option<String>,
    /// The name of the GitHub app
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub node_id: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub owner: Option<User1>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub permissions: Option<App2Permissions>,
    /// The slug name of the GitHub app
    #[serde(skip_serializing_if="Option::is_none")]
    pub slug: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub updated_at: Option<chrono::DateTime<chrono::Utc>>,
}

/// GitHub apps are a new way to extend GitHub. They can be installed directly on organizations and user accounts and granted access to specific repositories. They come with granular permissions and built-in webhooks. GitHub apps are first class actors within GitHub.
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct App5 {
    #[serde(skip_serializing_if="Option::is_none")]
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub description: Option<String>,
    /// The list of events for the GitHub app
    #[serde(skip_serializing_if="Option::is_none")]
    pub events: Option<Vec<String>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub external_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub html_url: Option<String>,
    /// Unique identifier of the GitHub app
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<i64>,
    /// The name of the GitHub app
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub node_id: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub owner: Option<User1>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub permissions: Option<App1Permissions>,
    /// The slug name of the GitHub app
    #[serde(skip_serializing_if="Option::is_none")]
    pub slug: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub updated_at: Option<chrono::DateTime<chrono::Utc>>,
}

/// GitHub apps are a new way to extend GitHub. They can be installed directly on organizations and user accounts and granted access to specific repositories. They come with granular permissions and built-in webhooks. GitHub apps are first class actors within GitHub.
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct App6 {
    #[serde(skip_serializing_if="Option::is_none")]
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub description: Option<String>,
    /// The list of events for the GitHub app
    #[serde(skip_serializing_if="Option::is_none")]
    pub events: Option<Vec<String>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub external_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub html_url: Option<String>,
    /// Unique identifier of the GitHub app
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<i64>,
    /// The name of the GitHub app
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub node_id: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub owner: Option<User1>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub permissions: Option<App1Permissions>,
    /// The slug name of the GitHub app
    #[serde(skip_serializing_if="Option::is_none")]
    pub slug: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub updated_at: Option<chrono::DateTime<chrono::Utc>>,
}

/// GitHub apps are a new way to extend GitHub. They can be installed directly on organizations and user accounts and granted access to specific repositories. They come with granular permissions and built-in webhooks. GitHub apps are first class actors within GitHub.
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct App7 {
    #[serde(skip_serializing_if="Option::is_none")]
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub description: Option<String>,
    /// The list of events for the GitHub app
    #[serde(skip_serializing_if="Option::is_none")]
    pub events: Option<Vec<String>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub external_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub html_url: Option<String>,
    /// Unique identifier of the GitHub app
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<i64>,
    /// The name of the GitHub app
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub node_id: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub owner: Option<User1>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub permissions: Option<App1Permissions>,
    /// The slug name of the GitHub app
    #[serde(skip_serializing_if="Option::is_none")]
    pub slug: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub updated_at: Option<chrono::DateTime<chrono::Utc>>,
}

/// GitHub apps are a new way to extend GitHub. They can be installed directly on organizations and user accounts and granted access to specific repositories. They come with granular permissions and built-in webhooks. GitHub apps are first class actors within GitHub.
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct App8 {
    #[serde(skip_serializing_if="Option::is_none")]
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub description: Option<String>,
    /// The list of events for the GitHub app
    #[serde(skip_serializing_if="Option::is_none")]
    pub events: Option<Vec<String>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub external_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub html_url: Option<String>,
    /// Unique identifier of the GitHub app
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<i64>,
    /// The name of the GitHub app
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub node_id: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub owner: Option<User1>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub permissions: Option<App1Permissions>,
    /// The slug name of the GitHub app
    #[serde(skip_serializing_if="Option::is_none")]
    pub slug: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub updated_at: Option<chrono::DateTime<chrono::Utc>>,
}

/// GitHub apps are a new way to extend GitHub. They can be installed directly on organizations and user accounts and granted access to specific repositories. They come with granular permissions and built-in webhooks. GitHub apps are first class actors within GitHub.
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct App9 {
    #[serde(skip_serializing_if="Option::is_none")]
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub description: Option<String>,
    /// The list of events for the GitHub app
    #[serde(skip_serializing_if="Option::is_none")]
    pub events: Option<Vec<String>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub external_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub html_url: Option<String>,
    /// Unique identifier of the GitHub app
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<i64>,
    /// The name of the GitHub app
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub node_id: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub owner: Option<User1>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub permissions: Option<AppPermissions>,
    /// The slug name of the GitHub app
    #[serde(skip_serializing_if="Option::is_none")]
    pub slug: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub updated_at: Option<chrono::DateTime<chrono::Utc>>,
}

/// The set of permissions for the GitHub app
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct AppPermissions {
    #[serde(skip_serializing_if="Option::is_none")]
    pub actions: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub administration: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub checks: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub content_references: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub contents: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub deployments: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub discussions: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub emails: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub environments: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub issues: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub keys: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub members: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub metadata: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub organization_administration: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub organization_hooks: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub organization_packages: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub organization_plan: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub organization_projects: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub organization_secrets: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub organization_self_hosted_runners: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub organization_user_blocking: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub packages: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub pages: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub pull_requests: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub repository_hooks: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub repository_projects: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub secret_scanning_alerts: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub secrets: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub security_events: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub security_scanning_alert: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub single_file: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub statuses: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub team_discussions: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub vulnerability_alerts: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub workflows: Option<String>,
}

/// An artifact
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct Artifact {
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub node_id: Option<String>,
    /// The name of the artifact.
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,
    /// The size in bytes of the artifact.
    #[serde(skip_serializing_if="Option::is_none")]
    pub size_in_bytes: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub archive_download_url: Option<String>,
    /// Whether or not the artifact has expired.
    #[serde(skip_serializing_if="Option::is_none")]
    pub expired: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub expires_at: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub updated_at: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub workflow_run: Option<ArtifactWorkflowRun>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct ArtifactWorkflowRun {
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub repository_id: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub head_repository_id: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub head_branch: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub head_sha: Option<String>,
}

/// Assigned Issue Event
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct AssignedIssueEvent {
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub node_id: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub actor: Option<SimpleUser>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub event: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub commit_id: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub commit_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub created_at: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub performed_via_github_app: Option<Integration>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub assignee: Option<SimpleUser>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub assigner: Option<SimpleUser>,
}

/// Authentication Token
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct AuthenticationToken {
    /// The token used for authentication
    #[serde(skip_serializing_if="Option::is_none")]
    pub token: Option<String>,
    /// The time this token expires
    #[serde(skip_serializing_if="Option::is_none")]
    pub expires_at: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub permissions: Option<HashMap<String, Value>>,
    /// The repositories this token has access to
    #[serde(skip_serializing_if="Option::is_none")]
    pub repositories: Option<Vec<Repository>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub single_file: Option<String>,
    /// Describe whether all repositories have been selected or there's a selection involved
    #[serde(skip_serializing_if="Option::is_none")]
    pub repository_selection: Option<String>,
}

/// How the author is associated with the repository.
/// Enumeration of values.
/// Since this enum's variants do not hold data, we can easily define them them as `#[repr(C)]`
/// which helps with FFI.
#[allow(non_camel_case_types)]
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq, PartialOrd, Serialize, Deserialize, Eq, Ord)]
pub enum AuthorAssociation { 
    #[serde(rename = "COLLABORATOR")]
    COLLABORATOR,
    #[serde(rename = "CONTRIBUTOR")]
    CONTRIBUTOR,
    #[serde(rename = "FIRST_TIMER")]
    FIRST_TIMER,
    #[serde(rename = "FIRST_TIME_CONTRIBUTOR")]
    FIRST_TIME_CONTRIBUTOR,
    #[serde(rename = "MANNEQUIN")]
    MANNEQUIN,
    #[serde(rename = "MEMBER")]
    MEMBER,
    #[serde(rename = "NONE")]
    NONE,
    #[serde(rename = "OWNER")]
    OWNER,
}

impl Display for AuthorAssociation {
    fn fmt(&self, f: &mut Formatter) -> fmt::Result {
        match *self { 
            AuthorAssociation::COLLABORATOR => write!(f, "{}", "COLLABORATOR"),
            AuthorAssociation::CONTRIBUTOR => write!(f, "{}", "CONTRIBUTOR"),
            AuthorAssociation::FIRST_TIMER => write!(f, "{}", "FIRST_TIMER"),
            AuthorAssociation::FIRST_TIME_CONTRIBUTOR => write!(f, "{}", "FIRST_TIME_CONTRIBUTOR"),
            AuthorAssociation::MANNEQUIN => write!(f, "{}", "MANNEQUIN"),
            AuthorAssociation::MEMBER => write!(f, "{}", "MEMBER"),
            AuthorAssociation::NONE => write!(f, "{}", "NONE"),
            AuthorAssociation::OWNER => write!(f, "{}", "OWNER"),
        }
    }
}

impl std::str::FromStr for AuthorAssociation {
    type Err = ();
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s {
            "COLLABORATOR" => Ok(AuthorAssociation::COLLABORATOR),
            "CONTRIBUTOR" => Ok(AuthorAssociation::CONTRIBUTOR),
            "FIRST_TIMER" => Ok(AuthorAssociation::FIRST_TIMER),
            "FIRST_TIME_CONTRIBUTOR" => Ok(AuthorAssociation::FIRST_TIME_CONTRIBUTOR),
            "MANNEQUIN" => Ok(AuthorAssociation::MANNEQUIN),
            "MEMBER" => Ok(AuthorAssociation::MEMBER),
            "NONE" => Ok(AuthorAssociation::NONE),
            "OWNER" => Ok(AuthorAssociation::OWNER),
            _ => Err(()),
        }
    }
}

/// The authorization for an OAuth app, GitHub App, or a Personal Access Token.
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct Authorization {
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub url: Option<String>,
    /// A list of scopes that this authorization is in.
    #[serde(skip_serializing_if="Option::is_none")]
    pub scopes: Option<Vec<String>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub token: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub token_last_eight: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub hashed_token: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub app: Option<AuthorizationApp>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub note: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub note_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub updated_at: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub fingerprint: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub user: Option<NullableSimpleUser>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub installation: Option<NullableScopedInstallation>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub expires_at: Option<chrono::DateTime<chrono::Utc>>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct AuthorizationApp {
    #[serde(skip_serializing_if="Option::is_none")]
    pub client_id: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub url: Option<String>,
}

/// The status of auto merging a pull request.
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct AutoMerge {
    #[serde(skip_serializing_if="Option::is_none")]
    pub enabled_by: Option<SimpleUser>,
    /// The merge method to use.
    #[serde(skip_serializing_if="Option::is_none")]
    pub merge_method: Option<String>,
    /// Title for the merge commit message.
    #[serde(skip_serializing_if="Option::is_none")]
    pub commit_title: Option<String>,
    /// Commit message for the merge commit.
    #[serde(skip_serializing_if="Option::is_none")]
    pub commit_message: Option<String>,
}

/// An autolink reference.
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct Autolink {
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<i64>,
    /// The prefix of a key that is linkified.
    #[serde(skip_serializing_if="Option::is_none")]
    pub key_prefix: Option<String>,
    /// A template for the target URL that is generated if a key was found.
    #[serde(skip_serializing_if="Option::is_none")]
    pub url_template: Option<String>,
    /// Whether this autolink reference matches alphanumeric characters. If false, this autolink reference only matches numeric characters.
    #[serde(skip_serializing_if="Option::is_none")]
    pub is_alphanumeric: Option<bool>,
}

/// Base Gist
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct BaseGist {
    #[serde(skip_serializing_if="Option::is_none")]
    pub url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub forks_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub commits_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub node_id: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub git_pull_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub git_push_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub html_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub files: Option<HashMap<String, BasegistFiles>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub public: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub updated_at: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub description: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub comments: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub comments_enabled: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub user: Option<NullableSimpleUser>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub comments_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub owner: Option<SimpleUser>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub truncated: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub forks: Option<Vec<Value>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub history: Option<Vec<Value>>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct BasegistFiles {
    #[serde(skip_serializing_if="Option::is_none")]
    pub filename: Option<String>,
    #[serde(rename = "type")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub _type: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub language: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub raw_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub size: Option<i64>,
    /// The encoding used for `content`. Currently, `\"utf-8\"` and `\"base64\"` are supported.
    #[serde(skip_serializing_if="Option::is_none")]
    pub encoding: Option<String>,
}

/// Basic Error
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct BasicError {
    #[serde(skip_serializing_if="Option::is_none")]
    pub message: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub documentation_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub status: Option<String>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct BillingUsageReport {
    #[serde(rename = "usageItems")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub usage_items: Option<Vec<BillingusagereportUsageItems>>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct BillingusagereportUsageItems {
    /// Date of the usage line item.
    #[serde(skip_serializing_if="Option::is_none")]
    pub date: Option<String>,
    /// Product name.
    #[serde(skip_serializing_if="Option::is_none")]
    pub product: Option<String>,
    /// SKU name.
    #[serde(skip_serializing_if="Option::is_none")]
    pub sku: Option<String>,
    /// Quantity of the usage line item.
    #[serde(skip_serializing_if="Option::is_none")]
    pub quantity: Option<i64>,
    /// Unit type of the usage line item.
    #[serde(rename = "unitType")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub unit_type: Option<String>,
    /// Price per unit of the usage line item.
    #[serde(rename = "pricePerUnit")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub price_per_unit: Option<f64>,
    /// Gross amount of the usage line item.
    #[serde(rename = "grossAmount")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub gross_amount: Option<f64>,
    /// Discount amount of the usage line item.
    #[serde(rename = "discountAmount")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub discount_amount: Option<f64>,
    /// Net amount of the usage line item.
    #[serde(rename = "netAmount")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub net_amount: Option<f64>,
    /// Name of the organization.
    #[serde(rename = "organizationName")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub organization_name: Option<String>,
    /// Name of the repository.
    #[serde(rename = "repositoryName")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub repository_name: Option<String>,
}

/// Blob
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct Blob {
    #[serde(skip_serializing_if="Option::is_none")]
    pub content: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub encoding: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub sha: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub size: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub node_id: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub highlighted_content: Option<String>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct PatchAppsUpdateWebhookConfigForApp {
    #[serde(skip_serializing_if="Option::is_none")]
    pub url: Option<WebhookConfigUrl>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub content_type: Option<WebhookConfigContentType>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub secret: Option<WebhookConfigSecret>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub insecure_ssl: Option<WebhookConfigInsecureSsl>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct PostAppsCreateInstallationAccessToken {
    /// List of repository names that the token should have access to
    #[serde(skip_serializing_if="Option::is_none")]
    pub repositories: Option<Vec<String>>,
    /// List of repository IDs that the token should have access to
    #[serde(skip_serializing_if="Option::is_none")]
    pub repository_ids: Option<Vec<i32>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub permissions: Option<AppPermissions>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct PutCodeSecuritySetConfigurationAsDefaultForEnterprise {
    /// Specify which types of repository this security configuration should be applied to by default.
    #[serde(skip_serializing_if="Option::is_none")]
    pub default_for_new_repos: Option<String>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct PostActionsReRunWorkflow {
    /// Whether to enable debug logging for the re-run.
    #[serde(skip_serializing_if="Option::is_none")]
    pub enable_debug_logging: Option<bool>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct PostActionsReRunWorkflowFailedJobs {
    /// Whether to enable debug logging for the re-run.
    #[serde(skip_serializing_if="Option::is_none")]
    pub enable_debug_logging: Option<bool>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct PutActionsCreateOrUpdateRepoSecret {
    /// Value for your secret, encrypted with [LibSodium](https://libsodium.gitbook.io/doc/bindings_for_other_languages) using the public key retrieved from the [Get a repository public key](https://docs.github.com/rest/actions/secrets#get-a-repository-public-key) endpoint.
    #[serde(skip_serializing_if="Option::is_none")]
    pub encrypted_value: Option<String>,
    /// ID of the key you used to encrypt the secret.
    #[serde(skip_serializing_if="Option::is_none")]
    pub key_id: Option<String>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct PostActionsCreateRepoVariable {
    /// The name of the variable.
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,
    /// The value of the variable.
    #[serde(skip_serializing_if="Option::is_none")]
    pub value: Option<String>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct PatchActionsUpdateRepoVariable {
    /// The name of the variable.
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,
    /// The value of the variable.
    #[serde(skip_serializing_if="Option::is_none")]
    pub value: Option<String>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct PostActionsCreateWorkflowDispatch {
    /// The git reference for the workflow. The reference can be a branch or tag name.
    #[serde(rename = "ref")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub git_ref: Option<String>,
    /// Input keys and values configured in the workflow file. The maximum number of properties is 10. Any default properties configured in the workflow file will be used when `inputs` are omitted.
    #[serde(skip_serializing_if="Option::is_none")]
    pub inputs: Option<HashMap<String, HashMap<String, Value>>>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct PostReposCreateAttestation {
    #[serde(skip_serializing_if="Option::is_none")]
    pub bundle: Option<ReposownerrepoattestationsBundle>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct PostReposCreateAutolink {
    /// This prefix appended by certain characters will generate a link any time it is found in an issue, pull request, or commit.
    #[serde(skip_serializing_if="Option::is_none")]
    pub key_prefix: Option<String>,
    /// The URL must contain `<num>` for the reference number. `<num>` matches different characters depending on the value of `is_alphanumeric`.
    #[serde(skip_serializing_if="Option::is_none")]
    pub url_template: Option<String>,
    /// Whether this autolink reference matches alphanumeric characters. If true, the `<num>` parameter of the `url_template` matches alphanumeric characters `A-Z` (case insensitive), `0-9`, and `-`. If false, this autolink reference only matches numeric characters.
    #[serde(skip_serializing_if="Option::is_none")]
    pub is_alphanumeric: Option<bool>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct PutReposUpdateBranchProtection {
    #[serde(skip_serializing_if="Option::is_none")]
    pub required_status_checks: Option<ReposownerrepobranchesbranchprotectionRequiredStatusChecks>,
    /// Enforce all configured restrictions for administrators. Set to `true` to enforce required status checks for repository administrators. Set to `null` to disable.
    #[serde(skip_serializing_if="Option::is_none")]
    pub enforce_admins: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub required_pull_request_reviews: Option<ReposownerrepobranchesbranchprotectionRequiredPullRequestReviews>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub restrictions: Option<ReposownerrepobranchesbranchprotectionRestrictions>,
    /// Enforces a linear commit Git history, which prevents anyone from pushing merge commits to a branch. Set to `true` to enforce a linear commit history. Set to `false` to disable a linear commit Git history. Your repository must allow squash merging or rebase merging before you can enable a linear commit history. Default: `false`. For more information, see \"[Requiring a linear commit history](https://docs.github.com/github/administering-a-repository/requiring-a-linear-commit-history)\" in the GitHub Help documentation.
    #[serde(skip_serializing_if="Option::is_none")]
    pub required_linear_history: Option<bool>,
    /// Permits force pushes to the protected branch by anyone with write access to the repository. Set to `true` to allow force pushes. Set to `false` or `null` to block force pushes. Default: `false`. For more information, see \"[Enabling force pushes to a protected branch](https://docs.github.com/github/administering-a-repository/enabling-force-pushes-to-a-protected-branch)\" in the GitHub Help documentation.\"
    #[serde(skip_serializing_if="Option::is_none")]
    pub allow_force_pushes: Option<bool>,
    /// Allows deletion of the protected branch by anyone with write access to the repository. Set to `false` to prevent deletion of the protected branch. Default: `false`. For more information, see \"[Enabling force pushes to a protected branch](https://docs.github.com/github/administering-a-repository/enabling-force-pushes-to-a-protected-branch)\" in the GitHub Help documentation.
    #[serde(skip_serializing_if="Option::is_none")]
    pub allow_deletions: Option<bool>,
    /// If set to `true`, the `restrictions` branch protection settings which limits who can push will also block pushes which create new branches, unless the push is initiated by a user, team, or app which has the ability to push. Set to `true` to restrict new branch creation. Default: `false`.
    #[serde(skip_serializing_if="Option::is_none")]
    pub block_creations: Option<bool>,
    /// Requires all conversations on code to be resolved before a pull request can be merged into a branch that matches this rule. Set to `false` to disable. Default: `false`.
    #[serde(skip_serializing_if="Option::is_none")]
    pub required_conversation_resolution: Option<bool>,
    /// Whether to set the branch as read-only. If this is true, users will not be able to push to the branch. Default: `false`.
    #[serde(skip_serializing_if="Option::is_none")]
    pub lock_branch: Option<bool>,
    /// Whether users can pull changes from upstream when the branch is locked. Set to `true` to allow fork syncing. Set to `false` to prevent fork syncing. Default: `false`.
    #[serde(skip_serializing_if="Option::is_none")]
    pub allow_fork_syncing: Option<bool>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct PatchReposUpdatePullRequestReviewProtection {
    #[serde(skip_serializing_if="Option::is_none")]
    pub dismissal_restrictions: Option<ReposownerrepobranchesbranchprotectionRequiredPullRequestReviewsDismissalRestrictions>,
    /// Set to `true` if you want to automatically dismiss approving reviews when someone pushes a new commit.
    #[serde(skip_serializing_if="Option::is_none")]
    pub dismiss_stale_reviews: Option<bool>,
    /// Blocks merging pull requests until [code owners](https://docs.github.com/articles/about-code-owners/) have reviewed.
    #[serde(skip_serializing_if="Option::is_none")]
    pub require_code_owner_reviews: Option<bool>,
    /// Specifies the number of reviewers required to approve pull requests. Use a number between 1 and 6 or 0 to not require reviewers.
    #[serde(skip_serializing_if="Option::is_none")]
    pub required_approving_review_count: Option<i64>,
    /// Whether the most recent push must be approved by someone other than the person who pushed it. Default: `false`
    #[serde(skip_serializing_if="Option::is_none")]
    pub require_last_push_approval: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub bypass_pull_request_allowances: Option<ReposownerrepobranchesbranchprotectionRequiredPullRequestReviewsBypassPullRequestAllowances>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct PostGistsCreate {
    /// Description of the gist
    #[serde(skip_serializing_if="Option::is_none")]
    pub description: Option<String>,
    /// Names and content for the files that make up the gist
    #[serde(skip_serializing_if="Option::is_none")]
    pub files: Option<HashMap<String, GistsFiles>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub public: Option<OneOfbody11Public>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct PatchReposUpdateStatusCheckProtection {
    /// Require branches to be up to date before merging.
    #[serde(skip_serializing_if="Option::is_none")]
    pub strict: Option<bool>,
    /// **Closing down notice**: The list of status checks to require in order to merge into this branch. If any of these checks have recently been set by a particular GitHub App, they will be required to come from that app in future for the branch to merge. Use `checks` instead of `contexts` for more fine-grained control.
    #[serde(skip_serializing_if="Option::is_none")]
    pub contexts: Option<Vec<String>>,
    /// The list of status checks to require in order to merge into this branch.
    #[serde(skip_serializing_if="Option::is_none")]
    pub checks: Option<Vec<ReposownerrepobranchesbranchprotectionRequiredStatusChecksChecks>>,
}

#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PutReposSetStatusCheckContexts { 
    PutReposSetStatusCheckContextsVariant0(HashMap<String, Vec<String>>),
    PutReposSetStatusCheckContextsVariant1(Vec<String>),
}

impl From<HashMap<String, Vec<String>>> for PutReposSetStatusCheckContexts {
    fn from(value: HashMap<String, Vec<String>>) -> Self {
        PutReposSetStatusCheckContexts::PutReposSetStatusCheckContextsVariant0(value)
    }
}

impl From<Vec<String>> for PutReposSetStatusCheckContexts {
    fn from(value: Vec<String>) -> Self {
        PutReposSetStatusCheckContexts::PutReposSetStatusCheckContextsVariant1(value)
    }
}

#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PostReposAddStatusCheckContexts { 
    PostReposAddStatusCheckContextsVariant0(HashMap<String, Vec<String>>),
    PostReposAddStatusCheckContextsVariant1(Vec<String>),
}

impl From<HashMap<String, Vec<String>>> for PostReposAddStatusCheckContexts {
    fn from(value: HashMap<String, Vec<String>>) -> Self {
        PostReposAddStatusCheckContexts::PostReposAddStatusCheckContextsVariant0(value)
    }
}

impl From<Vec<String>> for PostReposAddStatusCheckContexts {
    fn from(value: Vec<String>) -> Self {
        PostReposAddStatusCheckContexts::PostReposAddStatusCheckContextsVariant1(value)
    }
}

#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteReposRemoveStatusCheckContexts { 
    DeleteReposRemoveStatusCheckContextsVariant0(HashMap<String, Vec<String>>),
    DeleteReposRemoveStatusCheckContextsVariant1(Vec<String>),
}

impl From<HashMap<String, Vec<String>>> for DeleteReposRemoveStatusCheckContexts {
    fn from(value: HashMap<String, Vec<String>>) -> Self {
        DeleteReposRemoveStatusCheckContexts::DeleteReposRemoveStatusCheckContextsVariant0(value)
    }
}

impl From<Vec<String>> for DeleteReposRemoveStatusCheckContexts {
    fn from(value: Vec<String>) -> Self {
        DeleteReposRemoveStatusCheckContexts::DeleteReposRemoveStatusCheckContextsVariant1(value)
    }
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct PutReposSetAppAccessRestrictions {
    /// The GitHub Apps that have push access to this branch. Use the slugified version of the app name. **Note**: The list of users, apps, and teams in total is limited to 100 items.
    #[serde(skip_serializing_if="Option::is_none")]
    pub apps: Option<Vec<String>>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct PostReposAddAppAccessRestrictions {
    /// The GitHub Apps that have push access to this branch. Use the slugified version of the app name. **Note**: The list of users, apps, and teams in total is limited to 100 items.
    #[serde(skip_serializing_if="Option::is_none")]
    pub apps: Option<Vec<String>>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct DeleteReposRemoveAppAccessRestrictions {
    /// The GitHub Apps that have push access to this branch. Use the slugified version of the app name. **Note**: The list of users, apps, and teams in total is limited to 100 items.
    #[serde(skip_serializing_if="Option::is_none")]
    pub apps: Option<Vec<String>>,
}

#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PutReposSetTeamAccessRestrictions { 
    PutReposSetTeamAccessRestrictionsVariant0(HashMap<String, Vec<String>>),
    PutReposSetTeamAccessRestrictionsVariant1(Vec<String>),
}

impl From<HashMap<String, Vec<String>>> for PutReposSetTeamAccessRestrictions {
    fn from(value: HashMap<String, Vec<String>>) -> Self {
        PutReposSetTeamAccessRestrictions::PutReposSetTeamAccessRestrictionsVariant0(value)
    }
}

impl From<Vec<String>> for PutReposSetTeamAccessRestrictions {
    fn from(value: Vec<String>) -> Self {
        PutReposSetTeamAccessRestrictions::PutReposSetTeamAccessRestrictionsVariant1(value)
    }
}

#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PostReposAddTeamAccessRestrictions { 
    PostReposAddTeamAccessRestrictionsVariant0(HashMap<String, Vec<String>>),
    PostReposAddTeamAccessRestrictionsVariant1(Vec<String>),
}

impl From<HashMap<String, Vec<String>>> for PostReposAddTeamAccessRestrictions {
    fn from(value: HashMap<String, Vec<String>>) -> Self {
        PostReposAddTeamAccessRestrictions::PostReposAddTeamAccessRestrictionsVariant0(value)
    }
}

impl From<Vec<String>> for PostReposAddTeamAccessRestrictions {
    fn from(value: Vec<String>) -> Self {
        PostReposAddTeamAccessRestrictions::PostReposAddTeamAccessRestrictionsVariant1(value)
    }
}

#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteReposRemoveTeamAccessRestrictions { 
    DeleteReposRemoveTeamAccessRestrictionsVariant0(HashMap<String, Vec<String>>),
    DeleteReposRemoveTeamAccessRestrictionsVariant1(Vec<String>),
}

impl From<HashMap<String, Vec<String>>> for DeleteReposRemoveTeamAccessRestrictions {
    fn from(value: HashMap<String, Vec<String>>) -> Self {
        DeleteReposRemoveTeamAccessRestrictions::DeleteReposRemoveTeamAccessRestrictionsVariant0(value)
    }
}

impl From<Vec<String>> for DeleteReposRemoveTeamAccessRestrictions {
    fn from(value: Vec<String>) -> Self {
        DeleteReposRemoveTeamAccessRestrictions::DeleteReposRemoveTeamAccessRestrictionsVariant1(value)
    }
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct PatchGistsUpdate {
    /// The description of the gist.
    #[serde(skip_serializing_if="Option::is_none")]
    pub description: Option<String>,
    /// The gist files to be updated, renamed, or deleted. Each `key` must match the current filename (including extension) of the targeted gist file. For example: `hello.py`.  To delete a file, set the whole file to null. For example: `hello.py : null`. The file will also be deleted if the specified object does not contain at least one of `content` or `filename`.
    #[serde(skip_serializing_if="Option::is_none")]
    pub files: Option<HashMap<String, GistsgistIdFiles>>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct PutReposSetUserAccessRestrictions {
    /// The username for users
    #[serde(skip_serializing_if="Option::is_none")]
    pub users: Option<Vec<String>>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct PostReposAddUserAccessRestrictions {
    /// The username for users
    #[serde(skip_serializing_if="Option::is_none")]
    pub users: Option<Vec<String>>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct DeleteReposRemoveUserAccessRestrictions {
    /// The username for users
    #[serde(skip_serializing_if="Option::is_none")]
    pub users: Option<Vec<String>>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct PostReposRenameBranch {
    /// The new name of the branch.
    #[serde(skip_serializing_if="Option::is_none")]
    pub new_name: Option<String>,
}

#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PostChecksCreate { 
    PostChecksCreateVariant0(HashMap<String, String>),
}

impl From<HashMap<String, String>> for PostChecksCreate {
    fn from(value: HashMap<String, String>) -> Self {
        PostChecksCreate::PostChecksCreateVariant0(value)
    }
}

#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PatchChecksUpdate { 
    PatchChecksUpdateVariant0(HashMap<String, String>),
}

impl From<HashMap<String, String>> for PatchChecksUpdate {
    fn from(value: HashMap<String, String>) -> Self {
        PatchChecksUpdate::PatchChecksUpdateVariant0(value)
    }
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct PostChecksCreateSuite {
    /// The sha of the head commit.
    #[serde(skip_serializing_if="Option::is_none")]
    pub head_sha: Option<String>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct PatchChecksSetSuitesPreferences {
    /// Enables or disables automatic creation of CheckSuite events upon pushes to the repository. Enabled by default.
    #[serde(skip_serializing_if="Option::is_none")]
    pub auto_trigger_checks: Option<Vec<ReposownerrepochecksuitespreferencesAutoTriggerChecks>>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct PatchCodeScanningUpdateAlert {
    #[serde(skip_serializing_if="Option::is_none")]
    pub state: Option<CodeScanningAlertSetState>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub dismissed_reason: Option<CodeScanningAlertDismissedReason>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub dismissed_comment: Option<CodeScanningAlertDismissedComment>,
}

#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PostCodeScanningCreateVariantAnalysis { 
    PostCodeScanningCreateVariantAnalysisVariant0(Value),
}

impl From<Value> for PostCodeScanningCreateVariantAnalysis {
    fn from(value: Value) -> Self {
        PostCodeScanningCreateVariantAnalysis::PostCodeScanningCreateVariantAnalysisVariant0(value)
    }
}

impl Display for PostCodeScanningCreateVariantAnalysis {
    fn fmt(&self, f: &mut Formatter) -> fmt::Result {
        match self { 
            PostCodeScanningCreateVariantAnalysis::PostCodeScanningCreateVariantAnalysisVariant0(value) => write!(f, "{}", value),
        }
    }
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct PostGistsCreateComment {
    /// The comment text.
    #[serde(skip_serializing_if="Option::is_none")]
    pub body: Option<String>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct PostCodeScanningUploadSarif {
    #[serde(skip_serializing_if="Option::is_none")]
    pub commit_sha: Option<CodeScanningAnalysisCommitSha>,
    #[serde(rename = "ref")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub git_ref: Option<CodeScanningRefFull>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub sarif: Option<CodeScanningAnalysisSarifFile>,
    /// The base directory used in the analysis, as it appears in the SARIF file. This property is used to convert file paths from absolute to relative, so that alerts can be mapped to their correct location in the repository.
    #[serde(skip_serializing_if="Option::is_none")]
    pub checkout_uri: Option<String>,
    /// The time that the analysis run began. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.
    #[serde(skip_serializing_if="Option::is_none")]
    pub started_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The name of the tool used to generate the code scanning analysis. If this parameter is not used, the tool name defaults to \"API\". If the uploaded SARIF contains a tool GUID, this will be available for filtering using the `tool_guid` parameter of operations such as `GET /repos/{owner}/{repo}/code-scanning/alerts`.
    #[serde(skip_serializing_if="Option::is_none")]
    pub tool_name: Option<String>,
    /// Whether the SARIF file will be validated according to the code scanning specifications. This parameter is intended to help integrators ensure that the uploaded SARIF files are correctly rendered by code scanning.
    #[serde(skip_serializing_if="Option::is_none")]
    pub validate: Option<bool>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct PostCodespacesCreateWithRepoForAuthenticatedUser {
    /// Git ref (typically a branch name) for this codespace
    #[serde(rename = "ref")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub git_ref: Option<String>,
    /// The requested location for a new codespace. Best efforts are made to respect this upon creation. Assigned by IP if not provided.
    #[serde(skip_serializing_if="Option::is_none")]
    pub location: Option<String>,
    /// The geographic area for this codespace. If not specified, the value is assigned by IP. This property replaces `location`, which is closing down.
    #[serde(skip_serializing_if="Option::is_none")]
    pub geo: Option<String>,
    /// IP for location auto-detection when proxying a request
    #[serde(skip_serializing_if="Option::is_none")]
    pub client_ip: Option<String>,
    /// Machine type to use for this codespace
    #[serde(skip_serializing_if="Option::is_none")]
    pub machine: Option<String>,
    /// Path to devcontainer.json config to use for this codespace
    #[serde(skip_serializing_if="Option::is_none")]
    pub devcontainer_path: Option<String>,
    /// Whether to authorize requested permissions from devcontainer.json
    #[serde(skip_serializing_if="Option::is_none")]
    pub multi_repo_permissions_opt_out: Option<bool>,
    /// Working directory for this codespace
    #[serde(skip_serializing_if="Option::is_none")]
    pub working_directory: Option<String>,
    /// Time in minutes before codespace stops from inactivity
    #[serde(skip_serializing_if="Option::is_none")]
    pub idle_timeout_minutes: Option<i64>,
    /// Display name for this codespace
    #[serde(skip_serializing_if="Option::is_none")]
    pub display_name: Option<String>,
    /// Duration in minutes after codespace has gone idle in which it will be deleted. Must be integer minutes between 0 and 43200 (30 days).
    #[serde(skip_serializing_if="Option::is_none")]
    pub retention_period_minutes: Option<i64>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct PutCodespacesCreateOrUpdateRepoSecret {
    /// Value for your secret, encrypted with [LibSodium](https://libsodium.gitbook.io/doc/bindings_for_other_languages) using the public key retrieved from the [Get a repository public key](https://docs.github.com/rest/codespaces/repository-secrets#get-a-repository-public-key) endpoint.
    #[serde(skip_serializing_if="Option::is_none")]
    pub encrypted_value: Option<String>,
    /// ID of the key you used to encrypt the secret.
    #[serde(skip_serializing_if="Option::is_none")]
    pub key_id: Option<String>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct PutReposAddCollaborator {
    /// The permission to grant the collaborator. **Only valid on organization-owned repositories.** We accept the following permissions to be set: `pull`, `triage`, `push`, `maintain`, `admin` and you can also specify a custom repository role name, if the owning organization has defined any.
    #[serde(skip_serializing_if="Option::is_none")]
    pub permission: Option<String>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct PatchReposUpdateCommitComment {
    /// The contents of the comment
    #[serde(skip_serializing_if="Option::is_none")]
    pub body: Option<String>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct PostReactionsCreateForCommitComment {
    /// The [reaction type](https://docs.github.com/rest/reactions/reactions#about-reactions) to add to the commit comment.
    #[serde(skip_serializing_if="Option::is_none")]
    pub content: Option<String>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct PostReposCreateCommitComment {
    /// The contents of the comment.
    #[serde(skip_serializing_if="Option::is_none")]
    pub body: Option<String>,
    /// Relative path of the file to comment on.
    #[serde(skip_serializing_if="Option::is_none")]
    pub path: Option<String>,
    /// Line index in the diff to comment on.
    #[serde(skip_serializing_if="Option::is_none")]
    pub position: Option<i64>,
    /// **Closing down notice**. Use **position** parameter instead. Line number in the file to comment on.
    #[serde(skip_serializing_if="Option::is_none")]
    pub line: Option<i64>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct PutReposCreateOrUpdateFileContents {
    /// The commit message.
    #[serde(skip_serializing_if="Option::is_none")]
    pub message: Option<String>,
    /// The new file content, using Base64 encoding.
    #[serde(skip_serializing_if="Option::is_none")]
    pub content: Option<String>,
    /// **Required if you are updating a file**. The blob SHA of the file being replaced.
    #[serde(skip_serializing_if="Option::is_none")]
    pub sha: Option<String>,
    /// The branch name. Default: the repositorys default branch.
    #[serde(skip_serializing_if="Option::is_none")]
    pub branch: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub committer: Option<ReposownerrepocontentspathCommitter>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub author: Option<ReposownerrepocontentspathAuthor>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct DeleteReposDeleteFile {
    /// The commit message.
    #[serde(skip_serializing_if="Option::is_none")]
    pub message: Option<String>,
    /// The blob SHA of the file being deleted.
    #[serde(skip_serializing_if="Option::is_none")]
    pub sha: Option<String>,
    /// The branch name. Default: the repositorys default branch
    #[serde(skip_serializing_if="Option::is_none")]
    pub branch: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub committer: Option<ReposownerrepocontentspathCommitter1>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub author: Option<ReposownerrepocontentspathAuthor1>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct PatchDependabotUpdateAlert {
    /// The state of the Dependabot alert. A `dismissed_reason` must be provided when setting the state to `dismissed`.
    #[serde(skip_serializing_if="Option::is_none")]
    pub state: Option<String>,
    /// **Required when `state` is `dismissed`.** A reason for dismissing the alert.
    #[serde(skip_serializing_if="Option::is_none")]
    pub dismissed_reason: Option<String>,
    /// An optional comment associated with dismissing the alert.
    #[serde(skip_serializing_if="Option::is_none")]
    pub dismissed_comment: Option<String>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct PatchGistsUpdateComment {
    /// The comment text.
    #[serde(skip_serializing_if="Option::is_none")]
    pub body: Option<String>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct PutDependabotCreateOrUpdateRepoSecret {
    /// Value for your secret, encrypted with [LibSodium](https://libsodium.gitbook.io/doc/bindings_for_other_languages) using the public key retrieved from the [Get a repository public key](https://docs.github.com/rest/dependabot/secrets#get-a-repository-public-key) endpoint.
    #[serde(skip_serializing_if="Option::is_none")]
    pub encrypted_value: Option<String>,
    /// ID of the key you used to encrypt the secret.
    #[serde(skip_serializing_if="Option::is_none")]
    pub key_id: Option<String>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct PostReposCreateDeployment {
    /// The ref to deploy. This can be a branch, tag, or SHA.
    #[serde(rename = "ref")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub git_ref: Option<String>,
    /// Specifies a task to execute (e.g., `deploy` or `deploy:migrations`).
    #[serde(skip_serializing_if="Option::is_none")]
    pub task: Option<String>,
    /// Attempts to automatically merge the default branch into the requested ref, if it's behind the default branch.
    #[serde(skip_serializing_if="Option::is_none")]
    pub auto_merge: Option<bool>,
    /// The [status](https://docs.github.com/rest/commits/statuses) contexts to verify against commit status checks. If you omit this parameter, GitHub verifies all unique contexts before creating a deployment. To bypass checking entirely, pass an empty array. Defaults to all unique contexts.
    #[serde(skip_serializing_if="Option::is_none")]
    pub required_contexts: Option<Vec<String>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub payload: Option<OneOfbody141Payload>,
    /// Name for the target deployment environment (e.g., `production`, `staging`, `qa`).
    #[serde(skip_serializing_if="Option::is_none")]
    pub environment: Option<String>,
    /// Short description of the deployment.
    #[serde(skip_serializing_if="Option::is_none")]
    pub description: Option<String>,
    /// Specifies if the given environment is specific to the deployment and will no longer exist at some point in the future. Default: `false`
    #[serde(skip_serializing_if="Option::is_none")]
    pub transient_environment: Option<bool>,
    /// Specifies if the given environment is one that end-users directly interact with. Default: `true` when `environment` is `production` and `false` otherwise.
    #[serde(skip_serializing_if="Option::is_none")]
    pub production_environment: Option<bool>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct PostReposCreateDeploymentStatus {
    /// The state of the status. When you set a transient deployment to `inactive`, the deployment will be shown as `destroyed` in GitHub.
    #[serde(skip_serializing_if="Option::is_none")]
    pub state: Option<String>,
    /// The target URL to associate with this status. This URL should contain output to keep the user updated while the task is running or serve as historical information for what happened in the deployment.  > [!NOTE] > It's recommended to use the `log_url` parameter, which replaces `target_url`.
    #[serde(skip_serializing_if="Option::is_none")]
    pub target_url: Option<String>,
    /// The full URL of the deployment's output. This parameter replaces `target_url`. We will continue to accept `target_url` to support legacy uses, but we recommend replacing `target_url` with `log_url`. Setting `log_url` will automatically set `target_url` to the same value. Default: `\"\"`
    #[serde(skip_serializing_if="Option::is_none")]
    pub log_url: Option<String>,
    /// A short description of the status. The maximum description length is 140 characters.
    #[serde(skip_serializing_if="Option::is_none")]
    pub description: Option<String>,
    /// Name for the target deployment environment, which can be changed when setting a deploy status. For example, `production`, `staging`, or `qa`. If not defined, the environment of the previous status on the deployment will be used, if it exists. Otherwise, the environment of the deployment will be used.
    #[serde(skip_serializing_if="Option::is_none")]
    pub environment: Option<String>,
    /// Sets the URL for accessing your environment. Default: `\"\"`
    #[serde(skip_serializing_if="Option::is_none")]
    pub environment_url: Option<String>,
    /// Adds a new `inactive` status to all prior non-transient, non-production environment deployments with the same repository and `environment` name as the created status's deployment. An `inactive` status is only added to deployments that had a `success` state. Default: `true`
    #[serde(skip_serializing_if="Option::is_none")]
    pub auto_inactive: Option<bool>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct PostReposCreateDispatchEvent {
    /// A custom webhook event name. Must be 100 characters or fewer.
    #[serde(skip_serializing_if="Option::is_none")]
    pub event_type: Option<String>,
    /// JSON payload with extra information about the webhook event that your action or workflow may use. The maximum number of top-level properties is 10. The total size of the JSON payload must be less than 64KB.
    #[serde(skip_serializing_if="Option::is_none")]
    pub client_payload: Option<HashMap<String, HashMap<String, Value>>>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct PutReposCreateOrUpdateEnvironment {
    #[serde(skip_serializing_if="Option::is_none")]
    pub wait_timer: Option<WaitTimer>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub prevent_self_review: Option<PreventSelfReview>,
    /// The people or teams that may review jobs that reference the environment. You can list up to six users or teams as reviewers. The reviewers must have at least read access to the repository. Only one of the required reviewers needs to approve the job for it to proceed.
    #[serde(skip_serializing_if="Option::is_none")]
    pub reviewers: Option<Vec<ReposownerrepoenvironmentsenvironmentNameReviewers>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub deployment_branch_policy: Option<DeploymentBranchPolicySettings>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct PostReposCreateDeploymentProtectionRule {
    /// The ID of the custom app that will be enabled on the environment.
    #[serde(skip_serializing_if="Option::is_none")]
    pub integration_id: Option<i64>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct PutActionsCreateOrUpdateEnvironmentSecret {
    /// Value for your secret, encrypted with [LibSodium](https://libsodium.gitbook.io/doc/bindings_for_other_languages) using the public key retrieved from the [Get an environment public key](https://docs.github.com/rest/actions/secrets#get-an-environment-public-key) endpoint.
    #[serde(skip_serializing_if="Option::is_none")]
    pub encrypted_value: Option<String>,
    /// ID of the key you used to encrypt the secret.
    #[serde(skip_serializing_if="Option::is_none")]
    pub key_id: Option<String>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct PostActionsCreateEnvironmentVariable {
    /// The name of the variable.
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,
    /// The value of the variable.
    #[serde(skip_serializing_if="Option::is_none")]
    pub value: Option<String>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct PatchActionsUpdateEnvironmentVariable {
    /// The name of the variable.
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,
    /// The value of the variable.
    #[serde(skip_serializing_if="Option::is_none")]
    pub value: Option<String>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct PostReposCreateFork {
    /// Optional parameter to specify the organization name if forking into an organization.
    #[serde(skip_serializing_if="Option::is_none")]
    pub organization: Option<String>,
    /// When forking from an existing repository, a new name for the fork.
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,
    /// When forking from an existing repository, fork with only the default branch.
    #[serde(skip_serializing_if="Option::is_none")]
    pub default_branch_only: Option<bool>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct PostMarkdownRender {
    /// The Markdown text to render in HTML.
    #[serde(skip_serializing_if="Option::is_none")]
    pub text: Option<String>,
    /// The rendering mode.
    #[serde(skip_serializing_if="Option::is_none")]
    pub mode: Option<String>,
    /// The repository context to use when creating references in `gfm` mode.  For example, setting `context` to `octo-org/octo-repo` will change the text `#42` into an HTML link to issue 42 in the `octo-org/octo-repo` repository.
    #[serde(skip_serializing_if="Option::is_none")]
    pub context: Option<String>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct PostGitCreateBlob {
    /// The new blob's content.
    #[serde(skip_serializing_if="Option::is_none")]
    pub content: Option<String>,
    /// The encoding used for `content`. Currently, `\"utf-8\"` and `\"base64\"` are supported.
    #[serde(skip_serializing_if="Option::is_none")]
    pub encoding: Option<String>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct PostGitCreateCommit {
    /// The commit message
    #[serde(skip_serializing_if="Option::is_none")]
    pub message: Option<String>,
    /// The SHA of the tree object this commit points to
    #[serde(skip_serializing_if="Option::is_none")]
    pub tree: Option<String>,
    /// The full SHAs of the commits that were the parents of this commit. If omitted or empty, the commit will be written as a root commit. For a single parent, an array of one SHA should be provided; for a merge commit, an array of more than one should be provided.
    #[serde(skip_serializing_if="Option::is_none")]
    pub parents: Option<Vec<String>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub author: Option<ReposownerrepogitcommitsAuthor>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub committer: Option<ReposownerrepogitcommitsCommitter>,
    /// The [PGP signature](https://en.wikipedia.org/wiki/Pretty_Good_Privacy) of the commit. GitHub adds the signature to the `gpgsig` header of the created commit. For a commit signature to be verifiable by Git or GitHub, it must be an ASCII-armored detached PGP signature over the string commit as it would be written to the object database. To pass a `signature` parameter, you need to first manually create a valid PGP signature, which can be complicated. You may find it easier to [use the command line](https://git-scm.com/book/id/v2/Git-Tools-Signing-Your-Work) to create signed commits.
    #[serde(skip_serializing_if="Option::is_none")]
    pub signature: Option<String>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct PostGitCreateRef {
    /// The name of the fully qualified reference (ie: `refs/heads/master`). If it doesn't start with 'refs' and have at least two slashes, it will be rejected.
    #[serde(rename = "ref")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub git_ref: Option<String>,
    /// The SHA1 value for this reference.
    #[serde(skip_serializing_if="Option::is_none")]
    pub sha: Option<String>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct PatchGitUpdateRef {
    /// The SHA1 value to set this reference to
    #[serde(skip_serializing_if="Option::is_none")]
    pub sha: Option<String>,
    /// Indicates whether to force the update or to make sure the update is a fast-forward update. Leaving this out or setting it to `false` will make sure you're not overwriting work.
    #[serde(skip_serializing_if="Option::is_none")]
    pub force: Option<bool>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct PostGitCreateTag {
    /// The tag's name. This is typically a version (e.g., \"v0.0.1\").
    #[serde(skip_serializing_if="Option::is_none")]
    pub tag: Option<String>,
    /// The tag message.
    #[serde(skip_serializing_if="Option::is_none")]
    pub message: Option<String>,
    /// The SHA of the git object this is tagging.
    #[serde(skip_serializing_if="Option::is_none")]
    pub object: Option<String>,
    /// The type of the object we're tagging. Normally this is a `commit` but it can also be a `tree` or a `blob`.
    #[serde(rename = "type")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub _type: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub tagger: Option<ReposownerrepogittagsTagger>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct PostGitCreateTree {
    /// Objects (of `path`, `mode`, `type`, and `sha`) specifying a tree structure.
    #[serde(skip_serializing_if="Option::is_none")]
    pub tree: Option<Vec<ReposownerrepogittreesTree>>,
    /// The SHA1 of an existing Git tree object which will be used as the base for the new tree. If provided, a new Git tree object will be created from entries in the Git tree object pointed to by `base_tree` and entries defined in the `tree` parameter. Entries defined in the `tree` parameter will overwrite items from `base_tree` with the same `path`. If you're creating new changes on a branch, then normally you'd set `base_tree` to the SHA1 of the Git tree object of the current latest commit on the branch you're working on. If not provided, GitHub will create a new Git tree object from only the entries defined in the `tree` parameter. If you create a new commit pointing to such a tree, then all files which were a part of the parent commit's tree and were not defined in the `tree` parameter will be listed as deleted by the new commit.
    #[serde(skip_serializing_if="Option::is_none")]
    pub base_tree: Option<String>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct PostReposCreateWebhook {
    /// Use `web` to create a webhook. Default: `web`. This parameter only accepts the value `web`.
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub config: Option<ReposownerrepohooksConfig>,
    /// Determines what [events](https://docs.github.com/webhooks/event-payloads) the hook is triggered for.
    #[serde(skip_serializing_if="Option::is_none")]
    pub events: Option<Vec<String>>,
    /// Determines if notifications are sent when the webhook is triggered. Set to `true` to send notifications.
    #[serde(skip_serializing_if="Option::is_none")]
    pub active: Option<bool>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct PatchReposUpdateWebhook {
    #[serde(skip_serializing_if="Option::is_none")]
    pub config: Option<WebhookConfig>,
    /// Determines what [events](https://docs.github.com/webhooks/event-payloads) the hook is triggered for. This replaces the entire array of events.
    #[serde(skip_serializing_if="Option::is_none")]
    pub events: Option<Vec<String>>,
    /// Determines a list of events to be added to the list of events that the Hook triggers for.
    #[serde(skip_serializing_if="Option::is_none")]
    pub add_events: Option<Vec<String>>,
    /// Determines a list of events to be removed from the list of events that the Hook triggers for.
    #[serde(skip_serializing_if="Option::is_none")]
    pub remove_events: Option<Vec<String>>,
    /// Determines if notifications are sent when the webhook is triggered. Set to `true` to send notifications.
    #[serde(skip_serializing_if="Option::is_none")]
    pub active: Option<bool>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct PatchReposUpdateWebhookConfigForRepo {
    #[serde(skip_serializing_if="Option::is_none")]
    pub url: Option<WebhookConfigUrl>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub content_type: Option<WebhookConfigContentType>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub secret: Option<WebhookConfigSecret>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub insecure_ssl: Option<WebhookConfigInsecureSsl>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct PutMigrationsStartImport {
    /// The URL of the originating repository.
    #[serde(skip_serializing_if="Option::is_none")]
    pub vcs_url: Option<String>,
    /// The originating VCS type. Without this parameter, the import job will take additional time to detect the VCS type before beginning the import. This detection step will be reflected in the response.
    #[serde(skip_serializing_if="Option::is_none")]
    pub vcs: Option<String>,
    /// If authentication is required, the username to provide to `vcs_url`.
    #[serde(skip_serializing_if="Option::is_none")]
    pub vcs_username: Option<String>,
    /// If authentication is required, the password to provide to `vcs_url`.
    #[serde(skip_serializing_if="Option::is_none")]
    pub vcs_password: Option<String>,
    /// For a tfvc import, the name of the project that is being imported.
    #[serde(skip_serializing_if="Option::is_none")]
    pub tfvc_project: Option<String>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct PutActivityMarkNotificationsAsRead {
    /// Describes the last point that notifications were checked. Anything updated since this time will not be marked as read. If you omit this parameter, all notifications are marked as read. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`. Default: The current timestamp.
    #[serde(skip_serializing_if="Option::is_none")]
    pub last_read_at: Option<chrono::DateTime<chrono::Utc>>,
    /// Whether the notification has been read.
    #[serde(skip_serializing_if="Option::is_none")]
    pub read: Option<bool>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct PatchMigrationsUpdateImport {
    /// The username to provide to the originating repository.
    #[serde(skip_serializing_if="Option::is_none")]
    pub vcs_username: Option<String>,
    /// The password to provide to the originating repository.
    #[serde(skip_serializing_if="Option::is_none")]
    pub vcs_password: Option<String>,
    /// The type of version control system you are migrating from.
    #[serde(skip_serializing_if="Option::is_none")]
    pub vcs: Option<String>,
    /// For a tfvc import, the name of the project that is being imported.
    #[serde(skip_serializing_if="Option::is_none")]
    pub tfvc_project: Option<String>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct PatchMigrationsMapCommitAuthor {
    /// The new Git author email.
    #[serde(skip_serializing_if="Option::is_none")]
    pub email: Option<String>,
    /// The new Git author name.
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct PatchMigrationsSetLfsPreference {
    /// Whether to store large files during the import. `opt_in` means large files will be stored using Git LFS. `opt_out` means large files will be removed during the import.
    #[serde(skip_serializing_if="Option::is_none")]
    pub use_lfs: Option<String>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct PatchReposUpdateInvitation {
    /// The permissions that the associated user will have on the repository. Valid values are `read`, `write`, `maintain`, `triage`, and `admin`.
    #[serde(skip_serializing_if="Option::is_none")]
    pub permissions: Option<String>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct PostIssuesCreate {
    /// The title of the issue.
    #[serde(skip_serializing_if="Option::is_none")]
    pub title: Option<OneOfbody164Title>,
    /// The contents of the issue.
    #[serde(skip_serializing_if="Option::is_none")]
    pub body: Option<String>,
    /// Login for the user that this issue should be assigned to. _NOTE: Only users with push access can set the assignee for new issues. The assignee is silently dropped otherwise. **This field is closing down.**_
    #[serde(skip_serializing_if="Option::is_none")]
    pub assignee: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub milestone: Option<OneOfbody164Milestone>,
    /// Labels to associate with this issue. _NOTE: Only users with push access can set labels for new issues. Labels are silently dropped otherwise._
    #[serde(skip_serializing_if="Option::is_none")]
    pub labels: Option<Vec<OneOfbody164LabelsItems>>,
    /// Logins for Users to assign to this issue. _NOTE: Only users with push access can set assignees for new issues. Assignees are silently dropped otherwise._
    #[serde(skip_serializing_if="Option::is_none")]
    pub assignees: Option<Vec<String>>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct PatchIssuesUpdateComment {
    /// The contents of the comment.
    #[serde(skip_serializing_if="Option::is_none")]
    pub body: Option<String>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct PostReactionsCreateForIssueComment {
    /// The [reaction type](https://docs.github.com/rest/reactions/reactions#about-reactions) to add to the issue comment.
    #[serde(skip_serializing_if="Option::is_none")]
    pub content: Option<String>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct PatchIssuesUpdate {
    /// The title of the issue.
    #[serde(skip_serializing_if="Option::is_none")]
    pub title: Option<OneOfbody167Title>,
    /// The contents of the issue.
    #[serde(skip_serializing_if="Option::is_none")]
    pub body: Option<String>,
    /// Username to assign to this issue. **This field is closing down.**
    #[serde(skip_serializing_if="Option::is_none")]
    pub assignee: Option<String>,
    /// The open or closed state of the issue.
    #[serde(skip_serializing_if="Option::is_none")]
    pub state: Option<String>,
    /// The reason for the state change. Ignored unless `state` is changed.
    #[serde(skip_serializing_if="Option::is_none")]
    pub state_reason: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub milestone: Option<OneOfbody167Milestone>,
    /// Labels to associate with this issue. Pass one or more labels to _replace_ the set of labels on this issue. Send an empty array (`[]`) to clear all labels from the issue. Only users with push access can set labels for issues. Without push access to the repository, label changes are silently dropped.
    #[serde(skip_serializing_if="Option::is_none")]
    pub labels: Option<Vec<OneOfbody167LabelsItems>>,
    /// Usernames to assign to this issue. Pass one or more user logins to _replace_ the set of assignees on this issue. Send an empty array (`[]`) to clear all assignees from the issue. Only users with push access can set assignees for new issues. Without push access to the repository, assignee changes are silently dropped.
    #[serde(skip_serializing_if="Option::is_none")]
    pub assignees: Option<Vec<String>>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct PostIssuesAddAssignees {
    /// Usernames of people to assign this issue to. _NOTE: Only users with push access can add assignees to an issue. Assignees are silently ignored otherwise._
    #[serde(skip_serializing_if="Option::is_none")]
    pub assignees: Option<Vec<String>>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct DeleteIssuesRemoveAssignees {
    /// Usernames of assignees to remove from an issue. _NOTE: Only users with push access can remove assignees from an issue. Assignees are silently ignored otherwise._
    #[serde(skip_serializing_if="Option::is_none")]
    pub assignees: Option<Vec<String>>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct PutActivitySetThreadSubscription {
    /// Whether to block all notifications from a thread.
    #[serde(skip_serializing_if="Option::is_none")]
    pub ignored: Option<bool>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct PostIssuesCreateComment {
    /// The contents of the comment.
    #[serde(skip_serializing_if="Option::is_none")]
    pub body: Option<String>,
}

#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PutIssuesSetLabels { 
    PutIssuesSetLabelsVariant0(HashMap<String, Vec<String>>),
    PutIssuesSetLabelsVariant1(Vec<String>),
    PutIssuesSetLabelsVariant2(Vec<HashMap<String, Value>>),
    PutIssuesSetLabelsVariant3(String),
}

impl From<HashMap<String, Vec<String>>> for PutIssuesSetLabels {
    fn from(value: HashMap<String, Vec<String>>) -> Self {
        PutIssuesSetLabels::PutIssuesSetLabelsVariant0(value)
    }
}

impl From<Vec<String>> for PutIssuesSetLabels {
    fn from(value: Vec<String>) -> Self {
        PutIssuesSetLabels::PutIssuesSetLabelsVariant1(value)
    }
}

impl From<Vec<HashMap<String, Value>>> for PutIssuesSetLabels {
    fn from(value: Vec<HashMap<String, Value>>) -> Self {
        PutIssuesSetLabels::PutIssuesSetLabelsVariant2(value)
    }
}

impl From<String> for PutIssuesSetLabels {
    fn from(value: String) -> Self {
        PutIssuesSetLabels::PutIssuesSetLabelsVariant3(value)
    }
}

#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PostIssuesAddLabels { 
    PostIssuesAddLabelsVariant0(HashMap<String, Vec<String>>),
    PostIssuesAddLabelsVariant1(Vec<String>),
    PostIssuesAddLabelsVariant2(Vec<HashMap<String, Value>>),
    PostIssuesAddLabelsVariant3(String),
}

impl From<HashMap<String, Vec<String>>> for PostIssuesAddLabels {
    fn from(value: HashMap<String, Vec<String>>) -> Self {
        PostIssuesAddLabels::PostIssuesAddLabelsVariant0(value)
    }
}

impl From<Vec<String>> for PostIssuesAddLabels {
    fn from(value: Vec<String>) -> Self {
        PostIssuesAddLabels::PostIssuesAddLabelsVariant1(value)
    }
}

impl From<Vec<HashMap<String, Value>>> for PostIssuesAddLabels {
    fn from(value: Vec<HashMap<String, Value>>) -> Self {
        PostIssuesAddLabels::PostIssuesAddLabelsVariant2(value)
    }
}

impl From<String> for PostIssuesAddLabels {
    fn from(value: String) -> Self {
        PostIssuesAddLabels::PostIssuesAddLabelsVariant3(value)
    }
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct PutIssuesLock {
    /// The reason for locking the issue or pull request conversation. Lock will fail if you don't use one of these reasons:    * `off-topic`    * `too heated`    * `resolved`    * `spam`
    #[serde(skip_serializing_if="Option::is_none")]
    pub lock_reason: Option<String>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct PostReactionsCreateForIssue {
    /// The [reaction type](https://docs.github.com/rest/reactions/reactions#about-reactions) to add to the issue.
    #[serde(skip_serializing_if="Option::is_none")]
    pub content: Option<String>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct DeleteIssuesRemoveSubIssue {
    /// The id of the sub-issue to remove
    #[serde(skip_serializing_if="Option::is_none")]
    pub sub_issue_id: Option<i64>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct PostIssuesAddSubIssue {
    /// The id of the sub-issue to add. The sub-issue must belong to the same repository as the parent issue
    #[serde(skip_serializing_if="Option::is_none")]
    pub sub_issue_id: Option<i64>,
    /// Option that, when true, instructs the operation to replace the sub-issues current parent issue
    #[serde(skip_serializing_if="Option::is_none")]
    pub replace_parent: Option<bool>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct PatchIssuesReprioritizeSubIssue {
    /// The id of the sub-issue to reprioritize
    #[serde(skip_serializing_if="Option::is_none")]
    pub sub_issue_id: Option<i64>,
    /// The id of the sub-issue to be prioritized after (either positional argument after OR before should be specified).
    #[serde(skip_serializing_if="Option::is_none")]
    pub after_id: Option<i64>,
    /// The id of the sub-issue to be prioritized before (either positional argument after OR before should be specified).
    #[serde(skip_serializing_if="Option::is_none")]
    pub before_id: Option<i64>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct PostReposCreateDeployKey {
    /// A name for the key.
    #[serde(skip_serializing_if="Option::is_none")]
    pub title: Option<String>,
    /// The contents of the key.
    #[serde(skip_serializing_if="Option::is_none")]
    pub key: Option<String>,
    /// If `true`, the key will only be able to read repository contents. Otherwise, the key will be able to read and write.      Deploy keys with write access can perform the same actions as an organization member with admin access, or a collaborator on a personal repository. For more information, see \"[Repository permission levels for an organization](https://docs.github.com/articles/repository-permission-levels-for-an-organization/)\" and \"[Permission levels for a user account repository](https://docs.github.com/articles/permission-levels-for-a-user-account-repository/).\"
    #[serde(skip_serializing_if="Option::is_none")]
    pub read_only: Option<bool>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct PostIssuesCreateLabel {
    /// The name of the label. Emoji can be added to label names, using either native emoji or colon-style markup. For example, typing `:strawberry:` will render the emoji ![:strawberry:](https://github.githubassets.com/images/icons/emoji/unicode/1f353.png \":strawberry:\"). For a full list of available emoji and codes, see \"[Emoji cheat sheet](https://github.com/ikatyang/emoji-cheat-sheet).\"
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,
    /// The [hexadecimal color code](http://www.color-hex.com/) for the label, without the leading `#`.
    #[serde(skip_serializing_if="Option::is_none")]
    pub color: Option<String>,
    /// A short description of the label. Must be 100 characters or fewer.
    #[serde(skip_serializing_if="Option::is_none")]
    pub description: Option<String>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct PatchOrgsUpdate {
    /// Billing email address. This address is not publicized.
    #[serde(skip_serializing_if="Option::is_none")]
    pub billing_email: Option<String>,
    /// The company name.
    #[serde(skip_serializing_if="Option::is_none")]
    pub company: Option<String>,
    /// The publicly visible email address.
    #[serde(skip_serializing_if="Option::is_none")]
    pub email: Option<String>,
    /// The Twitter username of the company.
    #[serde(skip_serializing_if="Option::is_none")]
    pub twitter_username: Option<String>,
    /// The location.
    #[serde(skip_serializing_if="Option::is_none")]
    pub location: Option<String>,
    /// The shorthand name of the company.
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,
    /// The description of the company. The maximum size is 160 characters.
    #[serde(skip_serializing_if="Option::is_none")]
    pub description: Option<String>,
    /// Whether an organization can use organization projects.
    #[serde(skip_serializing_if="Option::is_none")]
    pub has_organization_projects: Option<bool>,
    /// Whether repositories that belong to the organization can use repository projects.
    #[serde(skip_serializing_if="Option::is_none")]
    pub has_repository_projects: Option<bool>,
    /// Default permission level members have for organization repositories.
    #[serde(skip_serializing_if="Option::is_none")]
    pub default_repository_permission: Option<String>,
    /// Whether of non-admin organization members can create repositories. **Note:** A parameter can override this parameter. See `members_allowed_repository_creation_type` in this table for details.
    #[serde(skip_serializing_if="Option::is_none")]
    pub members_can_create_repositories: Option<bool>,
    /// Whether organization members can create internal repositories, which are visible to all enterprise members. You can only allow members to create internal repositories if your organization is associated with an enterprise account using GitHub Enterprise Cloud or GitHub Enterprise Server 2.20+. For more information, see \"[Restricting repository creation in your organization](https://docs.github.com/github/setting-up-and-managing-organizations-and-teams/restricting-repository-creation-in-your-organization)\" in the GitHub Help documentation.
    #[serde(skip_serializing_if="Option::is_none")]
    pub members_can_create_internal_repositories: Option<bool>,
    /// Whether organization members can create private repositories, which are visible to organization members with permission. For more information, see \"[Restricting repository creation in your organization](https://docs.github.com/github/setting-up-and-managing-organizations-and-teams/restricting-repository-creation-in-your-organization)\" in the GitHub Help documentation.
    #[serde(skip_serializing_if="Option::is_none")]
    pub members_can_create_private_repositories: Option<bool>,
    /// Whether organization members can create public repositories, which are visible to anyone. For more information, see \"[Restricting repository creation in your organization](https://docs.github.com/github/setting-up-and-managing-organizations-and-teams/restricting-repository-creation-in-your-organization)\" in the GitHub Help documentation.
    #[serde(skip_serializing_if="Option::is_none")]
    pub members_can_create_public_repositories: Option<bool>,
    /// Specifies which types of repositories non-admin organization members can create. `private` is only available to repositories that are part of an organization on GitHub Enterprise Cloud.  **Note:** This parameter is closing down and will be removed in the future. Its return value ignores internal repositories. Using this parameter overrides values set in `members_can_create_repositories`. See the parameter deprecation notice in the operation description for details.
    #[serde(skip_serializing_if="Option::is_none")]
    pub members_allowed_repository_creation_type: Option<String>,
    /// Whether organization members can create GitHub Pages sites. Existing published sites will not be impacted.
    #[serde(skip_serializing_if="Option::is_none")]
    pub members_can_create_pages: Option<bool>,
    /// Whether organization members can create public GitHub Pages sites. Existing published sites will not be impacted.
    #[serde(skip_serializing_if="Option::is_none")]
    pub members_can_create_public_pages: Option<bool>,
    /// Whether organization members can create private GitHub Pages sites. Existing published sites will not be impacted.
    #[serde(skip_serializing_if="Option::is_none")]
    pub members_can_create_private_pages: Option<bool>,
    /// Whether organization members can fork private organization repositories.
    #[serde(skip_serializing_if="Option::is_none")]
    pub members_can_fork_private_repositories: Option<bool>,
    /// Whether contributors to organization repositories are required to sign off on commits they make through GitHub's web interface.
    #[serde(skip_serializing_if="Option::is_none")]
    pub web_commit_signoff_required: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub blog: Option<String>,
    /// **Endpoint closing down notice.** Please use [code security configurations](https://docs.github.com/rest/code-security/configurations) instead.  Whether GitHub Advanced Security is automatically enabled for new repositories and repositories transferred to this organization.  To use this parameter, you must have admin permissions for the repository or be an owner or security manager for the organization that owns the repository. For more information, see \"[Managing security managers in your organization](https://docs.github.com/organizations/managing-peoples-access-to-your-organization-with-roles/managing-security-managers-in-your-organization).\"  You can check which security and analysis features are currently enabled by using a `GET /orgs/{org}` request.
    #[serde(skip_serializing_if="Option::is_none")]
    pub advanced_security_enabled_for_new_repositories: Option<bool>,
    /// **Endpoint closing down notice.** Please use [code security configurations](https://docs.github.com/rest/code-security/configurations) instead.  Whether Dependabot alerts are automatically enabled for new repositories and repositories transferred to this organization.  To use this parameter, you must have admin permissions for the repository or be an owner or security manager for the organization that owns the repository. For more information, see \"[Managing security managers in your organization](https://docs.github.com/organizations/managing-peoples-access-to-your-organization-with-roles/managing-security-managers-in-your-organization).\"  You can check which security and analysis features are currently enabled by using a `GET /orgs/{org}` request.
    #[serde(skip_serializing_if="Option::is_none")]
    pub dependabot_alerts_enabled_for_new_repositories: Option<bool>,
    /// **Endpoint closing down notice.** Please use [code security configurations](https://docs.github.com/rest/code-security/configurations) instead.  Whether Dependabot security updates are automatically enabled for new repositories and repositories transferred to this organization.  To use this parameter, you must have admin permissions for the repository or be an owner or security manager for the organization that owns the repository. For more information, see \"[Managing security managers in your organization](https://docs.github.com/organizations/managing-peoples-access-to-your-organization-with-roles/managing-security-managers-in-your-organization).\"  You can check which security and analysis features are currently enabled by using a `GET /orgs/{org}` request.
    #[serde(skip_serializing_if="Option::is_none")]
    pub dependabot_security_updates_enabled_for_new_repositories: Option<bool>,
    /// **Endpoint closing down notice.** Please use [code security configurations](https://docs.github.com/rest/code-security/configurations) instead.  Whether dependency graph is automatically enabled for new repositories and repositories transferred to this organization.  To use this parameter, you must have admin permissions for the repository or be an owner or security manager for the organization that owns the repository. For more information, see \"[Managing security managers in your organization](https://docs.github.com/organizations/managing-peoples-access-to-your-organization-with-roles/managing-security-managers-in-your-organization).\"  You can check which security and analysis features are currently enabled by using a `GET /orgs/{org}` request.
    #[serde(skip_serializing_if="Option::is_none")]
    pub dependency_graph_enabled_for_new_repositories: Option<bool>,
    /// **Endpoint closing down notice.** Please use [code security configurations](https://docs.github.com/rest/code-security/configurations) instead.  Whether secret scanning is automatically enabled for new repositories and repositories transferred to this organization.  To use this parameter, you must have admin permissions for the repository or be an owner or security manager for the organization that owns the repository. For more information, see \"[Managing security managers in your organization](https://docs.github.com/organizations/managing-peoples-access-to-your-organization-with-roles/managing-security-managers-in-your-organization).\"  You can check which security and analysis features are currently enabled by using a `GET /orgs/{org}` request.
    #[serde(skip_serializing_if="Option::is_none")]
    pub secret_scanning_enabled_for_new_repositories: Option<bool>,
    /// **Endpoint closing down notice.** Please use [code security configurations](https://docs.github.com/rest/code-security/configurations) instead.  Whether secret scanning push protection is automatically enabled for new repositories and repositories transferred to this organization.  To use this parameter, you must have admin permissions for the repository or be an owner or security manager for the organization that owns the repository. For more information, see \"[Managing security managers in your organization](https://docs.github.com/organizations/managing-peoples-access-to-your-organization-with-roles/managing-security-managers-in-your-organization).\"  You can check which security and analysis features are currently enabled by using a `GET /orgs/{org}` request.
    #[serde(skip_serializing_if="Option::is_none")]
    pub secret_scanning_push_protection_enabled_for_new_repositories: Option<bool>,
    /// Whether a custom link is shown to contributors who are blocked from pushing a secret by push protection.
    #[serde(skip_serializing_if="Option::is_none")]
    pub secret_scanning_push_protection_custom_link_enabled: Option<bool>,
    /// If `secret_scanning_push_protection_custom_link_enabled` is true, the URL that will be displayed to contributors who are blocked from pushing a secret.
    #[serde(skip_serializing_if="Option::is_none")]
    pub secret_scanning_push_protection_custom_link: Option<String>,
    /// Controls whether or not deploy keys may be added and used for repositories in the organization.
    #[serde(skip_serializing_if="Option::is_none")]
    pub deploy_keys_enabled_for_repositories: Option<bool>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct PatchIssuesUpdateLabel {
    /// The new name of the label. Emoji can be added to label names, using either native emoji or colon-style markup. For example, typing `:strawberry:` will render the emoji ![:strawberry:](https://github.githubassets.com/images/icons/emoji/unicode/1f353.png \":strawberry:\"). For a full list of available emoji and codes, see \"[Emoji cheat sheet](https://github.com/ikatyang/emoji-cheat-sheet).\"
    #[serde(skip_serializing_if="Option::is_none")]
    pub new_name: Option<String>,
    /// The [hexadecimal color code](http://www.color-hex.com/) for the label, without the leading `#`.
    #[serde(skip_serializing_if="Option::is_none")]
    pub color: Option<String>,
    /// A short description of the label. Must be 100 characters or fewer.
    #[serde(skip_serializing_if="Option::is_none")]
    pub description: Option<String>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct PostReposMergeUpstream {
    /// The name of the branch which should be updated to match upstream.
    #[serde(skip_serializing_if="Option::is_none")]
    pub branch: Option<String>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct PostReposMerge {
    /// The name of the base branch that the head will be merged into.
    #[serde(skip_serializing_if="Option::is_none")]
    pub base: Option<String>,
    /// The head to merge. This can be a branch name or a commit SHA1.
    #[serde(skip_serializing_if="Option::is_none")]
    pub head: Option<String>,
    /// Commit message to use for the merge commit. If omitted, a default message will be used.
    #[serde(skip_serializing_if="Option::is_none")]
    pub commit_message: Option<String>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct PostIssuesCreateMilestone {
    /// The title of the milestone.
    #[serde(skip_serializing_if="Option::is_none")]
    pub title: Option<String>,
    /// The state of the milestone. Either `open` or `closed`.
    #[serde(skip_serializing_if="Option::is_none")]
    pub state: Option<String>,
    /// A description of the milestone.
    #[serde(skip_serializing_if="Option::is_none")]
    pub description: Option<String>,
    /// The milestone due date. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.
    #[serde(skip_serializing_if="Option::is_none")]
    pub due_on: Option<chrono::DateTime<chrono::Utc>>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct PatchIssuesUpdateMilestone {
    /// The title of the milestone.
    #[serde(skip_serializing_if="Option::is_none")]
    pub title: Option<String>,
    /// The state of the milestone. Either `open` or `closed`.
    #[serde(skip_serializing_if="Option::is_none")]
    pub state: Option<String>,
    /// A description of the milestone.
    #[serde(skip_serializing_if="Option::is_none")]
    pub description: Option<String>,
    /// The milestone due date. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.
    #[serde(skip_serializing_if="Option::is_none")]
    pub due_on: Option<chrono::DateTime<chrono::Utc>>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct PutActivityMarkRepoNotificationsAsRead {
    /// Describes the last point that notifications were checked. Anything updated since this time will not be marked as read. If you omit this parameter, all notifications are marked as read. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`. Default: The current timestamp.
    #[serde(skip_serializing_if="Option::is_none")]
    pub last_read_at: Option<chrono::DateTime<chrono::Utc>>,
}

#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PutReposUpdateInformationAboutPagesSite { 
    PutReposUpdateInformationAboutPagesSiteVariant0(Value),
}

impl From<Value> for PutReposUpdateInformationAboutPagesSite {
    fn from(value: Value) -> Self {
        PutReposUpdateInformationAboutPagesSite::PutReposUpdateInformationAboutPagesSiteVariant0(value)
    }
}

impl Display for PutReposUpdateInformationAboutPagesSite {
    fn fmt(&self, f: &mut Formatter) -> fmt::Result {
        match self { 
            PutReposUpdateInformationAboutPagesSite::PutReposUpdateInformationAboutPagesSiteVariant0(value) => write!(f, "{}", value),
        }
    }
}

/// The source branch and directory used to publish your Pages site.
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PostReposCreatePagesSite { 
    PostReposCreatePagesSiteVariant0(Value),
}

impl From<Value> for PostReposCreatePagesSite {
    fn from(value: Value) -> Self {
        PostReposCreatePagesSite::PostReposCreatePagesSiteVariant0(value)
    }
}

impl Display for PostReposCreatePagesSite {
    fn fmt(&self, f: &mut Formatter) -> fmt::Result {
        match self { 
            PostReposCreatePagesSite::PostReposCreatePagesSiteVariant0(value) => write!(f, "{}", value),
        }
    }
}

/// The object used to create GitHub Pages deployment
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct PostReposCreatePagesDeployment {
    /// The ID of an artifact that contains the .zip or .tar of static assets to deploy. The artifact belongs to the repository. Either `artifact_id` or `artifact_url` are required.
    #[serde(skip_serializing_if="Option::is_none")]
    pub artifact_id: Option<f64>,
    /// The URL of an artifact that contains the .zip or .tar of static assets to deploy. The artifact belongs to the repository. Either `artifact_id` or `artifact_url` are required.
    #[serde(skip_serializing_if="Option::is_none")]
    pub artifact_url: Option<String>,
    /// The target environment for this GitHub Pages deployment.
    #[serde(skip_serializing_if="Option::is_none")]
    pub environment: Option<String>,
    /// A unique string that represents the version of the build for this deployment.
    #[serde(skip_serializing_if="Option::is_none")]
    pub pages_build_version: Option<String>,
    /// The OIDC token issued by GitHub Actions certifying the origin of the deployment.
    #[serde(skip_serializing_if="Option::is_none")]
    pub oidc_token: Option<String>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct PostProjectsCreateForRepo {
    /// The name of the project.
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,
    /// The description of the project.
    #[serde(skip_serializing_if="Option::is_none")]
    pub body: Option<String>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct PostActionsCreateHostedRunnerForOrg {
    /// Name of the runner. Must be between 1 and 64 characters and may only contain upper and lowercase letters a-z, numbers 0-9, '.', '-', and '_'.
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub image: Option<OrgsorgactionshostedrunnersImage>,
    /// The machine size of the runner. To list available sizes, use `GET actions/hosted-runners/machine-sizes`
    #[serde(skip_serializing_if="Option::is_none")]
    pub size: Option<String>,
    /// The existing runner group to add this runner to.
    #[serde(skip_serializing_if="Option::is_none")]
    pub runner_group_id: Option<i64>,
    /// The maximum amount of runners to scale up to. Runners will not auto-scale above this number. Use this setting to limit your cost.
    #[serde(skip_serializing_if="Option::is_none")]
    pub maximum_runners: Option<i64>,
    /// Whether this runner should be created with a static public IP. Note limit on account. To list limits on account, use `GET actions/hosted-runners/limits`
    #[serde(skip_serializing_if="Option::is_none")]
    pub enable_static_ip: Option<bool>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct PatchReposCreateOrUpdateCustomPropertiesValues {
    /// A list of custom property names and associated values to apply to the repositories.
    #[serde(skip_serializing_if="Option::is_none")]
    pub properties: Option<Vec<CustomPropertyValue>>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct PostPullsCreate {
    /// The title of the new pull request. Required unless `issue` is specified.
    #[serde(skip_serializing_if="Option::is_none")]
    pub title: Option<String>,
    /// The name of the branch where your changes are implemented. For cross-repository pull requests in the same network, namespace `head` with a user like this: `username:branch`.
    #[serde(skip_serializing_if="Option::is_none")]
    pub head: Option<String>,
    /// The name of the repository where the changes in the pull request were made. This field is required for cross-repository pull requests if both repositories are owned by the same organization.
    #[serde(skip_serializing_if="Option::is_none")]
    pub head_repo: Option<String>,
    /// The name of the branch you want the changes pulled into. This should be an existing branch on the current repository. You cannot submit a pull request to one repository that requests a merge to a base of another repository.
    #[serde(skip_serializing_if="Option::is_none")]
    pub base: Option<String>,
    /// The contents of the pull request.
    #[serde(skip_serializing_if="Option::is_none")]
    pub body: Option<String>,
    /// Indicates whether [maintainers can modify](https://docs.github.com/articles/allowing-changes-to-a-pull-request-branch-created-from-a-fork/) the pull request.
    #[serde(skip_serializing_if="Option::is_none")]
    pub maintainer_can_modify: Option<bool>,
    /// Indicates whether the pull request is a draft. See \"[Draft Pull Requests](https://docs.github.com/articles/about-pull-requests#draft-pull-requests)\" in the GitHub Help documentation to learn more.
    #[serde(skip_serializing_if="Option::is_none")]
    pub draft: Option<bool>,
    /// An issue in the repository to convert to a pull request. The issue title, body, and comments will become the title, body, and comments on the new pull request. Required unless `title` is specified.
    #[serde(skip_serializing_if="Option::is_none")]
    pub issue: Option<i64>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct PatchPullsUpdateReviewComment {
    /// The text of the reply to the review comment.
    #[serde(skip_serializing_if="Option::is_none")]
    pub body: Option<String>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct PostReactionsCreateForPullRequestReviewComment {
    /// The [reaction type](https://docs.github.com/rest/reactions/reactions#about-reactions) to add to the pull request review comment.
    #[serde(skip_serializing_if="Option::is_none")]
    pub content: Option<String>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct PatchPullsUpdate {
    /// The title of the pull request.
    #[serde(skip_serializing_if="Option::is_none")]
    pub title: Option<String>,
    /// The contents of the pull request.
    #[serde(skip_serializing_if="Option::is_none")]
    pub body: Option<String>,
    /// State of this Pull Request. Either `open` or `closed`.
    #[serde(skip_serializing_if="Option::is_none")]
    pub state: Option<String>,
    /// The name of the branch you want your changes pulled into. This should be an existing branch on the current repository. You cannot update the base branch on a pull request to point to another repository.
    #[serde(skip_serializing_if="Option::is_none")]
    pub base: Option<String>,
    /// Indicates whether [maintainers can modify](https://docs.github.com/articles/allowing-changes-to-a-pull-request-branch-created-from-a-fork/) the pull request.
    #[serde(skip_serializing_if="Option::is_none")]
    pub maintainer_can_modify: Option<bool>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct PostCodespacesCreateWithPrForAuthenticatedUser {
    /// The requested location for a new codespace. Best efforts are made to respect this upon creation. Assigned by IP if not provided.
    #[serde(skip_serializing_if="Option::is_none")]
    pub location: Option<String>,
    /// The geographic area for this codespace. If not specified, the value is assigned by IP. This property replaces `location`, which is closing down.
    #[serde(skip_serializing_if="Option::is_none")]
    pub geo: Option<String>,
    /// IP for location auto-detection when proxying a request
    #[serde(skip_serializing_if="Option::is_none")]
    pub client_ip: Option<String>,
    /// Machine type to use for this codespace
    #[serde(skip_serializing_if="Option::is_none")]
    pub machine: Option<String>,
    /// Path to devcontainer.json config to use for this codespace
    #[serde(skip_serializing_if="Option::is_none")]
    pub devcontainer_path: Option<String>,
    /// Whether to authorize requested permissions from devcontainer.json
    #[serde(skip_serializing_if="Option::is_none")]
    pub multi_repo_permissions_opt_out: Option<bool>,
    /// Working directory for this codespace
    #[serde(skip_serializing_if="Option::is_none")]
    pub working_directory: Option<String>,
    /// Time in minutes before codespace stops from inactivity
    #[serde(skip_serializing_if="Option::is_none")]
    pub idle_timeout_minutes: Option<i64>,
    /// Display name for this codespace
    #[serde(skip_serializing_if="Option::is_none")]
    pub display_name: Option<String>,
    /// Duration in minutes after codespace has gone idle in which it will be deleted. Must be integer minutes between 0 and 43200 (30 days).
    #[serde(skip_serializing_if="Option::is_none")]
    pub retention_period_minutes: Option<i64>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct PostPullsCreateReviewComment {
    /// The text of the review comment.
    #[serde(skip_serializing_if="Option::is_none")]
    pub body: Option<String>,
    /// The SHA of the commit needing a comment. Not using the latest commit SHA may render your comment outdated if a subsequent commit modifies the line you specify as the `position`.
    #[serde(skip_serializing_if="Option::is_none")]
    pub commit_id: Option<String>,
    /// The relative path to the file that necessitates a comment.
    #[serde(skip_serializing_if="Option::is_none")]
    pub path: Option<String>,
    /// **This parameter is closing down. Use `line` instead**. The position in the diff where you want to add a review comment. Note this value is not the same as the line number in the file. The position value equals the number of lines down from the first \"@@\" hunk header in the file you want to add a comment. The line just below the \"@@\" line is position 1, the next line is position 2, and so on. The position in the diff continues to increase through lines of whitespace and additional hunks until the beginning of a new file.
    #[serde(skip_serializing_if="Option::is_none")]
    pub position: Option<i64>,
    /// In a split diff view, the side of the diff that the pull request's changes appear on. Can be `LEFT` or `RIGHT`. Use `LEFT` for deletions that appear in red. Use `RIGHT` for additions that appear in green or unchanged lines that appear in white and are shown for context. For a multi-line comment, side represents whether the last line of the comment range is a deletion or addition. For more information, see \"[Diff view options](https://docs.github.com/articles/about-comparing-branches-in-pull-requests#diff-view-options)\" in the GitHub Help documentation.
    #[serde(skip_serializing_if="Option::is_none")]
    pub side: Option<String>,
    /// **Required unless using `subject_type:file`**. The line of the blob in the pull request diff that the comment applies to. For a multi-line comment, the last line of the range that your comment applies to.
    #[serde(skip_serializing_if="Option::is_none")]
    pub line: Option<i64>,
    /// **Required when using multi-line comments unless using `in_reply_to`**. The `start_line` is the first line in the pull request diff that your multi-line comment applies to. To learn more about multi-line comments, see \"[Commenting on a pull request](https://docs.github.com/articles/commenting-on-a-pull-request#adding-line-comments-to-a-pull-request)\" in the GitHub Help documentation.
    #[serde(skip_serializing_if="Option::is_none")]
    pub start_line: Option<i64>,
    /// **Required when using multi-line comments unless using `in_reply_to`**. The `start_side` is the starting side of the diff that the comment applies to. Can be `LEFT` or `RIGHT`. To learn more about multi-line comments, see \"[Commenting on a pull request](https://docs.github.com/articles/commenting-on-a-pull-request#adding-line-comments-to-a-pull-request)\" in the GitHub Help documentation. See `side` in this table for additional context.
    #[serde(skip_serializing_if="Option::is_none")]
    pub start_side: Option<String>,
    /// The ID of the review comment to reply to. To find the ID of a review comment with [\"List review comments on a pull request\"](#list-review-comments-on-a-pull-request). When specified, all parameters other than `body` in the request body are ignored.
    #[serde(skip_serializing_if="Option::is_none")]
    pub in_reply_to: Option<i64>,
    /// The level at which the comment is targeted.
    #[serde(skip_serializing_if="Option::is_none")]
    pub subject_type: Option<String>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct PostPullsCreateReplyForReviewComment {
    /// The text of the review comment.
    #[serde(skip_serializing_if="Option::is_none")]
    pub body: Option<String>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct PutPullsMerge {
    /// Title for the automatic commit message.
    #[serde(skip_serializing_if="Option::is_none")]
    pub commit_title: Option<String>,
    /// Extra detail to append to automatic commit message.
    #[serde(skip_serializing_if="Option::is_none")]
    pub commit_message: Option<String>,
    /// SHA that pull request head must match to allow merge.
    #[serde(skip_serializing_if="Option::is_none")]
    pub sha: Option<String>,
    /// The merge method to use.
    #[serde(skip_serializing_if="Option::is_none")]
    pub merge_method: Option<String>,
}

#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PostPullsRequestReviewers { 
    PostPullsRequestReviewersVariant0(Value),
}

impl From<Value> for PostPullsRequestReviewers {
    fn from(value: Value) -> Self {
        PostPullsRequestReviewers::PostPullsRequestReviewersVariant0(value)
    }
}

impl Display for PostPullsRequestReviewers {
    fn fmt(&self, f: &mut Formatter) -> fmt::Result {
        match self { 
            PostPullsRequestReviewers::PostPullsRequestReviewersVariant0(value) => write!(f, "{}", value),
        }
    }
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct DeleteAppsDeleteAuthorization {
    /// The OAuth access token used to authenticate to the GitHub API.
    #[serde(skip_serializing_if="Option::is_none")]
    pub access_token: Option<String>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct PatchActionsUpdateHostedRunnerForOrg {
    /// Name of the runner. Must be between 1 and 64 characters and may only contain upper and lowercase letters a-z, numbers 0-9, '.', '-', and '_'.
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,
    /// The existing runner group to add this runner to.
    #[serde(skip_serializing_if="Option::is_none")]
    pub runner_group_id: Option<i64>,
    /// The maximum amount of runners to scale up to. Runners will not auto-scale above this number. Use this setting to limit your cost.
    #[serde(skip_serializing_if="Option::is_none")]
    pub maximum_runners: Option<i64>,
    /// Whether this runner should be updated with a static public IP. Note limit on account. To list limits on account, use `GET actions/hosted-runners/limits`
    #[serde(skip_serializing_if="Option::is_none")]
    pub enable_static_ip: Option<bool>,
    /// The version of the runner image to deploy. This is relevant only for runners using custom images.
    #[serde(skip_serializing_if="Option::is_none")]
    pub image_version: Option<String>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct DeletePullsRemoveRequestedReviewers {
    /// An array of user `login`s that will be removed.
    #[serde(skip_serializing_if="Option::is_none")]
    pub reviewers: Option<Vec<String>>,
    /// An array of team `slug`s that will be removed.
    #[serde(skip_serializing_if="Option::is_none")]
    pub team_reviewers: Option<Vec<String>>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct PostPullsCreateReview {
    /// The SHA of the commit that needs a review. Not using the latest commit SHA may render your review comment outdated if a subsequent commit modifies the line you specify as the `position`. Defaults to the most recent commit in the pull request when you do not specify a value.
    #[serde(skip_serializing_if="Option::is_none")]
    pub commit_id: Option<String>,
    /// **Required** when using `REQUEST_CHANGES` or `COMMENT` for the `event` parameter. The body text of the pull request review.
    #[serde(skip_serializing_if="Option::is_none")]
    pub body: Option<String>,
    /// The review action you want to perform. The review actions include: `APPROVE`, `REQUEST_CHANGES`, or `COMMENT`. By leaving this blank, you set the review action state to `PENDING`, which means you will need to [submit the pull request review](https://docs.github.com/rest/pulls/reviews#submit-a-review-for-a-pull-request) when you are ready.
    #[serde(skip_serializing_if="Option::is_none")]
    pub event: Option<String>,
    /// Use the following table to specify the location, destination, and contents of the draft review comment.
    #[serde(skip_serializing_if="Option::is_none")]
    pub comments: Option<Vec<ReposownerrepopullspullNumberreviewsComments>>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct PutPullsUpdateReview {
    /// The body text of the pull request review.
    #[serde(skip_serializing_if="Option::is_none")]
    pub body: Option<String>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct PutPullsDismissReview {
    /// The message for the pull request review dismissal
    #[serde(skip_serializing_if="Option::is_none")]
    pub message: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub event: Option<String>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct PostPullsSubmitReview {
    /// The body text of the pull request review
    #[serde(skip_serializing_if="Option::is_none")]
    pub body: Option<String>,
    /// The review action you want to perform. The review actions include: `APPROVE`, `REQUEST_CHANGES`, or `COMMENT`. When you leave this blank, the API returns _HTTP 422 (Unrecognizable entity)_ and sets the review action state to `PENDING`, which means you will need to re-submit the pull request review using a review action.
    #[serde(skip_serializing_if="Option::is_none")]
    pub event: Option<String>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct PutPullsUpdateBranch {
    /// The expected SHA of the pull request's HEAD ref. This is the most recent commit on the pull request's branch. If the expected SHA does not match the pull request's HEAD, you will receive a `422 Unprocessable Entity` status. You can use the \"[List commits](https://docs.github.com/rest/commits/commits#list-commits)\" endpoint to find the most recent commit SHA. Default: SHA of the pull request's current HEAD ref.
    #[serde(skip_serializing_if="Option::is_none")]
    pub expected_head_sha: Option<String>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct PostReposCreateRelease {
    /// The name of the tag.
    #[serde(skip_serializing_if="Option::is_none")]
    pub tag_name: Option<String>,
    /// Specifies the commitish value that determines where the Git tag is created from. Can be any branch or commit SHA. Unused if the Git tag already exists. Default: the repository's default branch.
    #[serde(skip_serializing_if="Option::is_none")]
    pub target_commitish: Option<String>,
    /// The name of the release.
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,
    /// Text describing the contents of the tag.
    #[serde(skip_serializing_if="Option::is_none")]
    pub body: Option<String>,
    /// `true` to create a draft (unpublished) release, `false` to create a published one.
    #[serde(skip_serializing_if="Option::is_none")]
    pub draft: Option<bool>,
    /// `true` to identify the release as a prerelease. `false` to identify the release as a full release.
    #[serde(skip_serializing_if="Option::is_none")]
    pub prerelease: Option<bool>,
    /// If specified, a discussion of the specified category is created and linked to the release. The value must be a category that already exists in the repository. For more information, see \"[Managing categories for discussions in your repository](https://docs.github.com/discussions/managing-discussions-for-your-community/managing-categories-for-discussions-in-your-repository).\"
    #[serde(skip_serializing_if="Option::is_none")]
    pub discussion_category_name: Option<String>,
    /// Whether to automatically generate the name and body for this release. If `name` is specified, the specified name will be used; otherwise, a name will be automatically generated. If `body` is specified, the body will be pre-pended to the automatically generated notes.
    #[serde(skip_serializing_if="Option::is_none")]
    pub generate_release_notes: Option<bool>,
    /// Specifies whether this release should be set as the latest release for the repository. Drafts and prereleases cannot be set as latest. Defaults to `true` for newly published releases. `legacy` specifies that the latest release should be determined based on the release creation date and higher semantic version.
    #[serde(skip_serializing_if="Option::is_none")]
    pub make_latest: Option<String>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct PatchReposUpdateReleaseAsset {
    /// The file name of the asset.
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,
    /// An alternate short description of the asset. Used in place of the filename.
    #[serde(skip_serializing_if="Option::is_none")]
    pub label: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub state: Option<String>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct PostReposGenerateReleaseNotes {
    /// The tag name for the release. This can be an existing tag or a new one.
    #[serde(skip_serializing_if="Option::is_none")]
    pub tag_name: Option<String>,
    /// Specifies the commitish value that will be the target for the release's tag. Required if the supplied tag_name does not reference an existing tag. Ignored if the tag_name already exists.
    #[serde(skip_serializing_if="Option::is_none")]
    pub target_commitish: Option<String>,
    /// The name of the previous tag to use as the starting point for the release notes. Use to manually specify the range for the set of changes considered as part this release.
    #[serde(skip_serializing_if="Option::is_none")]
    pub previous_tag_name: Option<String>,
    /// Specifies a path to a file in the repository containing configuration settings used for generating the release notes. If unspecified, the configuration file located in the repository at '.github/release.yml' or '.github/release.yaml' will be used. If that is not present, the default configuration will be used.
    #[serde(skip_serializing_if="Option::is_none")]
    pub configuration_file_path: Option<String>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct PatchReposUpdateRelease {
    /// The name of the tag.
    #[serde(skip_serializing_if="Option::is_none")]
    pub tag_name: Option<String>,
    /// Specifies the commitish value that determines where the Git tag is created from. Can be any branch or commit SHA. Unused if the Git tag already exists. Default: the repository's default branch.
    #[serde(skip_serializing_if="Option::is_none")]
    pub target_commitish: Option<String>,
    /// The name of the release.
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,
    /// Text describing the contents of the tag.
    #[serde(skip_serializing_if="Option::is_none")]
    pub body: Option<String>,
    /// `true` makes the release a draft, and `false` publishes the release.
    #[serde(skip_serializing_if="Option::is_none")]
    pub draft: Option<bool>,
    /// `true` to identify the release as a prerelease, `false` to identify the release as a full release.
    #[serde(skip_serializing_if="Option::is_none")]
    pub prerelease: Option<bool>,
    /// Specifies whether this release should be set as the latest release for the repository. Drafts and prereleases cannot be set as latest. Defaults to `true` for newly published releases. `legacy` specifies that the latest release should be determined based on the release creation date and higher semantic version.
    #[serde(skip_serializing_if="Option::is_none")]
    pub make_latest: Option<String>,
    /// If specified, a discussion of the specified category is created and linked to the release. The value must be a category that already exists in the repository. If there is already a discussion linked to the release, this parameter is ignored. For more information, see \"[Managing categories for discussions in your repository](https://docs.github.com/discussions/managing-discussions-for-your-community/managing-categories-for-discussions-in-your-repository).\"
    #[serde(skip_serializing_if="Option::is_none")]
    pub discussion_category_name: Option<String>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct PutActionsSetGithubActionsPermissionsOrganization {
    #[serde(skip_serializing_if="Option::is_none")]
    pub enabled_repositories: Option<EnabledRepositories>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub allowed_actions: Option<AllowedActions>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct PostReactionsCreateForRelease {
    /// The [reaction type](https://docs.github.com/rest/reactions/reactions#about-reactions) to add to the release.
    #[serde(skip_serializing_if="Option::is_none")]
    pub content: Option<String>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct PostReposCreateRepoRuleset {
    /// The name of the ruleset.
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,
    /// The target of the ruleset
    #[serde(skip_serializing_if="Option::is_none")]
    pub target: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub enforcement: Option<RepositoryRuleEnforcement>,
    /// The actors that can bypass the rules in this ruleset
    #[serde(skip_serializing_if="Option::is_none")]
    pub bypass_actors: Option<Vec<RepositoryRulesetBypassActor>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub conditions: Option<RepositoryRulesetConditions>,
    /// An array of rules within the ruleset.
    #[serde(skip_serializing_if="Option::is_none")]
    pub rules: Option<Vec<RepositoryRule>>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct PutReposUpdateRepoRuleset {
    /// The name of the ruleset.
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,
    /// The target of the ruleset
    #[serde(skip_serializing_if="Option::is_none")]
    pub target: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub enforcement: Option<RepositoryRuleEnforcement>,
    /// The actors that can bypass the rules in this ruleset
    #[serde(skip_serializing_if="Option::is_none")]
    pub bypass_actors: Option<Vec<RepositoryRulesetBypassActor>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub conditions: Option<RepositoryRulesetConditions>,
    /// An array of rules within the ruleset.
    #[serde(skip_serializing_if="Option::is_none")]
    pub rules: Option<Vec<RepositoryRule>>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct PatchSecretScanningUpdateAlert {
    #[serde(skip_serializing_if="Option::is_none")]
    pub state: Option<SecretScanningAlertState>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub resolution: Option<SecretScanningAlertResolution>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub resolution_comment: Option<SecretScanningAlertResolutionComment>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct PostSecretScanningCreatePushProtectionBypass {
    #[serde(skip_serializing_if="Option::is_none")]
    pub reason: Option<SecretScanningPushProtectionBypassReason>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub placeholder_id: Option<SecretScanningPushProtectionBypassPlaceholderId>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct PostReposCreateCommitStatus {
    /// The state of the status.
    #[serde(skip_serializing_if="Option::is_none")]
    pub state: Option<String>,
    /// The target URL to associate with this status. This URL will be linked from the GitHub UI to allow users to easily see the source of the status.   For example, if your continuous integration system is posting build status, you would want to provide the deep link for the build output for this specific SHA:   `http://ci.example.com/user/repo/build/sha`
    #[serde(skip_serializing_if="Option::is_none")]
    pub target_url: Option<String>,
    /// A short description of the status.
    #[serde(skip_serializing_if="Option::is_none")]
    pub description: Option<String>,
    /// A string label to differentiate this status from the status of other systems. This field is case-insensitive.
    #[serde(skip_serializing_if="Option::is_none")]
    pub context: Option<String>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct PutActivitySetRepoSubscription {
    /// Determines if notifications should be received from this repository.
    #[serde(skip_serializing_if="Option::is_none")]
    pub subscribed: Option<bool>,
    /// Determines if all notifications should be blocked from this repository.
    #[serde(skip_serializing_if="Option::is_none")]
    pub ignored: Option<bool>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct PostReposCreateTagProtection {
    /// An optional glob pattern to match against when enforcing tag protection.
    #[serde(skip_serializing_if="Option::is_none")]
    pub pattern: Option<String>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct PutReposReplaceAllTopics {
    /// An array of topics to add to the repository. Pass one or more topics to _replace_ the set of existing topics. Send an empty array (`[]`) to clear all topics from the repository. **Note:** Topic `names` will be saved as lowercase.
    #[serde(skip_serializing_if="Option::is_none")]
    pub names: Option<Vec<String>>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct PostReposTransfer {
    /// The username or organization name the repository will be transferred to.
    #[serde(skip_serializing_if="Option::is_none")]
    pub new_owner: Option<String>,
    /// The new name to be given to the repository.
    #[serde(skip_serializing_if="Option::is_none")]
    pub new_name: Option<String>,
    /// ID of the team or teams to add to the repository. Teams can only be added to organization-owned repositories.
    #[serde(skip_serializing_if="Option::is_none")]
    pub team_ids: Option<Vec<i32>>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct PutActionsSetSelectedRepositoriesEnabledGithubActionsOrganization {
    /// List of repository IDs to enable for GitHub Actions.
    #[serde(skip_serializing_if="Option::is_none")]
    pub selected_repository_ids: Option<Vec<i32>>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct PostReposCreateUsingTemplate {
    /// The organization or person who will own the new repository. To create a new repository in an organization, the authenticated user must be a member of the specified organization.
    #[serde(skip_serializing_if="Option::is_none")]
    pub owner: Option<String>,
    /// The name of the new repository.
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,
    /// A short description of the new repository.
    #[serde(skip_serializing_if="Option::is_none")]
    pub description: Option<String>,
    /// Set to `true` to include the directory structure and files from all branches in the template repository, and not just the default branch. Default: `false`.
    #[serde(skip_serializing_if="Option::is_none")]
    pub include_all_branches: Option<bool>,
    /// Either `true` to create a new private repository or `false` to create a new public one.
    #[serde(skip_serializing_if="Option::is_none")]
    pub private: Option<bool>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct PatchTeamsUpdateLegacy {
    /// The name of the team.
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,
    /// The description of the team.
    #[serde(skip_serializing_if="Option::is_none")]
    pub description: Option<String>,
    /// The level of privacy this team should have. Editing teams without specifying this parameter leaves `privacy` intact. The options are:   **For a non-nested team:**    * `secret` - only visible to organization owners and members of this team.    * `closed` - visible to all members of this organization.   **For a parent or child team:**    * `closed` - visible to all members of this organization.
    #[serde(skip_serializing_if="Option::is_none")]
    pub privacy: Option<String>,
    /// The notification setting the team has chosen. Editing teams without specifying this parameter leaves `notification_setting` intact. The options are:   * `notifications_enabled` - team members receive notifications when the team is @mentioned.    * `notifications_disabled` - no one receives notifications.
    #[serde(skip_serializing_if="Option::is_none")]
    pub notification_setting: Option<String>,
    /// **Closing down notice**. The permission that new repositories will be added to the team with when none is specified.
    #[serde(skip_serializing_if="Option::is_none")]
    pub permission: Option<String>,
    /// The ID of a team to set as the parent team.
    #[serde(skip_serializing_if="Option::is_none")]
    pub parent_team_id: Option<i64>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct PostTeamsCreateDiscussionLegacy {
    /// The discussion post's title.
    #[serde(skip_serializing_if="Option::is_none")]
    pub title: Option<String>,
    /// The discussion post's body text.
    #[serde(skip_serializing_if="Option::is_none")]
    pub body: Option<String>,
    /// Private posts are only visible to team members, organization owners, and team maintainers. Public posts are visible to all members of the organization. Set to `true` to create a private post.
    #[serde(skip_serializing_if="Option::is_none")]
    pub private: Option<bool>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct PatchTeamsUpdateDiscussionLegacy {
    /// The discussion post's title.
    #[serde(skip_serializing_if="Option::is_none")]
    pub title: Option<String>,
    /// The discussion post's body text.
    #[serde(skip_serializing_if="Option::is_none")]
    pub body: Option<String>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct PostTeamsCreateDiscussionCommentLegacy {
    /// The discussion comment's body text.
    #[serde(skip_serializing_if="Option::is_none")]
    pub body: Option<String>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct PatchTeamsUpdateDiscussionCommentLegacy {
    /// The discussion comment's body text.
    #[serde(skip_serializing_if="Option::is_none")]
    pub body: Option<String>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct PostReactionsCreateForTeamDiscussionCommentLegacy {
    /// The [reaction type](https://docs.github.com/rest/reactions/reactions#about-reactions) to add to the team discussion comment.
    #[serde(skip_serializing_if="Option::is_none")]
    pub content: Option<String>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct PostReactionsCreateForTeamDiscussionLegacy {
    /// The [reaction type](https://docs.github.com/rest/reactions/reactions#about-reactions) to add to the team discussion.
    #[serde(skip_serializing_if="Option::is_none")]
    pub content: Option<String>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct PutTeamsAddOrUpdateMembershipForUserLegacy {
    /// The role that this user should have in the team.
    #[serde(skip_serializing_if="Option::is_none")]
    pub role: Option<String>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct PutTeamsAddOrUpdateProjectPermissionsLegacy {
    /// The permission to grant to the team for this project. Default: the team's `permission` attribute will be used to determine what permission to grant the team on this project. Note that, if you choose not to pass any parameters, you'll need to set `Content-Length` to zero when calling this endpoint. For more information, see \"[HTTP method](https://docs.github.com/rest/guides/getting-started-with-the-rest-api#http-method).\"
    #[serde(skip_serializing_if="Option::is_none")]
    pub permission: Option<String>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct PostActionsCreateSelfHostedRunnerGroupForOrg {
    /// Name of the runner group.
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,
    /// Visibility of a runner group. You can select all repositories, select individual repositories, or limit access to private repositories.
    #[serde(skip_serializing_if="Option::is_none")]
    pub visibility: Option<String>,
    /// List of repository IDs that can access the runner group.
    #[serde(skip_serializing_if="Option::is_none")]
    pub selected_repository_ids: Option<Vec<i32>>,
    /// List of runner IDs to add to the runner group.
    #[serde(skip_serializing_if="Option::is_none")]
    pub runners: Option<Vec<i32>>,
    /// Whether the runner group can be used by `public` repositories.
    #[serde(skip_serializing_if="Option::is_none")]
    pub allows_public_repositories: Option<bool>,
    /// If `true`, the runner group will be restricted to running only the workflows specified in the `selected_workflows` array.
    #[serde(skip_serializing_if="Option::is_none")]
    pub restricted_to_workflows: Option<bool>,
    /// List of workflows the runner group should be allowed to run. This setting will be ignored unless `restricted_to_workflows` is set to `true`.
    #[serde(skip_serializing_if="Option::is_none")]
    pub selected_workflows: Option<Vec<String>>,
    /// The identifier of a hosted compute network configuration.
    #[serde(skip_serializing_if="Option::is_none")]
    pub network_configuration_id: Option<String>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct PutTeamsAddOrUpdateRepoPermissionsLegacy {
    /// The permission to grant the team on this repository. If no permission is specified, the team's `permission` attribute will be used to determine what permission to grant the team on this repository.
    #[serde(skip_serializing_if="Option::is_none")]
    pub permission: Option<String>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct PatchUsersUpdateAuthenticated {
    /// The new name of the user.
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,
    /// The publicly visible email address of the user.
    #[serde(skip_serializing_if="Option::is_none")]
    pub email: Option<String>,
    /// The new blog URL of the user.
    #[serde(skip_serializing_if="Option::is_none")]
    pub blog: Option<String>,
    /// The new Twitter username of the user.
    #[serde(skip_serializing_if="Option::is_none")]
    pub twitter_username: Option<String>,
    /// The new company of the user.
    #[serde(skip_serializing_if="Option::is_none")]
    pub company: Option<String>,
    /// The new location of the user.
    #[serde(skip_serializing_if="Option::is_none")]
    pub location: Option<String>,
    /// The new hiring availability of the user.
    #[serde(skip_serializing_if="Option::is_none")]
    pub hireable: Option<bool>,
    /// The new short biography of the user.
    #[serde(skip_serializing_if="Option::is_none")]
    pub bio: Option<String>,
}

#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PostCodespacesCreateForAuthenticatedUser { 
    PostCodespacesCreateForAuthenticatedUserVariant0(HashMap<String, i32>),
}

impl From<HashMap<String, i32>> for PostCodespacesCreateForAuthenticatedUser {
    fn from(value: HashMap<String, i32>) -> Self {
        PostCodespacesCreateForAuthenticatedUser::PostCodespacesCreateForAuthenticatedUserVariant0(value)
    }
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct PutCodespacesCreateOrUpdateSecretForAuthenticatedUser {
    /// Value for your secret, encrypted with [LibSodium](https://libsodium.gitbook.io/doc/bindings_for_other_languages) using the public key retrieved from the [Get the public key for the authenticated user](https://docs.github.com/rest/codespaces/secrets#get-public-key-for-the-authenticated-user) endpoint.
    #[serde(skip_serializing_if="Option::is_none")]
    pub encrypted_value: Option<String>,
    /// ID of the key you used to encrypt the secret.
    #[serde(skip_serializing_if="Option::is_none")]
    pub key_id: Option<String>,
    /// An array of repository ids that can access the user secret. You can manage the list of selected repositories using the [List selected repositories for a user secret](https://docs.github.com/rest/codespaces/secrets#list-selected-repositories-for-a-user-secret), [Set selected repositories for a user secret](https://docs.github.com/rest/codespaces/secrets#set-selected-repositories-for-a-user-secret), and [Remove a selected repository from a user secret](https://docs.github.com/rest/codespaces/secrets#remove-a-selected-repository-from-a-user-secret) endpoints.
    #[serde(skip_serializing_if="Option::is_none")]
    pub selected_repository_ids: Option<Vec<AnyOfbody233SelectedRepositoryIdsItems>>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct PutCodespacesSetRepositoriesForSecretForAuthenticatedUser {
    /// An array of repository ids for which a codespace can access the secret. You can manage the list of selected repositories using the [List selected repositories for a user secret](https://docs.github.com/rest/codespaces/secrets#list-selected-repositories-for-a-user-secret), [Add a selected repository to a user secret](https://docs.github.com/rest/codespaces/secrets#add-a-selected-repository-to-a-user-secret), and [Remove a selected repository from a user secret](https://docs.github.com/rest/codespaces/secrets#remove-a-selected-repository-from-a-user-secret) endpoints.
    #[serde(skip_serializing_if="Option::is_none")]
    pub selected_repository_ids: Option<Vec<i32>>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct PatchCodespacesUpdateForAuthenticatedUser {
    /// A valid machine to transition this codespace to.
    #[serde(skip_serializing_if="Option::is_none")]
    pub machine: Option<String>,
    /// Display name for this codespace
    #[serde(skip_serializing_if="Option::is_none")]
    pub display_name: Option<String>,
    /// Recently opened folders inside the codespace. It is currently used by the clients to determine the folder path to load the codespace in.
    #[serde(skip_serializing_if="Option::is_none")]
    pub recent_folders: Option<Vec<String>>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct PostCodespacesPublishForAuthenticatedUser {
    /// A name for the new repository.
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,
    /// Whether the new repository should be private.
    #[serde(skip_serializing_if="Option::is_none")]
    pub private: Option<bool>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct PatchUsersSetPrimaryEmailVisibilityForAuthenticatedUser {
    /// Denotes whether an email is publicly visible.
    #[serde(skip_serializing_if="Option::is_none")]
    pub visibility: Option<String>,
}

#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PostUsersAddEmailForAuthenticatedUser { 
    PostUsersAddEmailForAuthenticatedUserVariant0(HashMap<String, Vec<String>>),
    PostUsersAddEmailForAuthenticatedUserVariant1(Vec<String>),
    PostUsersAddEmailForAuthenticatedUserVariant2(String),
}

impl From<HashMap<String, Vec<String>>> for PostUsersAddEmailForAuthenticatedUser {
    fn from(value: HashMap<String, Vec<String>>) -> Self {
        PostUsersAddEmailForAuthenticatedUser::PostUsersAddEmailForAuthenticatedUserVariant0(value)
    }
}

impl From<Vec<String>> for PostUsersAddEmailForAuthenticatedUser {
    fn from(value: Vec<String>) -> Self {
        PostUsersAddEmailForAuthenticatedUser::PostUsersAddEmailForAuthenticatedUserVariant1(value)
    }
}

impl From<String> for PostUsersAddEmailForAuthenticatedUser {
    fn from(value: String) -> Self {
        PostUsersAddEmailForAuthenticatedUser::PostUsersAddEmailForAuthenticatedUserVariant2(value)
    }
}

#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteUsersDeleteEmailForAuthenticatedUser { 
    DeleteUsersDeleteEmailForAuthenticatedUserVariant0(HashMap<String, Vec<String>>),
    DeleteUsersDeleteEmailForAuthenticatedUserVariant1(Vec<String>),
    DeleteUsersDeleteEmailForAuthenticatedUserVariant2(String),
}

impl From<HashMap<String, Vec<String>>> for DeleteUsersDeleteEmailForAuthenticatedUser {
    fn from(value: HashMap<String, Vec<String>>) -> Self {
        DeleteUsersDeleteEmailForAuthenticatedUser::DeleteUsersDeleteEmailForAuthenticatedUserVariant0(value)
    }
}

impl From<Vec<String>> for DeleteUsersDeleteEmailForAuthenticatedUser {
    fn from(value: Vec<String>) -> Self {
        DeleteUsersDeleteEmailForAuthenticatedUser::DeleteUsersDeleteEmailForAuthenticatedUserVariant1(value)
    }
}

impl From<String> for DeleteUsersDeleteEmailForAuthenticatedUser {
    fn from(value: String) -> Self {
        DeleteUsersDeleteEmailForAuthenticatedUser::DeleteUsersDeleteEmailForAuthenticatedUserVariant2(value)
    }
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct PatchActionsUpdateSelfHostedRunnerGroupForOrg {
    /// Name of the runner group.
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,
    /// Visibility of a runner group. You can select all repositories, select individual repositories, or all private repositories.
    #[serde(skip_serializing_if="Option::is_none")]
    pub visibility: Option<String>,
    /// Whether the runner group can be used by `public` repositories.
    #[serde(skip_serializing_if="Option::is_none")]
    pub allows_public_repositories: Option<bool>,
    /// If `true`, the runner group will be restricted to running only the workflows specified in the `selected_workflows` array.
    #[serde(skip_serializing_if="Option::is_none")]
    pub restricted_to_workflows: Option<bool>,
    /// List of workflows the runner group should be allowed to run. This setting will be ignored unless `restricted_to_workflows` is set to `true`.
    #[serde(skip_serializing_if="Option::is_none")]
    pub selected_workflows: Option<Vec<String>>,
    /// The identifier of a hosted compute network configuration.
    #[serde(skip_serializing_if="Option::is_none")]
    pub network_configuration_id: Option<String>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct PostUsersCreateGpgKeyForAuthenticatedUser {
    /// A descriptive name for the new key.
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,
    /// A GPG key in ASCII-armored format.
    #[serde(skip_serializing_if="Option::is_none")]
    pub armored_public_key: Option<String>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct PostUsersCreatePublicSshKeyForAuthenticatedUser {
    /// A descriptive name for the new key.
    #[serde(skip_serializing_if="Option::is_none")]
    pub title: Option<String>,
    /// The public SSH key to add to your GitHub account.
    #[serde(skip_serializing_if="Option::is_none")]
    pub key: Option<String>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct PatchOrgsUpdateMembershipForAuthenticatedUser {
    /// The state that the membership should be in. Only `\"active\"` will be accepted.
    #[serde(skip_serializing_if="Option::is_none")]
    pub state: Option<String>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct PostMigrationsStartForAuthenticatedUser {
    /// Lock the repositories being migrated at the start of the migration
    #[serde(skip_serializing_if="Option::is_none")]
    pub lock_repositories: Option<bool>,
    /// Indicates whether metadata should be excluded and only git source should be included for the migration.
    #[serde(skip_serializing_if="Option::is_none")]
    pub exclude_metadata: Option<bool>,
    /// Indicates whether the repository git data should be excluded from the migration.
    #[serde(skip_serializing_if="Option::is_none")]
    pub exclude_git_data: Option<bool>,
    /// Do not include attachments in the migration
    #[serde(skip_serializing_if="Option::is_none")]
    pub exclude_attachments: Option<bool>,
    /// Do not include releases in the migration
    #[serde(skip_serializing_if="Option::is_none")]
    pub exclude_releases: Option<bool>,
    /// Indicates whether projects owned by the organization or users should be excluded.
    #[serde(skip_serializing_if="Option::is_none")]
    pub exclude_owner_projects: Option<bool>,
    /// Indicates whether this should only include organization metadata (repositories array should be empty and will ignore other flags).
    #[serde(skip_serializing_if="Option::is_none")]
    pub org_metadata_only: Option<bool>,
    /// Exclude attributes from the API response to improve performance
    #[serde(skip_serializing_if="Option::is_none")]
    pub exclude: Option<Vec<String>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub repositories: Option<Vec<String>>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct PostProjectsCreateForAuthenticatedUser {
    /// Name of the project
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,
    /// Body of the project
    #[serde(skip_serializing_if="Option::is_none")]
    pub body: Option<String>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct PostReposCreateForAuthenticatedUser {
    /// The name of the repository.
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,
    /// A short description of the repository.
    #[serde(skip_serializing_if="Option::is_none")]
    pub description: Option<String>,
    /// A URL with more information about the repository.
    #[serde(skip_serializing_if="Option::is_none")]
    pub homepage: Option<String>,
    /// Whether the repository is private.
    #[serde(skip_serializing_if="Option::is_none")]
    pub private: Option<bool>,
    /// Whether issues are enabled.
    #[serde(skip_serializing_if="Option::is_none")]
    pub has_issues: Option<bool>,
    /// Whether projects are enabled.
    #[serde(skip_serializing_if="Option::is_none")]
    pub has_projects: Option<bool>,
    /// Whether the wiki is enabled.
    #[serde(skip_serializing_if="Option::is_none")]
    pub has_wiki: Option<bool>,
    /// Whether discussions are enabled.
    #[serde(skip_serializing_if="Option::is_none")]
    pub has_discussions: Option<bool>,
    /// The id of the team that will be granted access to this repository. This is only valid when creating a repository in an organization.
    #[serde(skip_serializing_if="Option::is_none")]
    pub team_id: Option<i64>,
    /// Whether the repository is initialized with a minimal README.
    #[serde(skip_serializing_if="Option::is_none")]
    pub auto_init: Option<bool>,
    /// The desired language or platform to apply to the .gitignore.
    #[serde(skip_serializing_if="Option::is_none")]
    pub gitignore_template: Option<String>,
    /// The license keyword of the open source license for this repository.
    #[serde(skip_serializing_if="Option::is_none")]
    pub license_template: Option<String>,
    /// Whether to allow squash merges for pull requests.
    #[serde(skip_serializing_if="Option::is_none")]
    pub allow_squash_merge: Option<bool>,
    /// Whether to allow merge commits for pull requests.
    #[serde(skip_serializing_if="Option::is_none")]
    pub allow_merge_commit: Option<bool>,
    /// Whether to allow rebase merges for pull requests.
    #[serde(skip_serializing_if="Option::is_none")]
    pub allow_rebase_merge: Option<bool>,
    /// Whether to allow Auto-merge to be used on pull requests.
    #[serde(skip_serializing_if="Option::is_none")]
    pub allow_auto_merge: Option<bool>,
    /// Whether to delete head branches when pull requests are merged
    #[serde(skip_serializing_if="Option::is_none")]
    pub delete_branch_on_merge: Option<bool>,
    /// Required when using `squash_merge_commit_message`.  The default value for a squash merge commit title:  - `PR_TITLE` - default to the pull request's title. - `COMMIT_OR_PR_TITLE` - default to the commit's title (if only one commit) or the pull request's title (when more than one commit).
    #[serde(skip_serializing_if="Option::is_none")]
    pub squash_merge_commit_title: Option<String>,
    /// The default value for a squash merge commit message:  - `PR_BODY` - default to the pull request's body. - `COMMIT_MESSAGES` - default to the branch's commit messages. - `BLANK` - default to a blank commit message.
    #[serde(skip_serializing_if="Option::is_none")]
    pub squash_merge_commit_message: Option<String>,
    /// Required when using `merge_commit_message`.  The default value for a merge commit title.  - `PR_TITLE` - default to the pull request's title. - `MERGE_MESSAGE` - default to the classic title for a merge message (e.g., Merge pull request #123 from branch-name).
    #[serde(skip_serializing_if="Option::is_none")]
    pub merge_commit_title: Option<String>,
    /// The default value for a merge commit message.  - `PR_TITLE` - default to the pull request's title. - `PR_BODY` - default to the pull request's body. - `BLANK` - default to a blank commit message.
    #[serde(skip_serializing_if="Option::is_none")]
    pub merge_commit_message: Option<String>,
    /// Whether downloads are enabled.
    #[serde(skip_serializing_if="Option::is_none")]
    pub has_downloads: Option<bool>,
    /// Whether this repository acts as a template that can be used to generate new repositories.
    #[serde(skip_serializing_if="Option::is_none")]
    pub is_template: Option<bool>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct PostUsersAddSocialAccountForAuthenticatedUser {
    /// Full URLs for the social media profiles to add.
    #[serde(skip_serializing_if="Option::is_none")]
    pub account_urls: Option<Vec<String>>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct DeleteUsersDeleteSocialAccountForAuthenticatedUser {
    /// Full URLs for the social media profiles to delete.
    #[serde(skip_serializing_if="Option::is_none")]
    pub account_urls: Option<Vec<String>>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct PostUsersCreateSshSigningKeyForAuthenticatedUser {
    /// A descriptive name for the new key.
    #[serde(skip_serializing_if="Option::is_none")]
    pub title: Option<String>,
    /// The public SSH key to add to your GitHub account. For more information, see \"[Checking for existing SSH keys](https://docs.github.com/authentication/connecting-to-github-with-ssh/checking-for-existing-ssh-keys).\"
    #[serde(skip_serializing_if="Option::is_none")]
    pub key: Option<String>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct PutActionsSetRepoAccessToSelfHostedRunnerGroupInOrg {
    /// List of repository IDs that can access the runner group.
    #[serde(skip_serializing_if="Option::is_none")]
    pub selected_repository_ids: Option<Vec<i32>>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct PutActionsSetSelfHostedRunnersInGroupForOrg {
    /// List of runner IDs to add to the runner group.
    #[serde(skip_serializing_if="Option::is_none")]
    pub runners: Option<Vec<i32>>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct PostActionsGenerateRunnerJitconfigForOrg {
    /// The name of the new runner.
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,
    /// The ID of the runner group to register the runner to.
    #[serde(skip_serializing_if="Option::is_none")]
    pub runner_group_id: Option<i64>,
    /// The names of the custom labels to add to the runner. **Minimum items**: 1. **Maximum items**: 100.
    #[serde(skip_serializing_if="Option::is_none")]
    pub labels: Option<Vec<String>>,
    /// The working directory to be used for job execution, relative to the runner install directory.
    #[serde(skip_serializing_if="Option::is_none")]
    pub work_folder: Option<String>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct PutActionsSetCustomLabelsForSelfHostedRunnerForOrg {
    /// The names of the custom labels to set for the runner. You can pass an empty array to remove all custom labels.
    #[serde(skip_serializing_if="Option::is_none")]
    pub labels: Option<Vec<String>>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct PostActionsAddCustomLabelsToSelfHostedRunnerForOrg {
    /// The names of the custom labels to add to the runner.
    #[serde(skip_serializing_if="Option::is_none")]
    pub labels: Option<Vec<String>>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct PostAppsCheckToken {
    /// The access_token of the OAuth or GitHub application.
    #[serde(skip_serializing_if="Option::is_none")]
    pub access_token: Option<String>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct PutActionsCreateOrUpdateOrgSecret {
    /// Value for your secret, encrypted with [LibSodium](https://libsodium.gitbook.io/doc/bindings_for_other_languages) using the public key retrieved from the [Get an organization public key](https://docs.github.com/rest/actions/secrets#get-an-organization-public-key) endpoint.
    #[serde(skip_serializing_if="Option::is_none")]
    pub encrypted_value: Option<String>,
    /// ID of the key you used to encrypt the secret.
    #[serde(skip_serializing_if="Option::is_none")]
    pub key_id: Option<String>,
    /// Which type of organization repositories have access to the organization secret. `selected` means only the repositories specified by `selected_repository_ids` can access the secret.
    #[serde(skip_serializing_if="Option::is_none")]
    pub visibility: Option<String>,
    /// An array of repository ids that can access the organization secret. You can only provide a list of repository ids when the `visibility` is set to `selected`. You can manage the list of selected repositories using the [List selected repositories for an organization secret](https://docs.github.com/rest/actions/secrets#list-selected-repositories-for-an-organization-secret), [Set selected repositories for an organization secret](https://docs.github.com/rest/actions/secrets#set-selected-repositories-for-an-organization-secret), and [Remove selected repository from an organization secret](https://docs.github.com/rest/actions/secrets#remove-selected-repository-from-an-organization-secret) endpoints.
    #[serde(skip_serializing_if="Option::is_none")]
    pub selected_repository_ids: Option<Vec<i32>>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct PutActionsSetSelectedReposForOrgSecret {
    /// An array of repository ids that can access the organization secret. You can only provide a list of repository ids when the `visibility` is set to `selected`. You can add and remove individual repositories using the [Add selected repository to an organization secret](https://docs.github.com/rest/actions/secrets#add-selected-repository-to-an-organization-secret) and [Remove selected repository from an organization secret](https://docs.github.com/rest/actions/secrets#remove-selected-repository-from-an-organization-secret) endpoints.
    #[serde(skip_serializing_if="Option::is_none")]
    pub selected_repository_ids: Option<Vec<i32>>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct PostActionsCreateOrgVariable {
    /// The name of the variable.
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,
    /// The value of the variable.
    #[serde(skip_serializing_if="Option::is_none")]
    pub value: Option<String>,
    /// The type of repositories in the organization that can access the variable. `selected` means only the repositories specified by `selected_repository_ids` can access the variable.
    #[serde(skip_serializing_if="Option::is_none")]
    pub visibility: Option<String>,
    /// An array of repository ids that can access the organization variable. You can only provide a list of repository ids when the `visibility` is set to `selected`.
    #[serde(skip_serializing_if="Option::is_none")]
    pub selected_repository_ids: Option<Vec<i32>>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct PatchActionsUpdateOrgVariable {
    /// The name of the variable.
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,
    /// The value of the variable.
    #[serde(skip_serializing_if="Option::is_none")]
    pub value: Option<String>,
    /// The type of repositories in the organization that can access the variable. `selected` means only the repositories specified by `selected_repository_ids` can access the variable.
    #[serde(skip_serializing_if="Option::is_none")]
    pub visibility: Option<String>,
    /// An array of repository ids that can access the organization variable. You can only provide a list of repository ids when the `visibility` is set to `selected`.
    #[serde(skip_serializing_if="Option::is_none")]
    pub selected_repository_ids: Option<Vec<i32>>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct PutActionsSetSelectedReposForOrgVariable {
    /// The IDs of the repositories that can access the organization variable.
    #[serde(skip_serializing_if="Option::is_none")]
    pub selected_repository_ids: Option<Vec<i32>>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct PostCodeSecurityCreateConfiguration {
    /// The name of the code security configuration. Must be unique within the organization.
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,
    /// A description of the code security configuration
    #[serde(skip_serializing_if="Option::is_none")]
    pub description: Option<String>,
    /// The enablement status of GitHub Advanced Security
    #[serde(skip_serializing_if="Option::is_none")]
    pub advanced_security: Option<String>,
    /// The enablement status of Dependency Graph
    #[serde(skip_serializing_if="Option::is_none")]
    pub dependency_graph: Option<String>,
    /// The enablement status of Automatic dependency submission
    #[serde(skip_serializing_if="Option::is_none")]
    pub dependency_graph_autosubmit_action: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub dependency_graph_autosubmit_action_options: Option<EnterprisesenterprisecodesecurityconfigurationsDependencyGraphAutosubmitActionOptions>,
    /// The enablement status of Dependabot alerts
    #[serde(skip_serializing_if="Option::is_none")]
    pub dependabot_alerts: Option<String>,
    /// The enablement status of Dependabot security updates
    #[serde(skip_serializing_if="Option::is_none")]
    pub dependabot_security_updates: Option<String>,
    /// The enablement status of code scanning default setup
    #[serde(skip_serializing_if="Option::is_none")]
    pub code_scanning_default_setup: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub code_scanning_default_setup_options: Option<CodeScanningDefaultSetupOptions>,
    /// The enablement status of secret scanning
    #[serde(skip_serializing_if="Option::is_none")]
    pub secret_scanning: Option<String>,
    /// The enablement status of secret scanning push protection
    #[serde(skip_serializing_if="Option::is_none")]
    pub secret_scanning_push_protection: Option<String>,
    /// The enablement status of secret scanning delegated bypass
    #[serde(skip_serializing_if="Option::is_none")]
    pub secret_scanning_delegated_bypass: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub secret_scanning_delegated_bypass_options: Option<OrgsorgcodesecurityconfigurationsSecretScanningDelegatedBypassOptions>,
    /// The enablement status of secret scanning validity checks
    #[serde(skip_serializing_if="Option::is_none")]
    pub secret_scanning_validity_checks: Option<String>,
    /// The enablement status of secret scanning non provider patterns
    #[serde(skip_serializing_if="Option::is_none")]
    pub secret_scanning_non_provider_patterns: Option<String>,
    /// The enablement status of private vulnerability reporting
    #[serde(skip_serializing_if="Option::is_none")]
    pub private_vulnerability_reporting: Option<String>,
    /// The enforcement status for a security configuration
    #[serde(skip_serializing_if="Option::is_none")]
    pub enforcement: Option<String>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct DeleteCodeSecurityDetachConfiguration {
    /// An array of repository IDs to detach from configurations.
    #[serde(skip_serializing_if="Option::is_none")]
    pub selected_repository_ids: Option<Vec<i32>>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct PatchCodeSecurityUpdateConfiguration {
    /// The name of the code security configuration. Must be unique within the organization.
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,
    /// A description of the code security configuration
    #[serde(skip_serializing_if="Option::is_none")]
    pub description: Option<String>,
    /// The enablement status of GitHub Advanced Security
    #[serde(skip_serializing_if="Option::is_none")]
    pub advanced_security: Option<String>,
    /// The enablement status of Dependency Graph
    #[serde(skip_serializing_if="Option::is_none")]
    pub dependency_graph: Option<String>,
    /// The enablement status of Automatic dependency submission
    #[serde(skip_serializing_if="Option::is_none")]
    pub dependency_graph_autosubmit_action: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub dependency_graph_autosubmit_action_options: Option<EnterprisesenterprisecodesecurityconfigurationsconfigurationIdDependencyGraphAutosubmitActionOptions>,
    /// The enablement status of Dependabot alerts
    #[serde(skip_serializing_if="Option::is_none")]
    pub dependabot_alerts: Option<String>,
    /// The enablement status of Dependabot security updates
    #[serde(skip_serializing_if="Option::is_none")]
    pub dependabot_security_updates: Option<String>,
    /// The enablement status of code scanning default setup
    #[serde(skip_serializing_if="Option::is_none")]
    pub code_scanning_default_setup: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub code_scanning_default_setup_options: Option<CodeScanningDefaultSetupOptions>,
    /// The enablement status of secret scanning
    #[serde(skip_serializing_if="Option::is_none")]
    pub secret_scanning: Option<String>,
    /// The enablement status of secret scanning push protection
    #[serde(skip_serializing_if="Option::is_none")]
    pub secret_scanning_push_protection: Option<String>,
    /// The enablement status of secret scanning delegated bypass
    #[serde(skip_serializing_if="Option::is_none")]
    pub secret_scanning_delegated_bypass: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub secret_scanning_delegated_bypass_options: Option<OrgsorgcodesecurityconfigurationsSecretScanningDelegatedBypassOptions>,
    /// The enablement status of secret scanning validity checks
    #[serde(skip_serializing_if="Option::is_none")]
    pub secret_scanning_validity_checks: Option<String>,
    /// The enablement status of secret scanning non-provider patterns
    #[serde(skip_serializing_if="Option::is_none")]
    pub secret_scanning_non_provider_patterns: Option<String>,
    /// The enablement status of private vulnerability reporting
    #[serde(skip_serializing_if="Option::is_none")]
    pub private_vulnerability_reporting: Option<String>,
    /// The enforcement status for a security configuration
    #[serde(skip_serializing_if="Option::is_none")]
    pub enforcement: Option<String>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct PostCodeSecurityAttachConfiguration {
    /// The type of repositories to attach the configuration to. `selected` means the configuration will be attached to only the repositories specified by `selected_repository_ids`
    #[serde(skip_serializing_if="Option::is_none")]
    pub scope: Option<String>,
    /// An array of repository IDs to attach the configuration to. You can only provide a list of repository ids when the `scope` is set to `selected`.
    #[serde(skip_serializing_if="Option::is_none")]
    pub selected_repository_ids: Option<Vec<i32>>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct PutCodeSecuritySetConfigurationAsDefault {
    /// Specify which types of repository this security configuration should be applied to by default.
    #[serde(skip_serializing_if="Option::is_none")]
    pub default_for_new_repos: Option<String>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct DeleteAppsDeleteToken {
    /// The OAuth access token used to authenticate to the GitHub API.
    #[serde(skip_serializing_if="Option::is_none")]
    pub access_token: Option<String>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct PutCodespacesSetCodespacesAccess {
    /// Which users can access codespaces in the organization. `disabled` means that no users can access codespaces in the organization.
    #[serde(skip_serializing_if="Option::is_none")]
    pub visibility: Option<String>,
    /// The usernames of the organization members who should have access to codespaces in the organization. Required when `visibility` is `selected_members`. The provided list of usernames will replace any existing value.
    #[serde(skip_serializing_if="Option::is_none")]
    pub selected_usernames: Option<Vec<String>>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct PostCodespacesSetCodespacesAccessUsers {
    /// The usernames of the organization members whose codespaces be billed to the organization.
    #[serde(skip_serializing_if="Option::is_none")]
    pub selected_usernames: Option<Vec<String>>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct DeleteCodespacesDeleteCodespacesAccessUsers {
    /// The usernames of the organization members whose codespaces should not be billed to the organization.
    #[serde(skip_serializing_if="Option::is_none")]
    pub selected_usernames: Option<Vec<String>>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct PutCodespacesCreateOrUpdateOrgSecret {
    /// The value for your secret, encrypted with [LibSodium](https://libsodium.gitbook.io/doc/bindings_for_other_languages) using the public key retrieved from the [Get an organization public key](https://docs.github.com/rest/codespaces/organization-secrets#get-an-organization-public-key) endpoint.
    #[serde(skip_serializing_if="Option::is_none")]
    pub encrypted_value: Option<String>,
    /// The ID of the key you used to encrypt the secret.
    #[serde(skip_serializing_if="Option::is_none")]
    pub key_id: Option<String>,
    /// Which type of organization repositories have access to the organization secret. `selected` means only the repositories specified by `selected_repository_ids` can access the secret.
    #[serde(skip_serializing_if="Option::is_none")]
    pub visibility: Option<String>,
    /// An array of repository IDs that can access the organization secret. You can only provide a list of repository IDs when the `visibility` is set to `selected`. You can manage the list of selected repositories using the [List selected repositories for an organization secret](https://docs.github.com/rest/codespaces/organization-secrets#list-selected-repositories-for-an-organization-secret), [Set selected repositories for an organization secret](https://docs.github.com/rest/codespaces/organization-secrets#set-selected-repositories-for-an-organization-secret), and [Remove selected repository from an organization secret](https://docs.github.com/rest/codespaces/organization-secrets#remove-selected-repository-from-an-organization-secret) endpoints.
    #[serde(skip_serializing_if="Option::is_none")]
    pub selected_repository_ids: Option<Vec<i32>>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct PutCodespacesSetSelectedReposForOrgSecret {
    /// An array of repository ids that can access the organization secret. You can only provide a list of repository ids when the `visibility` is set to `selected`. You can add and remove individual repositories using the [Set selected repositories for an organization secret](https://docs.github.com/rest/codespaces/organization-secrets#set-selected-repositories-for-an-organization-secret) and [Remove selected repository from an organization secret](https://docs.github.com/rest/codespaces/organization-secrets#remove-selected-repository-from-an-organization-secret) endpoints.
    #[serde(skip_serializing_if="Option::is_none")]
    pub selected_repository_ids: Option<Vec<i32>>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct PostCopilotAddCopilotSeatsForTeams {
    /// List of team names within the organization to which to grant access to GitHub Copilot.
    #[serde(skip_serializing_if="Option::is_none")]
    pub selected_teams: Option<Vec<String>>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct DeleteCopilotCancelCopilotSeatAssignmentForTeams {
    /// The names of teams from which to revoke access to GitHub Copilot.
    #[serde(skip_serializing_if="Option::is_none")]
    pub selected_teams: Option<Vec<String>>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct PostCopilotAddCopilotSeatsForUsers {
    /// The usernames of the organization members to be granted access to GitHub Copilot.
    #[serde(skip_serializing_if="Option::is_none")]
    pub selected_usernames: Option<Vec<String>>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct DeleteCopilotCancelCopilotSeatAssignmentForUsers {
    /// The usernames of the organization members for which to revoke access to GitHub Copilot.
    #[serde(skip_serializing_if="Option::is_none")]
    pub selected_usernames: Option<Vec<String>>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct PutDependabotCreateOrUpdateOrgSecret {
    /// Value for your secret, encrypted with [LibSodium](https://libsodium.gitbook.io/doc/bindings_for_other_languages) using the public key retrieved from the [Get an organization public key](https://docs.github.com/rest/dependabot/secrets#get-an-organization-public-key) endpoint.
    #[serde(skip_serializing_if="Option::is_none")]
    pub encrypted_value: Option<String>,
    /// ID of the key you used to encrypt the secret.
    #[serde(skip_serializing_if="Option::is_none")]
    pub key_id: Option<String>,
    /// Which type of organization repositories have access to the organization secret. `selected` means only the repositories specified by `selected_repository_ids` can access the secret.
    #[serde(skip_serializing_if="Option::is_none")]
    pub visibility: Option<String>,
    /// An array of repository ids that can access the organization secret. You can only provide a list of repository ids when the `visibility` is set to `selected`. You can manage the list of selected repositories using the [List selected repositories for an organization secret](https://docs.github.com/rest/dependabot/secrets#list-selected-repositories-for-an-organization-secret), [Set selected repositories for an organization secret](https://docs.github.com/rest/dependabot/secrets#set-selected-repositories-for-an-organization-secret), and [Remove selected repository from an organization secret](https://docs.github.com/rest/dependabot/secrets#remove-selected-repository-from-an-organization-secret) endpoints.
    #[serde(skip_serializing_if="Option::is_none")]
    pub selected_repository_ids: Option<Vec<String>>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct PatchAppsResetToken {
    /// The access_token of the OAuth or GitHub application.
    #[serde(skip_serializing_if="Option::is_none")]
    pub access_token: Option<String>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct PutDependabotSetSelectedReposForOrgSecret {
    /// An array of repository ids that can access the organization secret. You can only provide a list of repository ids when the `visibility` is set to `selected`. You can add and remove individual repositories using the [Set selected repositories for an organization secret](https://docs.github.com/rest/dependabot/secrets#set-selected-repositories-for-an-organization-secret) and [Remove selected repository from an organization secret](https://docs.github.com/rest/dependabot/secrets#remove-selected-repository-from-an-organization-secret) endpoints.
    #[serde(skip_serializing_if="Option::is_none")]
    pub selected_repository_ids: Option<Vec<i32>>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct PostOrgsCreateWebhook {
    /// Must be passed as \"web\".
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub config: Option<OrgsorghooksConfig>,
    /// Determines what [events](https://docs.github.com/webhooks/event-payloads) the hook is triggered for. Set to `[\"*\"]` to receive all possible events.
    #[serde(skip_serializing_if="Option::is_none")]
    pub events: Option<Vec<String>>,
    /// Determines if notifications are sent when the webhook is triggered. Set to `true` to send notifications.
    #[serde(skip_serializing_if="Option::is_none")]
    pub active: Option<bool>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct PatchOrgsUpdateWebhook {
    #[serde(skip_serializing_if="Option::is_none")]
    pub config: Option<OrgsorghookshookIdConfig>,
    /// Determines what [events](https://docs.github.com/webhooks/event-payloads) the hook is triggered for.
    #[serde(skip_serializing_if="Option::is_none")]
    pub events: Option<Vec<String>>,
    /// Determines if notifications are sent when the webhook is triggered. Set to `true` to send notifications.
    #[serde(skip_serializing_if="Option::is_none")]
    pub active: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct PatchOrgsUpdateWebhookConfigForOrg {
    #[serde(skip_serializing_if="Option::is_none")]
    pub url: Option<WebhookConfigUrl>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub content_type: Option<WebhookConfigContentType>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub secret: Option<WebhookConfigSecret>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub insecure_ssl: Option<WebhookConfigInsecureSsl>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct PostOrgsCreateInvitation {
    /// **Required unless you provide `email`**. GitHub user ID for the person you are inviting.
    #[serde(skip_serializing_if="Option::is_none")]
    pub invitee_id: Option<i64>,
    /// **Required unless you provide `invitee_id`**. Email address of the person you are inviting, which can be an existing GitHub user.
    #[serde(skip_serializing_if="Option::is_none")]
    pub email: Option<String>,
    /// The role for the new member.   * `admin` - Organization owners with full administrative rights to the organization and complete access to all repositories and teams.    * `direct_member` - Non-owner organization members with ability to see other members and join teams by invitation.    * `billing_manager` - Non-owner organization members with ability to manage the billing settings of your organization.   * `reinstate` - The previous role assigned to the invitee before they were removed from your organization. Can be one of the roles listed above. Only works if the invitee was previously part of your organization.
    #[serde(skip_serializing_if="Option::is_none")]
    pub role: Option<String>,
    /// Specify IDs for the teams you want to invite new members to.
    #[serde(skip_serializing_if="Option::is_none")]
    pub team_ids: Option<Vec<i32>>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct PutOrgsSetMembershipForUser {
    /// The role to give the user in the organization. Can be one of:    * `admin` - The user will become an owner of the organization.    * `member` - The user will become a non-owner member of the organization.
    #[serde(skip_serializing_if="Option::is_none")]
    pub role: Option<String>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct PostMigrationsStartForOrg {
    /// A list of arrays indicating which repositories should be migrated.
    #[serde(skip_serializing_if="Option::is_none")]
    pub repositories: Option<Vec<String>>,
    /// Indicates whether repositories should be locked (to prevent manipulation) while migrating data.
    #[serde(skip_serializing_if="Option::is_none")]
    pub lock_repositories: Option<bool>,
    /// Indicates whether metadata should be excluded and only git source should be included for the migration.
    #[serde(skip_serializing_if="Option::is_none")]
    pub exclude_metadata: Option<bool>,
    /// Indicates whether the repository git data should be excluded from the migration.
    #[serde(skip_serializing_if="Option::is_none")]
    pub exclude_git_data: Option<bool>,
    /// Indicates whether attachments should be excluded from the migration (to reduce migration archive file size).
    #[serde(skip_serializing_if="Option::is_none")]
    pub exclude_attachments: Option<bool>,
    /// Indicates whether releases should be excluded from the migration (to reduce migration archive file size).
    #[serde(skip_serializing_if="Option::is_none")]
    pub exclude_releases: Option<bool>,
    /// Indicates whether projects owned by the organization or users should be excluded. from the migration.
    #[serde(skip_serializing_if="Option::is_none")]
    pub exclude_owner_projects: Option<bool>,
    /// Indicates whether this should only include organization metadata (repositories array should be empty and will ignore other flags).
    #[serde(skip_serializing_if="Option::is_none")]
    pub org_metadata_only: Option<bool>,
    /// Exclude related items from being returned in the response in order to improve performance of the request.
    #[serde(skip_serializing_if="Option::is_none")]
    pub exclude: Option<Vec<String>>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct PutOrgsConvertMemberToOutsideCollaborator {
    /// When set to `true`, the request will be performed asynchronously. Returns a 202 status code when the job is successfully queued.
    #[serde(rename = "async")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub _async: Option<bool>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct PostOrgsReviewPatGrantRequestsInBulk {
    /// Unique identifiers of the requests for access via fine-grained personal access token. Must be formed of between 1 and 100 `pat_request_id` values.
    #[serde(skip_serializing_if="Option::is_none")]
    pub pat_request_ids: Option<Vec<i32>>,
    /// Action to apply to the requests.
    #[serde(skip_serializing_if="Option::is_none")]
    pub action: Option<String>,
    /// Reason for approving or denying the requests. Max 1024 characters.
    #[serde(skip_serializing_if="Option::is_none")]
    pub reason: Option<String>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct PostOrgsReviewPatGrantRequest {
    /// Action to apply to the request.
    #[serde(skip_serializing_if="Option::is_none")]
    pub action: Option<String>,
    /// Reason for approving or denying the request. Max 1024 characters.
    #[serde(skip_serializing_if="Option::is_none")]
    pub reason: Option<String>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct PostAppsScopeToken {
    /// The access token used to authenticate to the GitHub API.
    #[serde(skip_serializing_if="Option::is_none")]
    pub access_token: Option<String>,
    /// The name of the user or organization to scope the user access token to. **Required** unless `target_id` is specified.
    #[serde(skip_serializing_if="Option::is_none")]
    pub target: Option<String>,
    /// The ID of the user or organization to scope the user access token to. **Required** unless `target` is specified.
    #[serde(skip_serializing_if="Option::is_none")]
    pub target_id: Option<i64>,
    /// The list of repository names to scope the user access token to. `repositories` may not be specified if `repository_ids` is specified.
    #[serde(skip_serializing_if="Option::is_none")]
    pub repositories: Option<Vec<String>>,
    /// The list of repository IDs to scope the user access token to. `repository_ids` may not be specified if `repositories` is specified.
    #[serde(skip_serializing_if="Option::is_none")]
    pub repository_ids: Option<Vec<i32>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub permissions: Option<AppPermissions>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct PostOrgsUpdatePatAccesses {
    /// Action to apply to the fine-grained personal access token.
    #[serde(skip_serializing_if="Option::is_none")]
    pub action: Option<String>,
    /// The IDs of the fine-grained personal access tokens.
    #[serde(skip_serializing_if="Option::is_none")]
    pub pat_ids: Option<Vec<i32>>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct PostOrgsUpdatePatAccess {
    /// Action to apply to the fine-grained personal access token.
    #[serde(skip_serializing_if="Option::is_none")]
    pub action: Option<String>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct PostPrivateRegistriesCreateOrgPrivateRegistry {
    /// The registry type.
    #[serde(skip_serializing_if="Option::is_none")]
    pub registry_type: Option<String>,
    /// The username to use when authenticating with the private registry. This field should be omitted if the private registry does not require a username for authentication.
    #[serde(skip_serializing_if="Option::is_none")]
    pub username: Option<String>,
    /// The value for your secret, encrypted with [LibSodium](https://libsodium.gitbook.io/doc/bindings_for_other_languages) using the public key retrieved from the [Get private registries public key for an organization](https://docs.github.com/rest/private-registries/organization-configurations#get-private-registries-public-key-for-an-organization) endpoint.
    #[serde(skip_serializing_if="Option::is_none")]
    pub encrypted_value: Option<String>,
    /// The ID of the key you used to encrypt the secret.
    #[serde(skip_serializing_if="Option::is_none")]
    pub key_id: Option<String>,
    /// Which type of organization repositories have access to the private registry. `selected` means only the repositories specified by `selected_repository_ids` can access the private registry.
    #[serde(skip_serializing_if="Option::is_none")]
    pub visibility: Option<String>,
    /// An array of repository IDs that can access the organization private registry. You can only provide a list of repository IDs when `visibility` is set to `selected`. You can manage the list of selected repositories using the [Update a private registry for an organization](https://docs.github.com/rest/private-registries/organization-configurations#update-a-private-registry-for-an-organization) endpoint. This field should be omitted if `visibility` is set to `all` or `private`.
    #[serde(skip_serializing_if="Option::is_none")]
    pub selected_repository_ids: Option<Vec<i32>>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct PatchPrivateRegistriesUpdateOrgPrivateRegistry {
    /// The registry type.
    #[serde(skip_serializing_if="Option::is_none")]
    pub registry_type: Option<String>,
    /// The username to use when authenticating with the private registry. This field should be omitted if the private registry does not require a username for authentication.
    #[serde(skip_serializing_if="Option::is_none")]
    pub username: Option<String>,
    /// The value for your secret, encrypted with [LibSodium](https://libsodium.gitbook.io/doc/bindings_for_other_languages) using the public key retrieved from the [Get private registries public key for an organization](https://docs.github.com/rest/private-registries/organization-configurations#get-private-registries-public-key-for-an-organization) endpoint.
    #[serde(skip_serializing_if="Option::is_none")]
    pub encrypted_value: Option<String>,
    /// The ID of the key you used to encrypt the secret.
    #[serde(skip_serializing_if="Option::is_none")]
    pub key_id: Option<String>,
    /// Which type of organization repositories have access to the private registry. `selected` means only the repositories specified by `selected_repository_ids` can access the private registry.
    #[serde(skip_serializing_if="Option::is_none")]
    pub visibility: Option<String>,
    /// An array of repository IDs that can access the organization private registry. You can only provide a list of repository IDs when `visibility` is set to `selected`. This field should be omitted if `visibility` is set to `all` or `private`.
    #[serde(skip_serializing_if="Option::is_none")]
    pub selected_repository_ids: Option<Vec<i32>>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct PostProjectsCreateForOrg {
    /// The name of the project.
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,
    /// The description of the project.
    #[serde(skip_serializing_if="Option::is_none")]
    pub body: Option<String>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct PatchOrgsCreateOrUpdateCustomProperties {
    /// The array of custom properties to create or update.
    #[serde(skip_serializing_if="Option::is_none")]
    pub properties: Option<Vec<CustomProperty>>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct PatchOrgsCreateOrUpdateCustomPropertiesValuesForRepos {
    /// The names of repositories that the custom property values will be applied to.
    #[serde(skip_serializing_if="Option::is_none")]
    pub repository_names: Option<Vec<String>>,
    /// List of custom property names and associated values to apply to the repositories.
    #[serde(skip_serializing_if="Option::is_none")]
    pub properties: Option<Vec<CustomPropertyValue>>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct PostReposCreateInOrg {
    /// The name of the repository.
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,
    /// A short description of the repository.
    #[serde(skip_serializing_if="Option::is_none")]
    pub description: Option<String>,
    /// A URL with more information about the repository.
    #[serde(skip_serializing_if="Option::is_none")]
    pub homepage: Option<String>,
    /// Whether the repository is private.
    #[serde(skip_serializing_if="Option::is_none")]
    pub private: Option<bool>,
    /// The visibility of the repository.
    #[serde(skip_serializing_if="Option::is_none")]
    pub visibility: Option<String>,
    /// Either `true` to enable issues for this repository or `false` to disable them.
    #[serde(skip_serializing_if="Option::is_none")]
    pub has_issues: Option<bool>,
    /// Either `true` to enable projects for this repository or `false` to disable them. **Note:** If you're creating a repository in an organization that has disabled repository projects, the default is `false`, and if you pass `true`, the API returns an error.
    #[serde(skip_serializing_if="Option::is_none")]
    pub has_projects: Option<bool>,
    /// Either `true` to enable the wiki for this repository or `false` to disable it.
    #[serde(skip_serializing_if="Option::is_none")]
    pub has_wiki: Option<bool>,
    /// Whether downloads are enabled.
    #[serde(skip_serializing_if="Option::is_none")]
    pub has_downloads: Option<bool>,
    /// Either `true` to make this repo available as a template repository or `false` to prevent it.
    #[serde(skip_serializing_if="Option::is_none")]
    pub is_template: Option<bool>,
    /// The id of the team that will be granted access to this repository. This is only valid when creating a repository in an organization.
    #[serde(skip_serializing_if="Option::is_none")]
    pub team_id: Option<i64>,
    /// Pass `true` to create an initial commit with empty README.
    #[serde(skip_serializing_if="Option::is_none")]
    pub auto_init: Option<bool>,
    /// Desired language or platform [.gitignore template](https://github.com/github/gitignore) to apply. Use the name of the template without the extension. For example, \"Haskell\".
    #[serde(skip_serializing_if="Option::is_none")]
    pub gitignore_template: Option<String>,
    /// Choose an [open source license template](https://choosealicense.com/) that best suits your needs, and then use the [license keyword](https://docs.github.com/articles/licensing-a-repository/#searching-github-by-license-type) as the `license_template` string. For example, \"mit\" or \"mpl-2.0\".
    #[serde(skip_serializing_if="Option::is_none")]
    pub license_template: Option<String>,
    /// Either `true` to allow squash-merging pull requests, or `false` to prevent squash-merging.
    #[serde(skip_serializing_if="Option::is_none")]
    pub allow_squash_merge: Option<bool>,
    /// Either `true` to allow merging pull requests with a merge commit, or `false` to prevent merging pull requests with merge commits.
    #[serde(skip_serializing_if="Option::is_none")]
    pub allow_merge_commit: Option<bool>,
    /// Either `true` to allow rebase-merging pull requests, or `false` to prevent rebase-merging.
    #[serde(skip_serializing_if="Option::is_none")]
    pub allow_rebase_merge: Option<bool>,
    /// Either `true` to allow auto-merge on pull requests, or `false` to disallow auto-merge.
    #[serde(skip_serializing_if="Option::is_none")]
    pub allow_auto_merge: Option<bool>,
    /// Either `true` to allow automatically deleting head branches when pull requests are merged, or `false` to prevent automatic deletion. **The authenticated user must be an organization owner to set this property to `true`.**
    #[serde(skip_serializing_if="Option::is_none")]
    pub delete_branch_on_merge: Option<bool>,
    /// Either `true` to allow squash-merge commits to use pull request title, or `false` to use commit message. **This property is closing down. Please use `squash_merge_commit_title` instead.
    #[serde(skip_serializing_if="Option::is_none")]
    pub use_squash_pr_title_as_default: Option<bool>,
    /// Required when using `squash_merge_commit_message`.  The default value for a squash merge commit title:  - `PR_TITLE` - default to the pull request's title. - `COMMIT_OR_PR_TITLE` - default to the commit's title (if only one commit) or the pull request's title (when more than one commit).
    #[serde(skip_serializing_if="Option::is_none")]
    pub squash_merge_commit_title: Option<String>,
    /// The default value for a squash merge commit message:  - `PR_BODY` - default to the pull request's body. - `COMMIT_MESSAGES` - default to the branch's commit messages. - `BLANK` - default to a blank commit message.
    #[serde(skip_serializing_if="Option::is_none")]
    pub squash_merge_commit_message: Option<String>,
    /// Required when using `merge_commit_message`.  The default value for a merge commit title.  - `PR_TITLE` - default to the pull request's title. - `MERGE_MESSAGE` - default to the classic title for a merge message (e.g., Merge pull request #123 from branch-name).
    #[serde(skip_serializing_if="Option::is_none")]
    pub merge_commit_title: Option<String>,
    /// The default value for a merge commit message.  - `PR_TITLE` - default to the pull request's title. - `PR_BODY` - default to the pull request's body. - `BLANK` - default to a blank commit message.
    #[serde(skip_serializing_if="Option::is_none")]
    pub merge_commit_message: Option<String>,
    /// The custom properties for the new repository. The keys are the custom property names, and the values are the corresponding custom property values.
    #[serde(skip_serializing_if="Option::is_none")]
    pub custom_properties: Option<HashMap<String, HashMap<String, Value>>>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct PostReposCreateOrgRuleset {
    /// The name of the ruleset.
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,
    /// The target of the ruleset
    #[serde(skip_serializing_if="Option::is_none")]
    pub target: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub enforcement: Option<RepositoryRuleEnforcement>,
    /// The actors that can bypass the rules in this ruleset
    #[serde(skip_serializing_if="Option::is_none")]
    pub bypass_actors: Option<Vec<RepositoryRulesetBypassActor>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub conditions: Option<OrgRulesetConditions>,
    /// An array of rules within the ruleset.
    #[serde(skip_serializing_if="Option::is_none")]
    pub rules: Option<Vec<RepositoryRule>>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct PutReposUpdateOrgRuleset {
    /// The name of the ruleset.
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,
    /// The target of the ruleset
    #[serde(skip_serializing_if="Option::is_none")]
    pub target: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub enforcement: Option<RepositoryRuleEnforcement>,
    /// The actors that can bypass the rules in this ruleset
    #[serde(skip_serializing_if="Option::is_none")]
    pub bypass_actors: Option<Vec<RepositoryRulesetBypassActor>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub conditions: Option<OrgRulesetConditions>,
    /// An array of rules within the ruleset.
    #[serde(skip_serializing_if="Option::is_none")]
    pub rules: Option<Vec<RepositoryRule>>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct PostCodeSecurityCreateConfigurationForEnterprise {
    /// The name of the code security configuration. Must be unique within the enterprise.
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,
    /// A description of the code security configuration
    #[serde(skip_serializing_if="Option::is_none")]
    pub description: Option<String>,
    /// The enablement status of GitHub Advanced Security
    #[serde(skip_serializing_if="Option::is_none")]
    pub advanced_security: Option<String>,
    /// The enablement status of Dependency Graph
    #[serde(skip_serializing_if="Option::is_none")]
    pub dependency_graph: Option<String>,
    /// The enablement status of Automatic dependency submission
    #[serde(skip_serializing_if="Option::is_none")]
    pub dependency_graph_autosubmit_action: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub dependency_graph_autosubmit_action_options: Option<EnterprisesenterprisecodesecurityconfigurationsDependencyGraphAutosubmitActionOptions>,
    /// The enablement status of Dependabot alerts
    #[serde(skip_serializing_if="Option::is_none")]
    pub dependabot_alerts: Option<String>,
    /// The enablement status of Dependabot security updates
    #[serde(skip_serializing_if="Option::is_none")]
    pub dependabot_security_updates: Option<String>,
    /// The enablement status of code scanning default setup
    #[serde(skip_serializing_if="Option::is_none")]
    pub code_scanning_default_setup: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub code_scanning_default_setup_options: Option<CodeScanningDefaultSetupOptions>,
    /// The enablement status of secret scanning
    #[serde(skip_serializing_if="Option::is_none")]
    pub secret_scanning: Option<String>,
    /// The enablement status of secret scanning push protection
    #[serde(skip_serializing_if="Option::is_none")]
    pub secret_scanning_push_protection: Option<String>,
    /// The enablement status of secret scanning validity checks
    #[serde(skip_serializing_if="Option::is_none")]
    pub secret_scanning_validity_checks: Option<String>,
    /// The enablement status of secret scanning non provider patterns
    #[serde(skip_serializing_if="Option::is_none")]
    pub secret_scanning_non_provider_patterns: Option<String>,
    /// The enablement status of private vulnerability reporting
    #[serde(skip_serializing_if="Option::is_none")]
    pub private_vulnerability_reporting: Option<String>,
    /// The enforcement status for a security configuration
    #[serde(skip_serializing_if="Option::is_none")]
    pub enforcement: Option<String>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct PostHostedComputeCreateNetworkConfigurationForOrg {
    /// Name of the network configuration. Must be between 1 and 100 characters and may only contain upper and lowercase letters a-z, numbers 0-9, '.', '-', and '_'.
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,
    /// The hosted compute service to use for the network configuration.
    #[serde(skip_serializing_if="Option::is_none")]
    pub compute_service: Option<String>,
    /// The identifier of the network settings to use for the network configuration. Exactly one network settings must be specified.
    #[serde(skip_serializing_if="Option::is_none")]
    pub network_settings_ids: Option<Vec<String>>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct PatchHostedComputeUpdateNetworkConfigurationForOrg {
    /// Name of the network configuration. Must be between 1 and 100 characters and may only contain upper and lowercase letters a-z, numbers 0-9, '.', '-', and '_'.
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,
    /// The hosted compute service to use for the network configuration.
    #[serde(skip_serializing_if="Option::is_none")]
    pub compute_service: Option<String>,
    /// The identifier of the network settings to use for the network configuration. Exactly one network settings must be specified.
    #[serde(skip_serializing_if="Option::is_none")]
    pub network_settings_ids: Option<Vec<String>>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct PostTeamsCreate {
    /// The name of the team.
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,
    /// The description of the team.
    #[serde(skip_serializing_if="Option::is_none")]
    pub description: Option<String>,
    /// List GitHub IDs for organization members who will become team maintainers.
    #[serde(skip_serializing_if="Option::is_none")]
    pub maintainers: Option<Vec<String>>,
    /// The full name (e.g., \"organization-name/repository-name\") of repositories to add the team to.
    #[serde(skip_serializing_if="Option::is_none")]
    pub repo_names: Option<Vec<String>>,
    /// The level of privacy this team should have. The options are:   **For a non-nested team:**    * `secret` - only visible to organization owners and members of this team.    * `closed` - visible to all members of this organization.   Default: `secret`   **For a parent or child team:**    * `closed` - visible to all members of this organization.   Default for child team: `closed`
    #[serde(skip_serializing_if="Option::is_none")]
    pub privacy: Option<String>,
    /// The notification setting the team has chosen. The options are:    * `notifications_enabled` - team members receive notifications when the team is @mentioned.    * `notifications_disabled` - no one receives notifications.   Default: `notifications_enabled`
    #[serde(skip_serializing_if="Option::is_none")]
    pub notification_setting: Option<String>,
    /// **Closing down notice**. The permission that new repositories will be added to the team with when none is specified.
    #[serde(skip_serializing_if="Option::is_none")]
    pub permission: Option<String>,
    /// The ID of a team to set as the parent team.
    #[serde(skip_serializing_if="Option::is_none")]
    pub parent_team_id: Option<i64>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct PatchTeamsUpdateInOrg {
    /// The name of the team.
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,
    /// The description of the team.
    #[serde(skip_serializing_if="Option::is_none")]
    pub description: Option<String>,
    /// The level of privacy this team should have. Editing teams without specifying this parameter leaves `privacy` intact. When a team is nested, the `privacy` for parent teams cannot be `secret`. The options are:   **For a non-nested team:**    * `secret` - only visible to organization owners and members of this team.    * `closed` - visible to all members of this organization.   **For a parent or child team:**    * `closed` - visible to all members of this organization.
    #[serde(skip_serializing_if="Option::is_none")]
    pub privacy: Option<String>,
    /// The notification setting the team has chosen. Editing teams without specifying this parameter leaves `notification_setting` intact. The options are:   * `notifications_enabled` - team members receive notifications when the team is @mentioned.    * `notifications_disabled` - no one receives notifications.
    #[serde(skip_serializing_if="Option::is_none")]
    pub notification_setting: Option<String>,
    /// **Closing down notice**. The permission that new repositories will be added to the team with when none is specified.
    #[serde(skip_serializing_if="Option::is_none")]
    pub permission: Option<String>,
    /// The ID of a team to set as the parent team.
    #[serde(skip_serializing_if="Option::is_none")]
    pub parent_team_id: Option<i64>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct PostTeamsCreateDiscussionInOrg {
    /// The discussion post's title.
    #[serde(skip_serializing_if="Option::is_none")]
    pub title: Option<String>,
    /// The discussion post's body text.
    #[serde(skip_serializing_if="Option::is_none")]
    pub body: Option<String>,
    /// Private posts are only visible to team members, organization owners, and team maintainers. Public posts are visible to all members of the organization. Set to `true` to create a private post.
    #[serde(skip_serializing_if="Option::is_none")]
    pub private: Option<bool>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct PatchTeamsUpdateDiscussionInOrg {
    /// The discussion post's title.
    #[serde(skip_serializing_if="Option::is_none")]
    pub title: Option<String>,
    /// The discussion post's body text.
    #[serde(skip_serializing_if="Option::is_none")]
    pub body: Option<String>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct PostTeamsCreateDiscussionCommentInOrg {
    /// The discussion comment's body text.
    #[serde(skip_serializing_if="Option::is_none")]
    pub body: Option<String>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct PatchTeamsUpdateDiscussionCommentInOrg {
    /// The discussion comment's body text.
    #[serde(skip_serializing_if="Option::is_none")]
    pub body: Option<String>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct PostReactionsCreateForTeamDiscussionCommentInOrg {
    /// The [reaction type](https://docs.github.com/rest/reactions/reactions#about-reactions) to add to the team discussion comment.
    #[serde(skip_serializing_if="Option::is_none")]
    pub content: Option<String>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct PostReactionsCreateForTeamDiscussionInOrg {
    /// The [reaction type](https://docs.github.com/rest/reactions/reactions#about-reactions) to add to the team discussion.
    #[serde(skip_serializing_if="Option::is_none")]
    pub content: Option<String>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct PatchCodeSecurityUpdateEnterpriseConfiguration {
    /// The name of the code security configuration. Must be unique across the enterprise.
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,
    /// A description of the code security configuration
    #[serde(skip_serializing_if="Option::is_none")]
    pub description: Option<String>,
    /// The enablement status of GitHub Advanced Security. Must be set to enabled if you want to enable any GHAS settings.
    #[serde(skip_serializing_if="Option::is_none")]
    pub advanced_security: Option<String>,
    /// The enablement status of Dependency Graph
    #[serde(skip_serializing_if="Option::is_none")]
    pub dependency_graph: Option<String>,
    /// The enablement status of Automatic dependency submission
    #[serde(skip_serializing_if="Option::is_none")]
    pub dependency_graph_autosubmit_action: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub dependency_graph_autosubmit_action_options: Option<EnterprisesenterprisecodesecurityconfigurationsconfigurationIdDependencyGraphAutosubmitActionOptions>,
    /// The enablement status of Dependabot alerts
    #[serde(skip_serializing_if="Option::is_none")]
    pub dependabot_alerts: Option<String>,
    /// The enablement status of Dependabot security updates
    #[serde(skip_serializing_if="Option::is_none")]
    pub dependabot_security_updates: Option<String>,
    /// The enablement status of code scanning default setup
    #[serde(skip_serializing_if="Option::is_none")]
    pub code_scanning_default_setup: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub code_scanning_default_setup_options: Option<CodeScanningDefaultSetupOptions>,
    /// The enablement status of secret scanning
    #[serde(skip_serializing_if="Option::is_none")]
    pub secret_scanning: Option<String>,
    /// The enablement status of secret scanning push protection
    #[serde(skip_serializing_if="Option::is_none")]
    pub secret_scanning_push_protection: Option<String>,
    /// The enablement status of secret scanning validity checks
    #[serde(skip_serializing_if="Option::is_none")]
    pub secret_scanning_validity_checks: Option<String>,
    /// The enablement status of secret scanning non-provider patterns
    #[serde(skip_serializing_if="Option::is_none")]
    pub secret_scanning_non_provider_patterns: Option<String>,
    /// The enablement status of private vulnerability reporting
    #[serde(skip_serializing_if="Option::is_none")]
    pub private_vulnerability_reporting: Option<String>,
    /// The enforcement status for a security configuration
    #[serde(skip_serializing_if="Option::is_none")]
    pub enforcement: Option<String>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct PutTeamsAddOrUpdateMembershipForUserInOrg {
    /// The role that this user should have in the team.
    #[serde(skip_serializing_if="Option::is_none")]
    pub role: Option<String>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct PutTeamsAddOrUpdateProjectPermissionsInOrg {
    /// The permission to grant to the team for this project. Default: the team's `permission` attribute will be used to determine what permission to grant the team on this project. Note that, if you choose not to pass any parameters, you'll need to set `Content-Length` to zero when calling this endpoint. For more information, see \"[HTTP method](https://docs.github.com/rest/guides/getting-started-with-the-rest-api#http-method).\"
    #[serde(skip_serializing_if="Option::is_none")]
    pub permission: Option<String>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct PutTeamsAddOrUpdateRepoPermissionsInOrg {
    /// The permission to grant the team on this repository. We accept the following permissions to be set: `pull`, `triage`, `push`, `maintain`, `admin` and you can also specify a custom repository role name, if the owning organization has defined any. If no permission is specified, the team's `permission` attribute will be used to determine what permission to grant the team on this repository.
    #[serde(skip_serializing_if="Option::is_none")]
    pub permission: Option<String>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct PostOrgsEnableOrDisableSecurityProductOnAllOrgRepos {
    /// CodeQL query suite to be used. If you specify the `query_suite` parameter, the default setup will be configured with this query suite only on all repositories that didn't have default setup already configured. It will not change the query suite on repositories that already have default setup configured. If you don't specify any `query_suite` in your request, the preferred query suite of the organization will be applied.
    #[serde(skip_serializing_if="Option::is_none")]
    pub query_suite: Option<String>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct PatchProjectsUpdateCard {
    /// The project card's note
    #[serde(skip_serializing_if="Option::is_none")]
    pub note: Option<String>,
    /// Whether or not the card is archived
    #[serde(skip_serializing_if="Option::is_none")]
    pub archived: Option<bool>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct PostProjectsMoveCard {
    /// The position of the card in a column. Can be one of: `top`, `bottom`, or `after:<card_id>` to place after the specified card.
    #[serde(skip_serializing_if="Option::is_none")]
    pub position: Option<String>,
    /// The unique identifier of the column the card should be moved to
    #[serde(skip_serializing_if="Option::is_none")]
    pub column_id: Option<i64>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct PatchProjectsUpdateColumn {
    /// Name of the project column
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,
}

#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PostProjectsCreateCard { 
    PostProjectsCreateCardVariant0(HashMap<String, String>),
}

impl From<HashMap<String, String>> for PostProjectsCreateCard {
    fn from(value: HashMap<String, String>) -> Self {
        PostProjectsCreateCard::PostProjectsCreateCardVariant0(value)
    }
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct PostProjectsMoveColumn {
    /// The position of the column in a project. Can be one of: `first`, `last`, or `after:<column_id>` to place after the specified column.
    #[serde(skip_serializing_if="Option::is_none")]
    pub position: Option<String>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct PatchProjectsUpdate {
    /// Name of the project
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,
    /// Body of the project
    #[serde(skip_serializing_if="Option::is_none")]
    pub body: Option<String>,
    /// State of the project; either 'open' or 'closed'
    #[serde(skip_serializing_if="Option::is_none")]
    pub state: Option<String>,
    /// The baseline permission that all organization members have on this project
    #[serde(skip_serializing_if="Option::is_none")]
    pub organization_permission: Option<String>,
    /// Whether or not this project can be seen by everyone.
    #[serde(skip_serializing_if="Option::is_none")]
    pub private: Option<bool>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct PostCodeSecurityAttachEnterpriseConfiguration {
    /// The type of repositories to attach the configuration to.
    #[serde(skip_serializing_if="Option::is_none")]
    pub scope: Option<String>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct PutProjectsAddCollaborator {
    /// The permission to grant the collaborator.
    #[serde(skip_serializing_if="Option::is_none")]
    pub permission: Option<String>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct PostProjectsCreateColumn {
    /// Name of the project column
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct PatchReposUpdate {
    /// The name of the repository.
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,
    /// A short description of the repository.
    #[serde(skip_serializing_if="Option::is_none")]
    pub description: Option<String>,
    /// A URL with more information about the repository.
    #[serde(skip_serializing_if="Option::is_none")]
    pub homepage: Option<String>,
    /// Either `true` to make the repository private or `false` to make it public. Default: `false`.   **Note**: You will get a `422` error if the organization restricts [changing repository visibility](https://docs.github.com/articles/repository-permission-levels-for-an-organization#changing-the-visibility-of-repositories) to organization owners and a non-owner tries to change the value of private.
    #[serde(skip_serializing_if="Option::is_none")]
    pub private: Option<bool>,
    /// The visibility of the repository.
    #[serde(skip_serializing_if="Option::is_none")]
    pub visibility: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub security_and_analysis: Option<ReposownerrepoSecurityAndAnalysis>,
    /// Either `true` to enable issues for this repository or `false` to disable them.
    #[serde(skip_serializing_if="Option::is_none")]
    pub has_issues: Option<bool>,
    /// Either `true` to enable projects for this repository or `false` to disable them. **Note:** If you're creating a repository in an organization that has disabled repository projects, the default is `false`, and if you pass `true`, the API returns an error.
    #[serde(skip_serializing_if="Option::is_none")]
    pub has_projects: Option<bool>,
    /// Either `true` to enable the wiki for this repository or `false` to disable it.
    #[serde(skip_serializing_if="Option::is_none")]
    pub has_wiki: Option<bool>,
    /// Either `true` to make this repo available as a template repository or `false` to prevent it.
    #[serde(skip_serializing_if="Option::is_none")]
    pub is_template: Option<bool>,
    /// Updates the default branch for this repository.
    #[serde(skip_serializing_if="Option::is_none")]
    pub default_branch: Option<String>,
    /// Either `true` to allow squash-merging pull requests, or `false` to prevent squash-merging.
    #[serde(skip_serializing_if="Option::is_none")]
    pub allow_squash_merge: Option<bool>,
    /// Either `true` to allow merging pull requests with a merge commit, or `false` to prevent merging pull requests with merge commits.
    #[serde(skip_serializing_if="Option::is_none")]
    pub allow_merge_commit: Option<bool>,
    /// Either `true` to allow rebase-merging pull requests, or `false` to prevent rebase-merging.
    #[serde(skip_serializing_if="Option::is_none")]
    pub allow_rebase_merge: Option<bool>,
    /// Either `true` to allow auto-merge on pull requests, or `false` to disallow auto-merge.
    #[serde(skip_serializing_if="Option::is_none")]
    pub allow_auto_merge: Option<bool>,
    /// Either `true` to allow automatically deleting head branches when pull requests are merged, or `false` to prevent automatic deletion.
    #[serde(skip_serializing_if="Option::is_none")]
    pub delete_branch_on_merge: Option<bool>,
    /// Either `true` to always allow a pull request head branch that is behind its base branch to be updated even if it is not required to be up to date before merging, or false otherwise.
    #[serde(skip_serializing_if="Option::is_none")]
    pub allow_update_branch: Option<bool>,
    /// Either `true` to allow squash-merge commits to use pull request title, or `false` to use commit message. **This property is closing down. Please use `squash_merge_commit_title` instead.
    #[serde(skip_serializing_if="Option::is_none")]
    pub use_squash_pr_title_as_default: Option<bool>,
    /// Required when using `squash_merge_commit_message`.  The default value for a squash merge commit title:  - `PR_TITLE` - default to the pull request's title. - `COMMIT_OR_PR_TITLE` - default to the commit's title (if only one commit) or the pull request's title (when more than one commit).
    #[serde(skip_serializing_if="Option::is_none")]
    pub squash_merge_commit_title: Option<String>,
    /// The default value for a squash merge commit message:  - `PR_BODY` - default to the pull request's body. - `COMMIT_MESSAGES` - default to the branch's commit messages. - `BLANK` - default to a blank commit message.
    #[serde(skip_serializing_if="Option::is_none")]
    pub squash_merge_commit_message: Option<String>,
    /// Required when using `merge_commit_message`.  The default value for a merge commit title.  - `PR_TITLE` - default to the pull request's title. - `MERGE_MESSAGE` - default to the classic title for a merge message (e.g., Merge pull request #123 from branch-name).
    #[serde(skip_serializing_if="Option::is_none")]
    pub merge_commit_title: Option<String>,
    /// The default value for a merge commit message.  - `PR_TITLE` - default to the pull request's title. - `PR_BODY` - default to the pull request's body. - `BLANK` - default to a blank commit message.
    #[serde(skip_serializing_if="Option::is_none")]
    pub merge_commit_message: Option<String>,
    /// Whether to archive this repository. `false` will unarchive a previously archived repository.
    #[serde(skip_serializing_if="Option::is_none")]
    pub archived: Option<bool>,
    /// Either `true` to allow private forks, or `false` to prevent private forks.
    #[serde(skip_serializing_if="Option::is_none")]
    pub allow_forking: Option<bool>,
    /// Either `true` to require contributors to sign off on web-based commits, or `false` to not require contributors to sign off on web-based commits.
    #[serde(skip_serializing_if="Option::is_none")]
    pub web_commit_signoff_required: Option<bool>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct PostActionsReRunJobForWorkflowRun {
    /// Whether to enable debug logging for the re-run.
    #[serde(skip_serializing_if="Option::is_none")]
    pub enable_debug_logging: Option<bool>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct PutActionsSetGithubActionsPermissionsRepository {
    #[serde(skip_serializing_if="Option::is_none")]
    pub enabled: Option<ActionsEnabled>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub allowed_actions: Option<AllowedActions>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct PostActionsGenerateRunnerJitconfigForRepo {
    /// The name of the new runner.
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,
    /// The ID of the runner group to register the runner to.
    #[serde(skip_serializing_if="Option::is_none")]
    pub runner_group_id: Option<i64>,
    /// The names of the custom labels to add to the runner. **Minimum items**: 1. **Maximum items**: 100.
    #[serde(skip_serializing_if="Option::is_none")]
    pub labels: Option<Vec<String>>,
    /// The working directory to be used for job execution, relative to the runner install directory.
    #[serde(skip_serializing_if="Option::is_none")]
    pub work_folder: Option<String>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct PutActionsSetCustomLabelsForSelfHostedRunnerForRepo {
    /// The names of the custom labels to set for the runner. You can pass an empty array to remove all custom labels.
    #[serde(skip_serializing_if="Option::is_none")]
    pub labels: Option<Vec<String>>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct PostActionsAddCustomLabelsToSelfHostedRunnerForRepo {
    /// The names of the custom labels to add to the runner.
    #[serde(skip_serializing_if="Option::is_none")]
    pub labels: Option<Vec<String>>,
}

#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PostActionsReviewCustomGatesForRun { 
    PostActionsReviewCustomGatesForRunVariant0(ReviewCustomGatesCommentRequired),
    PostActionsReviewCustomGatesForRunVariant1(ReviewCustomGatesStateRequired),
}

impl From<ReviewCustomGatesCommentRequired> for PostActionsReviewCustomGatesForRun {
    fn from(value: ReviewCustomGatesCommentRequired) -> Self {
        PostActionsReviewCustomGatesForRun::PostActionsReviewCustomGatesForRunVariant0(value)
    }
}

impl From<ReviewCustomGatesStateRequired> for PostActionsReviewCustomGatesForRun {
    fn from(value: ReviewCustomGatesStateRequired) -> Self {
        PostActionsReviewCustomGatesForRun::PostActionsReviewCustomGatesForRunVariant1(value)
    }
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct PostActionsReviewPendingDeploymentsForRun {
    /// The list of environment ids to approve or reject
    #[serde(skip_serializing_if="Option::is_none")]
    pub environment_ids: Option<Vec<i32>>,
    /// Whether to approve or reject deployment to the specified environments.
    #[serde(skip_serializing_if="Option::is_none")]
    pub state: Option<String>,
    /// A comment to accompany the deployment review
    #[serde(skip_serializing_if="Option::is_none")]
    pub comment: Option<String>,
}

/// Branch Protection
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct BranchProtection {
    #[serde(skip_serializing_if="Option::is_none")]
    pub url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub enabled: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub required_status_checks: Option<ProtectedBranchRequiredStatusCheck>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub enforce_admins: Option<ProtectedBranchAdminEnforced>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub required_pull_request_reviews: Option<ProtectedBranchPullRequestReview>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub restrictions: Option<BranchRestrictionPolicy>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub required_linear_history: Option<BranchprotectionRequiredLinearHistory>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub allow_force_pushes: Option<BranchprotectionRequiredLinearHistory>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub allow_deletions: Option<BranchprotectionRequiredLinearHistory>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub block_creations: Option<BranchprotectionRequiredLinearHistory>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub required_conversation_resolution: Option<BranchprotectionRequiredLinearHistory>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub protection_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub required_signatures: Option<BranchprotectionRequiredSignatures>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub lock_branch: Option<BranchprotectionLockBranch>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub allow_fork_syncing: Option<BranchprotectionAllowForkSyncing>,
}

/// Branch Restriction Policy
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct BranchRestrictionPolicy {
    #[serde(skip_serializing_if="Option::is_none")]
    pub url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub users_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub teams_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub apps_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub users: Option<Vec<BranchrestrictionpolicyUsers>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub teams: Option<Vec<BranchrestrictionpolicyTeams>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub apps: Option<Vec<BranchrestrictionpolicyApps>>,
}

/// Branch Short
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct BranchShort {
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub commit: Option<BranchshortCommit>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub protected: Option<bool>,
}

/// Branch With Protection
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct BranchWithProtection {
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub commit: Option<Commit>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub _links: Option<BranchwithprotectionLinks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub protected: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub protection: Option<BranchProtection>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub protection_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub pattern: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub required_approving_review_count: Option<i64>,
}

/// Whether users can pull changes from upstream when the branch is locked. Set to `true` to allow fork syncing. Set to `false` to prevent fork syncing.
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct BranchprotectionAllowForkSyncing {
    #[serde(skip_serializing_if="Option::is_none")]
    pub enabled: Option<bool>,
}

/// Whether to set the branch as read-only. If this is true, users will not be able to push to the branch.
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct BranchprotectionLockBranch {
    #[serde(skip_serializing_if="Option::is_none")]
    pub enabled: Option<bool>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct BranchprotectionRequiredLinearHistory {
    #[serde(skip_serializing_if="Option::is_none")]
    pub enabled: Option<bool>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct BranchprotectionRequiredSignatures {
    #[serde(skip_serializing_if="Option::is_none")]
    pub url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub enabled: Option<bool>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct BranchrestrictionpolicyApps {
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub slug: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub node_id: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub owner: Option<BranchrestrictionpolicyOwner>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub client_id: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub description: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub external_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub html_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub created_at: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub updated_at: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub permissions: Option<BranchrestrictionpolicyPermissions>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub events: Option<Vec<String>>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct BranchrestrictionpolicyOwner {
    #[serde(skip_serializing_if="Option::is_none")]
    pub login: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub node_id: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub repos_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub events_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub hooks_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub issues_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub members_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub public_members_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub avatar_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub description: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub gravatar_id: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub html_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub followers_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub following_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub gists_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub starred_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub subscriptions_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub organizations_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub received_events_url: Option<String>,
    #[serde(rename = "type")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub _type: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub site_admin: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub user_view_type: Option<String>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct BranchrestrictionpolicyPermissions {
    #[serde(skip_serializing_if="Option::is_none")]
    pub metadata: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub contents: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub issues: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub single_file: Option<String>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct BranchrestrictionpolicyTeams {
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub node_id: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub html_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub slug: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub description: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub privacy: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub notification_setting: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub permission: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub members_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub repositories_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub parent: Option<String>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct BranchrestrictionpolicyUsers {
    #[serde(skip_serializing_if="Option::is_none")]
    pub login: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub node_id: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub avatar_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub gravatar_id: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub html_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub followers_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub following_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub gists_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub starred_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub subscriptions_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub organizations_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub repos_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub events_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub received_events_url: Option<String>,
    #[serde(rename = "type")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub _type: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub site_admin: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub user_view_type: Option<String>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct BranchshortCommit {
    #[serde(skip_serializing_if="Option::is_none")]
    pub sha: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub url: Option<String>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct BranchwithprotectionLinks {
    #[serde(skip_serializing_if="Option::is_none")]
    pub html: Option<String>,
    #[serde(rename = "self")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub _self: Option<String>,
}

/// Check Annotation
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct CheckAnnotation {
    #[serde(skip_serializing_if="Option::is_none")]
    pub path: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub start_line: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub end_line: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub start_column: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub end_column: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub annotation_level: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub title: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub message: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub raw_details: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub blob_href: Option<String>,
}

/// Check Dependabot security updates
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct CheckAutomatedSecurityFixes {
    /// Whether Dependabot security updates are enabled for the repository.
    #[serde(skip_serializing_if="Option::is_none")]
    pub enabled: Option<bool>,
    /// Whether Dependabot security updates are paused for the repository.
    #[serde(skip_serializing_if="Option::is_none")]
    pub paused: Option<bool>,
}

/// A check performed on the code of a given code change
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct CheckRun {
    /// The id of the check.
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<i64>,
    /// The SHA of the commit that is being checked.
    #[serde(skip_serializing_if="Option::is_none")]
    pub head_sha: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub node_id: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub external_id: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub html_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub details_url: Option<String>,
    /// The phase of the lifecycle that the check is currently in. Statuses of waiting, requested, and pending are reserved for GitHub Actions check runs.
    #[serde(skip_serializing_if="Option::is_none")]
    pub status: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub conclusion: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub started_at: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub completed_at: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub output: Option<CheckrunOutput>,
    /// The name of the check.
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub check_suite: Option<CheckrunCheckSuite>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub app: Option<NullableIntegration>,
    /// Pull requests that are open with a `head_sha` or `head_branch` that matches the check. The returned pull requests do not necessarily indicate pull requests that triggered the check.
    #[serde(skip_serializing_if="Option::is_none")]
    pub pull_requests: Option<Vec<PullRequestMinimal>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub deployment: Option<DeploymentSimple>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct CheckRunPullRequest {
    #[serde(skip_serializing_if="Option::is_none")]
    pub base: Option<WebhookchecksuitecompletedCheckSuiteBase>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub head: Option<WebhookchecksuitecompletedCheckSuiteBase>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub number: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub url: Option<String>,
}

/// A check performed on the code of a given code change
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct CheckRunWithSimpleCheckSuite {
    #[serde(skip_serializing_if="Option::is_none")]
    pub app: Option<NullableIntegration>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub check_suite: Option<SimpleCheckSuite>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub completed_at: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub conclusion: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub deployment: Option<DeploymentSimple>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub details_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub external_id: Option<String>,
    /// The SHA of the commit that is being checked.
    #[serde(skip_serializing_if="Option::is_none")]
    pub head_sha: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub html_url: Option<String>,
    /// The id of the check.
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<i64>,
    /// The name of the check.
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub node_id: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub output: Option<CheckrunwithsimplechecksuiteOutput>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub pull_requests: Option<Vec<PullRequestMinimal>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub started_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The phase of the lifecycle that the check is currently in.
    #[serde(skip_serializing_if="Option::is_none")]
    pub status: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub url: Option<String>,
}

/// A suite of checks performed on the code of a given code change
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct CheckSuite {
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub node_id: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub head_branch: Option<String>,
    /// The SHA of the head commit that is being checked.
    #[serde(skip_serializing_if="Option::is_none")]
    pub head_sha: Option<String>,
    /// The phase of the lifecycle that the check suite is currently in. Statuses of waiting, requested, and pending are reserved for GitHub Actions check suites.
    #[serde(skip_serializing_if="Option::is_none")]
    pub status: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub conclusion: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub before: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub after: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub pull_requests: Option<Vec<PullRequestMinimal>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub app: Option<NullableIntegration>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub repository: Option<MinimalRepository>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub updated_at: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub head_commit: Option<SimpleCommit>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub latest_check_runs_count: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub check_runs_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub rerequestable: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub runs_rerequestable: Option<bool>,
}

/// Check suite configuration preferences for a repository.
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct CheckSuitePreference {
    #[serde(skip_serializing_if="Option::is_none")]
    pub preferences: Option<ChecksuitepreferencePreferences>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub repository: Option<MinimalRepository>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct CheckrunCheckSuite {
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<i64>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct CheckrunOutput {
    #[serde(skip_serializing_if="Option::is_none")]
    pub title: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub summary: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub text: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub annotations_count: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub annotations_url: Option<String>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct CheckrunwithsimplechecksuiteOutput {
    #[serde(skip_serializing_if="Option::is_none")]
    pub annotations_count: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub annotations_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub summary: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub text: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub title: Option<String>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct ChecksuitepreferencePreferences {
    #[serde(skip_serializing_if="Option::is_none")]
    pub auto_trigger_checks: Option<Vec<ChecksuitepreferencePreferencesAutoTriggerChecks>>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct ChecksuitepreferencePreferencesAutoTriggerChecks {
    #[serde(skip_serializing_if="Option::is_none")]
    pub app_id: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub setting: Option<bool>,
}

/// A GitHub Classroom classroom
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct Classroom {
    /// Unique identifier of the classroom.
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<i64>,
    /// The name of the classroom.
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,
    /// Whether classroom is archived.
    #[serde(skip_serializing_if="Option::is_none")]
    pub archived: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub organization: Option<SimpleClassroomOrganization>,
    /// The URL of the classroom on GitHub Classroom.
    #[serde(skip_serializing_if="Option::is_none")]
    pub url: Option<String>,
}

/// A GitHub Classroom accepted assignment
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct ClassroomAcceptedAssignment {
    /// Unique identifier of the repository.
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<i64>,
    /// Whether an accepted assignment has been submitted.
    #[serde(skip_serializing_if="Option::is_none")]
    pub submitted: Option<bool>,
    /// Whether a submission passed.
    #[serde(skip_serializing_if="Option::is_none")]
    pub passing: Option<bool>,
    /// Count of student commits.
    #[serde(skip_serializing_if="Option::is_none")]
    pub commit_count: Option<i64>,
    /// Most recent grade.
    #[serde(skip_serializing_if="Option::is_none")]
    pub grade: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub students: Option<Vec<SimpleClassroomUser>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub repository: Option<SimpleClassroomRepository>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub assignment: Option<SimpleClassroomAssignment>,
}

/// A GitHub Classroom assignment
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct ClassroomAssignment {
    /// Unique identifier of the repository.
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<i64>,
    /// Whether an accepted assignment creates a public repository.
    #[serde(skip_serializing_if="Option::is_none")]
    pub public_repo: Option<bool>,
    /// Assignment title.
    #[serde(skip_serializing_if="Option::is_none")]
    pub title: Option<String>,
    /// Whether it's a group assignment or individual assignment.
    #[serde(rename = "type")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub _type: Option<String>,
    /// The link that a student can use to accept the assignment.
    #[serde(skip_serializing_if="Option::is_none")]
    pub invite_link: Option<String>,
    /// Whether the invitation link is enabled. Visiting an enabled invitation link will accept the assignment.
    #[serde(skip_serializing_if="Option::is_none")]
    pub invitations_enabled: Option<bool>,
    /// Sluggified name of the assignment.
    #[serde(skip_serializing_if="Option::is_none")]
    pub slug: Option<String>,
    /// Whether students are admins on created repository when a student accepts the assignment.
    #[serde(skip_serializing_if="Option::is_none")]
    pub students_are_repo_admins: Option<bool>,
    /// Whether feedback pull request will be created when a student accepts the assignment.
    #[serde(skip_serializing_if="Option::is_none")]
    pub feedback_pull_requests_enabled: Option<bool>,
    /// The maximum allowable teams for the assignment.
    #[serde(skip_serializing_if="Option::is_none")]
    pub max_teams: Option<i64>,
    /// The maximum allowable members per team.
    #[serde(skip_serializing_if="Option::is_none")]
    pub max_members: Option<i64>,
    /// The selected editor for the assignment.
    #[serde(skip_serializing_if="Option::is_none")]
    pub editor: Option<String>,
    /// The number of students that have accepted the assignment.
    #[serde(skip_serializing_if="Option::is_none")]
    pub accepted: Option<i64>,
    /// The number of students that have submitted the assignment.
    #[serde(skip_serializing_if="Option::is_none")]
    pub submitted: Option<i64>,
    /// The number of students that have passed the assignment.
    #[serde(skip_serializing_if="Option::is_none")]
    pub passing: Option<i64>,
    /// The programming language used in the assignment.
    #[serde(skip_serializing_if="Option::is_none")]
    pub language: Option<String>,
    /// The time at which the assignment is due.
    #[serde(skip_serializing_if="Option::is_none")]
    pub deadline: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub starter_code_repository: Option<SimpleClassroomRepository>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub classroom: Option<Classroom>,
}

/// Grade for a student or groups GitHub Classroom assignment
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct ClassroomAssignmentGrade {
    /// Name of the assignment
    #[serde(skip_serializing_if="Option::is_none")]
    pub assignment_name: Option<String>,
    /// URL of the assignment
    #[serde(skip_serializing_if="Option::is_none")]
    pub assignment_url: Option<String>,
    /// URL of the starter code for the assignment
    #[serde(skip_serializing_if="Option::is_none")]
    pub starter_code_url: Option<String>,
    /// GitHub username of the student
    #[serde(skip_serializing_if="Option::is_none")]
    pub github_username: Option<String>,
    /// Roster identifier of the student
    #[serde(skip_serializing_if="Option::is_none")]
    pub roster_identifier: Option<String>,
    /// Name of the student's assignment repository
    #[serde(skip_serializing_if="Option::is_none")]
    pub student_repository_name: Option<String>,
    /// URL of the student's assignment repository
    #[serde(skip_serializing_if="Option::is_none")]
    pub student_repository_url: Option<String>,
    /// Timestamp of the student's assignment submission
    #[serde(skip_serializing_if="Option::is_none")]
    pub submission_timestamp: Option<String>,
    /// Number of points awarded to the student
    #[serde(skip_serializing_if="Option::is_none")]
    pub points_awarded: Option<i64>,
    /// Number of points available for the assignment
    #[serde(skip_serializing_if="Option::is_none")]
    pub points_available: Option<i64>,
    /// If a group assignment, name of the group the student is in
    #[serde(skip_serializing_if="Option::is_none")]
    pub group_name: Option<String>,
}

/// Clone Traffic
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct CloneTraffic {
    #[serde(skip_serializing_if="Option::is_none")]
    pub count: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub uniques: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub clones: Option<Vec<Traffic>>,
}

/// Code Frequency Stat
pub type CodeFrequencyStat = Vec<i32>;

/// Code Of Conduct
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct CodeOfConduct {
    #[serde(skip_serializing_if="Option::is_none")]
    pub key: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub body: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub html_url: Option<String>,
}

/// Code of Conduct Simple
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct CodeOfConductSimple {
    #[serde(skip_serializing_if="Option::is_none")]
    pub url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub key: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub html_url: Option<String>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct CodeScanningAlert {
    #[serde(skip_serializing_if="Option::is_none")]
    pub number: Option<AlertNumber>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub created_at: Option<AlertCreatedAt>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub updated_at: Option<AlertUpdatedAt>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub url: Option<AlertUrl>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub html_url: Option<AlertHtmlUrl>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub instances_url: Option<AlertInstancesUrl>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub state: Option<CodeScanningAlertState>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub fixed_at: Option<AlertFixedAt>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub dismissed_by: Option<NullableSimpleUser>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub dismissed_at: Option<AlertDismissedAt>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub dismissed_reason: Option<CodeScanningAlertDismissedReason>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub dismissed_comment: Option<CodeScanningAlertDismissedComment>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub rule: Option<CodeScanningAlertRule>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub tool: Option<CodeScanningAnalysisTool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub most_recent_instance: Option<CodeScanningAlertInstance>,
}

/// A classification of the file. For example to identify it as generated.
/// Enumeration of values.
/// Since this enum's variants do not hold data, we can easily define them them as `#[repr(C)]`
/// which helps with FFI.
#[allow(non_camel_case_types)]
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq, PartialOrd, Serialize, Deserialize, Eq, Ord)]
pub enum CodeScanningAlertClassification { 
    #[serde(rename = "source")]
    SOURCE,
    #[serde(rename = "generated")]
    GENERATED,
    #[serde(rename = "test")]
    TEST,
    #[serde(rename = "library")]
    LIBRARY,
}

impl Display for CodeScanningAlertClassification {
    fn fmt(&self, f: &mut Formatter) -> fmt::Result {
        match *self { 
            CodeScanningAlertClassification::SOURCE => write!(f, "{}", "source"),
            CodeScanningAlertClassification::GENERATED => write!(f, "{}", "generated"),
            CodeScanningAlertClassification::TEST => write!(f, "{}", "test"),
            CodeScanningAlertClassification::LIBRARY => write!(f, "{}", "library"),
        }
    }
}

impl std::str::FromStr for CodeScanningAlertClassification {
    type Err = ();
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s {
            "source" => Ok(CodeScanningAlertClassification::SOURCE),
            "generated" => Ok(CodeScanningAlertClassification::GENERATED),
            "test" => Ok(CodeScanningAlertClassification::TEST),
            "library" => Ok(CodeScanningAlertClassification::LIBRARY),
            _ => Err(()),
        }
    }
}

/// The dismissal comment associated with the dismissal of the alert.
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct CodeScanningAlertDismissedComment {
}

/// **Required when the state is dismissed.** The reason for dismissing or closing the alert.
/// Enumeration of values.
/// Since this enum's variants do not hold data, we can easily define them them as `#[repr(C)]`
/// which helps with FFI.
#[allow(non_camel_case_types)]
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq, PartialOrd, Serialize, Deserialize, Eq, Ord)]
pub enum CodeScanningAlertDismissedReason { 
    #[serde(rename = "false positive")]
    FALSE_POSITIVE,
    #[serde(rename = "won't fix")]
    WON_T_FIX,
    #[serde(rename = "used in tests")]
    USED_IN_TESTS,
}

impl Display for CodeScanningAlertDismissedReason {
    fn fmt(&self, f: &mut Formatter) -> fmt::Result {
        match *self { 
            CodeScanningAlertDismissedReason::FALSE_POSITIVE => write!(f, "{}", "false positive"),
            CodeScanningAlertDismissedReason::WON_T_FIX => write!(f, "{}", "won't fix"),
            CodeScanningAlertDismissedReason::USED_IN_TESTS => write!(f, "{}", "used in tests"),
        }
    }
}

impl std::str::FromStr for CodeScanningAlertDismissedReason {
    type Err = ();
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s {
            "false positive" => Ok(CodeScanningAlertDismissedReason::FALSE_POSITIVE),
            "won't fix" => Ok(CodeScanningAlertDismissedReason::WON_T_FIX),
            "used in tests" => Ok(CodeScanningAlertDismissedReason::USED_IN_TESTS),
            _ => Err(()),
        }
    }
}

/// Identifies the variable values associated with the environment in which the analysis that generated this alert instance was performed, such as the language that was analyzed.
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct CodeScanningAlertEnvironment {
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct CodeScanningAlertInstance {
    #[serde(rename = "ref")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub git_ref: Option<CodeScanningRef>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub analysis_key: Option<CodeScanningAnalysisAnalysisKey>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub environment: Option<CodeScanningAlertEnvironment>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub category: Option<CodeScanningAnalysisCategory>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub state: Option<CodeScanningAlertState>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub commit_sha: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub message: Option<CodescanningalertinstanceMessage>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub location: Option<CodeScanningAlertLocation>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub html_url: Option<String>,
    /// Classifications that have been applied to the file that triggered the alert. For example identifying it as documentation, or a generated file.
    #[serde(skip_serializing_if="Option::is_none")]
    pub classifications: Option<Vec<CodeScanningAlertClassification>>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct CodeScanningAlertItems {
    #[serde(skip_serializing_if="Option::is_none")]
    pub number: Option<AlertNumber>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub created_at: Option<AlertCreatedAt>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub updated_at: Option<AlertUpdatedAt>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub url: Option<AlertUrl>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub html_url: Option<AlertHtmlUrl>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub instances_url: Option<AlertInstancesUrl>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub state: Option<CodeScanningAlertState>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub fixed_at: Option<AlertFixedAt>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub dismissed_by: Option<NullableSimpleUser>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub dismissed_at: Option<AlertDismissedAt>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub dismissed_reason: Option<CodeScanningAlertDismissedReason>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub dismissed_comment: Option<CodeScanningAlertDismissedComment>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub rule: Option<CodeScanningAlertRuleSummary>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub tool: Option<CodeScanningAnalysisTool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub most_recent_instance: Option<CodeScanningAlertInstance>,
}

/// Describe a region within a file for the alert.
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct CodeScanningAlertLocation {
    #[serde(skip_serializing_if="Option::is_none")]
    pub path: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub start_line: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub end_line: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub start_column: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub end_column: Option<i64>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct CodeScanningAlertRule {
    /// A unique identifier for the rule used to detect the alert.
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<String>,
    /// The name of the rule used to detect the alert.
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,
    /// The severity of the alert.
    #[serde(skip_serializing_if="Option::is_none")]
    pub severity: Option<String>,
    /// The security severity of the alert.
    #[serde(skip_serializing_if="Option::is_none")]
    pub security_severity_level: Option<String>,
    /// A short description of the rule used to detect the alert.
    #[serde(skip_serializing_if="Option::is_none")]
    pub description: Option<String>,
    /// A description of the rule used to detect the alert.
    #[serde(skip_serializing_if="Option::is_none")]
    pub full_description: Option<String>,
    /// A set of tags applicable for the rule.
    #[serde(skip_serializing_if="Option::is_none")]
    pub tags: Option<Vec<String>>,
    /// Detailed documentation for the rule as GitHub Flavored Markdown.
    #[serde(skip_serializing_if="Option::is_none")]
    pub help: Option<String>,
    /// A link to the documentation for the rule used to detect the alert.
    #[serde(skip_serializing_if="Option::is_none")]
    pub help_uri: Option<String>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct CodeScanningAlertRuleSummary {
    /// A unique identifier for the rule used to detect the alert.
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<String>,
    /// The name of the rule used to detect the alert.
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,
    /// The severity of the alert.
    #[serde(skip_serializing_if="Option::is_none")]
    pub severity: Option<String>,
    /// The security severity of the alert.
    #[serde(skip_serializing_if="Option::is_none")]
    pub security_severity_level: Option<String>,
    /// A short description of the rule used to detect the alert.
    #[serde(skip_serializing_if="Option::is_none")]
    pub description: Option<String>,
    /// A description of the rule used to detect the alert.
    #[serde(skip_serializing_if="Option::is_none")]
    pub full_description: Option<String>,
    /// A set of tags applicable for the rule.
    #[serde(skip_serializing_if="Option::is_none")]
    pub tags: Option<Vec<String>>,
    /// Detailed documentation for the rule as GitHub Flavored Markdown.
    #[serde(skip_serializing_if="Option::is_none")]
    pub help: Option<String>,
    /// A link to the documentation for the rule used to detect the alert.
    #[serde(skip_serializing_if="Option::is_none")]
    pub help_uri: Option<String>,
}

/// Sets the state of the code scanning alert. You must provide `dismissed_reason` when you set the state to `dismissed`.
/// Enumeration of values.
/// Since this enum's variants do not hold data, we can easily define them them as `#[repr(C)]`
/// which helps with FFI.
#[allow(non_camel_case_types)]
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq, PartialOrd, Serialize, Deserialize, Eq, Ord)]
pub enum CodeScanningAlertSetState { 
    #[serde(rename = "open")]
    OPEN,
    #[serde(rename = "dismissed")]
    DISMISSED,
}

impl Display for CodeScanningAlertSetState {
    fn fmt(&self, f: &mut Formatter) -> fmt::Result {
        match *self { 
            CodeScanningAlertSetState::OPEN => write!(f, "{}", "open"),
            CodeScanningAlertSetState::DISMISSED => write!(f, "{}", "dismissed"),
        }
    }
}

impl std::str::FromStr for CodeScanningAlertSetState {
    type Err = ();
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s {
            "open" => Ok(CodeScanningAlertSetState::OPEN),
            "dismissed" => Ok(CodeScanningAlertSetState::DISMISSED),
            _ => Err(()),
        }
    }
}

/// Severity of a code scanning alert.
/// Enumeration of values.
/// Since this enum's variants do not hold data, we can easily define them them as `#[repr(C)]`
/// which helps with FFI.
#[allow(non_camel_case_types)]
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq, PartialOrd, Serialize, Deserialize, Eq, Ord)]
pub enum CodeScanningAlertSeverity { 
    #[serde(rename = "critical")]
    CRITICAL,
    #[serde(rename = "high")]
    HIGH,
    #[serde(rename = "medium")]
    MEDIUM,
    #[serde(rename = "low")]
    LOW,
    #[serde(rename = "warning")]
    WARNING,
    #[serde(rename = "note")]
    NOTE,
    #[serde(rename = "error")]
    ERROR,
}

impl Display for CodeScanningAlertSeverity {
    fn fmt(&self, f: &mut Formatter) -> fmt::Result {
        match *self { 
            CodeScanningAlertSeverity::CRITICAL => write!(f, "{}", "critical"),
            CodeScanningAlertSeverity::HIGH => write!(f, "{}", "high"),
            CodeScanningAlertSeverity::MEDIUM => write!(f, "{}", "medium"),
            CodeScanningAlertSeverity::LOW => write!(f, "{}", "low"),
            CodeScanningAlertSeverity::WARNING => write!(f, "{}", "warning"),
            CodeScanningAlertSeverity::NOTE => write!(f, "{}", "note"),
            CodeScanningAlertSeverity::ERROR => write!(f, "{}", "error"),
        }
    }
}

impl std::str::FromStr for CodeScanningAlertSeverity {
    type Err = ();
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s {
            "critical" => Ok(CodeScanningAlertSeverity::CRITICAL),
            "high" => Ok(CodeScanningAlertSeverity::HIGH),
            "medium" => Ok(CodeScanningAlertSeverity::MEDIUM),
            "low" => Ok(CodeScanningAlertSeverity::LOW),
            "warning" => Ok(CodeScanningAlertSeverity::WARNING),
            "note" => Ok(CodeScanningAlertSeverity::NOTE),
            "error" => Ok(CodeScanningAlertSeverity::ERROR),
            _ => Err(()),
        }
    }
}

/// State of a code scanning alert.
/// Enumeration of values.
/// Since this enum's variants do not hold data, we can easily define them them as `#[repr(C)]`
/// which helps with FFI.
#[allow(non_camel_case_types)]
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq, PartialOrd, Serialize, Deserialize, Eq, Ord)]
pub enum CodeScanningAlertState { 
    #[serde(rename = "open")]
    OPEN,
    #[serde(rename = "dismissed")]
    DISMISSED,
    #[serde(rename = "fixed")]
    FIXED,
}

impl Display for CodeScanningAlertState {
    fn fmt(&self, f: &mut Formatter) -> fmt::Result {
        match *self { 
            CodeScanningAlertState::OPEN => write!(f, "{}", "open"),
            CodeScanningAlertState::DISMISSED => write!(f, "{}", "dismissed"),
            CodeScanningAlertState::FIXED => write!(f, "{}", "fixed"),
        }
    }
}

impl std::str::FromStr for CodeScanningAlertState {
    type Err = ();
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s {
            "open" => Ok(CodeScanningAlertState::OPEN),
            "dismissed" => Ok(CodeScanningAlertState::DISMISSED),
            "fixed" => Ok(CodeScanningAlertState::FIXED),
            _ => Err(()),
        }
    }
}

/// State of a code scanning alert.
/// Enumeration of values.
/// Since this enum's variants do not hold data, we can easily define them them as `#[repr(C)]`
/// which helps with FFI.
#[allow(non_camel_case_types)]
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq, PartialOrd, Serialize, Deserialize, Eq, Ord)]
pub enum CodeScanningAlertStateQuery { 
    #[serde(rename = "open")]
    OPEN,
    #[serde(rename = "closed")]
    CLOSED,
    #[serde(rename = "dismissed")]
    DISMISSED,
    #[serde(rename = "fixed")]
    FIXED,
}

impl Display for CodeScanningAlertStateQuery {
    fn fmt(&self, f: &mut Formatter) -> fmt::Result {
        match *self { 
            CodeScanningAlertStateQuery::OPEN => write!(f, "{}", "open"),
            CodeScanningAlertStateQuery::CLOSED => write!(f, "{}", "closed"),
            CodeScanningAlertStateQuery::DISMISSED => write!(f, "{}", "dismissed"),
            CodeScanningAlertStateQuery::FIXED => write!(f, "{}", "fixed"),
        }
    }
}

impl std::str::FromStr for CodeScanningAlertStateQuery {
    type Err = ();
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s {
            "open" => Ok(CodeScanningAlertStateQuery::OPEN),
            "closed" => Ok(CodeScanningAlertStateQuery::CLOSED),
            "dismissed" => Ok(CodeScanningAlertStateQuery::DISMISSED),
            "fixed" => Ok(CodeScanningAlertStateQuery::FIXED),
            _ => Err(()),
        }
    }
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct CodeScanningAnalysis {
    #[serde(rename = "ref")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub git_ref: Option<CodeScanningRef>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub commit_sha: Option<CodeScanningAnalysisCommitSha>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub analysis_key: Option<CodeScanningAnalysisAnalysisKey>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub environment: Option<CodeScanningAnalysisEnvironment>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub category: Option<CodeScanningAnalysisCategory>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub error: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub created_at: Option<CodeScanningAnalysisCreatedAt>,
    /// The total number of results in the analysis.
    #[serde(skip_serializing_if="Option::is_none")]
    pub results_count: Option<i64>,
    /// The total number of rules used in the analysis.
    #[serde(skip_serializing_if="Option::is_none")]
    pub rules_count: Option<i64>,
    /// Unique identifier for this analysis.
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub url: Option<CodeScanningAnalysisUrl>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub sarif_id: Option<CodeScanningAnalysisSarifId>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub tool: Option<CodeScanningAnalysisTool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub deletable: Option<bool>,
    /// Warning generated when processing the analysis
    #[serde(skip_serializing_if="Option::is_none")]
    pub warning: Option<String>,
}

/// Identifies the configuration under which the analysis was executed. For example, in GitHub Actions this includes the workflow filename and job name.
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct CodeScanningAnalysisAnalysisKey {
}

/// Identifies the configuration under which the analysis was executed. Used to distinguish between multiple analyses for the same tool and commit, but performed on different languages or different parts of the code.
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct CodeScanningAnalysisCategory {
}

/// The SHA of the commit to which the analysis you are uploading relates.
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct CodeScanningAnalysisCommitSha {
}

/// The time that the analysis was created in ISO 8601 format: `YYYY-MM-DDTHH:MM:SSZ`.
pub type CodeScanningAnalysisCreatedAt = DateTime<Utc>;

/// Successful deletion of a code scanning analysis
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct CodeScanningAnalysisDeletion {
    /// Next deletable analysis in chain, without last analysis deletion confirmation
    #[serde(skip_serializing_if="Option::is_none")]
    pub next_analysis_url: Option<String>,
    /// Next deletable analysis in chain, with last analysis deletion confirmation
    #[serde(skip_serializing_if="Option::is_none")]
    pub confirm_delete_url: Option<String>,
}

/// Identifies the variable values associated with the environment in which this analysis was performed.
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct CodeScanningAnalysisEnvironment {
}

/// A Base64 string representing the SARIF file to upload. You must first compress your SARIF file using [`gzip`](http://www.gnu.org/software/gzip/manual/gzip.html) and then translate the contents of the file into a Base64 encoding string. For more information, see \"[SARIF support for code scanning](https://docs.github.com/code-security/secure-coding/sarif-support-for-code-scanning).\"
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct CodeScanningAnalysisSarifFile {
}

/// An identifier for the upload.
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct CodeScanningAnalysisSarifId {
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct CodeScanningAnalysisTool {
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<CodeScanningAnalysisToolName>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub version: Option<CodeScanningAnalysisToolVersion>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub guid: Option<CodeScanningAnalysisToolGuid>,
}

/// The GUID of the tool used to generate the code scanning analysis, if provided in the uploaded SARIF data.
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct CodeScanningAnalysisToolGuid {
}

/// The name of the tool used to generate the code scanning analysis.
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct CodeScanningAnalysisToolName {
}

/// The version of the tool used to generate the code scanning analysis.
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct CodeScanningAnalysisToolVersion {
}

/// The REST API URL of the analysis resource.
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct CodeScanningAnalysisUrl {
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct CodeScanningAutofix {
    #[serde(skip_serializing_if="Option::is_none")]
    pub status: Option<CodeScanningAutofixStatus>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub description: Option<CodeScanningAutofixDescription>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub started_at: Option<CodeScanningAutofixStartedAt>,
}

/// Commit an autofix for a code scanning alert
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct PostCodeScanningCommitAutofix {
    /// The Git reference of target branch for the commit. Branch needs to already exist.  For more information, see \"[Git References](https://git-scm.com/book/en/v2/Git-Internals-Git-References)\" in the Git documentation.
    #[serde(skip_serializing_if="Option::is_none")]
    pub target_ref: Option<String>,
    /// Commit message to be used.
    #[serde(skip_serializing_if="Option::is_none")]
    pub message: Option<String>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct CodeScanningAutofixCommitsResponse {
    /// The Git reference of target branch for the commit. For more information, see \"[Git References](https://git-scm.com/book/en/v2/Git-Internals-Git-References)\" in the Git documentation.
    #[serde(skip_serializing_if="Option::is_none")]
    pub target_ref: Option<String>,
    /// SHA of commit with autofix.
    #[serde(skip_serializing_if="Option::is_none")]
    pub sha: Option<String>,
}

/// The description of an autofix.
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct CodeScanningAutofixDescription {
}

/// The start time of an autofix in ISO 8601 format: `YYYY-MM-DDTHH:MM:SSZ`.
pub type CodeScanningAutofixStartedAt = DateTime<Utc>;

/// The status of an autofix.
/// Enumeration of values.
/// Since this enum's variants do not hold data, we can easily define them them as `#[repr(C)]`
/// which helps with FFI.
#[allow(non_camel_case_types)]
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq, PartialOrd, Serialize, Deserialize, Eq, Ord)]
pub enum CodeScanningAutofixStatus { 
    #[serde(rename = "pending")]
    PENDING,
    #[serde(rename = "error")]
    ERROR,
    #[serde(rename = "success")]
    SUCCESS,
    #[serde(rename = "outdated")]
    OUTDATED,
}

impl Display for CodeScanningAutofixStatus {
    fn fmt(&self, f: &mut Formatter) -> fmt::Result {
        match *self { 
            CodeScanningAutofixStatus::PENDING => write!(f, "{}", "pending"),
            CodeScanningAutofixStatus::ERROR => write!(f, "{}", "error"),
            CodeScanningAutofixStatus::SUCCESS => write!(f, "{}", "success"),
            CodeScanningAutofixStatus::OUTDATED => write!(f, "{}", "outdated"),
        }
    }
}

impl std::str::FromStr for CodeScanningAutofixStatus {
    type Err = ();
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s {
            "pending" => Ok(CodeScanningAutofixStatus::PENDING),
            "error" => Ok(CodeScanningAutofixStatus::ERROR),
            "success" => Ok(CodeScanningAutofixStatus::SUCCESS),
            "outdated" => Ok(CodeScanningAutofixStatus::OUTDATED),
            _ => Err(()),
        }
    }
}

/// A CodeQL database.
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct CodeScanningCodeqlDatabase {
    /// The ID of the CodeQL database.
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<i64>,
    /// The name of the CodeQL database.
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,
    /// The language of the CodeQL database.
    #[serde(skip_serializing_if="Option::is_none")]
    pub language: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub uploader: Option<SimpleUser>,
    /// The MIME type of the CodeQL database file.
    #[serde(skip_serializing_if="Option::is_none")]
    pub content_type: Option<String>,
    /// The size of the CodeQL database file in bytes.
    #[serde(skip_serializing_if="Option::is_none")]
    pub size: Option<i64>,
    /// The date and time at which the CodeQL database was created, in ISO 8601 format':' YYYY-MM-DDTHH:MM:SSZ.
    #[serde(skip_serializing_if="Option::is_none")]
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The date and time at which the CodeQL database was last updated, in ISO 8601 format':' YYYY-MM-DDTHH:MM:SSZ.
    #[serde(skip_serializing_if="Option::is_none")]
    pub updated_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The URL at which to download the CodeQL database. The `Accept` header must be set to the value of the `content_type` property.
    #[serde(skip_serializing_if="Option::is_none")]
    pub url: Option<String>,
    /// The commit SHA of the repository at the time the CodeQL database was created.
    #[serde(skip_serializing_if="Option::is_none")]
    pub commit_oid: Option<String>,
}

/// Configuration for code scanning default setup.
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct CodeScanningDefaultSetup {
    /// Code scanning default setup has been configured or not.
    #[serde(skip_serializing_if="Option::is_none")]
    pub state: Option<String>,
    /// Languages to be analyzed.
    #[serde(skip_serializing_if="Option::is_none")]
    pub languages: Option<Vec<String>>,
    /// Runner type to be used.
    #[serde(skip_serializing_if="Option::is_none")]
    pub runner_type: Option<String>,
    /// Runner label to be used if the runner type is labeled.
    #[serde(skip_serializing_if="Option::is_none")]
    pub runner_label: Option<String>,
    /// CodeQL query suite to be used.
    #[serde(skip_serializing_if="Option::is_none")]
    pub query_suite: Option<String>,
    /// Timestamp of latest configuration update.
    #[serde(skip_serializing_if="Option::is_none")]
    pub updated_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The frequency of the periodic analysis.
    #[serde(skip_serializing_if="Option::is_none")]
    pub schedule: Option<String>,
}

/// Feature options for code scanning default setup
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct CodeScanningDefaultSetupOptions {
    /// Whether to use labeled runners or standard GitHub runners.
    #[serde(skip_serializing_if="Option::is_none")]
    pub runner_type: Option<String>,
    /// The label of the runner to use for code scanning default setup when runner_type is 'labeled'.
    #[serde(skip_serializing_if="Option::is_none")]
    pub runner_label: Option<String>,
}

/// Configuration for code scanning default setup.
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct PatchCodeScanningUpdateDefaultSetup {
    /// The desired state of code scanning default setup.
    #[serde(skip_serializing_if="Option::is_none")]
    pub state: Option<String>,
    /// Runner type to be used.
    #[serde(skip_serializing_if="Option::is_none")]
    pub runner_type: Option<String>,
    /// Runner label to be used if the runner type is labeled.
    #[serde(skip_serializing_if="Option::is_none")]
    pub runner_label: Option<String>,
    /// CodeQL query suite to be used.
    #[serde(skip_serializing_if="Option::is_none")]
    pub query_suite: Option<String>,
    /// CodeQL languages to be analyzed.
    #[serde(skip_serializing_if="Option::is_none")]
    pub languages: Option<Vec<String>>,
}

/// You can use `run_url` to track the status of the run. This includes a property status and conclusion. You should not rely on this always being an actions workflow run object.
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct CodeScanningDefaultSetupUpdateResponse {
    /// ID of the corresponding run.
    #[serde(skip_serializing_if="Option::is_none")]
    pub run_id: Option<i64>,
    /// URL of the corresponding run.
    #[serde(skip_serializing_if="Option::is_none")]
    pub run_url: Option<String>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct CodeScanningOrganizationAlertItems {
    #[serde(skip_serializing_if="Option::is_none")]
    pub number: Option<AlertNumber>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub created_at: Option<AlertCreatedAt>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub updated_at: Option<AlertUpdatedAt>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub url: Option<AlertUrl>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub html_url: Option<AlertHtmlUrl>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub instances_url: Option<AlertInstancesUrl>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub state: Option<CodeScanningAlertState>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub fixed_at: Option<AlertFixedAt>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub dismissed_by: Option<NullableSimpleUser>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub dismissed_at: Option<AlertDismissedAt>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub dismissed_reason: Option<CodeScanningAlertDismissedReason>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub dismissed_comment: Option<CodeScanningAlertDismissedComment>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub rule: Option<CodeScanningAlertRuleSummary>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub tool: Option<CodeScanningAnalysisTool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub most_recent_instance: Option<CodeScanningAlertInstance>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub repository: Option<SimpleRepository>,
}

/// The Git reference, formatted as `refs/pull/<number>/merge`, `refs/pull/<number>/head`, `refs/heads/<branch name>` or simply `<branch name>`.
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct CodeScanningRef {
}

/// The full Git reference, formatted as `refs/heads/<branch name>`, `refs/tags/<tag>`, `refs/pull/<number>/merge`, or `refs/pull/<number>/head`.
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct CodeScanningRefFull {
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct CodeScanningSarifsReceipt {
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<CodeScanningAnalysisSarifId>,
    /// The REST API URL for checking the status of the upload.
    #[serde(skip_serializing_if="Option::is_none")]
    pub url: Option<String>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct CodeScanningSarifsStatus {
    /// `pending` files have not yet been processed, while `complete` means results from the SARIF have been stored. `failed` files have either not been processed at all, or could only be partially processed.
    #[serde(skip_serializing_if="Option::is_none")]
    pub processing_status: Option<String>,
    /// The REST API URL for getting the analyses associated with the upload.
    #[serde(skip_serializing_if="Option::is_none")]
    pub analyses_url: Option<String>,
    /// Any errors that ocurred during processing of the delivery.
    #[serde(skip_serializing_if="Option::is_none")]
    pub errors: Option<Vec<String>>,
}

/// A run of a CodeQL query against one or more repositories.
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct CodeScanningVariantAnalysis {
    /// The ID of the variant analysis.
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub controller_repo: Option<SimpleRepository>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub actor: Option<SimpleUser>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub query_language: Option<CodeScanningVariantAnalysisLanguage>,
    /// The download url for the query pack.
    #[serde(skip_serializing_if="Option::is_none")]
    pub query_pack_url: Option<String>,
    /// The date and time at which the variant analysis was created, in ISO 8601 format':' YYYY-MM-DDTHH:MM:SSZ.
    #[serde(skip_serializing_if="Option::is_none")]
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The date and time at which the variant analysis was last updated, in ISO 8601 format':' YYYY-MM-DDTHH:MM:SSZ.
    #[serde(skip_serializing_if="Option::is_none")]
    pub updated_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The date and time at which the variant analysis was completed, in ISO 8601 format':' YYYY-MM-DDTHH:MM:SSZ. Will be null if the variant analysis has not yet completed or this information is not available.
    #[serde(skip_serializing_if="Option::is_none")]
    pub completed_at: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub status: Option<String>,
    /// The GitHub Actions workflow run used to execute this variant analysis. This is only available if the workflow run has started.
    #[serde(skip_serializing_if="Option::is_none")]
    pub actions_workflow_run_id: Option<i64>,
    /// The reason for a failure of the variant analysis. This is only available if the variant analysis has failed.
    #[serde(skip_serializing_if="Option::is_none")]
    pub failure_reason: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub scanned_repositories: Option<Vec<CodescanningvariantanalysisScannedRepositories>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub skipped_repositories: Option<CodescanningvariantanalysisSkippedRepositories>,
}

/// The language targeted by the CodeQL query
/// Enumeration of values.
/// Since this enum's variants do not hold data, we can easily define them them as `#[repr(C)]`
/// which helps with FFI.
#[allow(non_camel_case_types)]
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq, PartialOrd, Serialize, Deserialize, Eq, Ord)]
pub enum CodeScanningVariantAnalysisLanguage { 
    #[serde(rename = "cpp")]
    CPP,
    #[serde(rename = "csharp")]
    CSHARP,
    #[serde(rename = "go")]
    GO,
    #[serde(rename = "java")]
    JAVA,
    #[serde(rename = "javascript")]
    JAVASCRIPT,
    #[serde(rename = "python")]
    PYTHON,
    #[serde(rename = "ruby")]
    RUBY,
    #[serde(rename = "swift")]
    SWIFT,
}

impl Display for CodeScanningVariantAnalysisLanguage {
    fn fmt(&self, f: &mut Formatter) -> fmt::Result {
        match *self { 
            CodeScanningVariantAnalysisLanguage::CPP => write!(f, "{}", "cpp"),
            CodeScanningVariantAnalysisLanguage::CSHARP => write!(f, "{}", "csharp"),
            CodeScanningVariantAnalysisLanguage::GO => write!(f, "{}", "go"),
            CodeScanningVariantAnalysisLanguage::JAVA => write!(f, "{}", "java"),
            CodeScanningVariantAnalysisLanguage::JAVASCRIPT => write!(f, "{}", "javascript"),
            CodeScanningVariantAnalysisLanguage::PYTHON => write!(f, "{}", "python"),
            CodeScanningVariantAnalysisLanguage::RUBY => write!(f, "{}", "ruby"),
            CodeScanningVariantAnalysisLanguage::SWIFT => write!(f, "{}", "swift"),
        }
    }
}

impl std::str::FromStr for CodeScanningVariantAnalysisLanguage {
    type Err = ();
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s {
            "cpp" => Ok(CodeScanningVariantAnalysisLanguage::CPP),
            "csharp" => Ok(CodeScanningVariantAnalysisLanguage::CSHARP),
            "go" => Ok(CodeScanningVariantAnalysisLanguage::GO),
            "java" => Ok(CodeScanningVariantAnalysisLanguage::JAVA),
            "javascript" => Ok(CodeScanningVariantAnalysisLanguage::JAVASCRIPT),
            "python" => Ok(CodeScanningVariantAnalysisLanguage::PYTHON),
            "ruby" => Ok(CodeScanningVariantAnalysisLanguage::RUBY),
            "swift" => Ok(CodeScanningVariantAnalysisLanguage::SWIFT),
            _ => Err(()),
        }
    }
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct CodeScanningVariantAnalysisRepoTask {
    #[serde(skip_serializing_if="Option::is_none")]
    pub repository: Option<SimpleRepository>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub analysis_status: Option<CodeScanningVariantAnalysisStatus>,
    /// The size of the artifact. This is only available for successful analyses.
    #[serde(skip_serializing_if="Option::is_none")]
    pub artifact_size_in_bytes: Option<i64>,
    /// The number of results in the case of a successful analysis. This is only available for successful analyses.
    #[serde(skip_serializing_if="Option::is_none")]
    pub result_count: Option<i64>,
    /// The reason of the failure of this repo task. This is only available if the repository task has failed.
    #[serde(skip_serializing_if="Option::is_none")]
    pub failure_message: Option<String>,
    /// The SHA of the commit the CodeQL database was built against. This is only available for successful analyses.
    #[serde(skip_serializing_if="Option::is_none")]
    pub database_commit_sha: Option<String>,
    /// The source location prefix to use. This is only available for successful analyses.
    #[serde(skip_serializing_if="Option::is_none")]
    pub source_location_prefix: Option<String>,
    /// The URL of the artifact. This is only available for successful analyses.
    #[serde(skip_serializing_if="Option::is_none")]
    pub artifact_url: Option<String>,
}

/// Repository Identifier
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct CodeScanningVariantAnalysisRepository {
    /// A unique identifier of the repository.
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<i64>,
    /// The name of the repository.
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,
    /// The full, globally unique, name of the repository.
    #[serde(skip_serializing_if="Option::is_none")]
    pub full_name: Option<String>,
    /// Whether the repository is private.
    #[serde(skip_serializing_if="Option::is_none")]
    pub private: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub stargazers_count: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub updated_at: Option<chrono::DateTime<chrono::Utc>>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct CodeScanningVariantAnalysisSkippedRepoGroup {
    /// The total number of repositories that were skipped for this reason.
    #[serde(skip_serializing_if="Option::is_none")]
    pub repository_count: Option<i64>,
    /// A list of repositories that were skipped. This list may not include all repositories that were skipped. This is only available when the repository was found and the user has access to it.
    #[serde(skip_serializing_if="Option::is_none")]
    pub repositories: Option<Vec<CodeScanningVariantAnalysisRepository>>,
}

/// The new status of the CodeQL variant analysis repository task.
/// Enumeration of values.
/// Since this enum's variants do not hold data, we can easily define them them as `#[repr(C)]`
/// which helps with FFI.
#[allow(non_camel_case_types)]
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq, PartialOrd, Serialize, Deserialize, Eq, Ord)]
pub enum CodeScanningVariantAnalysisStatus { 
    #[serde(rename = "pending")]
    PENDING,
    #[serde(rename = "in_progress")]
    IN_PROGRESS,
    #[serde(rename = "succeeded")]
    SUCCEEDED,
    #[serde(rename = "failed")]
    FAILED,
    #[serde(rename = "canceled")]
    CANCELED,
    #[serde(rename = "timed_out")]
    TIMED_OUT,
}

impl Display for CodeScanningVariantAnalysisStatus {
    fn fmt(&self, f: &mut Formatter) -> fmt::Result {
        match *self { 
            CodeScanningVariantAnalysisStatus::PENDING => write!(f, "{}", "pending"),
            CodeScanningVariantAnalysisStatus::IN_PROGRESS => write!(f, "{}", "in_progress"),
            CodeScanningVariantAnalysisStatus::SUCCEEDED => write!(f, "{}", "succeeded"),
            CodeScanningVariantAnalysisStatus::FAILED => write!(f, "{}", "failed"),
            CodeScanningVariantAnalysisStatus::CANCELED => write!(f, "{}", "canceled"),
            CodeScanningVariantAnalysisStatus::TIMED_OUT => write!(f, "{}", "timed_out"),
        }
    }
}

impl std::str::FromStr for CodeScanningVariantAnalysisStatus {
    type Err = ();
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s {
            "pending" => Ok(CodeScanningVariantAnalysisStatus::PENDING),
            "in_progress" => Ok(CodeScanningVariantAnalysisStatus::IN_PROGRESS),
            "succeeded" => Ok(CodeScanningVariantAnalysisStatus::SUCCEEDED),
            "failed" => Ok(CodeScanningVariantAnalysisStatus::FAILED),
            "canceled" => Ok(CodeScanningVariantAnalysisStatus::CANCELED),
            "timed_out" => Ok(CodeScanningVariantAnalysisStatus::TIMED_OUT),
            _ => Err(()),
        }
    }
}

/// Code Search Result Item
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct CodeSearchResultItem {
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub path: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub sha: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub git_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub html_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub repository: Option<MinimalRepository>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub score: Option<f64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub file_size: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub language: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub last_modified_at: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub line_numbers: Option<Vec<String>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub text_matches: Option<SearchResultTextMatches>,
}

/// A code security configuration
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct CodeSecurityConfiguration {
    /// The ID of the code security configuration
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<i64>,
    /// The name of the code security configuration. Must be unique within the organization.
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,
    /// The type of the code security configuration.
    #[serde(skip_serializing_if="Option::is_none")]
    pub target_type: Option<String>,
    /// A description of the code security configuration
    #[serde(skip_serializing_if="Option::is_none")]
    pub description: Option<String>,
    /// The enablement status of GitHub Advanced Security
    #[serde(skip_serializing_if="Option::is_none")]
    pub advanced_security: Option<String>,
    /// The enablement status of Dependency Graph
    #[serde(skip_serializing_if="Option::is_none")]
    pub dependency_graph: Option<String>,
    /// The enablement status of Automatic dependency submission
    #[serde(skip_serializing_if="Option::is_none")]
    pub dependency_graph_autosubmit_action: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub dependency_graph_autosubmit_action_options: Option<EnterprisesenterprisecodesecurityconfigurationsconfigurationIdDependencyGraphAutosubmitActionOptions>,
    /// The enablement status of Dependabot alerts
    #[serde(skip_serializing_if="Option::is_none")]
    pub dependabot_alerts: Option<String>,
    /// The enablement status of Dependabot security updates
    #[serde(skip_serializing_if="Option::is_none")]
    pub dependabot_security_updates: Option<String>,
    /// The enablement status of code scanning default setup
    #[serde(skip_serializing_if="Option::is_none")]
    pub code_scanning_default_setup: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub code_scanning_default_setup_options: Option<CodesecurityconfigurationCodeScanningDefaultSetupOptions>,
    /// The enablement status of secret scanning
    #[serde(skip_serializing_if="Option::is_none")]
    pub secret_scanning: Option<String>,
    /// The enablement status of secret scanning push protection
    #[serde(skip_serializing_if="Option::is_none")]
    pub secret_scanning_push_protection: Option<String>,
    /// The enablement status of secret scanning delegated bypass
    #[serde(skip_serializing_if="Option::is_none")]
    pub secret_scanning_delegated_bypass: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub secret_scanning_delegated_bypass_options: Option<OrgsorgcodesecurityconfigurationsSecretScanningDelegatedBypassOptions>,
    /// The enablement status of secret scanning validity checks
    #[serde(skip_serializing_if="Option::is_none")]
    pub secret_scanning_validity_checks: Option<String>,
    /// The enablement status of secret scanning non-provider patterns
    #[serde(skip_serializing_if="Option::is_none")]
    pub secret_scanning_non_provider_patterns: Option<String>,
    /// The enablement status of private vulnerability reporting
    #[serde(skip_serializing_if="Option::is_none")]
    pub private_vulnerability_reporting: Option<String>,
    /// The enforcement status for a security configuration
    #[serde(skip_serializing_if="Option::is_none")]
    pub enforcement: Option<String>,
    /// The URL of the configuration
    #[serde(skip_serializing_if="Option::is_none")]
    pub url: Option<String>,
    /// The URL of the configuration
    #[serde(skip_serializing_if="Option::is_none")]
    pub html_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub updated_at: Option<chrono::DateTime<chrono::Utc>>,
}

/// Code security configuration associated with a repository and attachment status
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct CodeSecurityConfigurationForRepository {
    /// The attachment status of the code security configuration on the repository.
    #[serde(skip_serializing_if="Option::is_none")]
    pub status: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub configuration: Option<CodeSecurityConfiguration>,
}

/// Repositories associated with a code security configuration and attachment status
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct CodeSecurityConfigurationRepositories {
    /// The attachment status of the code security configuration on the repository.
    #[serde(skip_serializing_if="Option::is_none")]
    pub status: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub repository: Option<SimpleRepository>,
}

/// A list of default code security configurations
pub type CodeSecurityDefaultConfigurations = Vec<CodesecuritydefaultconfigurationsInner>;

/// A list of errors found in a repo's CODEOWNERS file
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct CodeownersErrors {
    #[serde(skip_serializing_if="Option::is_none")]
    pub errors: Option<Vec<CodeownerserrorsErrors>>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct CodeownerserrorsErrors {
    /// The line number where this errors occurs.
    #[serde(skip_serializing_if="Option::is_none")]
    pub line: Option<i64>,
    /// The column number where this errors occurs.
    #[serde(skip_serializing_if="Option::is_none")]
    pub column: Option<i64>,
    /// The contents of the line where the error occurs.
    #[serde(skip_serializing_if="Option::is_none")]
    pub source: Option<String>,
    /// The type of error.
    #[serde(skip_serializing_if="Option::is_none")]
    pub kind: Option<String>,
    /// Suggested action to fix the error. This will usually be `null`, but is provided for some common errors.
    #[serde(skip_serializing_if="Option::is_none")]
    pub suggestion: Option<String>,
    /// A human-readable description of the error, combining information from multiple fields, laid out for display in a monospaced typeface (for example, a command-line setting).
    #[serde(skip_serializing_if="Option::is_none")]
    pub message: Option<String>,
    /// The path of the file where the error occured.
    #[serde(skip_serializing_if="Option::is_none")]
    pub path: Option<String>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct CodescanningalertinstanceMessage {
    #[serde(skip_serializing_if="Option::is_none")]
    pub text: Option<String>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct CodescanningvariantanalysisScannedRepositories {
    #[serde(skip_serializing_if="Option::is_none")]
    pub repository: Option<CodeScanningVariantAnalysisRepository>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub analysis_status: Option<CodeScanningVariantAnalysisStatus>,
    /// The number of results in the case of a successful analysis. This is only available for successful analyses.
    #[serde(skip_serializing_if="Option::is_none")]
    pub result_count: Option<i64>,
    /// The size of the artifact. This is only available for successful analyses.
    #[serde(skip_serializing_if="Option::is_none")]
    pub artifact_size_in_bytes: Option<i64>,
    /// The reason of the failure of this repo task. This is only available if the repository task has failed.
    #[serde(skip_serializing_if="Option::is_none")]
    pub failure_message: Option<String>,
}

/// Information about repositories that were skipped from processing. This information is only available to the user that initiated the variant analysis.
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct CodescanningvariantanalysisSkippedRepositories {
    #[serde(skip_serializing_if="Option::is_none")]
    pub access_mismatch_repos: Option<CodeScanningVariantAnalysisSkippedRepoGroup>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub not_found_repos: Option<CodescanningvariantanalysisSkippedRepositoriesNotFoundRepos>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub no_codeql_db_repos: Option<CodeScanningVariantAnalysisSkippedRepoGroup>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub over_limit_repos: Option<CodeScanningVariantAnalysisSkippedRepoGroup>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct CodescanningvariantanalysisSkippedRepositoriesNotFoundRepos {
    /// The total number of repositories that were skipped for this reason.
    #[serde(skip_serializing_if="Option::is_none")]
    pub repository_count: Option<i64>,
    /// A list of full repository names that were skipped. This list may not include all repositories that were skipped.
    #[serde(skip_serializing_if="Option::is_none")]
    pub repository_full_names: Option<Vec<String>>,
}

/// Feature options for code scanning default setup
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct CodesecurityconfigurationCodeScanningDefaultSetupOptions {
    /// Whether to use labeled runners or standard GitHub runners.
    #[serde(skip_serializing_if="Option::is_none")]
    pub runner_type: Option<String>,
    /// The label of the runner to use for code scanning when runner_type is 'labeled'.
    #[serde(skip_serializing_if="Option::is_none")]
    pub runner_label: Option<String>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct CodesecuritydefaultconfigurationsInner {
    /// The visibility of newly created repositories for which the code security configuration will be applied to by default
    #[serde(skip_serializing_if="Option::is_none")]
    pub default_for_new_repos: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub configuration: Option<CodeSecurityConfiguration>,
}

/// A codespace.
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct Codespace {
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<i64>,
    /// Automatically generated name of this codespace.
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,
    /// Display name for this codespace.
    #[serde(skip_serializing_if="Option::is_none")]
    pub display_name: Option<String>,
    /// UUID identifying this codespace's environment.
    #[serde(skip_serializing_if="Option::is_none")]
    pub environment_id: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub owner: Option<SimpleUser>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub billable_owner: Option<SimpleUser>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub repository: Option<MinimalRepository>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub machine: Option<NullableCodespaceMachine>,
    /// Path to devcontainer.json from repo root used to create Codespace.
    #[serde(skip_serializing_if="Option::is_none")]
    pub devcontainer_path: Option<String>,
    /// Whether the codespace was created from a prebuild.
    #[serde(skip_serializing_if="Option::is_none")]
    pub prebuild: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub updated_at: Option<chrono::DateTime<chrono::Utc>>,
    /// Last known time this codespace was started.
    #[serde(skip_serializing_if="Option::is_none")]
    pub last_used_at: Option<chrono::DateTime<chrono::Utc>>,
    /// State of this codespace.
    #[serde(skip_serializing_if="Option::is_none")]
    pub state: Option<String>,
    /// API URL for this codespace.
    #[serde(skip_serializing_if="Option::is_none")]
    pub url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub git_status: Option<CodespaceGitStatus>,
    /// The initally assigned location of a new codespace.
    #[serde(skip_serializing_if="Option::is_none")]
    pub location: Option<String>,
    /// The number of minutes of inactivity after which this codespace will be automatically stopped.
    #[serde(skip_serializing_if="Option::is_none")]
    pub idle_timeout_minutes: Option<i64>,
    /// URL to access this codespace on the web.
    #[serde(skip_serializing_if="Option::is_none")]
    pub web_url: Option<String>,
    /// API URL to access available alternate machine types for this codespace.
    #[serde(skip_serializing_if="Option::is_none")]
    pub machines_url: Option<String>,
    /// API URL to start this codespace.
    #[serde(skip_serializing_if="Option::is_none")]
    pub start_url: Option<String>,
    /// API URL to stop this codespace.
    #[serde(skip_serializing_if="Option::is_none")]
    pub stop_url: Option<String>,
    /// API URL to publish this codespace to a new repository.
    #[serde(skip_serializing_if="Option::is_none")]
    pub publish_url: Option<String>,
    /// API URL for the Pull Request associated with this codespace, if any.
    #[serde(skip_serializing_if="Option::is_none")]
    pub pulls_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub recent_folders: Option<Vec<String>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub runtime_constraints: Option<CodespaceRuntimeConstraints>,
    /// Whether or not a codespace has a pending async operation. This would mean that the codespace is temporarily unavailable. The only thing that you can do with a codespace in this state is delete it.
    #[serde(skip_serializing_if="Option::is_none")]
    pub pending_operation: Option<bool>,
    /// Text to show user when codespace is disabled by a pending operation
    #[serde(skip_serializing_if="Option::is_none")]
    pub pending_operation_disabled_reason: Option<String>,
    /// Text to show user when codespace idle timeout minutes has been overriden by an organization policy
    #[serde(skip_serializing_if="Option::is_none")]
    pub idle_timeout_notice: Option<String>,
    /// Duration in minutes after codespace has gone idle in which it will be deleted. Must be integer minutes between 0 and 43200 (30 days).
    #[serde(skip_serializing_if="Option::is_none")]
    pub retention_period_minutes: Option<i64>,
    /// When a codespace will be auto-deleted based on the \"retention_period_minutes\" and \"last_used_at\"
    #[serde(skip_serializing_if="Option::is_none")]
    pub retention_expires_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The text to display to a user when a codespace has been stopped for a potentially actionable reason.
    #[serde(skip_serializing_if="Option::is_none")]
    pub last_known_stop_notice: Option<String>,
}

/// An export of a codespace. Also, latest export details for a codespace can be fetched with id = latest
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct CodespaceExportDetails {
    /// State of the latest export
    #[serde(skip_serializing_if="Option::is_none")]
    pub state: Option<String>,
    /// Completion time of the last export operation
    #[serde(skip_serializing_if="Option::is_none")]
    pub completed_at: Option<chrono::DateTime<chrono::Utc>>,
    /// Name of the exported branch
    #[serde(skip_serializing_if="Option::is_none")]
    pub branch: Option<String>,
    /// Git commit SHA of the exported branch
    #[serde(skip_serializing_if="Option::is_none")]
    pub sha: Option<String>,
    /// Id for the export details
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<String>,
    /// Url for fetching export details
    #[serde(skip_serializing_if="Option::is_none")]
    pub export_url: Option<String>,
    /// Web url for the exported branch
    #[serde(skip_serializing_if="Option::is_none")]
    pub html_url: Option<String>,
}

/// Details about the codespace's git repository.
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct CodespaceGitStatus {
    /// The number of commits the local repository is ahead of the remote.
    #[serde(skip_serializing_if="Option::is_none")]
    pub ahead: Option<i64>,
    /// The number of commits the local repository is behind the remote.
    #[serde(skip_serializing_if="Option::is_none")]
    pub behind: Option<i64>,
    /// Whether the local repository has unpushed changes.
    #[serde(skip_serializing_if="Option::is_none")]
    pub has_unpushed_changes: Option<bool>,
    /// Whether the local repository has uncommitted changes.
    #[serde(skip_serializing_if="Option::is_none")]
    pub has_uncommitted_changes: Option<bool>,
    /// The current branch (or SHA if in detached HEAD state) of the local repository.
    #[serde(rename = "ref")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub git_ref: Option<String>,
}

/// A description of the machine powering a codespace.
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct CodespaceMachine {
    /// The name of the machine.
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,
    /// The display name of the machine includes cores, memory, and storage.
    #[serde(skip_serializing_if="Option::is_none")]
    pub display_name: Option<String>,
    /// The operating system of the machine.
    #[serde(skip_serializing_if="Option::is_none")]
    pub operating_system: Option<String>,
    /// How much storage is available to the codespace.
    #[serde(skip_serializing_if="Option::is_none")]
    pub storage_in_bytes: Option<i64>,
    /// How much memory is available to the codespace.
    #[serde(skip_serializing_if="Option::is_none")]
    pub memory_in_bytes: Option<i64>,
    /// How many cores are available to the codespace.
    #[serde(skip_serializing_if="Option::is_none")]
    pub cpus: Option<i64>,
    /// Whether a prebuild is currently available when creating a codespace for this machine and repository. If a branch was not specified as a ref, the default branch will be assumed. Value will be \"null\" if prebuilds are not supported or prebuild availability could not be determined. Value will be \"none\" if no prebuild is available. Latest values \"ready\" and \"in_progress\" indicate the prebuild availability status.
    #[serde(skip_serializing_if="Option::is_none")]
    pub prebuild_availability: Option<String>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct CodespaceRuntimeConstraints {
    /// The privacy settings a user can select from when forwarding a port.
    #[serde(skip_serializing_if="Option::is_none")]
    pub allowed_port_privacy_settings: Option<Vec<String>>,
}

/// A codespace.
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct CodespaceWithFullRepository {
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<i64>,
    /// Automatically generated name of this codespace.
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,
    /// Display name for this codespace.
    #[serde(skip_serializing_if="Option::is_none")]
    pub display_name: Option<String>,
    /// UUID identifying this codespace's environment.
    #[serde(skip_serializing_if="Option::is_none")]
    pub environment_id: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub owner: Option<SimpleUser>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub billable_owner: Option<SimpleUser>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub repository: Option<FullRepository>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub machine: Option<NullableCodespaceMachine>,
    /// Path to devcontainer.json from repo root used to create Codespace.
    #[serde(skip_serializing_if="Option::is_none")]
    pub devcontainer_path: Option<String>,
    /// Whether the codespace was created from a prebuild.
    #[serde(skip_serializing_if="Option::is_none")]
    pub prebuild: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub updated_at: Option<chrono::DateTime<chrono::Utc>>,
    /// Last known time this codespace was started.
    #[serde(skip_serializing_if="Option::is_none")]
    pub last_used_at: Option<chrono::DateTime<chrono::Utc>>,
    /// State of this codespace.
    #[serde(skip_serializing_if="Option::is_none")]
    pub state: Option<String>,
    /// API URL for this codespace.
    #[serde(skip_serializing_if="Option::is_none")]
    pub url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub git_status: Option<CodespaceGitStatus>,
    /// The initally assigned location of a new codespace.
    #[serde(skip_serializing_if="Option::is_none")]
    pub location: Option<String>,
    /// The number of minutes of inactivity after which this codespace will be automatically stopped.
    #[serde(skip_serializing_if="Option::is_none")]
    pub idle_timeout_minutes: Option<i64>,
    /// URL to access this codespace on the web.
    #[serde(skip_serializing_if="Option::is_none")]
    pub web_url: Option<String>,
    /// API URL to access available alternate machine types for this codespace.
    #[serde(skip_serializing_if="Option::is_none")]
    pub machines_url: Option<String>,
    /// API URL to start this codespace.
    #[serde(skip_serializing_if="Option::is_none")]
    pub start_url: Option<String>,
    /// API URL to stop this codespace.
    #[serde(skip_serializing_if="Option::is_none")]
    pub stop_url: Option<String>,
    /// API URL to publish this codespace to a new repository.
    #[serde(skip_serializing_if="Option::is_none")]
    pub publish_url: Option<String>,
    /// API URL for the Pull Request associated with this codespace, if any.
    #[serde(skip_serializing_if="Option::is_none")]
    pub pulls_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub recent_folders: Option<Vec<String>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub runtime_constraints: Option<CodespaceRuntimeConstraints>,
    /// Whether or not a codespace has a pending async operation. This would mean that the codespace is temporarily unavailable. The only thing that you can do with a codespace in this state is delete it.
    #[serde(skip_serializing_if="Option::is_none")]
    pub pending_operation: Option<bool>,
    /// Text to show user when codespace is disabled by a pending operation
    #[serde(skip_serializing_if="Option::is_none")]
    pub pending_operation_disabled_reason: Option<String>,
    /// Text to show user when codespace idle timeout minutes has been overriden by an organization policy
    #[serde(skip_serializing_if="Option::is_none")]
    pub idle_timeout_notice: Option<String>,
    /// Duration in minutes after codespace has gone idle in which it will be deleted. Must be integer minutes between 0 and 43200 (30 days).
    #[serde(skip_serializing_if="Option::is_none")]
    pub retention_period_minutes: Option<i64>,
    /// When a codespace will be auto-deleted based on the \"retention_period_minutes\" and \"last_used_at\"
    #[serde(skip_serializing_if="Option::is_none")]
    pub retention_expires_at: Option<chrono::DateTime<chrono::Utc>>,
}

/// Secrets for a GitHub Codespace.
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct CodespacesOrgSecret {
    /// The name of the secret
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,
    /// The date and time at which the secret was created, in ISO 8601 format':' YYYY-MM-DDTHH:MM:SSZ.
    #[serde(skip_serializing_if="Option::is_none")]
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The date and time at which the secret was created, in ISO 8601 format':' YYYY-MM-DDTHH:MM:SSZ.
    #[serde(skip_serializing_if="Option::is_none")]
    pub updated_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The type of repositories in the organization that the secret is visible to
    #[serde(skip_serializing_if="Option::is_none")]
    pub visibility: Option<String>,
    /// The API URL at which the list of repositories this secret is visible to can be retrieved
    #[serde(skip_serializing_if="Option::is_none")]
    pub selected_repositories_url: Option<String>,
}

/// Permission check result for a given devcontainer config.
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct CodespacesPermissionsCheckForDevcontainer {
    /// Whether the user has accepted the permissions defined by the devcontainer config
    #[serde(skip_serializing_if="Option::is_none")]
    pub accepted: Option<bool>,
}

/// The public key used for setting Codespaces secrets.
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct CodespacesPublicKey {
    /// The identifier for the key.
    #[serde(skip_serializing_if="Option::is_none")]
    pub key_id: Option<String>,
    /// The Base64 encoded public key.
    #[serde(skip_serializing_if="Option::is_none")]
    pub key: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub title: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub created_at: Option<String>,
}

/// Secrets for a GitHub Codespace.
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct CodespacesSecret {
    /// The name of the secret
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,
    /// The date and time at which the secret was created, in ISO 8601 format':' YYYY-MM-DDTHH:MM:SSZ.
    #[serde(skip_serializing_if="Option::is_none")]
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The date and time at which the secret was last updated, in ISO 8601 format':' YYYY-MM-DDTHH:MM:SSZ.
    #[serde(skip_serializing_if="Option::is_none")]
    pub updated_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The type of repositories in the organization that the secret is visible to
    #[serde(skip_serializing_if="Option::is_none")]
    pub visibility: Option<String>,
    /// The API URL at which the list of repositories this secret is visible to can be retrieved
    #[serde(skip_serializing_if="Option::is_none")]
    pub selected_repositories_url: Option<String>,
}

/// The public key used for setting user Codespaces' Secrets.
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct CodespacesUserPublicKey {
    /// The identifier for the key.
    #[serde(skip_serializing_if="Option::is_none")]
    pub key_id: Option<String>,
    /// The Base64 encoded public key.
    #[serde(skip_serializing_if="Option::is_none")]
    pub key: Option<String>,
}

/// Collaborator
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct Collaborator {
    #[serde(skip_serializing_if="Option::is_none")]
    pub login: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub email: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub node_id: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub avatar_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub gravatar_id: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub html_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub followers_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub following_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub gists_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub starred_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub subscriptions_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub organizations_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub repos_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub events_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub received_events_url: Option<String>,
    #[serde(rename = "type")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub _type: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub site_admin: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub permissions: Option<CollaboratorPermissions>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub role_name: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub user_view_type: Option<String>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct CollaboratorPermissions {
    #[serde(skip_serializing_if="Option::is_none")]
    pub pull: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub triage: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub push: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub maintain: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub admin: Option<bool>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct CombinedBillingUsage {
    /// Numbers of days left in billing cycle.
    #[serde(skip_serializing_if="Option::is_none")]
    pub days_left_in_billing_cycle: Option<i64>,
    /// Estimated storage space (GB) used in billing cycle.
    #[serde(skip_serializing_if="Option::is_none")]
    pub estimated_paid_storage_for_month: Option<i64>,
    /// Estimated sum of free and paid storage space (GB) used in billing cycle.
    #[serde(skip_serializing_if="Option::is_none")]
    pub estimated_storage_for_month: Option<i64>,
}

/// Combined Commit Status
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct CombinedCommitStatus {
    #[serde(skip_serializing_if="Option::is_none")]
    pub state: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub statuses: Option<Vec<SimpleCommitStatus>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub sha: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub total_count: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub repository: Option<MinimalRepository>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub commit_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub url: Option<String>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct Commit {
    /// An array of files added in the commit. A maximum of 3000 changed files will be reported per commit.
    #[serde(skip_serializing_if="Option::is_none")]
    pub added: Option<Vec<String>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub author: Option<Committer>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub committer: Option<Committer>,
    /// Whether this commit is distinct from any that have been pushed before.
    #[serde(skip_serializing_if="Option::is_none")]
    pub distinct: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<String>,
    /// The commit message.
    #[serde(skip_serializing_if="Option::is_none")]
    pub message: Option<String>,
    /// An array of files modified by the commit. A maximum of 3000 changed files will be reported per commit.
    #[serde(skip_serializing_if="Option::is_none")]
    pub modified: Option<Vec<String>>,
    /// An array of files removed in the commit. A maximum of 3000 changed files will be reported per commit.
    #[serde(skip_serializing_if="Option::is_none")]
    pub removed: Option<Vec<String>>,
    /// The ISO 8601 timestamp of the commit.
    #[serde(skip_serializing_if="Option::is_none")]
    pub timestamp: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub tree_id: Option<String>,
    /// URL that points to the commit API resource.
    #[serde(skip_serializing_if="Option::is_none")]
    pub url: Option<String>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct Commit1 {
    /// An array of files added in the commit.
    #[serde(skip_serializing_if="Option::is_none")]
    pub added: Option<Vec<String>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub author: Option<Committer>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub committer: Option<Committer>,
    /// Whether this commit is distinct from any that have been pushed before.
    #[serde(skip_serializing_if="Option::is_none")]
    pub distinct: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<String>,
    /// The commit message.
    #[serde(skip_serializing_if="Option::is_none")]
    pub message: Option<String>,
    /// An array of files modified by the commit.
    #[serde(skip_serializing_if="Option::is_none")]
    pub modified: Option<Vec<String>>,
    /// An array of files removed in the commit.
    #[serde(skip_serializing_if="Option::is_none")]
    pub removed: Option<Vec<String>>,
    /// The ISO 8601 timestamp of the commit.
    #[serde(skip_serializing_if="Option::is_none")]
    pub timestamp: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub tree_id: Option<String>,
    /// URL that points to the commit API resource.
    #[serde(skip_serializing_if="Option::is_none")]
    pub url: Option<String>,
}

/// Commit Activity
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct CommitActivity {
    #[serde(skip_serializing_if="Option::is_none")]
    pub days: Option<Vec<i32>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub total: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub week: Option<i64>,
}

/// Commit Comment
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct CommitComment {
    #[serde(skip_serializing_if="Option::is_none")]
    pub html_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub node_id: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub body: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub path: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub position: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub line: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub commit_id: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub user: Option<NullableSimpleUser>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub updated_at: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub author_association: Option<AuthorAssociation>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub reactions: Option<ReactionRollup>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct CommitCommit {
    #[serde(skip_serializing_if="Option::is_none")]
    pub url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub author: Option<NullableGitUser>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub committer: Option<NullableGitUser>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub message: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub comment_count: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub tree: Option<CommitCommitTree>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub verification: Option<Verification>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct CommitCommitTree {
    #[serde(skip_serializing_if="Option::is_none")]
    pub sha: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub url: Option<String>,
}

/// Commit Comparison
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct CommitComparison {
    #[serde(skip_serializing_if="Option::is_none")]
    pub url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub html_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub permalink_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub diff_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub patch_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub base_commit: Option<Commit>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub merge_base_commit: Option<Commit>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub status: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub ahead_by: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub behind_by: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub total_commits: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub commits: Option<Vec<Commit>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub files: Option<Vec<DiffEntry>>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct CommitParents {
    #[serde(skip_serializing_if="Option::is_none")]
    pub sha: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub html_url: Option<String>,
}

/// Commit Search Result Item
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct CommitSearchResultItem {
    #[serde(skip_serializing_if="Option::is_none")]
    pub url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub sha: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub html_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub comments_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub commit: Option<CommitsearchresultitemCommit>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub author: Option<NullableSimpleUser>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub committer: Option<NullableGitUser>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub parents: Option<Vec<FilecommitCommitParents>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub repository: Option<MinimalRepository>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub score: Option<f64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub node_id: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub text_matches: Option<SearchResultTextMatches>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct CommitStats {
    #[serde(skip_serializing_if="Option::is_none")]
    pub additions: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub deletions: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub total: Option<i64>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct CommitsearchresultitemCommit {
    #[serde(skip_serializing_if="Option::is_none")]
    pub author: Option<CommitsearchresultitemCommitAuthor>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub committer: Option<NullableGitUser>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub comment_count: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub message: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub tree: Option<ShortbranchCommit>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub verification: Option<Verification>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct CommitsearchresultitemCommitAuthor {
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub email: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub date: Option<chrono::DateTime<chrono::Utc>>,
}

/// Metaproperties for Git author/committer information.
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct Committer {
    #[serde(skip_serializing_if="Option::is_none")]
    pub date: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub email: Option<String>,
    /// The git author's name.
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub username: Option<String>,
}

/// Metaproperties for Git author/committer information.
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct Committer1 {
    #[serde(skip_serializing_if="Option::is_none")]
    pub date: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub email: Option<String>,
    /// The git author's name.
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub username: Option<String>,
}

/// Community Profile
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct CommunityProfile {
    #[serde(skip_serializing_if="Option::is_none")]
    pub health_percentage: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub description: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub documentation: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub files: Option<CommunityprofileFiles>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub updated_at: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub content_reports_enabled: Option<bool>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct CommunityprofileFiles {
    #[serde(skip_serializing_if="Option::is_none")]
    pub code_of_conduct: Option<NullableCodeOfConductSimple>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub code_of_conduct_file: Option<NullableCommunityHealthFile>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub license: Option<NullableLicenseSimple>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub contributing: Option<NullableCommunityHealthFile>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub readme: Option<NullableCommunityHealthFile>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub issue_template: Option<NullableCommunityHealthFile>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub pull_request_template: Option<NullableCommunityHealthFile>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct ContainerMetadata {
    #[serde(skip_serializing_if="Option::is_none")]
    pub tags: Option<Vec<String>>,
}

/// A list of directory items
pub type ContentDirectory = Vec<ContentdirectoryInner>;

/// Content File
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct ContentFile {
    #[serde(rename = "type")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub _type: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub encoding: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub size: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub path: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub content: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub sha: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub git_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub html_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub download_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub _links: Option<ContenttreeLinks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub target: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub submodule_git_url: Option<String>,
}

/// An object describing a submodule
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct ContentSubmodule {
    #[serde(rename = "type")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub _type: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub submodule_git_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub size: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub path: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub sha: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub git_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub html_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub download_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub _links: Option<ContenttreeLinks>,
}

/// An object describing a symlink
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct ContentSymlink {
    #[serde(rename = "type")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub _type: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub target: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub size: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub path: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub sha: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub git_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub html_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub download_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub _links: Option<ContenttreeLinks>,
}

/// Content Traffic
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct ContentTraffic {
    #[serde(skip_serializing_if="Option::is_none")]
    pub path: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub title: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub count: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub uniques: Option<i64>,
}

/// Content Tree
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct ContentTree {
    #[serde(rename = "type")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub _type: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub size: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub path: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub sha: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub content: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub git_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub html_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub download_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub entries: Option<Vec<ContenttreeEntries>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub _links: Option<ContenttreeLinks>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct ContentdirectoryInner {
    #[serde(rename = "type")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub _type: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub size: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub path: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub content: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub sha: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub git_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub html_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub download_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub _links: Option<HashMap<String, Value>>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct ContenttreeEntries {
    #[serde(rename = "type")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub _type: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub size: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub path: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub sha: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub git_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub html_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub download_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub _links: Option<ContenttreeLinks>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct ContenttreeLinks {
    #[serde(skip_serializing_if="Option::is_none")]
    pub git: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub html: Option<String>,
    #[serde(rename = "self")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub _self: Option<String>,
}

/// Contributor
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct Contributor {
    #[serde(skip_serializing_if="Option::is_none")]
    pub login: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub node_id: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub avatar_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub gravatar_id: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub html_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub followers_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub following_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub gists_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub starred_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub subscriptions_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub organizations_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub repos_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub events_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub received_events_url: Option<String>,
    #[serde(rename = "type")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub _type: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub site_admin: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub contributions: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub email: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub user_view_type: Option<String>,
}

/// Contributor Activity
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct ContributorActivity {
    #[serde(skip_serializing_if="Option::is_none")]
    pub author: Option<NullableSimpleUser>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub total: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub weeks: Option<Vec<ContributoractivityWeeks>>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct ContributoractivityWeeks {
    #[serde(skip_serializing_if="Option::is_none")]
    pub w: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub a: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub d: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub c: Option<i64>,
}

/// Converted Note to Issue Issue Event
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct ConvertedNoteToIssueIssueEvent {
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub node_id: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub actor: Option<SimpleUser>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub event: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub commit_id: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub commit_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub created_at: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub performed_via_github_app: Option<Integration>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub project_card: Option<AddedtoprojectissueeventProjectCard>,
}

/// Usage metrics for Copilot Chat in GitHub.com
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct CopilotDotcomChat {
    /// Total number of users who prompted Copilot Chat on github.com at least once.
    #[serde(rename = "total_engaged_users")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub total_engaged_users: Option<i32>,
    /// List of model metrics for a custom models and the default model.
    #[serde(rename = "models")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub models: Option<Vec<CopilotdotcomchatModels>>,
}

/// Usage metrics for Copilot for pull requests.
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct CopilotDotcomPullRequests {
    /// The number of users who used Copilot for Pull Requests on github.com to generate a pull request summary at least once.
    #[serde(rename = "total_engaged_users")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub total_engaged_users: Option<i32>,
    /// Repositories in which users used Copilot for Pull Requests to generate pull request summaries
    #[serde(rename = "repositories")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub repositories: Option<Vec<CopilotdotcompullrequestsRepositories>>,
}

/// Usage metrics for Copilot Chat in the IDE.
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct CopilotIdeChat {
    /// Total number of users who prompted Copilot Chat in the IDE.
    #[serde(rename = "total_engaged_users")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub total_engaged_users: Option<i32>,
    #[serde(rename = "editors")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub editors: Option<Vec<CopilotidechatEditors>>,
}

/// Usage metrics for Copilot editor code completions in the IDE.
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct CopilotIdeCodeCompletions {
    /// Number of users who accepted at least one Copilot code suggestion, across all active editors. Includes both full and partial acceptances.
    #[serde(rename = "total_engaged_users")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub total_engaged_users: Option<i32>,
    /// Code completion metrics for active languages.
    #[serde(rename = "languages")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub languages: Option<Vec<CopilotidecodecompletionsLanguages>>,
    #[serde(rename = "editors")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub editors: Option<Vec<CopilotidecodecompletionsEditors>>,
}

/// Information about the seat breakdown and policies set for an organization with a Copilot Business or Copilot Enterprise subscription.
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct CopilotOrganizationDetails {
    #[serde(rename = "seat_breakdown")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub seat_breakdown: Option<CopilotSeatBreakdown>,
    /// The organization policy for allowing or disallowing Copilot to make suggestions that match public code.
    #[serde(rename = "public_code_suggestions")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub public_code_suggestions: Option<String>,
    /// The organization policy for allowing or disallowing organization members to use Copilot Chat within their editor.
    #[serde(rename = "ide_chat")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub ide_chat: Option<String>,
    /// The organization policy for allowing or disallowing organization members to use Copilot features within github.com.
    #[serde(rename = "platform_chat")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub platform_chat: Option<String>,
    /// The organization policy for allowing or disallowing organization members to use Copilot within their CLI.
    #[serde(rename = "cli")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub cli: Option<String>,
    /// The mode of assigning new seats.
    #[serde(rename = "seat_management_setting")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub seat_management_setting: Option<String>,
    /// The Copilot plan of the organization, or the parent enterprise, when applicable.
    #[serde(rename = "plan_type")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub plan_type: Option<String>,
}

/// The breakdown of Copilot Business seats for the organization.
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct CopilotSeatBreakdown {
    /// The total number of seats being billed for the organization as of the current billing cycle.
    #[serde(skip_serializing_if="Option::is_none")]
    pub total: Option<i64>,
    /// Seats added during the current billing cycle.
    #[serde(skip_serializing_if="Option::is_none")]
    pub added_this_cycle: Option<i64>,
    /// The number of seats that are pending cancellation at the end of the current billing cycle.
    #[serde(skip_serializing_if="Option::is_none")]
    pub pending_cancellation: Option<i64>,
    /// The number of seats that have been assigned to users that have not yet accepted an invitation to this organization.
    #[serde(skip_serializing_if="Option::is_none")]
    pub pending_invitation: Option<i64>,
    /// The number of seats that have used Copilot during the current billing cycle.
    #[serde(skip_serializing_if="Option::is_none")]
    pub active_this_cycle: Option<i64>,
    /// The number of seats that have not used Copilot during the current billing cycle.
    #[serde(skip_serializing_if="Option::is_none")]
    pub inactive_this_cycle: Option<i64>,
}

/// Information about a Copilot Business seat assignment for a user, team, or organization.
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct CopilotSeatDetails {
    #[serde(skip_serializing_if="Option::is_none")]
    pub assignee: Option<SimpleUser>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub organization: Option<NullableOrganizationSimple>,
    /// The team through which the assignee is granted access to GitHub Copilot, if applicable.
    #[serde(skip_serializing_if="Option::is_none")]
    pub assigning_team: Option<OneOfcopilotSeatDetailsAssigningTeam>,
    /// The pending cancellation date for the seat, in `YYYY-MM-DD` format. This will be null unless the assignee's Copilot access has been canceled during the current billing cycle. If the seat has been cancelled, this corresponds to the start of the organization's next billing cycle.
    #[serde(skip_serializing_if="Option::is_none")]
    pub pending_cancellation_date: Option<chrono::DateTime<chrono::Utc>>,
    /// Timestamp of user's last GitHub Copilot activity, in ISO 8601 format.
    #[serde(skip_serializing_if="Option::is_none")]
    pub last_activity_at: Option<chrono::DateTime<chrono::Utc>>,
    /// Last editor that was used by the user for a GitHub Copilot completion.
    #[serde(skip_serializing_if="Option::is_none")]
    pub last_activity_editor: Option<String>,
    /// Timestamp of when the assignee was last granted access to GitHub Copilot, in ISO 8601 format.
    #[serde(skip_serializing_if="Option::is_none")]
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
    /// **Closing down notice:** This field is no longer relevant and is closing down. Use the `created_at` field to determine when the assignee was last granted access to GitHub Copilot. Timestamp of when the assignee's GitHub Copilot access was last updated, in ISO 8601 format.
    #[serde(skip_serializing_if="Option::is_none")]
    pub updated_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The Copilot plan of the organization, or the parent enterprise, when applicable.
    #[serde(skip_serializing_if="Option::is_none")]
    pub plan_type: Option<String>,
}

/// Summary of Copilot usage.
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct CopilotUsageMetrics {
    /// The date for which the usage metrics are reported, in `YYYY-MM-DD` format.
    #[serde(skip_serializing_if="Option::is_none")]
    pub day: Option<chrono::DateTime<chrono::Utc>>,
    /// The total number of Copilot code completion suggestions shown to users.
    #[serde(skip_serializing_if="Option::is_none")]
    pub total_suggestions_count: Option<i64>,
    /// The total number of Copilot code completion suggestions accepted by users.
    #[serde(skip_serializing_if="Option::is_none")]
    pub total_acceptances_count: Option<i64>,
    /// The total number of lines of code completions suggested by Copilot.
    #[serde(skip_serializing_if="Option::is_none")]
    pub total_lines_suggested: Option<i64>,
    /// The total number of lines of code completions accepted by users.
    #[serde(skip_serializing_if="Option::is_none")]
    pub total_lines_accepted: Option<i64>,
    /// The total number of users who were shown Copilot code completion suggestions during the day specified.
    #[serde(skip_serializing_if="Option::is_none")]
    pub total_active_users: Option<i64>,
    /// The total instances of users who accepted code suggested by Copilot Chat in the IDE (panel and inline).
    #[serde(skip_serializing_if="Option::is_none")]
    pub total_chat_acceptances: Option<i64>,
    /// The total number of chat turns (prompt and response pairs) sent between users and Copilot Chat in the IDE.
    #[serde(skip_serializing_if="Option::is_none")]
    pub total_chat_turns: Option<i64>,
    /// The total number of users who interacted with Copilot Chat in the IDE during the day specified.
    #[serde(skip_serializing_if="Option::is_none")]
    pub total_active_chat_users: Option<i64>,
    /// Breakdown of Copilot code completions usage by language and editor
    #[serde(skip_serializing_if="Option::is_none")]
    pub breakdown: Option<Vec<CopilotusagemetricsBreakdown>>,
}

/// Copilot usage metrics for a given day.
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct CopilotUsageMetricsDay {
    /// The date for which the usage metrics are aggregated, in `YYYY-MM-DD` format.
    #[serde(rename = "date")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub date: Option<chrono::DateTime<chrono::Utc>>,
    /// The total number of Copilot users with activity belonging to any Copilot feature, globally, for the given day. Includes passive activity such as receiving a code suggestion, as well as engagement activity such as accepting a code suggestion or prompting chat. Does not include authentication events. Is not limited to the individual features detailed on the endpoint.
    #[serde(rename = "total_active_users")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub total_active_users: Option<i32>,
    /// The total number of Copilot users who engaged with any Copilot feature, for the given day. Examples include but are not limited to accepting a code suggestion, prompting Copilot chat, or triggering a PR Summary. Does not include authentication events. Is not limited to the individual features detailed on the endpoint.
    #[serde(rename = "total_engaged_users")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub total_engaged_users: Option<i32>,
    #[serde(rename = "copilot_ide_code_completions")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub copilot_ide_code_completions: Option<CopilotIdeCodeCompletions>,
    #[serde(rename = "copilot_ide_chat")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub copilot_ide_chat: Option<CopilotIdeChat>,
    #[serde(rename = "copilot_dotcom_chat")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub copilot_dotcom_chat: Option<CopilotDotcomChat>,
    #[serde(rename = "copilot_dotcom_pull_requests")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub copilot_dotcom_pull_requests: Option<CopilotDotcomPullRequests>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct CopilotdotcomchatModels {
    /// Name of the model used for Copilot code completion suggestions. If the default model is used will appear as 'default'.
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,
    /// Indicates whether a model is custom or default.
    #[serde(skip_serializing_if="Option::is_none")]
    pub is_custom_model: Option<bool>,
    /// The training date for the custom model (if applicable).
    #[serde(skip_serializing_if="Option::is_none")]
    pub custom_model_training_date: Option<String>,
    /// Total number of users who prompted Copilot Chat on github.com at least once for each model.
    #[serde(skip_serializing_if="Option::is_none")]
    pub total_engaged_users: Option<i64>,
    /// Total number of chats initiated by users on github.com.
    #[serde(skip_serializing_if="Option::is_none")]
    pub total_chats: Option<i64>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct CopilotdotcompullrequestsModels {
    /// Name of the model used for Copilot code completion suggestions. If the default model is used will appear as 'default'.
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,
    /// Indicates whether a model is custom or default.
    #[serde(skip_serializing_if="Option::is_none")]
    pub is_custom_model: Option<bool>,
    /// The training date for the custom model.
    #[serde(skip_serializing_if="Option::is_none")]
    pub custom_model_training_date: Option<String>,
    /// The number of pull request summaries generated using Copilot for Pull Requests in the given repository.
    #[serde(skip_serializing_if="Option::is_none")]
    pub total_pr_summaries_created: Option<i64>,
    /// The number of users who generated pull request summaries using Copilot for Pull Requests in the given repository and model.
    #[serde(skip_serializing_if="Option::is_none")]
    pub total_engaged_users: Option<i64>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct CopilotdotcompullrequestsRepositories {
    /// Repository name
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,
    /// The number of users who generated pull request summaries using Copilot for Pull Requests in the given repository.
    #[serde(skip_serializing_if="Option::is_none")]
    pub total_engaged_users: Option<i64>,
    /// List of model metrics for custom models and the default model.
    #[serde(skip_serializing_if="Option::is_none")]
    pub models: Option<Vec<CopilotdotcompullrequestsModels>>,
}

/// Copilot Chat metrics, for active editors.
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct CopilotidechatEditors {
    /// Name of the given editor.
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,
    /// The number of users who prompted Copilot Chat in the specified editor.
    #[serde(skip_serializing_if="Option::is_none")]
    pub total_engaged_users: Option<i64>,
    /// List of model metrics for custom models and the default model.
    #[serde(skip_serializing_if="Option::is_none")]
    pub models: Option<Vec<CopilotidechatModels>>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct CopilotidechatModels {
    /// Name of the model used for Copilot code completion suggestions. If the default model is used will appear as 'default'.
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,
    /// Indicates whether a model is custom or default.
    #[serde(skip_serializing_if="Option::is_none")]
    pub is_custom_model: Option<bool>,
    /// The training date for the custom model.
    #[serde(skip_serializing_if="Option::is_none")]
    pub custom_model_training_date: Option<String>,
    /// The number of users who prompted Copilot Chat in the given editor and model.
    #[serde(skip_serializing_if="Option::is_none")]
    pub total_engaged_users: Option<i64>,
    /// The total number of chats initiated by users in the given editor and model.
    #[serde(skip_serializing_if="Option::is_none")]
    pub total_chats: Option<i64>,
    /// The number of times users accepted a code suggestion from Copilot Chat using the 'Insert Code' UI element, for the given editor.
    #[serde(skip_serializing_if="Option::is_none")]
    pub total_chat_insertion_events: Option<i64>,
    /// The number of times users copied a code suggestion from Copilot Chat using the keyboard, or the 'Copy' UI element, for the given editor.
    #[serde(skip_serializing_if="Option::is_none")]
    pub total_chat_copy_events: Option<i64>,
}

/// Copilot code completion metrics for active editors.
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct CopilotidecodecompletionsEditors {
    /// Name of the given editor.
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,
    /// Number of users who accepted at least one Copilot code completion suggestion for the given editor. Includes both full and partial acceptances.
    #[serde(skip_serializing_if="Option::is_none")]
    pub total_engaged_users: Option<i64>,
    /// List of model metrics for custom models and the default model.
    #[serde(skip_serializing_if="Option::is_none")]
    pub models: Option<Vec<CopilotidecodecompletionsModels>>,
}

/// Usage metrics for a given language for the given editor for Copilot code completions.
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct CopilotidecodecompletionsLanguages {
    /// Name of the language used for Copilot code completion suggestions.
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,
    /// Number of users who accepted at least one Copilot code completion suggestion for the given language. Includes both full and partial acceptances.
    #[serde(skip_serializing_if="Option::is_none")]
    pub total_engaged_users: Option<i64>,
}

/// Usage metrics for a given language for the given editor for Copilot code completions.
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct CopilotidecodecompletionsLanguages1 {
    /// Name of the language used for Copilot code completion suggestions, for the given editor.
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,
    /// Number of users who accepted at least one Copilot code completion suggestion for the given editor, for the given language. Includes both full and partial acceptances.
    #[serde(skip_serializing_if="Option::is_none")]
    pub total_engaged_users: Option<i64>,
    /// The number of Copilot code suggestions generated for the given editor, for the given language.
    #[serde(skip_serializing_if="Option::is_none")]
    pub total_code_suggestions: Option<i64>,
    /// The number of Copilot code suggestions accepted for the given editor, for the given language. Includes both full and partial acceptances.
    #[serde(skip_serializing_if="Option::is_none")]
    pub total_code_acceptances: Option<i64>,
    /// The number of lines of code suggested by Copilot code completions for the given editor, for the given language.
    #[serde(skip_serializing_if="Option::is_none")]
    pub total_code_lines_suggested: Option<i64>,
    /// The number of lines of code accepted from Copilot code suggestions for the given editor, for the given language.
    #[serde(skip_serializing_if="Option::is_none")]
    pub total_code_lines_accepted: Option<i64>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct CopilotidecodecompletionsModels {
    /// Name of the model used for Copilot code completion suggestions. If the default model is used will appear as 'default'.
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,
    /// Indicates whether a model is custom or default.
    #[serde(skip_serializing_if="Option::is_none")]
    pub is_custom_model: Option<bool>,
    /// The training date for the custom model.
    #[serde(skip_serializing_if="Option::is_none")]
    pub custom_model_training_date: Option<String>,
    /// Number of users who accepted at least one Copilot code completion suggestion for the given editor, for the given language and model. Includes both full and partial acceptances.
    #[serde(skip_serializing_if="Option::is_none")]
    pub total_engaged_users: Option<i64>,
    /// Code completion metrics for active languages, for the given editor.
    #[serde(skip_serializing_if="Option::is_none")]
    pub languages: Option<Vec<CopilotidecodecompletionsLanguages1>>,
}

/// Breakdown of Copilot usage by editor for this language
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct CopilotusagemetricsBreakdown {
    /// The language in which Copilot suggestions were shown to users in the specified editor.
    #[serde(skip_serializing_if="Option::is_none")]
    pub language: Option<String>,
    /// The editor in which Copilot suggestions were shown to users for the specified language.
    #[serde(skip_serializing_if="Option::is_none")]
    pub editor: Option<String>,
    /// The number of Copilot suggestions shown to users in the editor specified during the day specified.
    #[serde(skip_serializing_if="Option::is_none")]
    pub suggestions_count: Option<i64>,
    /// The number of Copilot suggestions accepted by users in the editor specified during the day specified.
    #[serde(skip_serializing_if="Option::is_none")]
    pub acceptances_count: Option<i64>,
    /// The number of lines of code suggested by Copilot in the editor specified during the day specified.
    #[serde(skip_serializing_if="Option::is_none")]
    pub lines_suggested: Option<i64>,
    /// The number of lines of code accepted by users in the editor specified during the day specified.
    #[serde(skip_serializing_if="Option::is_none")]
    pub lines_accepted: Option<i64>,
    /// The number of users who were shown Copilot completion suggestions in the editor specified during the day specified.
    #[serde(skip_serializing_if="Option::is_none")]
    pub active_users: Option<i64>,
}

/// A GitHub App that is providing a custom deployment protection rule.
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct CustomDeploymentRuleApp {
    /// The unique identifier of the deployment protection rule integration.
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<i64>,
    /// The slugified name of the deployment protection rule integration.
    #[serde(skip_serializing_if="Option::is_none")]
    pub slug: Option<String>,
    /// The URL for the endpoint to get details about the app.
    #[serde(skip_serializing_if="Option::is_none")]
    pub integration_url: Option<String>,
    /// The node ID for the deployment protection rule integration.
    #[serde(skip_serializing_if="Option::is_none")]
    pub node_id: Option<String>,
}

/// Custom property defined on an organization
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct CustomProperty {
    /// The name of the property
    #[serde(skip_serializing_if="Option::is_none")]
    pub property_name: Option<String>,
    /// The URL that can be used to fetch, update, or delete info about this property via the API.
    #[serde(skip_serializing_if="Option::is_none")]
    pub url: Option<String>,
    /// The source type of the property
    #[serde(skip_serializing_if="Option::is_none")]
    pub source_type: Option<String>,
    /// The type of the value for the property
    #[serde(skip_serializing_if="Option::is_none")]
    pub value_type: Option<String>,
    /// Whether the property is required.
    #[serde(skip_serializing_if="Option::is_none")]
    pub required: Option<bool>,
    /// Default value of the property
    #[serde(skip_serializing_if="Option::is_none")]
    pub default_value: Option<OneOfcustomPropertyDefaultValue>,
    /// Short description of the property
    #[serde(skip_serializing_if="Option::is_none")]
    pub description: Option<String>,
    /// An ordered list of the allowed values of the property. The property can have up to 200 allowed values.
    #[serde(skip_serializing_if="Option::is_none")]
    pub allowed_values: Option<Vec<String>>,
    /// Who can edit the values of the property
    #[serde(skip_serializing_if="Option::is_none")]
    pub values_editable_by: Option<String>,
}

/// Custom property set payload
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct PutOrgsCreateOrUpdateCustomProperty {
    /// The type of the value for the property
    #[serde(skip_serializing_if="Option::is_none")]
    pub value_type: Option<String>,
    /// Whether the property is required.
    #[serde(skip_serializing_if="Option::is_none")]
    pub required: Option<bool>,
    /// Default value of the property
    #[serde(skip_serializing_if="Option::is_none")]
    pub default_value: Option<OneOfcustomPropertySetPayloadDefaultValue>,
    /// Short description of the property
    #[serde(skip_serializing_if="Option::is_none")]
    pub description: Option<String>,
    /// An ordered list of the allowed values of the property. The property can have up to 200 allowed values.
    #[serde(skip_serializing_if="Option::is_none")]
    pub allowed_values: Option<Vec<String>>,
}

/// Custom property name and associated value
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct CustomPropertyValue {
    /// The name of the property
    #[serde(skip_serializing_if="Option::is_none")]
    pub property_name: Option<String>,
    /// The value assigned to the property
    #[serde(skip_serializing_if="Option::is_none")]
    pub value: Option<OneOfcustomPropertyValueValue>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct CvssSeverities {
    #[serde(skip_serializing_if="Option::is_none")]
    pub cvss_v3: Option<CvssseveritiesCvssV3>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub cvss_v4: Option<CvssseveritiesCvssV4>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct CvssseveritiesCvssV3 {
    /// The CVSS 3 vector string.
    #[serde(skip_serializing_if="Option::is_none")]
    pub vector_string: Option<String>,
    /// The CVSS 3 score.
    #[serde(skip_serializing_if="Option::is_none")]
    pub score: Option<f64>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct CvssseveritiesCvssV4 {
    /// The CVSS 4 vector string.
    #[serde(skip_serializing_if="Option::is_none")]
    pub vector_string: Option<String>,
    /// The CVSS 4 score.
    #[serde(skip_serializing_if="Option::is_none")]
    pub score: Option<f64>,
}

#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
#[serde(untagged)]
pub enum Cwes { 
    CwesVariant0(String),
    CwesVariant1(Vec<String>),
}

impl From<String> for Cwes {
    fn from(value: String) -> Self {
        Cwes::CwesVariant0(value)
    }
}

impl From<Vec<String>> for Cwes {
    fn from(value: Vec<String>) -> Self {
        Cwes::CwesVariant1(value)
    }
}

/// Demilestoned Issue Event
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct DemilestonedIssueEvent {
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub node_id: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub actor: Option<SimpleUser>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub event: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub commit_id: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub commit_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub created_at: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub performed_via_github_app: Option<NullableIntegration>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub milestone: Option<MilestonedissueeventMilestone>,
}

/// A Dependabot alert.
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct DependabotAlert {
    #[serde(skip_serializing_if="Option::is_none")]
    pub number: Option<AlertNumber>,
    /// The state of the Dependabot alert.
    #[serde(skip_serializing_if="Option::is_none")]
    pub state: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub dependency: Option<DependabotalertwithrepositoryDependency>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub security_advisory: Option<DependabotAlertSecurityAdvisory>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub security_vulnerability: Option<DependabotAlertSecurityVulnerability>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub url: Option<AlertUrl>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub html_url: Option<AlertHtmlUrl>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub created_at: Option<AlertCreatedAt>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub updated_at: Option<AlertUpdatedAt>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub dismissed_at: Option<AlertDismissedAt>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub dismissed_by: Option<NullableSimpleUser>,
    /// The reason that the alert was dismissed.
    #[serde(skip_serializing_if="Option::is_none")]
    pub dismissed_reason: Option<String>,
    /// An optional comment associated with the alert's dismissal.
    #[serde(skip_serializing_if="Option::is_none")]
    pub dismissed_comment: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub fixed_at: Option<AlertFixedAt>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub auto_dismissed_at: Option<AlertAutoDismissedAt>,
}

/// Details for the vulnerable package.
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct DependabotAlertPackage {
    /// The package's language or package management ecosystem.
    #[serde(skip_serializing_if="Option::is_none")]
    pub ecosystem: Option<String>,
    /// The unique package name within its ecosystem.
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,
}

/// Details for the GitHub Security Advisory.
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct DependabotAlertSecurityAdvisory {
    /// The unique GitHub Security Advisory ID assigned to the advisory.
    #[serde(skip_serializing_if="Option::is_none")]
    pub ghsa_id: Option<String>,
    /// The unique CVE ID assigned to the advisory.
    #[serde(skip_serializing_if="Option::is_none")]
    pub cve_id: Option<String>,
    /// A short, plain text summary of the advisory.
    #[serde(skip_serializing_if="Option::is_none")]
    pub summary: Option<String>,
    /// A long-form Markdown-supported description of the advisory.
    #[serde(skip_serializing_if="Option::is_none")]
    pub description: Option<String>,
    /// Vulnerable version range information for the advisory.
    #[serde(skip_serializing_if="Option::is_none")]
    pub vulnerabilities: Option<Vec<DependabotAlertSecurityVulnerability>>,
    /// The severity of the advisory.
    #[serde(skip_serializing_if="Option::is_none")]
    pub severity: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub cvss: Option<DependabotalertsecurityadvisoryCvss>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub cvss_severities: Option<CvssSeverities>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub epss: Option<SecurityAdvisoryEpss>,
    /// Details for the advisory pertaining to Common Weakness Enumeration.
    #[serde(skip_serializing_if="Option::is_none")]
    pub cwes: Option<Vec<DependabotalertsecurityadvisoryCwes>>,
    /// Values that identify this advisory among security information sources.
    #[serde(skip_serializing_if="Option::is_none")]
    pub identifiers: Option<Vec<DependabotalertsecurityadvisoryIdentifiers>>,
    /// Links to additional advisory information.
    #[serde(skip_serializing_if="Option::is_none")]
    pub references: Option<Vec<DependabotalertsecurityadvisoryReferences>>,
    /// The time that the advisory was published in ISO 8601 format: `YYYY-MM-DDTHH:MM:SSZ`.
    #[serde(skip_serializing_if="Option::is_none")]
    pub published_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The time that the advisory was last modified in ISO 8601 format: `YYYY-MM-DDTHH:MM:SSZ`.
    #[serde(skip_serializing_if="Option::is_none")]
    pub updated_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The time that the advisory was withdrawn in ISO 8601 format: `YYYY-MM-DDTHH:MM:SSZ`.
    #[serde(skip_serializing_if="Option::is_none")]
    pub withdrawn_at: Option<chrono::DateTime<chrono::Utc>>,
}

/// Details pertaining to one vulnerable version range for the advisory.
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct DependabotAlertSecurityVulnerability {
    #[serde(skip_serializing_if="Option::is_none")]
    pub package: Option<DependabotAlertPackage>,
    /// The severity of the vulnerability.
    #[serde(skip_serializing_if="Option::is_none")]
    pub severity: Option<String>,
    /// Conditions that identify vulnerable versions of this vulnerability's package.
    #[serde(skip_serializing_if="Option::is_none")]
    pub vulnerable_version_range: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub first_patched_version: Option<DependabotalertsecurityvulnerabilityFirstPatchedVersion>,
}

/// A Dependabot alert.
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct DependabotAlertWithRepository {
    #[serde(skip_serializing_if="Option::is_none")]
    pub number: Option<AlertNumber>,
    /// The state of the Dependabot alert.
    #[serde(skip_serializing_if="Option::is_none")]
    pub state: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub dependency: Option<DependabotalertwithrepositoryDependency>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub security_advisory: Option<DependabotAlertSecurityAdvisory>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub security_vulnerability: Option<DependabotAlertSecurityVulnerability>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub url: Option<AlertUrl>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub html_url: Option<AlertHtmlUrl>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub created_at: Option<AlertCreatedAt>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub updated_at: Option<AlertUpdatedAt>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub dismissed_at: Option<AlertDismissedAt>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub dismissed_by: Option<NullableSimpleUser>,
    /// The reason that the alert was dismissed.
    #[serde(skip_serializing_if="Option::is_none")]
    pub dismissed_reason: Option<String>,
    /// An optional comment associated with the alert's dismissal.
    #[serde(skip_serializing_if="Option::is_none")]
    pub dismissed_comment: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub fixed_at: Option<AlertFixedAt>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub auto_dismissed_at: Option<AlertAutoDismissedAt>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub repository: Option<SimpleRepository>,
}

/// The public key used for setting Dependabot Secrets.
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct DependabotPublicKey {
    /// The identifier for the key.
    #[serde(skip_serializing_if="Option::is_none")]
    pub key_id: Option<String>,
    /// The Base64 encoded public key.
    #[serde(skip_serializing_if="Option::is_none")]
    pub key: Option<String>,
}

/// Set secrets for Dependabot.
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct DependabotSecret {
    /// The name of the secret.
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub updated_at: Option<chrono::DateTime<chrono::Utc>>,
}

/// Details for the advisory pertaining to the Common Vulnerability Scoring System.
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct DependabotalertsecurityadvisoryCvss {
    /// The overall CVSS score of the advisory.
    #[serde(skip_serializing_if="Option::is_none")]
    pub score: Option<f64>,
    /// The full CVSS vector string for the advisory.
    #[serde(skip_serializing_if="Option::is_none")]
    pub vector_string: Option<String>,
}

/// A CWE weakness assigned to the advisory.
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct DependabotalertsecurityadvisoryCwes {
    /// The unique CWE ID.
    #[serde(skip_serializing_if="Option::is_none")]
    pub cwe_id: Option<String>,
    /// The short, plain text name of the CWE.
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,
}

/// An advisory identifier.
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct DependabotalertsecurityadvisoryIdentifiers {
    /// The type of advisory identifier.
    #[serde(rename = "type")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub _type: Option<String>,
    /// The value of the advisory identifer.
    #[serde(skip_serializing_if="Option::is_none")]
    pub value: Option<String>,
}

/// A link to additional advisory information.
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct DependabotalertsecurityadvisoryReferences {
    /// The URL of the reference.
    #[serde(skip_serializing_if="Option::is_none")]
    pub url: Option<String>,
}

/// Details pertaining to the package version that patches this vulnerability.
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct DependabotalertsecurityvulnerabilityFirstPatchedVersion {
    /// The package version that patches this vulnerability.
    #[serde(skip_serializing_if="Option::is_none")]
    pub identifier: Option<String>,
}

/// Details for the vulnerable dependency.
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct DependabotalertwithrepositoryDependency {
    #[serde(skip_serializing_if="Option::is_none")]
    pub package: Option<DependabotAlertPackage>,
    /// The full path to the dependency manifest file, relative to the root of the repository.
    #[serde(skip_serializing_if="Option::is_none")]
    pub manifest_path: Option<String>,
    /// The execution scope of the vulnerable dependency.
    #[serde(skip_serializing_if="Option::is_none")]
    pub scope: Option<String>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct Dependency {
    /// Package-url (PURL) of dependency. See https://github.com/package-url/purl-spec for more details.
    #[serde(skip_serializing_if="Option::is_none")]
    pub package_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub metadata: Option<Metadata>,
    /// A notation of whether a dependency is requested directly by this manifest or is a dependency of another dependency.
    #[serde(skip_serializing_if="Option::is_none")]
    pub relationship: Option<String>,
    /// A notation of whether the dependency is required for the primary build artifact (runtime) or is only used for development. Future versions of this specification may allow for more granular scopes.
    #[serde(skip_serializing_if="Option::is_none")]
    pub scope: Option<String>,
    /// Array of package-url (PURLs) of direct child dependencies.
    #[serde(skip_serializing_if="Option::is_none")]
    pub dependencies: Option<Vec<String>>,
}

/// A diff of the dependencies between two commits.
pub type DependencyGraphDiff = Vec<DependencygraphdiffInner>;

/// A schema for the SPDX JSON format returned by the Dependency Graph.
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct DependencyGraphSpdxSbom {
    #[serde(skip_serializing_if="Option::is_none")]
    pub sbom: Option<DependencygraphspdxsbomSbom>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct DependencygraphdiffInner {
    #[serde(skip_serializing_if="Option::is_none")]
    pub change_type: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub manifest: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub ecosystem: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub version: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub package_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub license: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub source_repository_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub vulnerabilities: Option<Vec<Value>>,
    /// Where the dependency is utilized. `development` means that the dependency is only utilized in the development environment. `runtime` means that the dependency is utilized at runtime and in the development environment.
    #[serde(skip_serializing_if="Option::is_none")]
    pub scope: Option<String>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct DependencygraphspdxsbomSbom {
    /// The SPDX identifier for the SPDX document.
    #[serde(rename = "SPDXID")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub spdxid: Option<String>,
    /// The version of the SPDX specification that this document conforms to.
    #[serde(rename = "spdxVersion")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub spdx_version: Option<String>,
    /// An optional comment about the SPDX document.
    #[serde(skip_serializing_if="Option::is_none")]
    pub comment: Option<String>,
    #[serde(rename = "creationInfo")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub creation_info: Option<DependencygraphspdxsbomSbomCreationInfo>,
    /// The name of the SPDX document.
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,
    /// The license under which the SPDX document is licensed.
    #[serde(rename = "dataLicense")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub data_license: Option<String>,
    /// The namespace for the SPDX document.
    #[serde(rename = "documentNamespace")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub document_namespace: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub packages: Option<Vec<DependencygraphspdxsbomSbomPackages>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub relationships: Option<Vec<DependencygraphspdxsbomSbomRelationships>>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct DependencygraphspdxsbomSbomCreationInfo {
    /// The date and time the SPDX document was created.
    #[serde(skip_serializing_if="Option::is_none")]
    pub created: Option<String>,
    /// The tools that were used to generate the SPDX document.
    #[serde(skip_serializing_if="Option::is_none")]
    pub creators: Option<Vec<String>>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct DependencygraphspdxsbomSbomExternalRefs {
    /// The category of reference to an external resource this reference refers to.
    #[serde(rename = "referenceCategory")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub reference_category: Option<String>,
    /// A locator for the particular external resource this reference refers to.
    #[serde(rename = "referenceLocator")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub reference_locator: Option<String>,
    /// The category of reference to an external resource this reference refers to.
    #[serde(rename = "referenceType")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub reference_type: Option<String>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct DependencygraphspdxsbomSbomPackages {
    /// A unique SPDX identifier for the package.
    #[serde(rename = "SPDXID")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub spdxid: Option<String>,
    /// The name of the package.
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,
    /// The version of the package. If the package does not have an exact version specified, a version range is given.
    #[serde(rename = "versionInfo")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub version_info: Option<String>,
    /// The location where the package can be downloaded, or NOASSERTION if this has not been determined.
    #[serde(rename = "downloadLocation")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub download_location: Option<String>,
    /// Whether the package's file content has been subjected to analysis during the creation of the SPDX document.
    #[serde(rename = "filesAnalyzed")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub files_analyzed: Option<bool>,
    /// The license of the package as determined while creating the SPDX document.
    #[serde(rename = "licenseConcluded")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub license_concluded: Option<String>,
    /// The license of the package as declared by its author, or NOASSERTION if this information was not available when the SPDX document was created.
    #[serde(rename = "licenseDeclared")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub license_declared: Option<String>,
    /// The distribution source of this package, or NOASSERTION if this was not determined.
    #[serde(skip_serializing_if="Option::is_none")]
    pub supplier: Option<String>,
    /// The copyright holders of the package, and any dates present with those notices, if available.
    #[serde(rename = "copyrightText")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub copyright_text: Option<String>,
    #[serde(rename = "externalRefs")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub external_refs: Option<Vec<DependencygraphspdxsbomSbomExternalRefs>>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct DependencygraphspdxsbomSbomRelationships {
    /// The type of relationship between the two SPDX elements.
    #[serde(rename = "relationshipType")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub relationship_type: Option<String>,
    /// The SPDX identifier of the package that is the source of the relationship.
    #[serde(rename = "spdxElementId")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub spdx_element_id: Option<String>,
    /// The SPDX identifier of the package that is the target of the relationship.
    #[serde(rename = "relatedSpdxElement")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub related_spdx_element: Option<String>,
}

/// An SSH key granting access to a single repository.
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct DeployKey {
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub key: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub title: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub verified: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub created_at: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub read_only: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub added_by: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub last_used: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub enabled: Option<bool>,
}

/// The [deployment](https://docs.github.com/rest/deployments/deployments#list-deployments).
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct Deployment {
    #[serde(skip_serializing_if="Option::is_none")]
    pub created_at: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub creator: Option<User1>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub description: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub environment: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub node_id: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub original_environment: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub payload: Option<OneOfDeploymentPayload>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub performed_via_github_app: Option<App5>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub production_environment: Option<bool>,
    #[serde(rename = "ref")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub git_ref: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub repository_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub sha: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub statuses_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub task: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub transient_environment: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub updated_at: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub url: Option<String>,
}

/// The [deployment](https://docs.github.com/rest/deployments/deployments#list-deployments).
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct Deployment1 {
    #[serde(skip_serializing_if="Option::is_none")]
    pub created_at: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub creator: Option<User1>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub description: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub environment: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub node_id: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub original_environment: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub payload: Option<OneOfDeployment1Payload>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub performed_via_github_app: Option<App6>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub production_environment: Option<bool>,
    #[serde(rename = "ref")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub git_ref: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub repository_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub sha: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub statuses_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub task: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub transient_environment: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub updated_at: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub url: Option<String>,
}

/// Details of a deployment branch or tag policy.
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct DeploymentBranchPolicy {
    /// The unique identifier of the branch or tag policy.
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub node_id: Option<String>,
    /// The name pattern that branches or tags must match in order to deploy to the environment.
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,
    /// Whether this rule targets a branch or tag.
    #[serde(rename = "type")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub _type: Option<String>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct PutReposUpdateDeploymentBranchPolicy {
    /// The name pattern that branches must match in order to deploy to the environment.  Wildcard characters will not match `/`. For example, to match branches that begin with `release/` and contain an additional single slash, use `release/_*_/_*`. For more information about pattern matching syntax, see the [Ruby File.fnmatch documentation](https://ruby-doc.org/core-2.5.1/File.html#method-c-fnmatch).
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct PostReposCreateDeploymentBranchPolicy {
    /// The name pattern that branches or tags must match in order to deploy to the environment.  Wildcard characters will not match `/`. For example, to match branches that begin with `release/` and contain an additional single slash, use `release/_*_/_*`. For more information about pattern matching syntax, see the [Ruby File.fnmatch documentation](https://ruby-doc.org/core-2.5.1/File.html#method-c-fnmatch).
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,
    /// Whether this rule targets a branch or tag
    #[serde(rename = "type")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub _type: Option<String>,
}

/// The type of deployment branch policy for this environment. To allow all branches to deploy, set to `null`.
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct DeploymentBranchPolicySettings {
    /// Whether only branches with branch protection rules can deploy to this environment. If `protected_branches` is `true`, `custom_branch_policies` must be `false`; if `protected_branches` is `false`, `custom_branch_policies` must be `true`.
    #[serde(skip_serializing_if="Option::is_none")]
    pub protected_branches: Option<bool>,
    /// Whether only branches that match the specified name patterns can deploy to this environment.  If `custom_branch_policies` is `true`, `protected_branches` must be `false`; if `custom_branch_policies` is `false`, `protected_branches` must be `true`.
    #[serde(skip_serializing_if="Option::is_none")]
    pub custom_branch_policies: Option<bool>,
}

/// Deployment protection rule
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct DeploymentProtectionRule {
    /// The unique identifier for the deployment protection rule.
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<i64>,
    /// The node ID for the deployment protection rule.
    #[serde(skip_serializing_if="Option::is_none")]
    pub node_id: Option<String>,
    /// Whether the deployment protection rule is enabled for the environment.
    #[serde(skip_serializing_if="Option::is_none")]
    pub enabled: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub app: Option<CustomDeploymentRuleApp>,
}

/// The type of reviewer.
/// Enumeration of values.
/// Since this enum's variants do not hold data, we can easily define them them as `#[repr(C)]`
/// which helps with FFI.
#[allow(non_camel_case_types)]
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq, PartialOrd, Serialize, Deserialize, Eq, Ord)]
pub enum DeploymentReviewerType { 
    #[serde(rename = "User")]
    USER,
    #[serde(rename = "Team")]
    TEAM,
}

impl Display for DeploymentReviewerType {
    fn fmt(&self, f: &mut Formatter) -> fmt::Result {
        match *self { 
            DeploymentReviewerType::USER => write!(f, "{}", "User"),
            DeploymentReviewerType::TEAM => write!(f, "{}", "Team"),
        }
    }
}

impl std::str::FromStr for DeploymentReviewerType {
    type Err = ();
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s {
            "User" => Ok(DeploymentReviewerType::USER),
            "Team" => Ok(DeploymentReviewerType::TEAM),
            _ => Err(()),
        }
    }
}

/// A deployment created as the result of an Actions check run from a workflow that references an environment
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct DeploymentSimple {
    #[serde(skip_serializing_if="Option::is_none")]
    pub url: Option<String>,
    /// Unique identifier of the deployment
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub node_id: Option<String>,
    /// Parameter to specify a task to execute
    #[serde(skip_serializing_if="Option::is_none")]
    pub task: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub original_environment: Option<String>,
    /// Name for the target deployment environment.
    #[serde(skip_serializing_if="Option::is_none")]
    pub environment: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub description: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub updated_at: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub statuses_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub repository_url: Option<String>,
    /// Specifies if the given environment is will no longer exist at some point in the future. Default: false.
    #[serde(skip_serializing_if="Option::is_none")]
    pub transient_environment: Option<bool>,
    /// Specifies if the given environment is one that end-users directly interact with. Default: false.
    #[serde(skip_serializing_if="Option::is_none")]
    pub production_environment: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub performed_via_github_app: Option<NullableIntegration>,
}

/// The status of a deployment.
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct DeploymentStatus {
    #[serde(skip_serializing_if="Option::is_none")]
    pub url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub node_id: Option<String>,
    /// The state of the status.
    #[serde(skip_serializing_if="Option::is_none")]
    pub state: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub creator: Option<NullableSimpleUser>,
    /// A short description of the status.
    #[serde(skip_serializing_if="Option::is_none")]
    pub description: Option<String>,
    /// The environment of the deployment that the status is for.
    #[serde(skip_serializing_if="Option::is_none")]
    pub environment: Option<String>,
    /// Closing down notice: the URL to associate with this status.
    #[serde(skip_serializing_if="Option::is_none")]
    pub target_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub updated_at: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub deployment_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub repository_url: Option<String>,
    /// The URL for accessing your environment.
    #[serde(skip_serializing_if="Option::is_none")]
    pub environment_url: Option<String>,
    /// The URL to associate with this status.
    #[serde(skip_serializing_if="Option::is_none")]
    pub log_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub performed_via_github_app: Option<NullableIntegration>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct DeploymentWorkflowRun {
    #[serde(skip_serializing_if="Option::is_none")]
    pub actor: Option<User1>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub artifacts_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub cancel_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub check_suite_id: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub check_suite_node_id: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub check_suite_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub conclusion: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub display_title: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub event: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub head_branch: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub head_commit: Option<Value>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub head_repository: Option<DeploymentWorkflowRunHeadRepository>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub head_sha: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub html_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub jobs_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub logs_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub node_id: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub path: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub previous_attempt_url: Option<Value>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub pull_requests: Option<Vec<CheckRunPullRequest>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub referenced_workflows: Option<Vec<DeploymentWorkflowRunReferencedWorkflows>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub repository: Option<DeploymentWorkflowRunHeadRepository>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub rerun_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub run_attempt: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub run_number: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub run_started_at: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub status: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub triggering_actor: Option<User1>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub updated_at: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub workflow_id: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub workflow_url: Option<String>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct DeploymentWorkflowRun1 {
    #[serde(skip_serializing_if="Option::is_none")]
    pub actor: Option<User1>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub artifacts_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub cancel_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub check_suite_id: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub check_suite_node_id: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub check_suite_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub conclusion: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub display_title: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub event: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub head_branch: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub head_commit: Option<HashMap<String, Value>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub head_repository: Option<DeploymentWorkflowRun1HeadRepository>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub head_sha: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub html_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub jobs_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub logs_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub node_id: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub path: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub previous_attempt_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub pull_requests: Option<Vec<CheckRunPullRequest>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub referenced_workflows: Option<Vec<DeploymentWorkflowRunReferencedWorkflows>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub repository: Option<DeploymentWorkflowRun1HeadRepository>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub rerun_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub run_attempt: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub run_number: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub run_started_at: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub status: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub triggering_actor: Option<User1>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub updated_at: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub workflow_id: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub workflow_url: Option<String>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct DeploymentWorkflowRun1HeadRepository {
    #[serde(skip_serializing_if="Option::is_none")]
    pub archive_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub assignees_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub blobs_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub branches_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub collaborators_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub comments_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub commits_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub compare_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub contents_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub contributors_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub deployments_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub description: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub downloads_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub events_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub fork: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub forks_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub full_name: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub git_commits_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub git_refs_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub git_tags_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub hooks_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub html_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub issue_comment_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub issue_events_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub issues_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub keys_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub labels_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub languages_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub merges_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub milestones_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub node_id: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub notifications_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub owner: Option<WebhooksSponsorshipMaintainer>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub private: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub pulls_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub releases_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub stargazers_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub statuses_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub subscribers_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub subscription_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub tags_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub teams_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub trees_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub url: Option<String>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct DeploymentWorkflowRun2 {
    #[serde(skip_serializing_if="Option::is_none")]
    pub actor: Option<User1>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub artifacts_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub cancel_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub check_suite_id: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub check_suite_node_id: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub check_suite_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub conclusion: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub event: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub head_branch: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub head_commit: Option<HashMap<String, Value>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub head_repository: Option<DeploymentWorkflowRun1HeadRepository>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub head_sha: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub html_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub jobs_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub logs_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub node_id: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub path: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub previous_attempt_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub pull_requests: Option<Vec<CheckRunPullRequest>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub referenced_workflows: Option<Vec<DeploymentWorkflowRunReferencedWorkflows>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub repository: Option<DeploymentWorkflowRun1HeadRepository>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub rerun_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub run_attempt: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub run_number: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub run_started_at: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub status: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub triggering_actor: Option<User1>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub updated_at: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub workflow_id: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub workflow_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub display_title: Option<String>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct DeploymentWorkflowRun3 {
    #[serde(skip_serializing_if="Option::is_none")]
    pub actor: Option<User1>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub artifacts_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub cancel_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub check_suite_id: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub check_suite_node_id: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub check_suite_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub conclusion: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub event: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub head_branch: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub head_commit: Option<HashMap<String, Value>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub head_repository: Option<DeploymentWorkflowRun1HeadRepository>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub head_sha: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub html_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub jobs_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub logs_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub node_id: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub path: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub previous_attempt_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub pull_requests: Option<Vec<CheckRunPullRequest>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub referenced_workflows: Option<Vec<DeploymentWorkflowRunReferencedWorkflows>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub repository: Option<DeploymentWorkflowRun1HeadRepository>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub rerun_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub run_attempt: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub run_number: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub run_started_at: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub status: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub triggering_actor: Option<User1>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub updated_at: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub workflow_id: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub workflow_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub display_title: Option<String>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct DeploymentWorkflowRun4 {
    #[serde(skip_serializing_if="Option::is_none")]
    pub actor: Option<User1>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub artifacts_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub cancel_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub check_suite_id: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub check_suite_node_id: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub check_suite_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub conclusion: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub display_title: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub event: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub head_branch: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub head_commit: Option<Value>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub head_repository: Option<DeploymentWorkflowRunHeadRepository>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub head_sha: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub html_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub jobs_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub logs_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub node_id: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub path: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub previous_attempt_url: Option<Value>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub pull_requests: Option<Vec<CheckRunPullRequest>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub referenced_workflows: Option<Vec<DeploymentWorkflowRunReferencedWorkflows>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub repository: Option<DeploymentWorkflowRunHeadRepository>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub rerun_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub run_attempt: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub run_number: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub run_started_at: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub status: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub triggering_actor: Option<User1>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub updated_at: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub workflow_id: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub workflow_url: Option<String>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct DeploymentWorkflowRunHeadRepository {
    #[serde(skip_serializing_if="Option::is_none")]
    pub archive_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub assignees_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub blobs_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub branches_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub collaborators_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub comments_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub commits_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub compare_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub contents_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub contributors_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub deployments_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub description: Option<Value>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub downloads_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub events_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub fork: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub forks_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub full_name: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub git_commits_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub git_refs_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub git_tags_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub hooks_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub html_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub issue_comment_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub issue_events_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub issues_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub keys_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub labels_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub languages_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub merges_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub milestones_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub node_id: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub notifications_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub owner: Option<DeploymentWorkflowRunHeadRepositoryOwner>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub private: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub pulls_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub releases_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub stargazers_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub statuses_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub subscribers_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub subscription_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub tags_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub teams_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub trees_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub url: Option<String>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct DeploymentWorkflowRunHeadRepositoryOwner {
    #[serde(skip_serializing_if="Option::is_none")]
    pub avatar_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub events_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub followers_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub following_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub gists_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub gravatar_id: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub html_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub login: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub node_id: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub organizations_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub received_events_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub repos_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub site_admin: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub starred_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub subscriptions_url: Option<String>,
    #[serde(rename = "type")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub _type: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub url: Option<String>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct DeploymentWorkflowRunReferencedWorkflows {
    #[serde(skip_serializing_if="Option::is_none")]
    pub path: Option<String>,
    #[serde(rename = "ref")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub git_ref: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub sha: Option<String>,
}

/// Diff Entry
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct DiffEntry {
    #[serde(skip_serializing_if="Option::is_none")]
    pub sha: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub filename: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub status: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub additions: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub deletions: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub changes: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub blob_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub raw_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub contents_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub patch: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub previous_filename: Option<String>,
}

/// A Discussion in a repository.
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct Discussion {
    #[serde(skip_serializing_if="Option::is_none")]
    pub active_lock_reason: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub answer_chosen_at: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub answer_chosen_by: Option<User1>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub answer_html_url: Option<String>,
    /// How the author is associated with the repository.
    #[serde(skip_serializing_if="Option::is_none")]
    pub author_association: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub body: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub category: Option<DiscussionCategory>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub comments: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub html_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub locked: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub node_id: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub number: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub reactions: Option<Reactions>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub repository_url: Option<String>,
    /// The current state of the discussion. `converting` means that the discussion is being converted from an issue. `transferring` means that the discussion is being transferred from another repository.
    #[serde(skip_serializing_if="Option::is_none")]
    pub state: Option<String>,
    /// The reason for the current state
    #[serde(skip_serializing_if="Option::is_none")]
    pub state_reason: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub timeline_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub title: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub updated_at: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub user: Option<User>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub labels: Option<Vec<Label>>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct DiscussionCategory {
    #[serde(skip_serializing_if="Option::is_none")]
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub description: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub emoji: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub is_answerable: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub node_id: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub repository_id: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub slug: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub updated_at: Option<String>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct DockerMetadata {
    #[serde(skip_serializing_if="Option::is_none")]
    pub tag: Option<Vec<String>>,
}

/// Email
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct Email {
    #[serde(skip_serializing_if="Option::is_none")]
    pub email: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub primary: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub verified: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub visibility: Option<String>,
}

/// An object without any properties.
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct EmptyObject {
}

/// The policy that controls the repositories in the organization that are allowed to run GitHub Actions.
/// Enumeration of values.
/// Since this enum's variants do not hold data, we can easily define them them as `#[repr(C)]`
/// which helps with FFI.
#[allow(non_camel_case_types)]
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq, PartialOrd, Serialize, Deserialize, Eq, Ord)]
pub enum EnabledRepositories { 
    #[serde(rename = "all")]
    ALL,
    #[serde(rename = "none")]
    NONE,
    #[serde(rename = "selected")]
    SELECTED,
}

impl Display for EnabledRepositories {
    fn fmt(&self, f: &mut Formatter) -> fmt::Result {
        match *self { 
            EnabledRepositories::ALL => write!(f, "{}", "all"),
            EnabledRepositories::NONE => write!(f, "{}", "none"),
            EnabledRepositories::SELECTED => write!(f, "{}", "selected"),
        }
    }
}

impl std::str::FromStr for EnabledRepositories {
    type Err = ();
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s {
            "all" => Ok(EnabledRepositories::ALL),
            "none" => Ok(EnabledRepositories::NONE),
            "selected" => Ok(EnabledRepositories::SELECTED),
            _ => Err(()),
        }
    }
}

/// An enterprise on GitHub.
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct Enterprise {
    /// A short description of the enterprise.
    #[serde(skip_serializing_if="Option::is_none")]
    pub description: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub html_url: Option<String>,
    /// The enterprise's website URL.
    #[serde(skip_serializing_if="Option::is_none")]
    pub website_url: Option<String>,
    /// Unique identifier of the enterprise
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub node_id: Option<String>,
    /// The name of the enterprise.
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,
    /// The slug url identifier for the enterprise.
    #[serde(skip_serializing_if="Option::is_none")]
    pub slug: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub updated_at: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub avatar_url: Option<String>,
}

/// Group of enterprise owners and/or members
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct EnterpriseTeam {
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub slug: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub sync_to_organizations: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub group_id: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub group_name: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub html_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub members_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub updated_at: Option<chrono::DateTime<chrono::Utc>>,
}

/// An enterprise on GitHub. Webhook payloads contain the `enterprise` property when the webhook is configured on an enterprise account or an organization that's part of an enterprise account. For more information, see \"[About enterprise accounts](https://docs.github.com/admin/overview/about-enterprise-accounts).\"
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct EnterpriseWebhooks {
    /// A short description of the enterprise.
    #[serde(skip_serializing_if="Option::is_none")]
    pub description: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub html_url: Option<String>,
    /// The enterprise's website URL.
    #[serde(skip_serializing_if="Option::is_none")]
    pub website_url: Option<String>,
    /// Unique identifier of the enterprise
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub node_id: Option<String>,
    /// The name of the enterprise.
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,
    /// The slug url identifier for the enterprise.
    #[serde(skip_serializing_if="Option::is_none")]
    pub slug: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub updated_at: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub avatar_url: Option<String>,
}

/// Feature options for Automatic dependency submission
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct EnterprisesenterprisecodesecurityconfigurationsDependencyGraphAutosubmitActionOptions {
    /// Whether to use runners labeled with 'dependency-submission' or standard GitHub runners.
    #[serde(skip_serializing_if="Option::is_none")]
    pub labeled_runners: Option<bool>,
}

/// Feature options for Automatic dependency submission
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct EnterprisesenterprisecodesecurityconfigurationsconfigurationIdDependencyGraphAutosubmitActionOptions {
    /// Whether to use runners labeled with 'dependency-submission' or standard GitHub runners.
    #[serde(skip_serializing_if="Option::is_none")]
    pub labeled_runners: Option<bool>,
}

/// Details of a deployment environment
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct Environment {
    /// The id of the environment.
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub node_id: Option<String>,
    /// The name of the environment.
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub html_url: Option<String>,
    /// The time that the environment was created, in ISO 8601 format.
    #[serde(skip_serializing_if="Option::is_none")]
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The time that the environment was last updated, in ISO 8601 format.
    #[serde(skip_serializing_if="Option::is_none")]
    pub updated_at: Option<chrono::DateTime<chrono::Utc>>,
    /// Built-in deployment protection rules for the environment.
    #[serde(skip_serializing_if="Option::is_none")]
    pub protection_rules: Option<Vec<AnyOfenvironmentProtectionRulesItems>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub deployment_branch_policy: Option<DeploymentBranchPolicySettings>,
}

/// An entry in the reviews log for environment deployments
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct EnvironmentApprovals {
    /// The list of environments that were approved or rejected
    #[serde(skip_serializing_if="Option::is_none")]
    pub environments: Option<Vec<EnvironmentapprovalsEnvironments>>,
    /// Whether deployment to the environment(s) was approved or rejected or pending (with comments)
    #[serde(skip_serializing_if="Option::is_none")]
    pub state: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub user: Option<SimpleUser>,
    /// The comment submitted with the deployment review
    #[serde(skip_serializing_if="Option::is_none")]
    pub comment: Option<String>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct EnvironmentapprovalsEnvironments {
    /// The id of the environment.
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub node_id: Option<String>,
    /// The name of the environment.
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub html_url: Option<String>,
    /// The time that the environment was created, in ISO 8601 format.
    #[serde(skip_serializing_if="Option::is_none")]
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The time that the environment was last updated, in ISO 8601 format.
    #[serde(skip_serializing_if="Option::is_none")]
    pub updated_at: Option<chrono::DateTime<chrono::Utc>>,
}

/// Event
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct Event {
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<String>,
    #[serde(rename = "type")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub _type: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub actor: Option<Actor>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub repo: Option<EventRepo>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub org: Option<Actor>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub payload: Option<EventPayload>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub public: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct EventPayload {
    #[serde(skip_serializing_if="Option::is_none")]
    pub action: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub issue: Option<Issue>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub comment: Option<IssueComment>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub pages: Option<Vec<EventPayloadPages>>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct EventPayloadPages {
    #[serde(skip_serializing_if="Option::is_none")]
    pub page_name: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub title: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub summary: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub action: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub sha: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub html_url: Option<String>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct EventRepo {
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub url: Option<String>,
}

/// Feed
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct Feed {
    #[serde(skip_serializing_if="Option::is_none")]
    pub timeline_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub user_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub current_user_public_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub current_user_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub current_user_actor_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub current_user_organization_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub current_user_organization_urls: Option<Vec<String>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub security_advisories_url: Option<String>,
    /// A feed of discussions for a given repository.
    #[serde(skip_serializing_if="Option::is_none")]
    pub repository_discussions_url: Option<String>,
    /// A feed of discussions for a given repository and category.
    #[serde(skip_serializing_if="Option::is_none")]
    pub repository_discussions_category_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub _links: Option<FeedLinks>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct FeedLinks {
    #[serde(skip_serializing_if="Option::is_none")]
    pub timeline: Option<LinkWithType>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub user: Option<LinkWithType>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub security_advisories: Option<LinkWithType>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub current_user: Option<LinkWithType>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub current_user_public: Option<LinkWithType>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub current_user_actor: Option<LinkWithType>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub current_user_organization: Option<LinkWithType>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub current_user_organizations: Option<Vec<LinkWithType>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub repository_discussions: Option<LinkWithType>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub repository_discussions_category: Option<LinkWithType>,
}

/// File Commit
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct FileCommit {
    #[serde(skip_serializing_if="Option::is_none")]
    pub content: Option<FilecommitContent>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub commit: Option<FilecommitCommit>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct FilecommitCommit {
    #[serde(skip_serializing_if="Option::is_none")]
    pub sha: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub node_id: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub html_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub author: Option<FilecommitCommitAuthor>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub committer: Option<FilecommitCommitAuthor>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub message: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub tree: Option<FilecommitCommitTree>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub parents: Option<Vec<FilecommitCommitParents>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub verification: Option<FilecommitCommitVerification>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct FilecommitCommitAuthor {
    #[serde(skip_serializing_if="Option::is_none")]
    pub date: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub email: Option<String>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct FilecommitCommitParents {
    #[serde(skip_serializing_if="Option::is_none")]
    pub url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub html_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub sha: Option<String>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct FilecommitCommitTree {
    #[serde(skip_serializing_if="Option::is_none")]
    pub url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub sha: Option<String>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct FilecommitCommitVerification {
    #[serde(skip_serializing_if="Option::is_none")]
    pub verified: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub reason: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub signature: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub payload: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub verified_at: Option<String>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct FilecommitContent {
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub path: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub sha: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub size: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub html_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub git_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub download_url: Option<String>,
    #[serde(rename = "type")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub _type: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub _links: Option<FilecommitContentLinks>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct FilecommitContentLinks {
    #[serde(rename = "self")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub _self: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub git: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub html: Option<String>,
}

/// Full Repository
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct FullRepository {
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub node_id: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub full_name: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub owner: Option<SimpleUser>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub private: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub html_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub description: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub fork: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub archive_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub assignees_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub blobs_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub branches_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub collaborators_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub comments_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub commits_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub compare_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub contents_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub contributors_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub deployments_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub downloads_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub events_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub forks_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub git_commits_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub git_refs_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub git_tags_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub git_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub issue_comment_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub issue_events_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub issues_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub keys_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub labels_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub languages_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub merges_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub milestones_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub notifications_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub pulls_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub releases_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub ssh_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub stargazers_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub statuses_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub subscribers_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub subscription_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub tags_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub teams_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub trees_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub clone_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub mirror_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub hooks_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub svn_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub homepage: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub language: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub forks_count: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub stargazers_count: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub watchers_count: Option<i64>,
    /// The size of the repository, in kilobytes. Size is calculated hourly. When a repository is initially created, the size is 0.
    #[serde(skip_serializing_if="Option::is_none")]
    pub size: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub default_branch: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub open_issues_count: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub is_template: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub topics: Option<Vec<String>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub has_issues: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub has_projects: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub has_wiki: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub has_pages: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub has_downloads: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub has_discussions: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub archived: Option<bool>,
    /// Returns whether or not this repository disabled.
    #[serde(skip_serializing_if="Option::is_none")]
    pub disabled: Option<bool>,
    /// The repository visibility: public, private, or internal.
    #[serde(skip_serializing_if="Option::is_none")]
    pub visibility: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub pushed_at: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub updated_at: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub permissions: Option<FullrepositoryPermissions>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub allow_rebase_merge: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub template_repository: Option<NullableRepository>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub temp_clone_token: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub allow_squash_merge: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub allow_auto_merge: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub delete_branch_on_merge: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub allow_merge_commit: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub allow_update_branch: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub use_squash_pr_title_as_default: Option<bool>,
    /// The default value for a squash merge commit title:  - `PR_TITLE` - default to the pull request's title. - `COMMIT_OR_PR_TITLE` - default to the commit's title (if only one commit) or the pull request's title (when more than one commit).
    #[serde(skip_serializing_if="Option::is_none")]
    pub squash_merge_commit_title: Option<String>,
    /// The default value for a squash merge commit message:  - `PR_BODY` - default to the pull request's body. - `COMMIT_MESSAGES` - default to the branch's commit messages. - `BLANK` - default to a blank commit message.
    #[serde(skip_serializing_if="Option::is_none")]
    pub squash_merge_commit_message: Option<String>,
    /// The default value for a merge commit title.    - `PR_TITLE` - default to the pull request's title.   - `MERGE_MESSAGE` - default to the classic title for a merge message (e.g., Merge pull request #123 from branch-name).
    #[serde(skip_serializing_if="Option::is_none")]
    pub merge_commit_title: Option<String>,
    /// The default value for a merge commit message.  - `PR_TITLE` - default to the pull request's title. - `PR_BODY` - default to the pull request's body. - `BLANK` - default to a blank commit message.
    #[serde(skip_serializing_if="Option::is_none")]
    pub merge_commit_message: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub allow_forking: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub web_commit_signoff_required: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub subscribers_count: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub network_count: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub license: Option<NullableLicenseSimple>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub organization: Option<NullableSimpleUser>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub parent: Option<Repository>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub source: Option<Repository>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub forks: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub master_branch: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub open_issues: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub watchers: Option<i64>,
    /// Whether anonymous git access is allowed.
    #[serde(skip_serializing_if="Option::is_none")]
    pub anonymous_access_enabled: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub code_of_conduct: Option<CodeOfConductSimple>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub security_and_analysis: Option<SecurityAndAnalysis>,
    /// The custom properties that were defined for the repository. The keys are the custom property names, and the values are the corresponding custom property values.
    #[serde(skip_serializing_if="Option::is_none")]
    pub custom_properties: Option<HashMap<String, HashMap<String, Value>>>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct FullrepositoryPermissions {
    #[serde(skip_serializing_if="Option::is_none")]
    pub admin: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub maintain: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub push: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub triage: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub pull: Option<bool>,
}

/// Gist
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct Gist {
    #[serde(skip_serializing_if="Option::is_none")]
    pub url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub forks_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub commits_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub node_id: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub git_pull_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub git_push_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub html_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub files: Option<HashMap<String, GistFiles>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub public: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub updated_at: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub description: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub comments: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub comments_enabled: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub user: Option<NullableSimpleUser>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub comments_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub owner: Option<NullableSimpleUser>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub truncated: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub forks: Option<Vec<Value>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub history: Option<Vec<Value>>,
}

/// A comment made to a gist.
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct GistComment {
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub node_id: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub url: Option<String>,
    /// The comment text.
    #[serde(skip_serializing_if="Option::is_none")]
    pub body: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub user: Option<NullableSimpleUser>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub updated_at: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub author_association: Option<AuthorAssociation>,
}

/// Gist Commit
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct GistCommit {
    #[serde(skip_serializing_if="Option::is_none")]
    pub url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub version: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub user: Option<NullableSimpleUser>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub change_status: Option<GisthistoryChangeStatus>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub committed_at: Option<chrono::DateTime<chrono::Utc>>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct GistFiles {
    #[serde(skip_serializing_if="Option::is_none")]
    pub filename: Option<String>,
    #[serde(rename = "type")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub _type: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub language: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub raw_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub size: Option<i64>,
}

/// Gist History
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct GistHistory {
    #[serde(skip_serializing_if="Option::is_none")]
    pub user: Option<NullableSimpleUser>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub version: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub committed_at: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub change_status: Option<GisthistoryChangeStatus>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub url: Option<String>,
}

/// Gist Simple
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct GistSimple {
    #[serde(skip_serializing_if="Option::is_none")]
    pub forks: Option<Vec<GistsimpleForks>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub history: Option<Vec<GistHistory>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub fork_of: Option<Gist>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub forks_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub commits_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub node_id: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub git_pull_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub git_push_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub html_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub files: Option<HashMap<String, GistsimpleFiles>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub public: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub created_at: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub updated_at: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub description: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub comments: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub comments_enabled: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub user: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub comments_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub owner: Option<SimpleUser>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub truncated: Option<bool>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct GisthistoryChangeStatus {
    #[serde(skip_serializing_if="Option::is_none")]
    pub total: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub additions: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub deletions: Option<i64>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct GistsFiles {
    /// Content of the file
    #[serde(skip_serializing_if="Option::is_none")]
    pub content: Option<String>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct GistsgistIdFiles {
    /// The new content of the file.
    #[serde(skip_serializing_if="Option::is_none")]
    pub content: Option<String>,
    /// The new filename for the file.
    #[serde(skip_serializing_if="Option::is_none")]
    pub filename: Option<String>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct GistsimpleFiles {
    #[serde(skip_serializing_if="Option::is_none")]
    pub filename: Option<String>,
    #[serde(rename = "type")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub _type: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub language: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub raw_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub size: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub truncated: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub content: Option<String>,
    /// The encoding used for `content`. Currently, `\"utf-8\"` and `\"base64\"` are supported.
    #[serde(skip_serializing_if="Option::is_none")]
    pub encoding: Option<String>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct GistsimpleForks {
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub user: Option<PublicUser>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub updated_at: Option<chrono::DateTime<chrono::Utc>>,
}

/// Low-level Git commit operations within a repository
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct GitCommit {
    /// SHA for the commit
    #[serde(skip_serializing_if="Option::is_none")]
    pub sha: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub node_id: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub author: Option<GitcommitAuthor>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub committer: Option<GitcommitAuthor>,
    /// Message describing the purpose of the commit
    #[serde(skip_serializing_if="Option::is_none")]
    pub message: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub tree: Option<GitcommitTree>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub parents: Option<Vec<GitcommitParents>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub verification: Option<GitcommitVerification>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub html_url: Option<String>,
}

/// Git references within a repository
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct GitRef {
    #[serde(rename = "ref")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub git_ref: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub node_id: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub object: Option<GitrefObject>,
}

/// Metadata for a Git tag
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct GitTag {
    #[serde(skip_serializing_if="Option::is_none")]
    pub node_id: Option<String>,
    /// Name of the tag
    #[serde(skip_serializing_if="Option::is_none")]
    pub tag: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub sha: Option<String>,
    /// URL for the tag
    #[serde(skip_serializing_if="Option::is_none")]
    pub url: Option<String>,
    /// Message describing the purpose of the tag
    #[serde(skip_serializing_if="Option::is_none")]
    pub message: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub tagger: Option<GittagTagger>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub object: Option<GittagObject>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub verification: Option<Verification>,
}

/// The hierarchy between files in a Git repository.
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct GitTree {
    #[serde(skip_serializing_if="Option::is_none")]
    pub sha: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub truncated: Option<bool>,
    /// Objects specifying a tree structure
    #[serde(skip_serializing_if="Option::is_none")]
    pub tree: Option<Vec<GittreeTree>>,
}

/// Identifying information for the git-user
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct GitcommitAuthor {
    /// Timestamp of the commit
    #[serde(skip_serializing_if="Option::is_none")]
    pub date: Option<chrono::DateTime<chrono::Utc>>,
    /// Git email address of the user
    #[serde(skip_serializing_if="Option::is_none")]
    pub email: Option<String>,
    /// Name of the git user
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct GitcommitParents {
    /// SHA for the commit
    #[serde(skip_serializing_if="Option::is_none")]
    pub sha: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub html_url: Option<String>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct GitcommitTree {
    /// SHA for the commit
    #[serde(skip_serializing_if="Option::is_none")]
    pub sha: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub url: Option<String>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct GitcommitVerification {
    #[serde(skip_serializing_if="Option::is_none")]
    pub verified: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub reason: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub signature: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub payload: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub verified_at: Option<String>,
}

/// Gitignore Template
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct GitignoreTemplate {
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub source: Option<String>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct GitrefObject {
    #[serde(rename = "type")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub _type: Option<String>,
    /// SHA for the reference
    #[serde(skip_serializing_if="Option::is_none")]
    pub sha: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub url: Option<String>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct GittagObject {
    #[serde(skip_serializing_if="Option::is_none")]
    pub sha: Option<String>,
    #[serde(rename = "type")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub _type: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub url: Option<String>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct GittagTagger {
    #[serde(skip_serializing_if="Option::is_none")]
    pub date: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub email: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct GittreeTree {
    #[serde(skip_serializing_if="Option::is_none")]
    pub path: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub mode: Option<String>,
    #[serde(rename = "type")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub _type: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub sha: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub size: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub url: Option<String>,
}

/// A GitHub Security Advisory.
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct GlobalAdvisory {
    /// The GitHub Security Advisory ID.
    #[serde(skip_serializing_if="Option::is_none")]
    pub ghsa_id: Option<String>,
    /// The Common Vulnerabilities and Exposures (CVE) ID.
    #[serde(skip_serializing_if="Option::is_none")]
    pub cve_id: Option<String>,
    /// The API URL for the advisory.
    #[serde(skip_serializing_if="Option::is_none")]
    pub url: Option<String>,
    /// The URL for the advisory.
    #[serde(skip_serializing_if="Option::is_none")]
    pub html_url: Option<String>,
    /// The API URL for the repository advisory.
    #[serde(skip_serializing_if="Option::is_none")]
    pub repository_advisory_url: Option<String>,
    /// A short summary of the advisory.
    #[serde(skip_serializing_if="Option::is_none")]
    pub summary: Option<String>,
    /// A detailed description of what the advisory entails.
    #[serde(skip_serializing_if="Option::is_none")]
    pub description: Option<String>,
    /// The type of advisory.
    #[serde(rename = "type")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub _type: Option<String>,
    /// The severity of the advisory.
    #[serde(skip_serializing_if="Option::is_none")]
    pub severity: Option<String>,
    /// The URL of the advisory's source code.
    #[serde(skip_serializing_if="Option::is_none")]
    pub source_code_location: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub identifiers: Option<Vec<GlobaladvisoryIdentifiers>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub references: Option<Vec<String>>,
    /// The date and time of when the advisory was published, in ISO 8601 format.
    #[serde(skip_serializing_if="Option::is_none")]
    pub published_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The date and time of when the advisory was last updated, in ISO 8601 format.
    #[serde(skip_serializing_if="Option::is_none")]
    pub updated_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The date and time of when the advisory was reviewed by GitHub, in ISO 8601 format.
    #[serde(skip_serializing_if="Option::is_none")]
    pub github_reviewed_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The date and time when the advisory was published in the National Vulnerability Database, in ISO 8601 format. This field is only populated when the advisory is imported from the National Vulnerability Database.
    #[serde(skip_serializing_if="Option::is_none")]
    pub nvd_published_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The date and time of when the advisory was withdrawn, in ISO 8601 format.
    #[serde(skip_serializing_if="Option::is_none")]
    pub withdrawn_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The products and respective version ranges affected by the advisory.
    #[serde(skip_serializing_if="Option::is_none")]
    pub vulnerabilities: Option<Vec<Vulnerability>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub cvss: Option<GlobaladvisoryCvss>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub cvss_severities: Option<CvssSeverities>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub epss: Option<SecurityAdvisoryEpss>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub cwes: Option<Vec<GlobaladvisoryCwes>>,
    /// The users who contributed to the advisory.
    #[serde(skip_serializing_if="Option::is_none")]
    pub credits: Option<Vec<GlobaladvisoryCredits>>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct GlobaladvisoryCredits {
    #[serde(skip_serializing_if="Option::is_none")]
    pub user: Option<SimpleUser>,
    #[serde(rename = "type")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub _type: Option<SecurityAdvisoryCreditTypes>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct GlobaladvisoryCvss {
    /// The CVSS vector.
    #[serde(skip_serializing_if="Option::is_none")]
    pub vector_string: Option<String>,
    /// The CVSS score.
    #[serde(skip_serializing_if="Option::is_none")]
    pub score: Option<f64>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct GlobaladvisoryCwes {
    /// The Common Weakness Enumeration (CWE) identifier.
    #[serde(skip_serializing_if="Option::is_none")]
    pub cwe_id: Option<String>,
    /// The name of the CWE.
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct GlobaladvisoryIdentifiers {
    /// The type of identifier.
    #[serde(rename = "type")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub _type: Option<String>,
    /// The identifier value.
    #[serde(skip_serializing_if="Option::is_none")]
    pub value: Option<String>,
}

/// A unique encryption key
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct GpgKey {
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub primary_key_id: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub key_id: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub public_key: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub emails: Option<Vec<GpgkeyEmails>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub subkeys: Option<Vec<GpgkeySubkeys>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub can_sign: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub can_encrypt_comms: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub can_encrypt_storage: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub can_certify: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub expires_at: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub revoked: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub raw_key: Option<String>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct GpgkeyEmails {
    #[serde(skip_serializing_if="Option::is_none")]
    pub email: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub verified: Option<bool>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct GpgkeySubkeys {
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub primary_key_id: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub key_id: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub public_key: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub emails: Option<Vec<GpgkeyEmails>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub subkeys: Option<Vec<Value>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub can_sign: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub can_encrypt_comms: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub can_encrypt_storage: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub can_certify: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub created_at: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub expires_at: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub raw_key: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub revoked: Option<bool>,
}

/// Webhooks for repositories.
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct Hook {
    #[serde(rename = "type")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub _type: Option<String>,
    /// Unique identifier of the webhook.
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<i64>,
    /// The name of a valid service, use 'web' for a webhook.
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,
    /// Determines whether the hook is actually triggered on pushes.
    #[serde(skip_serializing_if="Option::is_none")]
    pub active: Option<bool>,
    /// Determines what events the hook is triggered for. Default: ['push'].
    #[serde(skip_serializing_if="Option::is_none")]
    pub events: Option<Vec<String>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub config: Option<WebhookConfig>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub updated_at: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub test_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub ping_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub deliveries_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub last_response: Option<HookResponse>,
}

/// Delivery made by a webhook.
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct HookDelivery {
    /// Unique identifier of the delivery.
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<i64>,
    /// Unique identifier for the event (shared with all deliveries for all webhooks that subscribe to this event).
    #[serde(skip_serializing_if="Option::is_none")]
    pub guid: Option<String>,
    /// Time when the delivery was delivered.
    #[serde(skip_serializing_if="Option::is_none")]
    pub delivered_at: Option<chrono::DateTime<chrono::Utc>>,
    /// Whether the delivery is a redelivery.
    #[serde(skip_serializing_if="Option::is_none")]
    pub redelivery: Option<bool>,
    /// Time spent delivering.
    #[serde(skip_serializing_if="Option::is_none")]
    pub duration: Option<f64>,
    /// Description of the status of the attempted delivery
    #[serde(skip_serializing_if="Option::is_none")]
    pub status: Option<String>,
    /// Status code received when delivery was made.
    #[serde(skip_serializing_if="Option::is_none")]
    pub status_code: Option<i64>,
    /// The event that triggered the delivery.
    #[serde(skip_serializing_if="Option::is_none")]
    pub event: Option<String>,
    /// The type of activity for the event that triggered the delivery.
    #[serde(skip_serializing_if="Option::is_none")]
    pub action: Option<String>,
    /// The id of the GitHub App installation associated with this event.
    #[serde(skip_serializing_if="Option::is_none")]
    pub installation_id: Option<i64>,
    /// The id of the repository associated with this event.
    #[serde(skip_serializing_if="Option::is_none")]
    pub repository_id: Option<i64>,
    /// Time when the webhook delivery was throttled.
    #[serde(skip_serializing_if="Option::is_none")]
    pub throttled_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The URL target of the delivery.
    #[serde(skip_serializing_if="Option::is_none")]
    pub url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub request: Option<HookdeliveryRequest>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub response: Option<HookdeliveryResponse>,
}

/// Delivery made by a webhook, without request and response information.
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct HookDeliveryItem {
    /// Unique identifier of the webhook delivery.
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<i64>,
    /// Unique identifier for the event (shared with all deliveries for all webhooks that subscribe to this event).
    #[serde(skip_serializing_if="Option::is_none")]
    pub guid: Option<String>,
    /// Time when the webhook delivery occurred.
    #[serde(skip_serializing_if="Option::is_none")]
    pub delivered_at: Option<chrono::DateTime<chrono::Utc>>,
    /// Whether the webhook delivery is a redelivery.
    #[serde(skip_serializing_if="Option::is_none")]
    pub redelivery: Option<bool>,
    /// Time spent delivering.
    #[serde(skip_serializing_if="Option::is_none")]
    pub duration: Option<f64>,
    /// Describes the response returned after attempting the delivery.
    #[serde(skip_serializing_if="Option::is_none")]
    pub status: Option<String>,
    /// Status code received when delivery was made.
    #[serde(skip_serializing_if="Option::is_none")]
    pub status_code: Option<i64>,
    /// The event that triggered the delivery.
    #[serde(skip_serializing_if="Option::is_none")]
    pub event: Option<String>,
    /// The type of activity for the event that triggered the delivery.
    #[serde(skip_serializing_if="Option::is_none")]
    pub action: Option<String>,
    /// The id of the GitHub App installation associated with this event.
    #[serde(skip_serializing_if="Option::is_none")]
    pub installation_id: Option<i64>,
    /// The id of the repository associated with this event.
    #[serde(skip_serializing_if="Option::is_none")]
    pub repository_id: Option<i64>,
    /// Time when the webhook delivery was throttled.
    #[serde(skip_serializing_if="Option::is_none")]
    pub throttled_at: Option<chrono::DateTime<chrono::Utc>>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct HookResponse {
    #[serde(skip_serializing_if="Option::is_none")]
    pub code: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub status: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub message: Option<String>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct HookdeliveryRequest {
    /// The request headers sent with the webhook delivery.
    #[serde(skip_serializing_if="Option::is_none")]
    pub headers: Option<HashMap<String, HashMap<String, Value>>>,
    /// The webhook payload.
    #[serde(skip_serializing_if="Option::is_none")]
    pub payload: Option<HashMap<String, HashMap<String, Value>>>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct HookdeliveryResponse {
    /// The response headers received when the delivery was made.
    #[serde(skip_serializing_if="Option::is_none")]
    pub headers: Option<HashMap<String, HashMap<String, Value>>>,
    /// The response payload received.
    #[serde(skip_serializing_if="Option::is_none")]
    pub payload: Option<HashMap<String, HashMap<String, Value>>>,
}

/// Hovercard
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct Hovercard {
    #[serde(skip_serializing_if="Option::is_none")]
    pub contexts: Option<Vec<HovercardContexts>>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct HovercardContexts {
    #[serde(skip_serializing_if="Option::is_none")]
    pub message: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub octicon: Option<String>,
}

/// A repository import from an external source.
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct Import {
    #[serde(skip_serializing_if="Option::is_none")]
    pub vcs: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub use_lfs: Option<bool>,
    /// The URL of the originating repository.
    #[serde(skip_serializing_if="Option::is_none")]
    pub vcs_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub svc_root: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub tfvc_project: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub status: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub status_text: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub failed_step: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub error_message: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub import_percent: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub commit_count: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub push_percent: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub has_large_files: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub large_files_size: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub large_files_count: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub project_choices: Option<Vec<ImportProjectChoices>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub message: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub authors_count: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub html_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub authors_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub repository_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub svn_root: Option<String>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct ImportProjectChoices {
    #[serde(skip_serializing_if="Option::is_none")]
    pub vcs: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub tfvc_project: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub human_name: Option<String>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct PutCodeSecuritySetConfigurationAsDefaultResponse200 {
    /// Specifies which types of repository this security configuration is applied to by default.
    #[serde(skip_serializing_if="Option::is_none")]
    pub default_for_new_repos: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub configuration: Option<CodeSecurityConfiguration>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct GetAppsListReposAccessibleToInstallationResponse200 {
    #[serde(skip_serializing_if="Option::is_none")]
    pub total_count: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub repositories: Option<Vec<Repository>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub repository_selection: Option<String>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct GetActionsListRepoAccessToSelfHostedRunnerGroupInOrgResponse200 {
    #[serde(skip_serializing_if="Option::is_none")]
    pub total_count: Option<f64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub repositories: Option<Vec<MinimalRepository>>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct GetActionsListSelfHostedRunnersInGroupForOrgResponse200 {
    #[serde(skip_serializing_if="Option::is_none")]
    pub total_count: Option<f64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub runners: Option<Vec<Runner>>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct GetActionsListSelfHostedRunnersForRepoResponse200 {
    #[serde(skip_serializing_if="Option::is_none")]
    pub total_count: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub runners: Option<Vec<Runner>>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct DeleteActionsRemoveCustomLabelFromSelfHostedRunnerForRepoResponse200 {
    #[serde(skip_serializing_if="Option::is_none")]
    pub total_count: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub labels: Option<Vec<RunnerLabel>>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct GetActionsListOrgSecretsResponse200 {
    #[serde(skip_serializing_if="Option::is_none")]
    pub total_count: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub secrets: Option<Vec<OrganizationActionsSecret>>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct GetCodespacesListRepositoriesForSecretForAuthenticatedUserResponse200 {
    #[serde(skip_serializing_if="Option::is_none")]
    pub total_count: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub repositories: Option<Vec<MinimalRepository>>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct GetActionsListOrgVariablesResponse200 {
    #[serde(skip_serializing_if="Option::is_none")]
    pub total_count: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub variables: Option<Vec<OrganizationActionsVariable>>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct GetReposListAttestationsResponse200 {
    #[serde(skip_serializing_if="Option::is_none")]
    pub attestations: Option<Vec<InlineResponse20017Attestations>>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct InlineResponse20017Attestations {
    #[serde(skip_serializing_if="Option::is_none")]
    pub bundle: Option<ReposownerrepoattestationsBundle>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub repository_id: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub bundle_url: Option<String>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct GetCodespacesListForAuthenticatedUserResponse200 {
    #[serde(skip_serializing_if="Option::is_none")]
    pub total_count: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub codespaces: Option<Vec<Codespace>>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct GetCodespacesListOrgSecretsResponse200 {
    #[serde(skip_serializing_if="Option::is_none")]
    pub total_count: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub secrets: Option<Vec<CodespacesOrgSecret>>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct GetActionsGetActionsCacheUsageByRepoForOrgResponse200 {
    #[serde(skip_serializing_if="Option::is_none")]
    pub total_count: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub repository_cache_usages: Option<Vec<ActionsCacheUsageByRepository>>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct GetCopilotListCopilotSeatsResponse200 {
    /// Total number of Copilot seats for the organization currently being billed.
    #[serde(skip_serializing_if="Option::is_none")]
    pub total_seats: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub seats: Option<Vec<CopilotSeatDetails>>,
}

/// The total number of seats set to \"pending cancellation\" for members of the specified team(s).
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct DeleteCopilotCancelCopilotSeatAssignmentForTeamsResponse200 {
    #[serde(skip_serializing_if="Option::is_none")]
    pub seats_cancelled: Option<i64>,
}

/// The total number of seats set to \"pending cancellation\" for the specified users.
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct DeleteCopilotCancelCopilotSeatAssignmentForUsersResponse200 {
    #[serde(skip_serializing_if="Option::is_none")]
    pub seats_cancelled: Option<i64>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct GetDependabotListOrgSecretsResponse200 {
    #[serde(skip_serializing_if="Option::is_none")]
    pub total_count: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub secrets: Option<Vec<OrganizationDependabotSecret>>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct GetAppsListInstallationsForAuthenticatedUserResponse200 {
    #[serde(skip_serializing_if="Option::is_none")]
    pub total_count: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub installations: Option<Vec<Installation>>,
}

#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetInteractionsGetRestrictionsForAuthenticatedUserResponse200 { 
    GetInteractionsGetRestrictionsForAuthenticatedUserResponse200Variant0(InteractionLimitResponse),
    GetInteractionsGetRestrictionsForAuthenticatedUserResponse200Variant1(HashMap<String, Value>),
}

impl From<InteractionLimitResponse> for GetInteractionsGetRestrictionsForAuthenticatedUserResponse200 {
    fn from(value: InteractionLimitResponse) -> Self {
        GetInteractionsGetRestrictionsForAuthenticatedUserResponse200::GetInteractionsGetRestrictionsForAuthenticatedUserResponse200Variant0(value)
    }
}

impl From<HashMap<String, Value>> for GetInteractionsGetRestrictionsForAuthenticatedUserResponse200 {
    fn from(value: HashMap<String, Value>) -> Self {
        GetInteractionsGetRestrictionsForAuthenticatedUserResponse200::GetInteractionsGetRestrictionsForAuthenticatedUserResponse200Variant1(value)
    }
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct GetOrgsListOrgRolesResponse200 {
    /// The total number of organization roles available to the organization.
    #[serde(skip_serializing_if="Option::is_none")]
    pub total_count: Option<i64>,
    /// The list of organization roles available to the organization.
    #[serde(skip_serializing_if="Option::is_none")]
    pub roles: Option<Vec<OrganizationRole>>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct GetPrivateRegistriesListOrgPrivateRegistriesResponse200 {
    #[serde(skip_serializing_if="Option::is_none")]
    pub total_count: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub configurations: Option<Vec<OrgPrivateRegistryConfiguration>>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct GetPrivateRegistriesGetOrgPublicKeyResponse200 {
    /// The identifier for the key.
    #[serde(skip_serializing_if="Option::is_none")]
    pub key_id: Option<String>,
    /// The Base64 encoded public key.
    #[serde(skip_serializing_if="Option::is_none")]
    pub key: Option<String>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct GetHostedComputeListNetworkConfigurationsForOrgResponse200 {
    #[serde(skip_serializing_if="Option::is_none")]
    pub total_count: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub network_configurations: Option<Vec<NetworkConfiguration>>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct GetActionsListHostedRunnersForOrgResponse200 {
    #[serde(skip_serializing_if="Option::is_none")]
    pub total_count: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub runners: Option<Vec<ActionsHostedRunner>>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct GetActionsListWorkflowRunArtifactsResponse200 {
    #[serde(skip_serializing_if="Option::is_none")]
    pub total_count: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub artifacts: Option<Vec<Artifact>>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct GetActionsListEnvironmentSecretsResponse200 {
    #[serde(skip_serializing_if="Option::is_none")]
    pub total_count: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub secrets: Option<Vec<ActionsSecret>>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct GetActionsListEnvironmentVariablesResponse200 {
    #[serde(skip_serializing_if="Option::is_none")]
    pub total_count: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub variables: Option<Vec<ActionsVariable>>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct GetActionsListWorkflowRunsResponse200 {
    #[serde(skip_serializing_if="Option::is_none")]
    pub total_count: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub workflow_runs: Option<Vec<WorkflowRun>>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct GetActionsListJobsForWorkflowRunResponse200 {
    #[serde(skip_serializing_if="Option::is_none")]
    pub total_count: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub jobs: Option<Vec<Job>>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct GetActionsListRepoWorkflowsResponse200 {
    #[serde(skip_serializing_if="Option::is_none")]
    pub total_count: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub workflows: Option<Vec<Workflow>>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct GetChecksListForRefResponse200 {
    #[serde(skip_serializing_if="Option::is_none")]
    pub total_count: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub check_runs: Option<Vec<CheckRun>>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct GetCodespacesListDevcontainersInRepositoryForAuthenticatedUserResponse200 {
    #[serde(skip_serializing_if="Option::is_none")]
    pub total_count: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub devcontainers: Option<Vec<InlineResponse20037Devcontainers>>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct InlineResponse20037Devcontainers {
    #[serde(skip_serializing_if="Option::is_none")]
    pub path: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub display_name: Option<String>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct GetCodespacesCodespaceMachinesForAuthenticatedUserResponse200 {
    #[serde(skip_serializing_if="Option::is_none")]
    pub total_count: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub machines: Option<Vec<CodespaceMachine>>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct GetCodespacesPreFlightWithRepoForAuthenticatedUserResponse200 {
    #[serde(skip_serializing_if="Option::is_none")]
    pub billable_owner: Option<SimpleUser>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub defaults: Option<InlineResponse20039Defaults>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct InlineResponse20039Defaults {
    #[serde(skip_serializing_if="Option::is_none")]
    pub location: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub devcontainer_path: Option<String>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct GetActionsGetHostedRunnersPartnerImagesForOrgResponse200 {
    #[serde(skip_serializing_if="Option::is_none")]
    pub total_count: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub images: Option<Vec<ActionsHostedRunnerImage>>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct GetCodespacesListRepoSecretsResponse200 {
    #[serde(skip_serializing_if="Option::is_none")]
    pub total_count: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub secrets: Option<Vec<RepoCodespacesSecret>>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct GetChecksListSuitesForRefResponse200 {
    #[serde(skip_serializing_if="Option::is_none")]
    pub total_count: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub check_suites: Option<Vec<CheckSuite>>,
}

#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
#[serde(untagged)]
pub enum InlineResponse20042 { 
    InlineResponse20042Variant0(ContentDirectory),
    InlineResponse20042Variant1(ContentFile),
    InlineResponse20042Variant2(ContentSymlink),
    InlineResponse20042Variant3(ContentSubmodule),
}

impl From<ContentDirectory> for InlineResponse20042 {
    fn from(value: ContentDirectory) -> Self {
        InlineResponse20042::InlineResponse20042Variant0(value)
    }
}

impl From<ContentFile> for InlineResponse20042 {
    fn from(value: ContentFile) -> Self {
        InlineResponse20042::InlineResponse20042Variant1(value)
    }
}

impl From<ContentSymlink> for InlineResponse20042 {
    fn from(value: ContentSymlink) -> Self {
        InlineResponse20042::InlineResponse20042Variant2(value)
    }
}

impl From<ContentSubmodule> for InlineResponse20042 {
    fn from(value: ContentSubmodule) -> Self {
        InlineResponse20042::InlineResponse20042Variant3(value)
    }
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct GetDependabotListRepoSecretsResponse200 {
    #[serde(skip_serializing_if="Option::is_none")]
    pub total_count: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub secrets: Option<Vec<DependabotSecret>>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct GetReposGetAllEnvironmentsResponse200 {
    /// The number of environments in this repository
    #[serde(skip_serializing_if="Option::is_none")]
    pub total_count: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub environments: Option<Vec<Environment>>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct GetReposListDeploymentBranchPoliciesResponse200 {
    /// The number of deployment branch policies for the environment.
    #[serde(skip_serializing_if="Option::is_none")]
    pub total_count: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub branch_policies: Option<Vec<DeploymentBranchPolicy>>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct GetReposGetAllDeploymentProtectionRulesResponse200 {
    /// The number of enabled custom deployment protection rules for this environment
    #[serde(skip_serializing_if="Option::is_none")]
    pub total_count: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub custom_deployment_protection_rules: Option<Vec<DeploymentProtectionRule>>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct GetReposListCustomDeploymentRuleIntegrationsResponse200 {
    /// The total number of custom deployment protection rule integrations available for this environment.
    #[serde(skip_serializing_if="Option::is_none")]
    pub total_count: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub available_custom_deployment_protection_rule_integrations: Option<Vec<CustomDeploymentRuleApp>>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct GetReposCheckPrivateVulnerabilityReportingResponse200 {
    /// Whether or not private vulnerability reporting is enabled for the repository.
    #[serde(skip_serializing_if="Option::is_none")]
    pub enabled: Option<bool>,
}

#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetActivityListStargazersForRepoResponse200 { 
    GetActivityListStargazersForRepoResponse200Variant0(Vec<SimpleUser>),
    GetActivityListStargazersForRepoResponse200Variant1(Vec<Stargazer>),
}

impl From<Vec<SimpleUser>> for GetActivityListStargazersForRepoResponse200 {
    fn from(value: Vec<SimpleUser>) -> Self {
        GetActivityListStargazersForRepoResponse200::GetActivityListStargazersForRepoResponse200Variant0(value)
    }
}

impl From<Vec<Stargazer>> for GetActivityListStargazersForRepoResponse200 {
    fn from(value: Vec<Stargazer>) -> Self {
        GetActivityListStargazersForRepoResponse200::GetActivityListStargazersForRepoResponse200Variant1(value)
    }
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct GetActionsGetHostedRunnersMachineSpecsForOrgResponse200 {
    #[serde(skip_serializing_if="Option::is_none")]
    pub total_count: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub machine_specs: Option<Vec<ActionsHostedRunnerMachineSpec>>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct GetSearchCodeResponse200 {
    #[serde(skip_serializing_if="Option::is_none")]
    pub total_count: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub incomplete_results: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub items: Option<Vec<CodeSearchResultItem>>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct GetSearchCommitsResponse200 {
    #[serde(skip_serializing_if="Option::is_none")]
    pub total_count: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub incomplete_results: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub items: Option<Vec<CommitSearchResultItem>>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct GetSearchIssuesAndPullRequestsResponse200 {
    #[serde(skip_serializing_if="Option::is_none")]
    pub total_count: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub incomplete_results: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub items: Option<Vec<IssueSearchResultItem>>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct GetSearchLabelsResponse200 {
    #[serde(skip_serializing_if="Option::is_none")]
    pub total_count: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub incomplete_results: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub items: Option<Vec<LabelSearchResultItem>>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct GetSearchReposResponse200 {
    #[serde(skip_serializing_if="Option::is_none")]
    pub total_count: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub incomplete_results: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub items: Option<Vec<RepoSearchResultItem>>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct GetSearchTopicsResponse200 {
    #[serde(skip_serializing_if="Option::is_none")]
    pub total_count: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub incomplete_results: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub items: Option<Vec<TopicSearchResultItem>>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct GetSearchUsersResponse200 {
    #[serde(skip_serializing_if="Option::is_none")]
    pub total_count: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub incomplete_results: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub items: Option<Vec<UserSearchResultItem>>,
}

#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetUsersGetByUsernameResponse200 { 
    GetUsersGetByUsernameResponse200Variant0(PrivateUser),
    GetUsersGetByUsernameResponse200Variant1(PublicUser),
}

impl From<PrivateUser> for GetUsersGetByUsernameResponse200 {
    fn from(value: PrivateUser) -> Self {
        GetUsersGetByUsernameResponse200::GetUsersGetByUsernameResponse200Variant0(value)
    }
}

impl From<PublicUser> for GetUsersGetByUsernameResponse200 {
    fn from(value: PublicUser) -> Self {
        GetUsersGetByUsernameResponse200::GetUsersGetByUsernameResponse200Variant1(value)
    }
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct GetCodespacesListSecretsForAuthenticatedUserResponse200 {
    #[serde(skip_serializing_if="Option::is_none")]
    pub total_count: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub secrets: Option<Vec<CodespacesSecret>>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct GetAppsListInstallationReposForAuthenticatedUserResponse200 {
    #[serde(skip_serializing_if="Option::is_none")]
    pub total_count: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub repository_selection: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub repositories: Option<Vec<Repository>>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct GetActionsGetHostedRunnersPlatformsForOrgResponse200 {
    #[serde(skip_serializing_if="Option::is_none")]
    pub total_count: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub platforms: Option<Vec<String>>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct GetUsersListAttestationsResponse200 {
    #[serde(skip_serializing_if="Option::is_none")]
    pub attestations: Option<Vec<InlineResponse20060Attestations>>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct InlineResponse20060Attestations {
    #[serde(skip_serializing_if="Option::is_none")]
    pub bundle: Option<SigstoreBundle0>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub repository_id: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub bundle_url: Option<String>,
}

#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetActivityListReposStarredByUserResponse200 { 
    GetActivityListReposStarredByUserResponse200Variant0(Vec<StarredRepository>),
    GetActivityListReposStarredByUserResponse200Variant1(Vec<Repository>),
}

impl From<Vec<StarredRepository>> for GetActivityListReposStarredByUserResponse200 {
    fn from(value: Vec<StarredRepository>) -> Self {
        GetActivityListReposStarredByUserResponse200::GetActivityListReposStarredByUserResponse200Variant0(value)
    }
}

impl From<Vec<Repository>> for GetActivityListReposStarredByUserResponse200 {
    fn from(value: Vec<Repository>) -> Self {
        GetActivityListReposStarredByUserResponse200::GetActivityListReposStarredByUserResponse200Variant1(value)
    }
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct GetActionsListSelectedRepositoriesEnabledGithubActionsOrganizationResponse200 {
    #[serde(skip_serializing_if="Option::is_none")]
    pub total_count: Option<f64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub repositories: Option<Vec<Repository>>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct GetActionsListSelfHostedRunnerGroupsForOrgResponse200 {
    #[serde(skip_serializing_if="Option::is_none")]
    pub total_count: Option<f64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub runner_groups: Option<Vec<RunnerGroupsOrg>>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct GetActionsListGithubHostedRunnersInGroupForOrgResponse200 {
    #[serde(skip_serializing_if="Option::is_none")]
    pub total_count: Option<f64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub runners: Option<Vec<ActionsHostedRunner>>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct PostAppsCreateFromManifestResponse201 {
    /// Unique identifier of the GitHub app
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<i64>,
    /// The slug name of the GitHub app
    #[serde(skip_serializing_if="Option::is_none")]
    pub slug: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub node_id: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub client_id: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub owner: Option<Value>,
    /// The name of the GitHub app
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub description: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub external_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub html_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub updated_at: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub permissions: Option<IntegrationPermissions>,
    /// The list of events for the GitHub app
    #[serde(skip_serializing_if="Option::is_none")]
    pub events: Option<Vec<String>>,
    /// The number of installations associated with the GitHub app
    #[serde(skip_serializing_if="Option::is_none")]
    pub installations_count: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub client_secret: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub webhook_secret: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub pem: Option<String>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct PostActionsGenerateRunnerJitconfigForRepoResponse201 {
    #[serde(skip_serializing_if="Option::is_none")]
    pub runner: Option<Runner>,
    /// The base64 encoded runner configuration.
    #[serde(skip_serializing_if="Option::is_none")]
    pub encoded_jit_config: Option<String>,
}

/// The total number of seats created for members of the specified team(s).
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct PostCopilotAddCopilotSeatsForTeamsResponse201 {
    #[serde(skip_serializing_if="Option::is_none")]
    pub seats_created: Option<i64>,
}

/// The total number of seats created for the specified user(s).
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct PostCopilotAddCopilotSeatsForUsersResponse201 {
    #[serde(skip_serializing_if="Option::is_none")]
    pub seats_created: Option<i64>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct PostReposCreateAttestationResponse201 {
    /// The ID of the attestation.
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<i64>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct PostDependencyGraphCreateRepositorySnapshotResponse201 {
    /// ID of the created snapshot.
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<i64>,
    /// The time at which the snapshot was created.
    #[serde(skip_serializing_if="Option::is_none")]
    pub created_at: Option<String>,
    /// Either \"SUCCESS\", \"ACCEPTED\", or \"INVALID\". \"SUCCESS\" indicates that the snapshot was successfully created and the repository's dependencies were updated. \"ACCEPTED\" indicates that the snapshot was successfully created, but the repository's dependencies were not updated. \"INVALID\" indicates that the snapshot was malformed.
    #[serde(skip_serializing_if="Option::is_none")]
    pub result: Option<String>,
    /// A message providing further details about the result, such as why the dependencies were not updated.
    #[serde(skip_serializing_if="Option::is_none")]
    pub message: Option<String>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct PostReposCreateDeploymentResponse202 {
    #[serde(skip_serializing_if="Option::is_none")]
    pub message: Option<String>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct PutPullsUpdateBranchResponse202 {
    #[serde(skip_serializing_if="Option::is_none")]
    pub message: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub url: Option<String>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct GetGistsGetCommentResponse403 {
    #[serde(skip_serializing_if="Option::is_none")]
    pub block: Option<InlineResponse403Block>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub message: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub documentation_url: Option<String>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct PatchProjectsUpdateResponse403 {
    #[serde(skip_serializing_if="Option::is_none")]
    pub message: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub documentation_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub errors: Option<Vec<String>>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct PostProjectsMoveCardResponse403 {
    #[serde(skip_serializing_if="Option::is_none")]
    pub message: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub documentation_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub errors: Option<Vec<InlineResponse4032Errors>>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct InlineResponse4032Errors {
    #[serde(skip_serializing_if="Option::is_none")]
    pub code: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub message: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub resource: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub field: Option<String>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct InlineResponse403Block {
    #[serde(skip_serializing_if="Option::is_none")]
    pub reason: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub created_at: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub html_url: Option<String>,
}

#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PutReposCreateOrUpdateFileContentsResponse409 { 
    PutReposCreateOrUpdateFileContentsResponse409Variant0(BasicError),
    PutReposCreateOrUpdateFileContentsResponse409Variant1(RepositoryRuleViolationError),
}

impl From<BasicError> for PutReposCreateOrUpdateFileContentsResponse409 {
    fn from(value: BasicError) -> Self {
        PutReposCreateOrUpdateFileContentsResponse409::PutReposCreateOrUpdateFileContentsResponse409Variant0(value)
    }
}

impl From<RepositoryRuleViolationError> for PutReposCreateOrUpdateFileContentsResponse409 {
    fn from(value: RepositoryRuleViolationError) -> Self {
        PutReposCreateOrUpdateFileContentsResponse409::PutReposCreateOrUpdateFileContentsResponse409Variant1(value)
    }
}

#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PostProjectsCreateCardResponse422 { 
    PostProjectsCreateCardResponse422Variant0(ValidationError),
    PostProjectsCreateCardResponse422Variant1(ValidationErrorSimple),
}

impl From<ValidationError> for PostProjectsCreateCardResponse422 {
    fn from(value: ValidationError) -> Self {
        PostProjectsCreateCardResponse422::PostProjectsCreateCardResponse422Variant0(value)
    }
}

impl From<ValidationErrorSimple> for PostProjectsCreateCardResponse422 {
    fn from(value: ValidationErrorSimple) -> Self {
        PostProjectsCreateCardResponse422::PostProjectsCreateCardResponse422Variant1(value)
    }
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct PutTeamsAddOrUpdateProjectPermissionsLegacyResponse403 {
    #[serde(skip_serializing_if="Option::is_none")]
    pub message: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub documentation_url: Option<String>,
}

#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PostGitCreateBlobResponse422 { 
    PostGitCreateBlobResponse422Variant0(ValidationError),
    PostGitCreateBlobResponse422Variant1(RepositoryRuleViolationError),
}

impl From<ValidationError> for PostGitCreateBlobResponse422 {
    fn from(value: ValidationError) -> Self {
        PostGitCreateBlobResponse422::PostGitCreateBlobResponse422Variant0(value)
    }
}

impl From<RepositoryRuleViolationError> for PostGitCreateBlobResponse422 {
    fn from(value: RepositoryRuleViolationError) -> Self {
        PostGitCreateBlobResponse422::PostGitCreateBlobResponse422Variant1(value)
    }
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct PostCodespacesCreateForAuthenticatedUserResponse503 {
    #[serde(skip_serializing_if="Option::is_none")]
    pub code: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub message: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub documentation_url: Option<String>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct PostProjectsCreateCardResponse503 {
    #[serde(skip_serializing_if="Option::is_none")]
    pub code: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub message: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub documentation_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub errors: Option<Vec<InlineResponse5031Errors>>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct InlineResponse5031Errors {
    #[serde(skip_serializing_if="Option::is_none")]
    pub code: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub message: Option<String>,
}

/// Installation
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct Installation {
    /// The ID of the installation.
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub account: Option<AnyOfinstallationAccount>,
    /// Describe whether all repositories have been selected or there's a selection involved
    #[serde(skip_serializing_if="Option::is_none")]
    pub repository_selection: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub access_tokens_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub repositories_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub html_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub app_id: Option<i64>,
    /// The ID of the user or organization this token is being scoped to.
    #[serde(skip_serializing_if="Option::is_none")]
    pub target_id: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub target_type: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub permissions: Option<AppPermissions>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub events: Option<Vec<String>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub updated_at: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub single_file_name: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub has_multiple_single_files: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub single_file_paths: Option<Vec<String>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub app_slug: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub suspended_by: Option<NullableSimpleUser>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub suspended_at: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub contact_email: Option<String>,
}

/// Authentication token for a GitHub App installed on a user or org.
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct InstallationToken {
    #[serde(skip_serializing_if="Option::is_none")]
    pub token: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub expires_at: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub permissions: Option<AppPermissions>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub repository_selection: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub repositories: Option<Vec<Repository>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub single_file: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub has_multiple_single_files: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub single_file_paths: Option<Vec<String>>,
}

/// GitHub apps are a new way to extend GitHub. They can be installed directly on organizations and user accounts and granted access to specific repositories. They come with granular permissions and built-in webhooks. GitHub apps are first class actors within GitHub.
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct Integration {
    /// Unique identifier of the GitHub app
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<i64>,
    /// The slug name of the GitHub app
    #[serde(skip_serializing_if="Option::is_none")]
    pub slug: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub node_id: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub client_id: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub owner: Option<OneOfintegrationOwner>,
    /// The name of the GitHub app
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub description: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub external_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub html_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub updated_at: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub permissions: Option<IntegrationPermissions>,
    /// The list of events for the GitHub app
    #[serde(skip_serializing_if="Option::is_none")]
    pub events: Option<Vec<String>>,
    /// The number of installations associated with the GitHub app
    #[serde(skip_serializing_if="Option::is_none")]
    pub installations_count: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub client_secret: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub webhook_secret: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub pem: Option<String>,
}

/// Request to install an integration on a target
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct IntegrationInstallationRequest {
    /// Unique identifier of the request installation.
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub node_id: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub account: Option<AnyOfintegrationInstallationRequestAccount>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub requester: Option<SimpleUser>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
}

/// The set of permissions for the GitHub app
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct IntegrationPermissions {
    #[serde(skip_serializing_if="Option::is_none")]
    pub issues: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub checks: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub metadata: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub contents: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub deployments: Option<String>,
}

/// The duration of the interaction restriction. Default: `one_day`.
/// Enumeration of values.
/// Since this enum's variants do not hold data, we can easily define them them as `#[repr(C)]`
/// which helps with FFI.
#[allow(non_camel_case_types)]
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq, PartialOrd, Serialize, Deserialize, Eq, Ord)]
pub enum InteractionExpiry { 
    #[serde(rename = "one_day")]
    ONE_DAY,
    #[serde(rename = "three_days")]
    THREE_DAYS,
    #[serde(rename = "one_week")]
    ONE_WEEK,
    #[serde(rename = "one_month")]
    ONE_MONTH,
    #[serde(rename = "six_months")]
    SIX_MONTHS,
}

impl Display for InteractionExpiry {
    fn fmt(&self, f: &mut Formatter) -> fmt::Result {
        match *self { 
            InteractionExpiry::ONE_DAY => write!(f, "{}", "one_day"),
            InteractionExpiry::THREE_DAYS => write!(f, "{}", "three_days"),
            InteractionExpiry::ONE_WEEK => write!(f, "{}", "one_week"),
            InteractionExpiry::ONE_MONTH => write!(f, "{}", "one_month"),
            InteractionExpiry::SIX_MONTHS => write!(f, "{}", "six_months"),
        }
    }
}

impl std::str::FromStr for InteractionExpiry {
    type Err = ();
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s {
            "one_day" => Ok(InteractionExpiry::ONE_DAY),
            "three_days" => Ok(InteractionExpiry::THREE_DAYS),
            "one_week" => Ok(InteractionExpiry::ONE_WEEK),
            "one_month" => Ok(InteractionExpiry::ONE_MONTH),
            "six_months" => Ok(InteractionExpiry::SIX_MONTHS),
            _ => Err(()),
        }
    }
}

/// The type of GitHub user that can comment, open issues, or create pull requests while the interaction limit is in effect.
/// Enumeration of values.
/// Since this enum's variants do not hold data, we can easily define them them as `#[repr(C)]`
/// which helps with FFI.
#[allow(non_camel_case_types)]
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq, PartialOrd, Serialize, Deserialize, Eq, Ord)]
pub enum InteractionGroup { 
    #[serde(rename = "existing_users")]
    EXISTING_USERS,
    #[serde(rename = "contributors_only")]
    CONTRIBUTORS_ONLY,
    #[serde(rename = "collaborators_only")]
    COLLABORATORS_ONLY,
}

impl Display for InteractionGroup {
    fn fmt(&self, f: &mut Formatter) -> fmt::Result {
        match *self { 
            InteractionGroup::EXISTING_USERS => write!(f, "{}", "existing_users"),
            InteractionGroup::CONTRIBUTORS_ONLY => write!(f, "{}", "contributors_only"),
            InteractionGroup::COLLABORATORS_ONLY => write!(f, "{}", "collaborators_only"),
        }
    }
}

impl std::str::FromStr for InteractionGroup {
    type Err = ();
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s {
            "existing_users" => Ok(InteractionGroup::EXISTING_USERS),
            "contributors_only" => Ok(InteractionGroup::CONTRIBUTORS_ONLY),
            "collaborators_only" => Ok(InteractionGroup::COLLABORATORS_ONLY),
            _ => Err(()),
        }
    }
}

/// Limit interactions to a specific type of user for a specified duration
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct PutInteractionsSetRestrictionsForAuthenticatedUser {
    #[serde(skip_serializing_if="Option::is_none")]
    pub limit: Option<InteractionGroup>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub expiry: Option<InteractionExpiry>,
}

/// Interaction limit settings.
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct InteractionLimitResponse {
    #[serde(skip_serializing_if="Option::is_none")]
    pub limit: Option<InteractionGroup>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub origin: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub expires_at: Option<chrono::DateTime<chrono::Utc>>,
}

/// The [issue](https://docs.github.com/rest/issues/issues#get-an-issue) itself.
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct Issue {
    #[serde(skip_serializing_if="Option::is_none")]
    pub active_lock_reason: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub assignee: Option<User1>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub assignees: Option<Vec<User5>>,
    /// How the author is associated with the repository.
    #[serde(skip_serializing_if="Option::is_none")]
    pub author_association: Option<String>,
    /// Contents of the issue
    #[serde(skip_serializing_if="Option::is_none")]
    pub body: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub closed_at: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub comments: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub comments_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub draft: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub events_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub html_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub labels: Option<Vec<Label>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub labels_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub locked: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub milestone: Option<Milestone1>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub node_id: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub number: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub performed_via_github_app: Option<App8>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub pull_request: Option<WebhooksIssuePullRequest>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub reactions: Option<Reactions>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub repository_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub sub_issues_summary: Option<SubissuesSummary>,
    /// State of the issue; either 'open' or 'closed'
    #[serde(skip_serializing_if="Option::is_none")]
    pub state: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub state_reason: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub timeline_url: Option<String>,
    /// Title of the issue
    #[serde(skip_serializing_if="Option::is_none")]
    pub title: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub updated_at: Option<chrono::DateTime<chrono::Utc>>,
    /// URL for the issue
    #[serde(skip_serializing_if="Option::is_none")]
    pub url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub user: Option<User>,
}

/// The [issue](https://docs.github.com/rest/issues/issues#get-an-issue) itself.
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct Issue1 {
    #[serde(skip_serializing_if="Option::is_none")]
    pub active_lock_reason: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub assignee: Option<User4>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub assignees: Option<Vec<User4>>,
    /// How the author is associated with the repository.
    #[serde(skip_serializing_if="Option::is_none")]
    pub author_association: Option<String>,
    /// Contents of the issue
    #[serde(skip_serializing_if="Option::is_none")]
    pub body: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub closed_at: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub comments: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub comments_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub draft: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub events_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub html_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub labels: Option<Vec<Label>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub labels_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub locked: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub milestone: Option<Milestone>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub node_id: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub number: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub performed_via_github_app: Option<App9>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub pull_request: Option<WebhooksIssuePullRequest>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub reactions: Option<Reactions>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub repository_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub sub_issues_summary: Option<SubissuesSummary>,
    /// State of the issue; either 'open' or 'closed'
    #[serde(skip_serializing_if="Option::is_none")]
    pub state: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub state_reason: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub timeline_url: Option<String>,
    /// Title of the issue
    #[serde(skip_serializing_if="Option::is_none")]
    pub title: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub updated_at: Option<chrono::DateTime<chrono::Utc>>,
    /// URL for the issue
    #[serde(skip_serializing_if="Option::is_none")]
    pub url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub user: Option<User2>,
}

/// The [issue](https://docs.github.com/rest/issues/issues#get-an-issue) itself.
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct Issue2 {
    #[serde(skip_serializing_if="Option::is_none")]
    pub active_lock_reason: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub assignee: Option<User3>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub assignees: Option<Vec<User4>>,
    /// How the author is associated with the repository.
    #[serde(skip_serializing_if="Option::is_none")]
    pub author_association: Option<String>,
    /// Contents of the issue
    #[serde(skip_serializing_if="Option::is_none")]
    pub body: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub closed_at: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub comments: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub comments_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub draft: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub events_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub html_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub labels: Option<Vec<Label>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub labels_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub locked: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub milestone: Option<Milestone>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub node_id: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub number: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub performed_via_github_app: Option<App10>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub pull_request: Option<WebhooksIssuePullRequest>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub reactions: Option<Reactions>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub repository_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub sub_issues_summary: Option<SubissuesSummary>,
    /// State of the issue; either 'open' or 'closed'
    #[serde(skip_serializing_if="Option::is_none")]
    pub state: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub state_reason: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub timeline_url: Option<String>,
    /// Title of the issue
    #[serde(skip_serializing_if="Option::is_none")]
    pub title: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub updated_at: Option<chrono::DateTime<chrono::Utc>>,
    /// URL for the issue
    #[serde(skip_serializing_if="Option::is_none")]
    pub url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub user: Option<User2>,
}

/// The [issue](https://docs.github.com/rest/issues/issues#get-an-issue) itself.
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct Issue3 {
    #[serde(skip_serializing_if="Option::is_none")]
    pub active_lock_reason: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub assignee: Option<User3>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub assignees: Option<Vec<User4>>,
    /// How the author is associated with the repository.
    #[serde(skip_serializing_if="Option::is_none")]
    pub author_association: Option<String>,
    /// Contents of the issue
    #[serde(skip_serializing_if="Option::is_none")]
    pub body: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub closed_at: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub comments: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub comments_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub draft: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub events_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub html_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub labels: Option<Vec<Label>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub labels_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub locked: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub milestone: Option<Milestone>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub node_id: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub number: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub performed_via_github_app: Option<App11>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub pull_request: Option<WebhooksIssuePullRequest>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub reactions: Option<Reactions>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub repository_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub sub_issues_summary: Option<SubissuesSummary>,
    /// State of the issue; either 'open' or 'closed'
    #[serde(skip_serializing_if="Option::is_none")]
    pub state: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub state_reason: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub timeline_url: Option<String>,
    /// Title of the issue
    #[serde(skip_serializing_if="Option::is_none")]
    pub title: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub updated_at: Option<chrono::DateTime<chrono::Utc>>,
    /// URL for the issue
    #[serde(skip_serializing_if="Option::is_none")]
    pub url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub user: Option<User2>,
}

/// The [issue](https://docs.github.com/rest/issues/issues#get-an-issue) itself.
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct Issue4 {
    #[serde(skip_serializing_if="Option::is_none")]
    pub active_lock_reason: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub assignee: Option<User1>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub assignees: Option<Vec<User1>>,
    /// How the author is associated with the repository.
    #[serde(skip_serializing_if="Option::is_none")]
    pub author_association: Option<String>,
    /// Contents of the issue
    #[serde(skip_serializing_if="Option::is_none")]
    pub body: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub closed_at: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub comments: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub comments_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub draft: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub events_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub html_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub labels: Option<Vec<Label>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub labels_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub locked: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub milestone: Option<Milestone1>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub node_id: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub number: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub performed_via_github_app: Option<App12>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub pull_request: Option<WebhooksIssuePullRequest>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub reactions: Option<Reactions>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub repository_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub sub_issues_summary: Option<SubissuesSummary>,
    /// State of the issue; either 'open' or 'closed'
    #[serde(skip_serializing_if="Option::is_none")]
    pub state: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub state_reason: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub timeline_url: Option<String>,
    /// Title of the issue
    #[serde(skip_serializing_if="Option::is_none")]
    pub title: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub updated_at: Option<chrono::DateTime<chrono::Utc>>,
    /// URL for the issue
    #[serde(skip_serializing_if="Option::is_none")]
    pub url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub user: Option<User>,
}

/// The [issue](https://docs.github.com/rest/issues/issues#get-an-issue) itself.
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct Issue5 {
    #[serde(skip_serializing_if="Option::is_none")]
    pub active_lock_reason: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub assignee: Option<User5>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub assignees: Option<Vec<User5>>,
    /// How the author is associated with the repository.
    #[serde(skip_serializing_if="Option::is_none")]
    pub author_association: Option<String>,
    /// Contents of the issue
    #[serde(skip_serializing_if="Option::is_none")]
    pub body: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub closed_at: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub comments: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub comments_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub draft: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub events_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub html_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub labels: Option<Vec<Label>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub labels_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub locked: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub milestone: Option<Milestone>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub node_id: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub number: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub performed_via_github_app: Option<App13>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub pull_request: Option<WebhooksIssuePullRequest>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub reactions: Option<Reactions>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub repository_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub sub_issues_summary: Option<SubissuesSummary>,
    /// State of the issue; either 'open' or 'closed'
    #[serde(skip_serializing_if="Option::is_none")]
    pub state: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub state_reason: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub timeline_url: Option<String>,
    /// Title of the issue
    #[serde(skip_serializing_if="Option::is_none")]
    pub title: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub updated_at: Option<chrono::DateTime<chrono::Utc>>,
    /// URL for the issue
    #[serde(skip_serializing_if="Option::is_none")]
    pub url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub user: Option<User>,
}

/// The [issue](https://docs.github.com/rest/issues/issues#get-an-issue) itself.
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct Issue6 {
    #[serde(skip_serializing_if="Option::is_none")]
    pub active_lock_reason: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub assignee: Option<User1>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub assignees: Option<Vec<User1>>,
    /// How the author is associated with the repository.
    #[serde(skip_serializing_if="Option::is_none")]
    pub author_association: Option<String>,
    /// Contents of the issue
    #[serde(skip_serializing_if="Option::is_none")]
    pub body: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub closed_at: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub comments: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub comments_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub draft: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub events_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub html_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub labels: Option<Vec<Label>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub labels_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub locked: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub milestone: Option<Milestone1>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub node_id: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub number: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub performed_via_github_app: Option<App1>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub pull_request: Option<WebhooksIssuePullRequest>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub reactions: Option<Reactions>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub repository_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub sub_issues_summary: Option<SubissuesSummary>,
    /// State of the issue; either 'open' or 'closed'
    #[serde(skip_serializing_if="Option::is_none")]
    pub state: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub state_reason: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub timeline_url: Option<String>,
    /// Title of the issue
    #[serde(skip_serializing_if="Option::is_none")]
    pub title: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub updated_at: Option<chrono::DateTime<chrono::Utc>>,
    /// URL for the issue
    #[serde(skip_serializing_if="Option::is_none")]
    pub url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub user: Option<User>,
}

/// The [issue](https://docs.github.com/rest/issues/issues#get-an-issue) itself.
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct Issue7 {
    #[serde(skip_serializing_if="Option::is_none")]
    pub active_lock_reason: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub assignee: Option<User1>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub assignees: Option<Vec<User1>>,
    /// How the author is associated with the repository.
    #[serde(skip_serializing_if="Option::is_none")]
    pub author_association: Option<String>,
    /// Contents of the issue
    #[serde(skip_serializing_if="Option::is_none")]
    pub body: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub closed_at: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub comments: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub comments_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub draft: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub events_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub html_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub labels: Option<Vec<Label>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub labels_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub locked: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub milestone: Option<Milestone>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub node_id: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub number: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub performed_via_github_app: Option<App10>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub pull_request: Option<WebhooksIssuePullRequest>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub reactions: Option<Reactions>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub repository_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub sub_issues_summary: Option<SubissuesSummary>,
    /// State of the issue; either 'open' or 'closed'
    #[serde(skip_serializing_if="Option::is_none")]
    pub state: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub state_reason: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub timeline_url: Option<String>,
    /// Title of the issue
    #[serde(skip_serializing_if="Option::is_none")]
    pub title: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub updated_at: Option<chrono::DateTime<chrono::Utc>>,
    /// URL for the issue
    #[serde(skip_serializing_if="Option::is_none")]
    pub url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub user: Option<User>,
}

/// The [issue](https://docs.github.com/rest/issues/issues#get-an-issue) itself.
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct Issue8 {
    #[serde(skip_serializing_if="Option::is_none")]
    pub active_lock_reason: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub assignee: Option<User5>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub assignees: Option<Vec<User4>>,
    /// How the author is associated with the repository.
    #[serde(skip_serializing_if="Option::is_none")]
    pub author_association: Option<String>,
    /// Contents of the issue
    #[serde(skip_serializing_if="Option::is_none")]
    pub body: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub closed_at: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub comments: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub comments_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub draft: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub events_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub html_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub labels: Option<Vec<Label>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub labels_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub locked: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub milestone: Option<Milestone>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub node_id: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub number: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub performed_via_github_app: Option<App14>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub pull_request: Option<WebhooksIssuePullRequest>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub reactions: Option<Reactions>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub repository_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub sub_issues_summary: Option<SubissuesSummary>,
    /// State of the issue; either 'open' or 'closed'
    #[serde(skip_serializing_if="Option::is_none")]
    pub state: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub state_reason: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub timeline_url: Option<String>,
    /// Title of the issue
    #[serde(skip_serializing_if="Option::is_none")]
    pub title: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub updated_at: Option<chrono::DateTime<chrono::Utc>>,
    /// URL for the issue
    #[serde(skip_serializing_if="Option::is_none")]
    pub url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub user: Option<User2>,
}

/// The [issue](https://docs.github.com/rest/issues/issues#get-an-issue) itself.
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct Issue9 {
    #[serde(skip_serializing_if="Option::is_none")]
    pub active_lock_reason: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub assignee: Option<User1>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub assignees: Option<Vec<User1>>,
    /// How the author is associated with the repository.
    #[serde(skip_serializing_if="Option::is_none")]
    pub author_association: Option<String>,
    /// Contents of the issue
    #[serde(skip_serializing_if="Option::is_none")]
    pub body: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub closed_at: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub comments: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub comments_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub draft: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub events_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub html_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub labels: Option<Vec<Label>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub labels_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub locked: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub milestone: Option<Milestone1>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub node_id: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub number: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub performed_via_github_app: Option<App1>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub pull_request: Option<WebhooksIssuePullRequest>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub reactions: Option<Reactions>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub repository_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub sub_issues_summary: Option<SubissuesSummary>,
    /// State of the issue; either 'open' or 'closed'
    #[serde(skip_serializing_if="Option::is_none")]
    pub state: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub state_reason: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub timeline_url: Option<String>,
    /// Title of the issue
    #[serde(skip_serializing_if="Option::is_none")]
    pub title: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub updated_at: Option<chrono::DateTime<chrono::Utc>>,
    /// URL for the issue
    #[serde(skip_serializing_if="Option::is_none")]
    pub url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub user: Option<User>,
}

/// The [comment](https://docs.github.com/rest/issues/comments#get-an-issue-comment) itself.
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct IssueComment {
    /// How the author is associated with the repository.
    #[serde(skip_serializing_if="Option::is_none")]
    pub author_association: Option<String>,
    /// Contents of the issue comment
    #[serde(skip_serializing_if="Option::is_none")]
    pub body: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub html_url: Option<String>,
    /// Unique identifier of the issue comment
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub issue_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub node_id: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub performed_via_github_app: Option<NullableIntegration>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub reactions: Option<Reactions>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub updated_at: Option<chrono::DateTime<chrono::Utc>>,
    /// URL for the issue comment
    #[serde(skip_serializing_if="Option::is_none")]
    pub url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub user: Option<User>,
}

/// Issue Event
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct IssueEvent {
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub node_id: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub actor: Option<NullableSimpleUser>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub event: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub commit_id: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub commit_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub issue: Option<NullableIssue>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub label: Option<IssueEventLabel>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub assignee: Option<NullableSimpleUser>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub assigner: Option<NullableSimpleUser>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub review_requester: Option<NullableSimpleUser>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub requested_reviewer: Option<NullableSimpleUser>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub requested_team: Option<Team>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub dismissed_review: Option<IssueEventDismissedReview>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub milestone: Option<IssueEventMilestone>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub project_card: Option<IssueEventProjectCard>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub rename: Option<IssueEventRename>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub author_association: Option<AuthorAssociation>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub lock_reason: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub performed_via_github_app: Option<NullableIntegration>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct IssueEventDismissedReview {
    #[serde(skip_serializing_if="Option::is_none")]
    pub state: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub review_id: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub dismissal_message: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub dismissal_commit_id: Option<String>,
}

/// Issue Event for Issue
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
#[serde(untagged)]
pub enum IssueEventForIssue { 
    IssueEventForIssueVariant0(LabeledIssueEvent),
    IssueEventForIssueVariant1(UnlabeledIssueEvent),
    IssueEventForIssueVariant2(AssignedIssueEvent),
    IssueEventForIssueVariant3(UnassignedIssueEvent),
    IssueEventForIssueVariant4(MilestonedIssueEvent),
    IssueEventForIssueVariant5(DemilestonedIssueEvent),
    IssueEventForIssueVariant6(RenamedIssueEvent),
    IssueEventForIssueVariant7(ReviewRequestedIssueEvent),
    IssueEventForIssueVariant8(ReviewRequestRemovedIssueEvent),
    IssueEventForIssueVariant9(ReviewDismissedIssueEvent),
    IssueEventForIssueVariant10(LockedIssueEvent),
    IssueEventForIssueVariant11(AddedToProjectIssueEvent),
    IssueEventForIssueVariant12(MovedColumnInProjectIssueEvent),
    IssueEventForIssueVariant13(RemovedFromProjectIssueEvent),
    IssueEventForIssueVariant14(ConvertedNoteToIssueIssueEvent),
}

impl From<LabeledIssueEvent> for IssueEventForIssue {
    fn from(value: LabeledIssueEvent) -> Self {
        IssueEventForIssue::IssueEventForIssueVariant0(value)
    }
}

impl From<UnlabeledIssueEvent> for IssueEventForIssue {
    fn from(value: UnlabeledIssueEvent) -> Self {
        IssueEventForIssue::IssueEventForIssueVariant1(value)
    }
}

impl From<AssignedIssueEvent> for IssueEventForIssue {
    fn from(value: AssignedIssueEvent) -> Self {
        IssueEventForIssue::IssueEventForIssueVariant2(value)
    }
}

impl From<UnassignedIssueEvent> for IssueEventForIssue {
    fn from(value: UnassignedIssueEvent) -> Self {
        IssueEventForIssue::IssueEventForIssueVariant3(value)
    }
}

impl From<MilestonedIssueEvent> for IssueEventForIssue {
    fn from(value: MilestonedIssueEvent) -> Self {
        IssueEventForIssue::IssueEventForIssueVariant4(value)
    }
}

impl From<DemilestonedIssueEvent> for IssueEventForIssue {
    fn from(value: DemilestonedIssueEvent) -> Self {
        IssueEventForIssue::IssueEventForIssueVariant5(value)
    }
}

impl From<RenamedIssueEvent> for IssueEventForIssue {
    fn from(value: RenamedIssueEvent) -> Self {
        IssueEventForIssue::IssueEventForIssueVariant6(value)
    }
}

impl From<ReviewRequestedIssueEvent> for IssueEventForIssue {
    fn from(value: ReviewRequestedIssueEvent) -> Self {
        IssueEventForIssue::IssueEventForIssueVariant7(value)
    }
}

impl From<ReviewRequestRemovedIssueEvent> for IssueEventForIssue {
    fn from(value: ReviewRequestRemovedIssueEvent) -> Self {
        IssueEventForIssue::IssueEventForIssueVariant8(value)
    }
}

impl From<ReviewDismissedIssueEvent> for IssueEventForIssue {
    fn from(value: ReviewDismissedIssueEvent) -> Self {
        IssueEventForIssue::IssueEventForIssueVariant9(value)
    }
}

impl From<LockedIssueEvent> for IssueEventForIssue {
    fn from(value: LockedIssueEvent) -> Self {
        IssueEventForIssue::IssueEventForIssueVariant10(value)
    }
}

impl From<AddedToProjectIssueEvent> for IssueEventForIssue {
    fn from(value: AddedToProjectIssueEvent) -> Self {
        IssueEventForIssue::IssueEventForIssueVariant11(value)
    }
}

impl From<MovedColumnInProjectIssueEvent> for IssueEventForIssue {
    fn from(value: MovedColumnInProjectIssueEvent) -> Self {
        IssueEventForIssue::IssueEventForIssueVariant12(value)
    }
}

impl From<RemovedFromProjectIssueEvent> for IssueEventForIssue {
    fn from(value: RemovedFromProjectIssueEvent) -> Self {
        IssueEventForIssue::IssueEventForIssueVariant13(value)
    }
}

impl From<ConvertedNoteToIssueIssueEvent> for IssueEventForIssue {
    fn from(value: ConvertedNoteToIssueIssueEvent) -> Self {
        IssueEventForIssue::IssueEventForIssueVariant14(value)
    }
}

/// Issue Event Label
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct IssueEventLabel {
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub color: Option<String>,
}

/// Issue Event Milestone
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct IssueEventMilestone {
    #[serde(skip_serializing_if="Option::is_none")]
    pub title: Option<String>,
}

/// Issue Event Project Card
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct IssueEventProjectCard {
    #[serde(skip_serializing_if="Option::is_none")]
    pub url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub project_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub project_id: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub column_name: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub previous_column_name: Option<String>,
}

/// Issue Event Rename
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct IssueEventRename {
    #[serde(skip_serializing_if="Option::is_none")]
    pub from: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub to: Option<String>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct IssuePullRequest {
    #[serde(skip_serializing_if="Option::is_none")]
    pub merged_at: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub diff_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub html_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub patch_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub url: Option<String>,
}

/// Issue Search Result Item
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct IssueSearchResultItem {
    #[serde(skip_serializing_if="Option::is_none")]
    pub url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub repository_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub labels_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub comments_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub events_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub html_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub node_id: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub number: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub title: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub locked: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub active_lock_reason: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub assignees: Option<Vec<SimpleUser>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub user: Option<NullableSimpleUser>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub labels: Option<Vec<IssuesearchresultitemLabels>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub sub_issues_summary: Option<SubissuesSummary>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub state: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub state_reason: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub assignee: Option<NullableSimpleUser>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub milestone: Option<NullableMilestone>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub comments: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub updated_at: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub closed_at: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub text_matches: Option<SearchResultTextMatches>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub pull_request: Option<IssuePullRequest>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub body: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub score: Option<f64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub author_association: Option<AuthorAssociation>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub draft: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub repository: Option<Repository>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub body_html: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub body_text: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub timeline_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub performed_via_github_app: Option<NullableIntegration>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub reactions: Option<ReactionRollup>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct IssuesearchresultitemLabels {
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub node_id: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub color: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub default: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub description: Option<String>,
}

/// Information of a job execution in a workflow run
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct Job {
    /// The id of the job.
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<i64>,
    /// The id of the associated workflow run.
    #[serde(skip_serializing_if="Option::is_none")]
    pub run_id: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub run_url: Option<String>,
    /// Attempt number of the associated workflow run, 1 for first attempt and higher if the workflow was re-run.
    #[serde(skip_serializing_if="Option::is_none")]
    pub run_attempt: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub node_id: Option<String>,
    /// The SHA of the commit that is being run.
    #[serde(skip_serializing_if="Option::is_none")]
    pub head_sha: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub html_url: Option<String>,
    /// The phase of the lifecycle that the job is currently in.
    #[serde(skip_serializing_if="Option::is_none")]
    pub status: Option<String>,
    /// The outcome of the job.
    #[serde(skip_serializing_if="Option::is_none")]
    pub conclusion: Option<String>,
    /// The time that the job created, in ISO 8601 format.
    #[serde(skip_serializing_if="Option::is_none")]
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The time that the job started, in ISO 8601 format.
    #[serde(skip_serializing_if="Option::is_none")]
    pub started_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The time that the job finished, in ISO 8601 format.
    #[serde(skip_serializing_if="Option::is_none")]
    pub completed_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The name of the job.
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,
    /// Steps in this job.
    #[serde(skip_serializing_if="Option::is_none")]
    pub steps: Option<Vec<JobSteps>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub check_run_url: Option<String>,
    /// Labels for the workflow job. Specified by the \"runs_on\" attribute in the action's workflow file.
    #[serde(skip_serializing_if="Option::is_none")]
    pub labels: Option<Vec<String>>,
    /// The ID of the runner to which this job has been assigned. (If a runner hasn't yet been assigned, this will be null.)
    #[serde(skip_serializing_if="Option::is_none")]
    pub runner_id: Option<i64>,
    /// The name of the runner to which this job has been assigned. (If a runner hasn't yet been assigned, this will be null.)
    #[serde(skip_serializing_if="Option::is_none")]
    pub runner_name: Option<String>,
    /// The ID of the runner group to which this job has been assigned. (If a runner hasn't yet been assigned, this will be null.)
    #[serde(skip_serializing_if="Option::is_none")]
    pub runner_group_id: Option<i64>,
    /// The name of the runner group to which this job has been assigned. (If a runner hasn't yet been assigned, this will be null.)
    #[serde(skip_serializing_if="Option::is_none")]
    pub runner_group_name: Option<String>,
    /// The name of the workflow.
    #[serde(skip_serializing_if="Option::is_none")]
    pub workflow_name: Option<String>,
    /// The name of the current branch.
    #[serde(skip_serializing_if="Option::is_none")]
    pub head_branch: Option<String>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct JobSteps {
    /// The phase of the lifecycle that the job is currently in.
    #[serde(skip_serializing_if="Option::is_none")]
    pub status: Option<String>,
    /// The outcome of the job.
    #[serde(skip_serializing_if="Option::is_none")]
    pub conclusion: Option<String>,
    /// The name of the job.
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub number: Option<i64>,
    /// The time that the step started, in ISO 8601 format.
    #[serde(skip_serializing_if="Option::is_none")]
    pub started_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The time that the job finished, in ISO 8601 format.
    #[serde(skip_serializing_if="Option::is_none")]
    pub completed_at: Option<chrono::DateTime<chrono::Utc>>,
}

/// Key
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct Key {
    #[serde(skip_serializing_if="Option::is_none")]
    pub key: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub title: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub verified: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub read_only: Option<bool>,
}

/// Key Simple
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct KeySimple {
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub key: Option<String>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct Label {
    /// 6-character hex code, without the leading #, identifying the color
    #[serde(skip_serializing_if="Option::is_none")]
    pub color: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub default: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub description: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<i64>,
    /// The name of the label.
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub node_id: Option<String>,
    /// URL for the label
    #[serde(skip_serializing_if="Option::is_none")]
    pub url: Option<String>,
}

/// Label Search Result Item
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct LabelSearchResultItem {
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub node_id: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub color: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub default: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub description: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub score: Option<f64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub text_matches: Option<SearchResultTextMatches>,
}

/// Labeled Issue Event
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct LabeledIssueEvent {
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub node_id: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub actor: Option<SimpleUser>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub event: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub commit_id: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub commit_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub created_at: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub performed_via_github_app: Option<NullableIntegration>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub label: Option<LabeledissueeventLabel>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct LabeledissueeventLabel {
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub color: Option<String>,
}

/// Language
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct Language {
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct License {
    #[serde(skip_serializing_if="Option::is_none")]
    pub key: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub node_id: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub spdx_id: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub url: Option<String>,
}

/// License Content
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct LicenseContent {
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub path: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub sha: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub size: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub html_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub git_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub download_url: Option<String>,
    #[serde(rename = "type")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub _type: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub content: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub encoding: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub _links: Option<ContenttreeLinks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub license: Option<NullableLicenseSimple>,
}

/// License Simple
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct LicenseSimple {
    #[serde(skip_serializing_if="Option::is_none")]
    pub key: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub spdx_id: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub node_id: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub html_url: Option<String>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct Link {
    #[serde(skip_serializing_if="Option::is_none")]
    pub href: Option<String>,
}

/// Hypermedia Link with Type
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct LinkWithType {
    #[serde(skip_serializing_if="Option::is_none")]
    pub href: Option<String>,
    #[serde(rename = "type")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub _type: Option<String>,
}

/// Locked Issue Event
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct LockedIssueEvent {
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub node_id: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub actor: Option<SimpleUser>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub event: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub commit_id: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub commit_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub created_at: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub performed_via_github_app: Option<NullableIntegration>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub lock_reason: Option<String>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct Manifest {
    /// The name of the manifest.
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub file: Option<ManifestFile>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub metadata: Option<Metadata>,
    /// A collection of resolved package dependencies.
    #[serde(skip_serializing_if="Option::is_none")]
    pub resolved: Option<HashMap<String, Dependency>>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct ManifestFile {
    /// The path of the manifest file relative to the root of the Git repository.
    #[serde(skip_serializing_if="Option::is_none")]
    pub source_location: Option<String>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct MarketplaceAccount {
    #[serde(skip_serializing_if="Option::is_none")]
    pub url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<i64>,
    #[serde(rename = "type")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub _type: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub node_id: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub login: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub email: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub organization_billing_email: Option<String>,
}

/// Marketplace Listing Plan
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct MarketplaceListingPlan {
    #[serde(skip_serializing_if="Option::is_none")]
    pub url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub accounts_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub number: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub description: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub monthly_price_in_cents: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub yearly_price_in_cents: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub price_model: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub has_free_trial: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub unit_name: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub state: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub bullets: Option<Vec<String>>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct MarketplacePurchase {
    #[serde(skip_serializing_if="Option::is_none")]
    pub account: Option<WebhooksMarketplacePurchaseAccount>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub billing_cycle: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub free_trial_ends_on: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub next_billing_date: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub on_free_trial: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub plan: Option<WebhooksPreviousMarketplacePurchasePlan>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub unit_count: Option<i64>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct MarketplacePurchase1 {
    #[serde(skip_serializing_if="Option::is_none")]
    pub account: Option<WebhooksMarketplacePurchaseAccount>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub billing_cycle: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub free_trial_ends_on: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub next_billing_date: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub on_free_trial: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub plan: Option<WebhooksPreviousMarketplacePurchasePlan>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub unit_count: Option<i64>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct MarketplacePurchase2 {
    #[serde(skip_serializing_if="Option::is_none")]
    pub account: Option<WebhooksMarketplacePurchaseAccount>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub billing_cycle: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub free_trial_ends_on: Option<Value>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub next_billing_date: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub on_free_trial: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub plan: Option<WebhooksPreviousMarketplacePurchasePlan>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub unit_count: Option<i64>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct MarketplacepurchaseMarketplacePendingChange {
    #[serde(skip_serializing_if="Option::is_none")]
    pub is_installed: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub effective_date: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub unit_count: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub plan: Option<MarketplaceListingPlan>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct MarketplacepurchaseMarketplacePurchase {
    #[serde(skip_serializing_if="Option::is_none")]
    pub billing_cycle: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub next_billing_date: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub is_installed: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub unit_count: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub on_free_trial: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub free_trial_ends_on: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub updated_at: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub plan: Option<MarketplaceListingPlan>,
}

/// A group of pull requests that the merge queue has grouped together to be merged.
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct MergeGroup {
    /// The SHA of the merge group.
    #[serde(skip_serializing_if="Option::is_none")]
    pub head_sha: Option<String>,
    /// The full ref of the merge group.
    #[serde(skip_serializing_if="Option::is_none")]
    pub head_ref: Option<String>,
    /// The SHA of the merge group's parent commit.
    #[serde(skip_serializing_if="Option::is_none")]
    pub base_sha: Option<String>,
    /// The full ref of the branch the merge group will be merged into.
    #[serde(skip_serializing_if="Option::is_none")]
    pub base_ref: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub head_commit: Option<SimpleCommit>,
}

/// Results of a successful merge upstream request
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct MergedUpstream {
    #[serde(skip_serializing_if="Option::is_none")]
    pub message: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub merge_type: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub base_branch: Option<String>,
}

/// User-defined metadata to store domain-specific information limited to 8 keys with scalar values.
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct Metadata {
}

/// A migration.
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct Migration {
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub owner: Option<NullableSimpleUser>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub guid: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub state: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub lock_repositories: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub exclude_metadata: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub exclude_git_data: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub exclude_attachments: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub exclude_releases: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub exclude_owner_projects: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub org_metadata_only: Option<bool>,
    /// The repositories included in the migration. Only returned for export migrations.
    #[serde(skip_serializing_if="Option::is_none")]
    pub repositories: Option<Vec<Repository>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub updated_at: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub node_id: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub archive_url: Option<String>,
    /// Exclude related items from being returned in the response in order to improve performance of the request. The array can include any of: `\"repositories\"`.
    #[serde(skip_serializing_if="Option::is_none")]
    pub exclude: Option<Vec<String>>,
}

/// A collection of related issues and pull requests.
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct Milestone {
    #[serde(skip_serializing_if="Option::is_none")]
    pub closed_at: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub closed_issues: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub creator: Option<User3>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub description: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub due_on: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub html_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub labels_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub node_id: Option<String>,
    /// The number of the milestone.
    #[serde(skip_serializing_if="Option::is_none")]
    pub number: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub open_issues: Option<i64>,
    /// The state of the milestone.
    #[serde(skip_serializing_if="Option::is_none")]
    pub state: Option<String>,
    /// The title of the milestone.
    #[serde(skip_serializing_if="Option::is_none")]
    pub title: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub updated_at: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub url: Option<String>,
}

/// A collection of related issues and pull requests.
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct Milestone1 {
    #[serde(skip_serializing_if="Option::is_none")]
    pub closed_at: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub closed_issues: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub creator: Option<User1>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub description: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub due_on: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub html_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub labels_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub node_id: Option<String>,
    /// The number of the milestone.
    #[serde(skip_serializing_if="Option::is_none")]
    pub number: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub open_issues: Option<i64>,
    /// The state of the milestone.
    #[serde(skip_serializing_if="Option::is_none")]
    pub state: Option<String>,
    /// The title of the milestone.
    #[serde(skip_serializing_if="Option::is_none")]
    pub title: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub updated_at: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub url: Option<String>,
}

/// Milestoned Issue Event
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct MilestonedIssueEvent {
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub node_id: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub actor: Option<SimpleUser>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub event: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub commit_id: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub commit_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub created_at: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub performed_via_github_app: Option<NullableIntegration>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub milestone: Option<MilestonedissueeventMilestone>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct MilestonedissueeventMilestone {
    #[serde(skip_serializing_if="Option::is_none")]
    pub title: Option<String>,
}

/// Minimal Repository
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct MinimalRepository {
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub node_id: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub full_name: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub owner: Option<SimpleUser>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub private: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub html_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub description: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub fork: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub archive_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub assignees_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub blobs_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub branches_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub collaborators_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub comments_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub commits_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub compare_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub contents_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub contributors_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub deployments_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub downloads_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub events_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub forks_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub git_commits_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub git_refs_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub git_tags_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub git_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub issue_comment_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub issue_events_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub issues_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub keys_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub labels_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub languages_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub merges_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub milestones_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub notifications_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub pulls_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub releases_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub ssh_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub stargazers_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub statuses_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub subscribers_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub subscription_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub tags_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub teams_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub trees_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub clone_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub mirror_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub hooks_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub svn_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub homepage: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub language: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub forks_count: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub stargazers_count: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub watchers_count: Option<i64>,
    /// The size of the repository, in kilobytes. Size is calculated hourly. When a repository is initially created, the size is 0.
    #[serde(skip_serializing_if="Option::is_none")]
    pub size: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub default_branch: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub open_issues_count: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub is_template: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub topics: Option<Vec<String>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub has_issues: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub has_projects: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub has_wiki: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub has_pages: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub has_downloads: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub has_discussions: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub archived: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub disabled: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub visibility: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub pushed_at: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub updated_at: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub permissions: Option<MinimalrepositoryPermissions>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub role_name: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub temp_clone_token: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub delete_branch_on_merge: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub subscribers_count: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub network_count: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub code_of_conduct: Option<CodeOfConduct>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub license: Option<MinimalrepositoryLicense>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub forks: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub open_issues: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub watchers: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub allow_forking: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub web_commit_signoff_required: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub security_and_analysis: Option<SecurityAndAnalysis>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct MinimalrepositoryLicense {
    #[serde(skip_serializing_if="Option::is_none")]
    pub key: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub spdx_id: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub node_id: Option<String>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct MinimalrepositoryPermissions {
    #[serde(skip_serializing_if="Option::is_none")]
    pub admin: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub maintain: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub push: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub triage: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub pull: Option<bool>,
}

/// Moved Column in Project Issue Event
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct MovedColumnInProjectIssueEvent {
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub node_id: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub actor: Option<SimpleUser>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub event: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub commit_id: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub commit_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub created_at: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub performed_via_github_app: Option<NullableIntegration>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub project_card: Option<AddedtoprojectissueeventProjectCard>,
}

/// A hosted compute network configuration.
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct NetworkConfiguration {
    /// The unique identifier of the network configuration.
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<String>,
    /// The name of the network configuration.
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,
    /// The hosted compute service the network configuration supports.
    #[serde(skip_serializing_if="Option::is_none")]
    pub compute_service: Option<String>,
    /// The unique identifier of each network settings in the configuration.
    #[serde(skip_serializing_if="Option::is_none")]
    pub network_settings_ids: Option<Vec<String>>,
    /// The time at which the network configuration was created, in ISO 8601 format.
    #[serde(skip_serializing_if="Option::is_none")]
    pub created_on: Option<chrono::DateTime<chrono::Utc>>,
}

/// A hosted compute network settings resource.
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct NetworkSettings {
    /// The unique identifier of the network settings resource.
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<String>,
    /// The identifier of the network configuration that is using this settings resource.
    #[serde(skip_serializing_if="Option::is_none")]
    pub network_configuration_id: Option<String>,
    /// The name of the network settings resource.
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,
    /// The subnet this network settings resource is configured for.
    #[serde(skip_serializing_if="Option::is_none")]
    pub subnet_id: Option<String>,
    /// The location of the subnet this network settings resource is configured for.
    #[serde(skip_serializing_if="Option::is_none")]
    pub region: Option<String>,
}

/// Provides details of a hosted runner image
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct NullableActionsHostedRunnerPoolImage {
    /// The ID of the image. Use this ID for the `image` parameter when creating a new larger runner.
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<String>,
    /// Image size in GB.
    #[serde(skip_serializing_if="Option::is_none")]
    pub size_gb: Option<i64>,
    /// Display name for this image.
    #[serde(skip_serializing_if="Option::is_none")]
    pub display_name: Option<String>,
    /// The image provider.
    #[serde(skip_serializing_if="Option::is_none")]
    pub source: Option<String>,
    /// The image version of the hosted runner pool.
    #[serde(skip_serializing_if="Option::is_none")]
    pub version: Option<String>,
}

/// The time that the alert was last updated in ISO 8601 format: `YYYY-MM-DDTHH:MM:SSZ`.
pub type NullableAlertUpdatedAt = DateTime<Utc>;

/// Code of Conduct Simple
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct NullableCodeOfConductSimple {
    #[serde(skip_serializing_if="Option::is_none")]
    pub url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub key: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub html_url: Option<String>,
}

/// A description of the machine powering a codespace.
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct NullableCodespaceMachine {
    /// The name of the machine.
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,
    /// The display name of the machine includes cores, memory, and storage.
    #[serde(skip_serializing_if="Option::is_none")]
    pub display_name: Option<String>,
    /// The operating system of the machine.
    #[serde(skip_serializing_if="Option::is_none")]
    pub operating_system: Option<String>,
    /// How much storage is available to the codespace.
    #[serde(skip_serializing_if="Option::is_none")]
    pub storage_in_bytes: Option<i64>,
    /// How much memory is available to the codespace.
    #[serde(skip_serializing_if="Option::is_none")]
    pub memory_in_bytes: Option<i64>,
    /// How many cores are available to the codespace.
    #[serde(skip_serializing_if="Option::is_none")]
    pub cpus: Option<i64>,
    /// Whether a prebuild is currently available when creating a codespace for this machine and repository. If a branch was not specified as a ref, the default branch will be assumed. Value will be \"null\" if prebuilds are not supported or prebuild availability could not be determined. Value will be \"none\" if no prebuild is available. Latest values \"ready\" and \"in_progress\" indicate the prebuild availability status.
    #[serde(skip_serializing_if="Option::is_none")]
    pub prebuild_availability: Option<String>,
}

/// Collaborator
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct NullableCollaborator {
    #[serde(skip_serializing_if="Option::is_none")]
    pub login: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub email: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub node_id: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub avatar_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub gravatar_id: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub html_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub followers_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub following_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub gists_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub starred_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub subscriptions_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub organizations_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub repos_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub events_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub received_events_url: Option<String>,
    #[serde(rename = "type")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub _type: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub site_admin: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub permissions: Option<CollaboratorPermissions>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub role_name: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub user_view_type: Option<String>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct NullableCommunityHealthFile {
    #[serde(skip_serializing_if="Option::is_none")]
    pub url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub html_url: Option<String>,
}

/// Metaproperties for Git author/committer information.
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct NullableGitUser {
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub email: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub date: Option<String>,
}

/// GitHub apps are a new way to extend GitHub. They can be installed directly on organizations and user accounts and granted access to specific repositories. They come with granular permissions and built-in webhooks. GitHub apps are first class actors within GitHub.
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct NullableIntegration {
    /// Unique identifier of the GitHub app
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<i64>,
    /// The slug name of the GitHub app
    #[serde(skip_serializing_if="Option::is_none")]
    pub slug: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub node_id: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub client_id: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub owner: Option<OneOfnullableIntegrationOwner>,
    /// The name of the GitHub app
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub description: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub external_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub html_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub updated_at: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub permissions: Option<IntegrationPermissions>,
    /// The list of events for the GitHub app
    #[serde(skip_serializing_if="Option::is_none")]
    pub events: Option<Vec<String>>,
    /// The number of installations associated with the GitHub app
    #[serde(skip_serializing_if="Option::is_none")]
    pub installations_count: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub client_secret: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub webhook_secret: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub pem: Option<String>,
}

/// Issues are a great way to keep track of tasks, enhancements, and bugs for your projects.
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct NullableIssue {
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub node_id: Option<String>,
    /// URL for the issue
    #[serde(skip_serializing_if="Option::is_none")]
    pub url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub repository_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub labels_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub comments_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub events_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub html_url: Option<String>,
    /// Number uniquely identifying the issue within its repository
    #[serde(skip_serializing_if="Option::is_none")]
    pub number: Option<i64>,
    /// State of the issue; either 'open' or 'closed'
    #[serde(skip_serializing_if="Option::is_none")]
    pub state: Option<String>,
    /// The reason for the current state
    #[serde(skip_serializing_if="Option::is_none")]
    pub state_reason: Option<String>,
    /// Title of the issue
    #[serde(skip_serializing_if="Option::is_none")]
    pub title: Option<String>,
    /// Contents of the issue
    #[serde(skip_serializing_if="Option::is_none")]
    pub body: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub user: Option<NullableSimpleUser>,
    /// Labels to associate with this issue; pass one or more label names to replace the set of labels on this issue; send an empty array to clear all labels from the issue; note that the labels are silently dropped for users without push access to the repository
    #[serde(skip_serializing_if="Option::is_none")]
    pub labels: Option<Vec<OneOfnullableIssueLabelsItems>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub assignee: Option<NullableSimpleUser>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub assignees: Option<Vec<SimpleUser>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub milestone: Option<NullableMilestone>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub locked: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub active_lock_reason: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub comments: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub pull_request: Option<IssuePullRequest>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub closed_at: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub updated_at: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub draft: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub closed_by: Option<NullableSimpleUser>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub body_html: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub body_text: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub timeline_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub repository: Option<Repository>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub performed_via_github_app: Option<NullableIntegration>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub author_association: Option<AuthorAssociation>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub reactions: Option<ReactionRollup>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub sub_issues_summary: Option<SubIssuesSummary>,
}

/// License Simple
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct NullableLicenseSimple {
    #[serde(skip_serializing_if="Option::is_none")]
    pub key: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub spdx_id: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub node_id: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub html_url: Option<String>,
}

/// A collection of related issues and pull requests.
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct NullableMilestone {
    #[serde(skip_serializing_if="Option::is_none")]
    pub url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub html_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub labels_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub node_id: Option<String>,
    /// The number of the milestone.
    #[serde(skip_serializing_if="Option::is_none")]
    pub number: Option<i64>,
    /// The state of the milestone.
    #[serde(skip_serializing_if="Option::is_none")]
    pub state: Option<String>,
    /// The title of the milestone.
    #[serde(skip_serializing_if="Option::is_none")]
    pub title: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub description: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub creator: Option<NullableSimpleUser>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub open_issues: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub closed_issues: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub updated_at: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub closed_at: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub due_on: Option<chrono::DateTime<chrono::Utc>>,
}

/// Minimal Repository
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct NullableMinimalRepository {
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub node_id: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub full_name: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub owner: Option<SimpleUser>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub private: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub html_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub description: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub fork: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub archive_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub assignees_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub blobs_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub branches_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub collaborators_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub comments_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub commits_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub compare_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub contents_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub contributors_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub deployments_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub downloads_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub events_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub forks_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub git_commits_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub git_refs_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub git_tags_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub git_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub issue_comment_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub issue_events_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub issues_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub keys_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub labels_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub languages_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub merges_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub milestones_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub notifications_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub pulls_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub releases_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub ssh_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub stargazers_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub statuses_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub subscribers_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub subscription_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub tags_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub teams_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub trees_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub clone_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub mirror_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub hooks_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub svn_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub homepage: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub language: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub forks_count: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub stargazers_count: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub watchers_count: Option<i64>,
    /// The size of the repository, in kilobytes. Size is calculated hourly. When a repository is initially created, the size is 0.
    #[serde(skip_serializing_if="Option::is_none")]
    pub size: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub default_branch: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub open_issues_count: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub is_template: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub topics: Option<Vec<String>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub has_issues: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub has_projects: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub has_wiki: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub has_pages: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub has_downloads: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub has_discussions: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub archived: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub disabled: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub visibility: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub pushed_at: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub updated_at: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub permissions: Option<MinimalrepositoryPermissions>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub role_name: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub temp_clone_token: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub delete_branch_on_merge: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub subscribers_count: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub network_count: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub code_of_conduct: Option<CodeOfConduct>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub license: Option<MinimalrepositoryLicense>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub forks: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub open_issues: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub watchers: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub allow_forking: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub web_commit_signoff_required: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub security_and_analysis: Option<SecurityAndAnalysis>,
}

/// A GitHub organization.
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct NullableOrganizationSimple {
    #[serde(skip_serializing_if="Option::is_none")]
    pub login: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub node_id: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub repos_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub events_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub hooks_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub issues_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub members_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub public_members_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub avatar_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub description: Option<String>,
}

/// A repository on GitHub.
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct NullableRepository {
    /// Unique identifier of the repository
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub node_id: Option<String>,
    /// The name of the repository.
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub full_name: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub license: Option<NullableLicenseSimple>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub forks: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub permissions: Option<RepositoryPermissions>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub owner: Option<SimpleUser>,
    /// Whether the repository is private or public.
    #[serde(skip_serializing_if="Option::is_none")]
    pub private: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub html_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub description: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub fork: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub archive_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub assignees_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub blobs_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub branches_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub collaborators_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub comments_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub commits_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub compare_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub contents_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub contributors_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub deployments_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub downloads_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub events_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub forks_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub git_commits_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub git_refs_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub git_tags_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub git_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub issue_comment_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub issue_events_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub issues_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub keys_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub labels_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub languages_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub merges_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub milestones_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub notifications_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub pulls_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub releases_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub ssh_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub stargazers_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub statuses_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub subscribers_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub subscription_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub tags_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub teams_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub trees_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub clone_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub mirror_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub hooks_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub svn_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub homepage: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub language: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub forks_count: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub stargazers_count: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub watchers_count: Option<i64>,
    /// The size of the repository, in kilobytes. Size is calculated hourly. When a repository is initially created, the size is 0.
    #[serde(skip_serializing_if="Option::is_none")]
    pub size: Option<i64>,
    /// The default branch of the repository.
    #[serde(skip_serializing_if="Option::is_none")]
    pub default_branch: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub open_issues_count: Option<i64>,
    /// Whether this repository acts as a template that can be used to generate new repositories.
    #[serde(skip_serializing_if="Option::is_none")]
    pub is_template: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub topics: Option<Vec<String>>,
    /// Whether issues are enabled.
    #[serde(skip_serializing_if="Option::is_none")]
    pub has_issues: Option<bool>,
    /// Whether projects are enabled.
    #[serde(skip_serializing_if="Option::is_none")]
    pub has_projects: Option<bool>,
    /// Whether the wiki is enabled.
    #[serde(skip_serializing_if="Option::is_none")]
    pub has_wiki: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub has_pages: Option<bool>,
    /// Whether downloads are enabled.
    #[serde(skip_serializing_if="Option::is_none")]
    pub has_downloads: Option<bool>,
    /// Whether discussions are enabled.
    #[serde(skip_serializing_if="Option::is_none")]
    pub has_discussions: Option<bool>,
    /// Whether the repository is archived.
    #[serde(skip_serializing_if="Option::is_none")]
    pub archived: Option<bool>,
    /// Returns whether or not this repository disabled.
    #[serde(skip_serializing_if="Option::is_none")]
    pub disabled: Option<bool>,
    /// The repository visibility: public, private, or internal.
    #[serde(skip_serializing_if="Option::is_none")]
    pub visibility: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub pushed_at: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub updated_at: Option<chrono::DateTime<chrono::Utc>>,
    /// Whether to allow rebase merges for pull requests.
    #[serde(skip_serializing_if="Option::is_none")]
    pub allow_rebase_merge: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub temp_clone_token: Option<String>,
    /// Whether to allow squash merges for pull requests.
    #[serde(skip_serializing_if="Option::is_none")]
    pub allow_squash_merge: Option<bool>,
    /// Whether to allow Auto-merge to be used on pull requests.
    #[serde(skip_serializing_if="Option::is_none")]
    pub allow_auto_merge: Option<bool>,
    /// Whether to delete head branches when pull requests are merged
    #[serde(skip_serializing_if="Option::is_none")]
    pub delete_branch_on_merge: Option<bool>,
    /// Whether or not a pull request head branch that is behind its base branch can always be updated even if it is not required to be up to date before merging.
    #[serde(skip_serializing_if="Option::is_none")]
    pub allow_update_branch: Option<bool>,
    /// Whether a squash merge commit can use the pull request title as default. **This property is closing down. Please use `squash_merge_commit_title` instead.
    #[serde(skip_serializing_if="Option::is_none")]
    pub use_squash_pr_title_as_default: Option<bool>,
    /// The default value for a squash merge commit title:  - `PR_TITLE` - default to the pull request's title. - `COMMIT_OR_PR_TITLE` - default to the commit's title (if only one commit) or the pull request's title (when more than one commit).
    #[serde(skip_serializing_if="Option::is_none")]
    pub squash_merge_commit_title: Option<String>,
    /// The default value for a squash merge commit message:  - `PR_BODY` - default to the pull request's body. - `COMMIT_MESSAGES` - default to the branch's commit messages. - `BLANK` - default to a blank commit message.
    #[serde(skip_serializing_if="Option::is_none")]
    pub squash_merge_commit_message: Option<String>,
    /// The default value for a merge commit title.  - `PR_TITLE` - default to the pull request's title. - `MERGE_MESSAGE` - default to the classic title for a merge message (e.g., Merge pull request #123 from branch-name).
    #[serde(skip_serializing_if="Option::is_none")]
    pub merge_commit_title: Option<String>,
    /// The default value for a merge commit message.  - `PR_TITLE` - default to the pull request's title. - `PR_BODY` - default to the pull request's body. - `BLANK` - default to a blank commit message.
    #[serde(skip_serializing_if="Option::is_none")]
    pub merge_commit_message: Option<String>,
    /// Whether to allow merge commits for pull requests.
    #[serde(skip_serializing_if="Option::is_none")]
    pub allow_merge_commit: Option<bool>,
    /// Whether to allow forking this repo
    #[serde(skip_serializing_if="Option::is_none")]
    pub allow_forking: Option<bool>,
    /// Whether to require contributors to sign off on web-based commits
    #[serde(skip_serializing_if="Option::is_none")]
    pub web_commit_signoff_required: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub open_issues: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub watchers: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub master_branch: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub starred_at: Option<String>,
    /// Whether anonymous git access is enabled for this repository
    #[serde(skip_serializing_if="Option::is_none")]
    pub anonymous_access_enabled: Option<bool>,
}

/// The repository on GitHub where the event occurred. Webhook payloads contain the `repository` property when the event occurs from activity in a repository.
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct NullableRepositoryWebhooks {
    /// Unique identifier of the repository
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub node_id: Option<String>,
    /// The name of the repository.
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub full_name: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub license: Option<NullableLicenseSimple>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub organization: Option<NullableSimpleUser>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub forks: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub permissions: Option<RepositoryPermissions>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub owner: Option<SimpleUser>,
    /// Whether the repository is private or public.
    #[serde(skip_serializing_if="Option::is_none")]
    pub private: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub html_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub description: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub fork: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub archive_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub assignees_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub blobs_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub branches_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub collaborators_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub comments_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub commits_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub compare_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub contents_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub contributors_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub deployments_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub downloads_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub events_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub forks_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub git_commits_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub git_refs_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub git_tags_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub git_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub issue_comment_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub issue_events_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub issues_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub keys_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub labels_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub languages_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub merges_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub milestones_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub notifications_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub pulls_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub releases_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub ssh_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub stargazers_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub statuses_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub subscribers_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub subscription_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub tags_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub teams_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub trees_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub clone_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub mirror_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub hooks_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub svn_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub homepage: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub language: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub forks_count: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub stargazers_count: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub watchers_count: Option<i64>,
    /// The size of the repository, in kilobytes. Size is calculated hourly. When a repository is initially created, the size is 0.
    #[serde(skip_serializing_if="Option::is_none")]
    pub size: Option<i64>,
    /// The default branch of the repository.
    #[serde(skip_serializing_if="Option::is_none")]
    pub default_branch: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub open_issues_count: Option<i64>,
    /// Whether this repository acts as a template that can be used to generate new repositories.
    #[serde(skip_serializing_if="Option::is_none")]
    pub is_template: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub topics: Option<Vec<String>>,
    /// The custom properties that were defined for the repository. The keys are the custom property names, and the values are the corresponding custom property values.
    #[serde(skip_serializing_if="Option::is_none")]
    pub custom_properties: Option<HashMap<String, HashMap<String, Value>>>,
    /// Whether issues are enabled.
    #[serde(skip_serializing_if="Option::is_none")]
    pub has_issues: Option<bool>,
    /// Whether projects are enabled.
    #[serde(skip_serializing_if="Option::is_none")]
    pub has_projects: Option<bool>,
    /// Whether the wiki is enabled.
    #[serde(skip_serializing_if="Option::is_none")]
    pub has_wiki: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub has_pages: Option<bool>,
    /// Whether downloads are enabled.
    #[serde(skip_serializing_if="Option::is_none")]
    pub has_downloads: Option<bool>,
    /// Whether discussions are enabled.
    #[serde(skip_serializing_if="Option::is_none")]
    pub has_discussions: Option<bool>,
    /// Whether the repository is archived.
    #[serde(skip_serializing_if="Option::is_none")]
    pub archived: Option<bool>,
    /// Returns whether or not this repository disabled.
    #[serde(skip_serializing_if="Option::is_none")]
    pub disabled: Option<bool>,
    /// The repository visibility: public, private, or internal.
    #[serde(skip_serializing_if="Option::is_none")]
    pub visibility: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub pushed_at: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub updated_at: Option<chrono::DateTime<chrono::Utc>>,
    /// Whether to allow rebase merges for pull requests.
    #[serde(skip_serializing_if="Option::is_none")]
    pub allow_rebase_merge: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub template_repository: Option<RepositorywebhooksTemplateRepository>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub temp_clone_token: Option<String>,
    /// Whether to allow squash merges for pull requests.
    #[serde(skip_serializing_if="Option::is_none")]
    pub allow_squash_merge: Option<bool>,
    /// Whether to allow Auto-merge to be used on pull requests.
    #[serde(skip_serializing_if="Option::is_none")]
    pub allow_auto_merge: Option<bool>,
    /// Whether to delete head branches when pull requests are merged
    #[serde(skip_serializing_if="Option::is_none")]
    pub delete_branch_on_merge: Option<bool>,
    /// Whether or not a pull request head branch that is behind its base branch can always be updated even if it is not required to be up to date before merging.
    #[serde(skip_serializing_if="Option::is_none")]
    pub allow_update_branch: Option<bool>,
    /// Whether a squash merge commit can use the pull request title as default. **This property is closing down. Please use `squash_merge_commit_title` instead.
    #[serde(skip_serializing_if="Option::is_none")]
    pub use_squash_pr_title_as_default: Option<bool>,
    /// The default value for a squash merge commit title:  - `PR_TITLE` - default to the pull request's title. - `COMMIT_OR_PR_TITLE` - default to the commit's title (if only one commit) or the pull request's title (when more than one commit).
    #[serde(skip_serializing_if="Option::is_none")]
    pub squash_merge_commit_title: Option<String>,
    /// The default value for a squash merge commit message:  - `PR_BODY` - default to the pull request's body. - `COMMIT_MESSAGES` - default to the branch's commit messages. - `BLANK` - default to a blank commit message.
    #[serde(skip_serializing_if="Option::is_none")]
    pub squash_merge_commit_message: Option<String>,
    /// The default value for a merge commit title.  - `PR_TITLE` - default to the pull request's title. - `MERGE_MESSAGE` - default to the classic title for a merge message (e.g., Merge pull request #123 from branch-name).
    #[serde(skip_serializing_if="Option::is_none")]
    pub merge_commit_title: Option<String>,
    /// The default value for a merge commit message.  - `PR_TITLE` - default to the pull request's title. - `PR_BODY` - default to the pull request's body. - `BLANK` - default to a blank commit message.
    #[serde(skip_serializing_if="Option::is_none")]
    pub merge_commit_message: Option<String>,
    /// Whether to allow merge commits for pull requests.
    #[serde(skip_serializing_if="Option::is_none")]
    pub allow_merge_commit: Option<bool>,
    /// Whether to allow forking this repo
    #[serde(skip_serializing_if="Option::is_none")]
    pub allow_forking: Option<bool>,
    /// Whether to require contributors to sign off on web-based commits
    #[serde(skip_serializing_if="Option::is_none")]
    pub web_commit_signoff_required: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub subscribers_count: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub network_count: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub open_issues: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub watchers: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub master_branch: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub starred_at: Option<String>,
    /// Whether anonymous git access is enabled for this repository
    #[serde(skip_serializing_if="Option::is_none")]
    pub anonymous_access_enabled: Option<bool>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct NullableScopedInstallation {
    #[serde(skip_serializing_if="Option::is_none")]
    pub permissions: Option<AppPermissions>,
    /// Describe whether all repositories have been selected or there's a selection involved
    #[serde(skip_serializing_if="Option::is_none")]
    pub repository_selection: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub single_file_name: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub has_multiple_single_files: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub single_file_paths: Option<Vec<String>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub repositories_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub account: Option<SimpleUser>,
}

/// A commit.
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct NullableSimpleCommit {
    /// SHA for the commit
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<String>,
    /// SHA for the commit's tree
    #[serde(skip_serializing_if="Option::is_none")]
    pub tree_id: Option<String>,
    /// Message describing the purpose of the commit
    #[serde(skip_serializing_if="Option::is_none")]
    pub message: Option<String>,
    /// Timestamp of the commit
    #[serde(skip_serializing_if="Option::is_none")]
    pub timestamp: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub author: Option<NullablesimplecommitAuthor>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub committer: Option<NullablesimplecommitCommitter>,
}

/// A GitHub user.
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct NullableSimpleUser {
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub email: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub login: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub node_id: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub avatar_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub gravatar_id: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub html_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub followers_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub following_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub gists_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub starred_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub subscriptions_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub organizations_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub repos_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub events_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub received_events_url: Option<String>,
    #[serde(rename = "type")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub _type: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub site_admin: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub starred_at: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub user_view_type: Option<String>,
}

/// Groups of organization members that gives permissions on specified repositories.
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct NullableTeamSimple {
    /// Unique identifier of the team
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub node_id: Option<String>,
    /// URL for the team
    #[serde(skip_serializing_if="Option::is_none")]
    pub url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub members_url: Option<String>,
    /// Name of the team
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,
    /// Description of the team
    #[serde(skip_serializing_if="Option::is_none")]
    pub description: Option<String>,
    /// Permission that the team will have for its repositories
    #[serde(skip_serializing_if="Option::is_none")]
    pub permission: Option<String>,
    /// The level of privacy this team should have
    #[serde(skip_serializing_if="Option::is_none")]
    pub privacy: Option<String>,
    /// The notification setting the team has set
    #[serde(skip_serializing_if="Option::is_none")]
    pub notification_setting: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub html_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub repositories_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub slug: Option<String>,
    /// Distinguished Name (DN) that team maps to within LDAP environment
    #[serde(skip_serializing_if="Option::is_none")]
    pub ldap_dn: Option<String>,
}

/// Information about the Git author
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct NullablesimplecommitAuthor {
    /// Name of the commit's author
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,
    /// Git email address of the commit's author
    #[serde(skip_serializing_if="Option::is_none")]
    pub email: Option<String>,
}

/// Information about the Git committer
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct NullablesimplecommitCommitter {
    /// Name of the commit's committer
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,
    /// Git email address of the commit's committer
    #[serde(skip_serializing_if="Option::is_none")]
    pub email: Option<String>,
}

/// Actions OIDC Subject customization
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct OidcCustomSub {
    /// Array of unique strings. Each claim key can only contain alphanumeric characters and underscores.
    #[serde(skip_serializing_if="Option::is_none")]
    pub include_claim_keys: Option<Vec<String>>,
}

/// Actions OIDC subject customization for a repository
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct OidcCustomSubRepo {
    /// Whether to use the default template or not. If `true`, the `include_claim_keys` field is ignored.
    #[serde(skip_serializing_if="Option::is_none")]
    pub use_default: Option<bool>,
    /// Array of unique strings. Each claim key can only contain alphanumeric characters and underscores.
    #[serde(skip_serializing_if="Option::is_none")]
    pub include_claim_keys: Option<Vec<String>>,
}

#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
#[serde(untagged)]
pub enum OneOfDeployment1Payload { 
    OneOfDeployment1PayloadVariant0(String),
    OneOfDeployment1PayloadVariant1(HashMap<String, Value>),
}

impl From<String> for OneOfDeployment1Payload {
    fn from(value: String) -> Self {
        OneOfDeployment1Payload::OneOfDeployment1PayloadVariant0(value)
    }
}

impl From<HashMap<String, Value>> for OneOfDeployment1Payload {
    fn from(value: HashMap<String, Value>) -> Self {
        OneOfDeployment1Payload::OneOfDeployment1PayloadVariant1(value)
    }
}

#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
#[serde(untagged)]
pub enum OneOfDeploymentPayload { 
    OneOfDeploymentPayloadVariant0(HashMap<String, Value>),
    OneOfDeploymentPayloadVariant1(String),
}

impl From<HashMap<String, Value>> for OneOfDeploymentPayload {
    fn from(value: HashMap<String, Value>) -> Self {
        OneOfDeploymentPayload::OneOfDeploymentPayloadVariant0(value)
    }
}

impl From<String> for OneOfDeploymentPayload {
    fn from(value: String) -> Self {
        OneOfDeploymentPayload::OneOfDeploymentPayloadVariant1(value)
    }
}

#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
#[serde(untagged)]
pub enum OneOfPullRequest10RequestedReviewersItems { 
    OneOfPullRequest10RequestedReviewersItemsVariant0(HashMap<String, Value>),
}

impl From<HashMap<String, Value>> for OneOfPullRequest10RequestedReviewersItems {
    fn from(value: HashMap<String, Value>) -> Self {
        OneOfPullRequest10RequestedReviewersItems::OneOfPullRequest10RequestedReviewersItemsVariant0(value)
    }
}

#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
#[serde(untagged)]
pub enum OneOfPullRequest11RequestedReviewersItems { 
    OneOfPullRequest11RequestedReviewersItemsVariant0(HashMap<String, Value>),
}

impl From<HashMap<String, Value>> for OneOfPullRequest11RequestedReviewersItems {
    fn from(value: HashMap<String, Value>) -> Self {
        OneOfPullRequest11RequestedReviewersItems::OneOfPullRequest11RequestedReviewersItemsVariant0(value)
    }
}

#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
#[serde(untagged)]
pub enum OneOfPullRequest12RequestedReviewersItems { 
    OneOfPullRequest12RequestedReviewersItemsVariant0(HashMap<String, Value>),
}

impl From<HashMap<String, Value>> for OneOfPullRequest12RequestedReviewersItems {
    fn from(value: HashMap<String, Value>) -> Self {
        OneOfPullRequest12RequestedReviewersItems::OneOfPullRequest12RequestedReviewersItemsVariant0(value)
    }
}

#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
#[serde(untagged)]
pub enum OneOfPullRequest13RequestedReviewersItems { 
    OneOfPullRequest13RequestedReviewersItemsVariant0(HashMap<String, Value>),
}

impl From<HashMap<String, Value>> for OneOfPullRequest13RequestedReviewersItems {
    fn from(value: HashMap<String, Value>) -> Self {
        OneOfPullRequest13RequestedReviewersItems::OneOfPullRequest13RequestedReviewersItemsVariant0(value)
    }
}

#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
#[serde(untagged)]
pub enum OneOfPullRequest1RequestedReviewersItems { 
    OneOfPullRequest1RequestedReviewersItemsVariant0(HashMap<String, Value>),
}

impl From<HashMap<String, Value>> for OneOfPullRequest1RequestedReviewersItems {
    fn from(value: HashMap<String, Value>) -> Self {
        OneOfPullRequest1RequestedReviewersItems::OneOfPullRequest1RequestedReviewersItemsVariant0(value)
    }
}

#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
#[serde(untagged)]
pub enum OneOfPullRequest2RequestedReviewersItems { 
    OneOfPullRequest2RequestedReviewersItemsVariant0(HashMap<String, Value>),
}

impl From<HashMap<String, Value>> for OneOfPullRequest2RequestedReviewersItems {
    fn from(value: HashMap<String, Value>) -> Self {
        OneOfPullRequest2RequestedReviewersItems::OneOfPullRequest2RequestedReviewersItemsVariant0(value)
    }
}

#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
#[serde(untagged)]
pub enum OneOfPullRequest3RequestedReviewersItems { 
    OneOfPullRequest3RequestedReviewersItemsVariant0(HashMap<String, Value>),
}

impl From<HashMap<String, Value>> for OneOfPullRequest3RequestedReviewersItems {
    fn from(value: HashMap<String, Value>) -> Self {
        OneOfPullRequest3RequestedReviewersItems::OneOfPullRequest3RequestedReviewersItemsVariant0(value)
    }
}

#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
#[serde(untagged)]
pub enum OneOfPullRequest4RequestedReviewersItems { 
    OneOfPullRequest4RequestedReviewersItemsVariant0(HashMap<String, Value>),
}

impl From<HashMap<String, Value>> for OneOfPullRequest4RequestedReviewersItems {
    fn from(value: HashMap<String, Value>) -> Self {
        OneOfPullRequest4RequestedReviewersItems::OneOfPullRequest4RequestedReviewersItemsVariant0(value)
    }
}

#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
#[serde(untagged)]
pub enum OneOfPullRequest5RequestedReviewersItems { 
    OneOfPullRequest5RequestedReviewersItemsVariant0(HashMap<String, Value>),
}

impl From<HashMap<String, Value>> for OneOfPullRequest5RequestedReviewersItems {
    fn from(value: HashMap<String, Value>) -> Self {
        OneOfPullRequest5RequestedReviewersItems::OneOfPullRequest5RequestedReviewersItemsVariant0(value)
    }
}

#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
#[serde(untagged)]
pub enum OneOfPullRequest6RequestedReviewersItems { 
    OneOfPullRequest6RequestedReviewersItemsVariant0(HashMap<String, Value>),
}

impl From<HashMap<String, Value>> for OneOfPullRequest6RequestedReviewersItems {
    fn from(value: HashMap<String, Value>) -> Self {
        OneOfPullRequest6RequestedReviewersItems::OneOfPullRequest6RequestedReviewersItemsVariant0(value)
    }
}

#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
#[serde(untagged)]
pub enum OneOfPullRequest7RequestedReviewersItems { 
    OneOfPullRequest7RequestedReviewersItemsVariant0(HashMap<String, Value>),
}

impl From<HashMap<String, Value>> for OneOfPullRequest7RequestedReviewersItems {
    fn from(value: HashMap<String, Value>) -> Self {
        OneOfPullRequest7RequestedReviewersItems::OneOfPullRequest7RequestedReviewersItemsVariant0(value)
    }
}

#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
#[serde(untagged)]
pub enum OneOfPullRequest8RequestedReviewersItems { 
    OneOfPullRequest8RequestedReviewersItemsVariant0(HashMap<String, Value>),
}

impl From<HashMap<String, Value>> for OneOfPullRequest8RequestedReviewersItems {
    fn from(value: HashMap<String, Value>) -> Self {
        OneOfPullRequest8RequestedReviewersItems::OneOfPullRequest8RequestedReviewersItemsVariant0(value)
    }
}

#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
#[serde(untagged)]
pub enum OneOfPullRequest9RequestedReviewersItems { 
    OneOfPullRequest9RequestedReviewersItemsVariant0(HashMap<String, Value>),
}

impl From<HashMap<String, Value>> for OneOfPullRequest9RequestedReviewersItems {
    fn from(value: HashMap<String, Value>) -> Self {
        OneOfPullRequest9RequestedReviewersItems::OneOfPullRequest9RequestedReviewersItemsVariant0(value)
    }
}

#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
#[serde(untagged)]
pub enum OneOfPullRequestRequestedReviewersItems { 
    OneOfPullRequestRequestedReviewersItemsVariant0(HashMap<String, Value>),
}

impl From<HashMap<String, Value>> for OneOfPullRequestRequestedReviewersItems {
    fn from(value: HashMap<String, Value>) -> Self {
        OneOfPullRequestRequestedReviewersItems::OneOfPullRequestRequestedReviewersItemsVariant0(value)
    }
}

#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
#[serde(untagged)]
pub enum OneOfRepository10CreatedAt { 
    OneOfRepository10CreatedAtVariant0(i32),
    OneOfRepository10CreatedAtVariant1(chrono::DateTime<chrono::Utc>),
}

impl From<i32> for OneOfRepository10CreatedAt {
    fn from(value: i32) -> Self {
        OneOfRepository10CreatedAt::OneOfRepository10CreatedAtVariant0(value)
    }
}

impl From<chrono::DateTime<chrono::Utc>> for OneOfRepository10CreatedAt {
    fn from(value: chrono::DateTime<chrono::Utc>) -> Self {
        OneOfRepository10CreatedAt::OneOfRepository10CreatedAtVariant1(value)
    }
}

#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
#[serde(untagged)]
pub enum OneOfRepository10PushedAt { 
    OneOfRepository10PushedAtVariant0(i32),
    OneOfRepository10PushedAtVariant1(chrono::DateTime<chrono::Utc>),
}

impl From<i32> for OneOfRepository10PushedAt {
    fn from(value: i32) -> Self {
        OneOfRepository10PushedAt::OneOfRepository10PushedAtVariant0(value)
    }
}

impl From<chrono::DateTime<chrono::Utc>> for OneOfRepository10PushedAt {
    fn from(value: chrono::DateTime<chrono::Utc>) -> Self {
        OneOfRepository10PushedAt::OneOfRepository10PushedAtVariant1(value)
    }
}

#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
#[serde(untagged)]
pub enum OneOfRepository11CreatedAt { 
    OneOfRepository11CreatedAtVariant0(i32),
    OneOfRepository11CreatedAtVariant1(chrono::DateTime<chrono::Utc>),
}

impl From<i32> for OneOfRepository11CreatedAt {
    fn from(value: i32) -> Self {
        OneOfRepository11CreatedAt::OneOfRepository11CreatedAtVariant0(value)
    }
}

impl From<chrono::DateTime<chrono::Utc>> for OneOfRepository11CreatedAt {
    fn from(value: chrono::DateTime<chrono::Utc>) -> Self {
        OneOfRepository11CreatedAt::OneOfRepository11CreatedAtVariant1(value)
    }
}

#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
#[serde(untagged)]
pub enum OneOfRepository11PushedAt { 
    OneOfRepository11PushedAtVariant0(i32),
    OneOfRepository11PushedAtVariant1(chrono::DateTime<chrono::Utc>),
}

impl From<i32> for OneOfRepository11PushedAt {
    fn from(value: i32) -> Self {
        OneOfRepository11PushedAt::OneOfRepository11PushedAtVariant0(value)
    }
}

impl From<chrono::DateTime<chrono::Utc>> for OneOfRepository11PushedAt {
    fn from(value: chrono::DateTime<chrono::Utc>) -> Self {
        OneOfRepository11PushedAt::OneOfRepository11PushedAtVariant1(value)
    }
}

#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
#[serde(untagged)]
pub enum OneOfRepository1CreatedAt { 
    OneOfRepository1CreatedAtVariant0(i32),
    OneOfRepository1CreatedAtVariant1(chrono::DateTime<chrono::Utc>),
}

impl From<i32> for OneOfRepository1CreatedAt {
    fn from(value: i32) -> Self {
        OneOfRepository1CreatedAt::OneOfRepository1CreatedAtVariant0(value)
    }
}

impl From<chrono::DateTime<chrono::Utc>> for OneOfRepository1CreatedAt {
    fn from(value: chrono::DateTime<chrono::Utc>) -> Self {
        OneOfRepository1CreatedAt::OneOfRepository1CreatedAtVariant1(value)
    }
}

#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
#[serde(untagged)]
pub enum OneOfRepository1PushedAt { 
    OneOfRepository1PushedAtVariant0(i32),
    OneOfRepository1PushedAtVariant1(chrono::DateTime<chrono::Utc>),
}

impl From<i32> for OneOfRepository1PushedAt {
    fn from(value: i32) -> Self {
        OneOfRepository1PushedAt::OneOfRepository1PushedAtVariant0(value)
    }
}

impl From<chrono::DateTime<chrono::Utc>> for OneOfRepository1PushedAt {
    fn from(value: chrono::DateTime<chrono::Utc>) -> Self {
        OneOfRepository1PushedAt::OneOfRepository1PushedAtVariant1(value)
    }
}

#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
#[serde(untagged)]
pub enum OneOfRepository2CreatedAt { 
    OneOfRepository2CreatedAtVariant0(i32),
    OneOfRepository2CreatedAtVariant1(chrono::DateTime<chrono::Utc>),
}

impl From<i32> for OneOfRepository2CreatedAt {
    fn from(value: i32) -> Self {
        OneOfRepository2CreatedAt::OneOfRepository2CreatedAtVariant0(value)
    }
}

impl From<chrono::DateTime<chrono::Utc>> for OneOfRepository2CreatedAt {
    fn from(value: chrono::DateTime<chrono::Utc>) -> Self {
        OneOfRepository2CreatedAt::OneOfRepository2CreatedAtVariant1(value)
    }
}

#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
#[serde(untagged)]
pub enum OneOfRepository2PushedAt { 
    OneOfRepository2PushedAtVariant0(i32),
    OneOfRepository2PushedAtVariant1(chrono::DateTime<chrono::Utc>),
}

impl From<i32> for OneOfRepository2PushedAt {
    fn from(value: i32) -> Self {
        OneOfRepository2PushedAt::OneOfRepository2PushedAtVariant0(value)
    }
}

impl From<chrono::DateTime<chrono::Utc>> for OneOfRepository2PushedAt {
    fn from(value: chrono::DateTime<chrono::Utc>) -> Self {
        OneOfRepository2PushedAt::OneOfRepository2PushedAtVariant1(value)
    }
}

#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
#[serde(untagged)]
pub enum OneOfRepository3CreatedAt { 
    OneOfRepository3CreatedAtVariant0(i32),
    OneOfRepository3CreatedAtVariant1(chrono::DateTime<chrono::Utc>),
}

impl From<i32> for OneOfRepository3CreatedAt {
    fn from(value: i32) -> Self {
        OneOfRepository3CreatedAt::OneOfRepository3CreatedAtVariant0(value)
    }
}

impl From<chrono::DateTime<chrono::Utc>> for OneOfRepository3CreatedAt {
    fn from(value: chrono::DateTime<chrono::Utc>) -> Self {
        OneOfRepository3CreatedAt::OneOfRepository3CreatedAtVariant1(value)
    }
}

#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
#[serde(untagged)]
pub enum OneOfRepository3PushedAt { 
    OneOfRepository3PushedAtVariant0(i32),
    OneOfRepository3PushedAtVariant1(chrono::DateTime<chrono::Utc>),
}

impl From<i32> for OneOfRepository3PushedAt {
    fn from(value: i32) -> Self {
        OneOfRepository3PushedAt::OneOfRepository3PushedAtVariant0(value)
    }
}

impl From<chrono::DateTime<chrono::Utc>> for OneOfRepository3PushedAt {
    fn from(value: chrono::DateTime<chrono::Utc>) -> Self {
        OneOfRepository3PushedAt::OneOfRepository3PushedAtVariant1(value)
    }
}

#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
#[serde(untagged)]
pub enum OneOfRepository4CreatedAt { 
    OneOfRepository4CreatedAtVariant0(i32),
    OneOfRepository4CreatedAtVariant1(chrono::DateTime<chrono::Utc>),
}

impl From<i32> for OneOfRepository4CreatedAt {
    fn from(value: i32) -> Self {
        OneOfRepository4CreatedAt::OneOfRepository4CreatedAtVariant0(value)
    }
}

impl From<chrono::DateTime<chrono::Utc>> for OneOfRepository4CreatedAt {
    fn from(value: chrono::DateTime<chrono::Utc>) -> Self {
        OneOfRepository4CreatedAt::OneOfRepository4CreatedAtVariant1(value)
    }
}

#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
#[serde(untagged)]
pub enum OneOfRepository4PushedAt { 
    OneOfRepository4PushedAtVariant0(i32),
    OneOfRepository4PushedAtVariant1(chrono::DateTime<chrono::Utc>),
}

impl From<i32> for OneOfRepository4PushedAt {
    fn from(value: i32) -> Self {
        OneOfRepository4PushedAt::OneOfRepository4PushedAtVariant0(value)
    }
}

impl From<chrono::DateTime<chrono::Utc>> for OneOfRepository4PushedAt {
    fn from(value: chrono::DateTime<chrono::Utc>) -> Self {
        OneOfRepository4PushedAt::OneOfRepository4PushedAtVariant1(value)
    }
}

#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
#[serde(untagged)]
pub enum OneOfRepository5CreatedAt { 
    OneOfRepository5CreatedAtVariant0(i32),
    OneOfRepository5CreatedAtVariant1(chrono::DateTime<chrono::Utc>),
}

impl From<i32> for OneOfRepository5CreatedAt {
    fn from(value: i32) -> Self {
        OneOfRepository5CreatedAt::OneOfRepository5CreatedAtVariant0(value)
    }
}

impl From<chrono::DateTime<chrono::Utc>> for OneOfRepository5CreatedAt {
    fn from(value: chrono::DateTime<chrono::Utc>) -> Self {
        OneOfRepository5CreatedAt::OneOfRepository5CreatedAtVariant1(value)
    }
}

#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
#[serde(untagged)]
pub enum OneOfRepository5PushedAt { 
    OneOfRepository5PushedAtVariant0(i32),
    OneOfRepository5PushedAtVariant1(chrono::DateTime<chrono::Utc>),
}

impl From<i32> for OneOfRepository5PushedAt {
    fn from(value: i32) -> Self {
        OneOfRepository5PushedAt::OneOfRepository5PushedAtVariant0(value)
    }
}

impl From<chrono::DateTime<chrono::Utc>> for OneOfRepository5PushedAt {
    fn from(value: chrono::DateTime<chrono::Utc>) -> Self {
        OneOfRepository5PushedAt::OneOfRepository5PushedAtVariant1(value)
    }
}

#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
#[serde(untagged)]
pub enum OneOfRepository6CreatedAt { 
    OneOfRepository6CreatedAtVariant0(i32),
    OneOfRepository6CreatedAtVariant1(chrono::DateTime<chrono::Utc>),
}

impl From<i32> for OneOfRepository6CreatedAt {
    fn from(value: i32) -> Self {
        OneOfRepository6CreatedAt::OneOfRepository6CreatedAtVariant0(value)
    }
}

impl From<chrono::DateTime<chrono::Utc>> for OneOfRepository6CreatedAt {
    fn from(value: chrono::DateTime<chrono::Utc>) -> Self {
        OneOfRepository6CreatedAt::OneOfRepository6CreatedAtVariant1(value)
    }
}

#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
#[serde(untagged)]
pub enum OneOfRepository6PushedAt { 
    OneOfRepository6PushedAtVariant0(i32),
    OneOfRepository6PushedAtVariant1(chrono::DateTime<chrono::Utc>),
}

impl From<i32> for OneOfRepository6PushedAt {
    fn from(value: i32) -> Self {
        OneOfRepository6PushedAt::OneOfRepository6PushedAtVariant0(value)
    }
}

impl From<chrono::DateTime<chrono::Utc>> for OneOfRepository6PushedAt {
    fn from(value: chrono::DateTime<chrono::Utc>) -> Self {
        OneOfRepository6PushedAt::OneOfRepository6PushedAtVariant1(value)
    }
}

#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
#[serde(untagged)]
pub enum OneOfRepository7CreatedAt { 
    OneOfRepository7CreatedAtVariant0(i32),
    OneOfRepository7CreatedAtVariant1(chrono::DateTime<chrono::Utc>),
}

impl From<i32> for OneOfRepository7CreatedAt {
    fn from(value: i32) -> Self {
        OneOfRepository7CreatedAt::OneOfRepository7CreatedAtVariant0(value)
    }
}

impl From<chrono::DateTime<chrono::Utc>> for OneOfRepository7CreatedAt {
    fn from(value: chrono::DateTime<chrono::Utc>) -> Self {
        OneOfRepository7CreatedAt::OneOfRepository7CreatedAtVariant1(value)
    }
}

#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
#[serde(untagged)]
pub enum OneOfRepository7PushedAt { 
    OneOfRepository7PushedAtVariant0(i32),
    OneOfRepository7PushedAtVariant1(chrono::DateTime<chrono::Utc>),
}

impl From<i32> for OneOfRepository7PushedAt {
    fn from(value: i32) -> Self {
        OneOfRepository7PushedAt::OneOfRepository7PushedAtVariant0(value)
    }
}

impl From<chrono::DateTime<chrono::Utc>> for OneOfRepository7PushedAt {
    fn from(value: chrono::DateTime<chrono::Utc>) -> Self {
        OneOfRepository7PushedAt::OneOfRepository7PushedAtVariant1(value)
    }
}

#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
#[serde(untagged)]
pub enum OneOfRepository8CreatedAt { 
    OneOfRepository8CreatedAtVariant0(i32),
    OneOfRepository8CreatedAtVariant1(chrono::DateTime<chrono::Utc>),
}

impl From<i32> for OneOfRepository8CreatedAt {
    fn from(value: i32) -> Self {
        OneOfRepository8CreatedAt::OneOfRepository8CreatedAtVariant0(value)
    }
}

impl From<chrono::DateTime<chrono::Utc>> for OneOfRepository8CreatedAt {
    fn from(value: chrono::DateTime<chrono::Utc>) -> Self {
        OneOfRepository8CreatedAt::OneOfRepository8CreatedAtVariant1(value)
    }
}

#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
#[serde(untagged)]
pub enum OneOfRepository8PushedAt { 
    OneOfRepository8PushedAtVariant0(i32),
    OneOfRepository8PushedAtVariant1(chrono::DateTime<chrono::Utc>),
}

impl From<i32> for OneOfRepository8PushedAt {
    fn from(value: i32) -> Self {
        OneOfRepository8PushedAt::OneOfRepository8PushedAtVariant0(value)
    }
}

impl From<chrono::DateTime<chrono::Utc>> for OneOfRepository8PushedAt {
    fn from(value: chrono::DateTime<chrono::Utc>) -> Self {
        OneOfRepository8PushedAt::OneOfRepository8PushedAtVariant1(value)
    }
}

#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
#[serde(untagged)]
pub enum OneOfRepository9CreatedAt { 
    OneOfRepository9CreatedAtVariant0(i32),
    OneOfRepository9CreatedAtVariant1(chrono::DateTime<chrono::Utc>),
}

impl From<i32> for OneOfRepository9CreatedAt {
    fn from(value: i32) -> Self {
        OneOfRepository9CreatedAt::OneOfRepository9CreatedAtVariant0(value)
    }
}

impl From<chrono::DateTime<chrono::Utc>> for OneOfRepository9CreatedAt {
    fn from(value: chrono::DateTime<chrono::Utc>) -> Self {
        OneOfRepository9CreatedAt::OneOfRepository9CreatedAtVariant1(value)
    }
}

#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
#[serde(untagged)]
pub enum OneOfRepository9PushedAt { 
    OneOfRepository9PushedAtVariant0(i32),
    OneOfRepository9PushedAtVariant1(chrono::DateTime<chrono::Utc>),
}

impl From<i32> for OneOfRepository9PushedAt {
    fn from(value: i32) -> Self {
        OneOfRepository9PushedAt::OneOfRepository9PushedAtVariant0(value)
    }
}

impl From<chrono::DateTime<chrono::Utc>> for OneOfRepository9PushedAt {
    fn from(value: chrono::DateTime<chrono::Utc>) -> Self {
        OneOfRepository9PushedAt::OneOfRepository9PushedAtVariant1(value)
    }
}

#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
#[serde(untagged)]
pub enum OneOfRepositoryCreatedAt { 
    OneOfRepositoryCreatedAtVariant0(i32),
    OneOfRepositoryCreatedAtVariant1(chrono::DateTime<chrono::Utc>),
}

impl From<i32> for OneOfRepositoryCreatedAt {
    fn from(value: i32) -> Self {
        OneOfRepositoryCreatedAt::OneOfRepositoryCreatedAtVariant0(value)
    }
}

impl From<chrono::DateTime<chrono::Utc>> for OneOfRepositoryCreatedAt {
    fn from(value: chrono::DateTime<chrono::Utc>) -> Self {
        OneOfRepositoryCreatedAt::OneOfRepositoryCreatedAtVariant1(value)
    }
}

#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
#[serde(untagged)]
pub enum OneOfRepositoryPushedAt { 
    OneOfRepositoryPushedAtVariant0(i32),
    OneOfRepositoryPushedAtVariant1(chrono::DateTime<chrono::Utc>),
}

impl From<i32> for OneOfRepositoryPushedAt {
    fn from(value: i32) -> Self {
        OneOfRepositoryPushedAt::OneOfRepositoryPushedAtVariant0(value)
    }
}

impl From<chrono::DateTime<chrono::Utc>> for OneOfRepositoryPushedAt {
    fn from(value: chrono::DateTime<chrono::Utc>) -> Self {
        OneOfRepositoryPushedAt::OneOfRepositoryPushedAtVariant1(value)
    }
}

#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
#[serde(untagged)]
pub enum OneOfSimplePullRequest1RequestedReviewersItems { 
    OneOfSimplePullRequest1RequestedReviewersItemsVariant0(HashMap<String, Value>),
}

impl From<HashMap<String, Value>> for OneOfSimplePullRequest1RequestedReviewersItems {
    fn from(value: HashMap<String, Value>) -> Self {
        OneOfSimplePullRequest1RequestedReviewersItems::OneOfSimplePullRequest1RequestedReviewersItemsVariant0(value)
    }
}

#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
#[serde(untagged)]
pub enum OneOfSimplePullRequest2RequestedReviewersItems { 
    OneOfSimplePullRequest2RequestedReviewersItemsVariant0(HashMap<String, Value>),
}

impl From<HashMap<String, Value>> for OneOfSimplePullRequest2RequestedReviewersItems {
    fn from(value: HashMap<String, Value>) -> Self {
        OneOfSimplePullRequest2RequestedReviewersItems::OneOfSimplePullRequest2RequestedReviewersItemsVariant0(value)
    }
}

#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
#[serde(untagged)]
pub enum OneOfSimplePullRequest3RequestedReviewersItems { 
    OneOfSimplePullRequest3RequestedReviewersItemsVariant0(HashMap<String, Value>),
}

impl From<HashMap<String, Value>> for OneOfSimplePullRequest3RequestedReviewersItems {
    fn from(value: HashMap<String, Value>) -> Self {
        OneOfSimplePullRequest3RequestedReviewersItems::OneOfSimplePullRequest3RequestedReviewersItemsVariant0(value)
    }
}

#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
#[serde(untagged)]
pub enum OneOfSimplePullRequest4RequestedReviewersItems { 
    OneOfSimplePullRequest4RequestedReviewersItemsVariant0(HashMap<String, Value>),
}

impl From<HashMap<String, Value>> for OneOfSimplePullRequest4RequestedReviewersItems {
    fn from(value: HashMap<String, Value>) -> Self {
        OneOfSimplePullRequest4RequestedReviewersItems::OneOfSimplePullRequest4RequestedReviewersItemsVariant0(value)
    }
}

#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
#[serde(untagged)]
pub enum OneOfSimplePullRequestRequestedReviewersItems { 
    OneOfSimplePullRequestRequestedReviewersItemsVariant0(HashMap<String, Value>),
}

impl From<HashMap<String, Value>> for OneOfSimplePullRequestRequestedReviewersItems {
    fn from(value: HashMap<String, Value>) -> Self {
        OneOfSimplePullRequestRequestedReviewersItems::OneOfSimplePullRequestRequestedReviewersItemsVariant0(value)
    }
}

#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
#[serde(untagged)]
pub enum OneOfbody11Public { 
    OneOfbody11PublicVariant0(bool),
    OneOfbody11PublicVariant1(String),
}

impl From<bool> for OneOfbody11Public {
    fn from(value: bool) -> Self {
        OneOfbody11Public::OneOfbody11PublicVariant0(value)
    }
}

impl From<String> for OneOfbody11Public {
    fn from(value: String) -> Self {
        OneOfbody11Public::OneOfbody11PublicVariant1(value)
    }
}

#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
#[serde(untagged)]
pub enum OneOfbody141Payload { 
    OneOfbody141PayloadVariant0(HashMap<String, HashMap<String, Value>>),
    OneOfbody141PayloadVariant1(String),
}

impl From<HashMap<String, HashMap<String, Value>>> for OneOfbody141Payload {
    fn from(value: HashMap<String, HashMap<String, Value>>) -> Self {
        OneOfbody141Payload::OneOfbody141PayloadVariant0(value)
    }
}

impl From<String> for OneOfbody141Payload {
    fn from(value: String) -> Self {
        OneOfbody141Payload::OneOfbody141PayloadVariant1(value)
    }
}

#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
#[serde(untagged)]
pub enum OneOfbody164LabelsItems { 
    OneOfbody164LabelsItemsVariant0(String),
    OneOfbody164LabelsItemsVariant1(HashMap<String, Value>),
}

impl From<String> for OneOfbody164LabelsItems {
    fn from(value: String) -> Self {
        OneOfbody164LabelsItems::OneOfbody164LabelsItemsVariant0(value)
    }
}

impl From<HashMap<String, Value>> for OneOfbody164LabelsItems {
    fn from(value: HashMap<String, Value>) -> Self {
        OneOfbody164LabelsItems::OneOfbody164LabelsItemsVariant1(value)
    }
}

#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
#[serde(untagged)]
pub enum OneOfbody164Milestone { 
    OneOfbody164MilestoneVariant0(String),
    OneOfbody164MilestoneVariant1(i32),
}

impl From<String> for OneOfbody164Milestone {
    fn from(value: String) -> Self {
        OneOfbody164Milestone::OneOfbody164MilestoneVariant0(value)
    }
}

impl From<i32> for OneOfbody164Milestone {
    fn from(value: i32) -> Self {
        OneOfbody164Milestone::OneOfbody164MilestoneVariant1(value)
    }
}

#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
#[serde(untagged)]
pub enum OneOfbody164Title { 
    OneOfbody164TitleVariant0(String),
    OneOfbody164TitleVariant1(i32),
}

impl From<String> for OneOfbody164Title {
    fn from(value: String) -> Self {
        OneOfbody164Title::OneOfbody164TitleVariant0(value)
    }
}

impl From<i32> for OneOfbody164Title {
    fn from(value: i32) -> Self {
        OneOfbody164Title::OneOfbody164TitleVariant1(value)
    }
}

#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
#[serde(untagged)]
pub enum OneOfbody167LabelsItems { 
    OneOfbody167LabelsItemsVariant0(String),
    OneOfbody167LabelsItemsVariant1(HashMap<String, Value>),
}

impl From<String> for OneOfbody167LabelsItems {
    fn from(value: String) -> Self {
        OneOfbody167LabelsItems::OneOfbody167LabelsItemsVariant0(value)
    }
}

impl From<HashMap<String, Value>> for OneOfbody167LabelsItems {
    fn from(value: HashMap<String, Value>) -> Self {
        OneOfbody167LabelsItems::OneOfbody167LabelsItemsVariant1(value)
    }
}

#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
#[serde(untagged)]
pub enum OneOfbody167Milestone { 
    OneOfbody167MilestoneVariant0(String),
    OneOfbody167MilestoneVariant1(i32),
}

impl From<String> for OneOfbody167Milestone {
    fn from(value: String) -> Self {
        OneOfbody167Milestone::OneOfbody167MilestoneVariant0(value)
    }
}

impl From<i32> for OneOfbody167Milestone {
    fn from(value: i32) -> Self {
        OneOfbody167Milestone::OneOfbody167MilestoneVariant1(value)
    }
}

#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
#[serde(untagged)]
pub enum OneOfbody167Title { 
    OneOfbody167TitleVariant0(String),
    OneOfbody167TitleVariant1(i32),
}

impl From<String> for OneOfbody167Title {
    fn from(value: String) -> Self {
        OneOfbody167Title::OneOfbody167TitleVariant0(value)
    }
}

impl From<i32> for OneOfbody167Title {
    fn from(value: i32) -> Self {
        OneOfbody167Title::OneOfbody167TitleVariant1(value)
    }
}

#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
#[serde(untagged)]
pub enum OneOfcopilotSeatDetailsAssigningTeam { 
    OneOfcopilotSeatDetailsAssigningTeamVariant0(Team),
    OneOfcopilotSeatDetailsAssigningTeamVariant1(EnterpriseTeam),
}

impl From<Team> for OneOfcopilotSeatDetailsAssigningTeam {
    fn from(value: Team) -> Self {
        OneOfcopilotSeatDetailsAssigningTeam::OneOfcopilotSeatDetailsAssigningTeamVariant0(value)
    }
}

impl From<EnterpriseTeam> for OneOfcopilotSeatDetailsAssigningTeam {
    fn from(value: EnterpriseTeam) -> Self {
        OneOfcopilotSeatDetailsAssigningTeam::OneOfcopilotSeatDetailsAssigningTeamVariant1(value)
    }
}

#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
#[serde(untagged)]
pub enum OneOfcustomPropertyDefaultValue { 
    OneOfcustomPropertyDefaultValueVariant0(String),
    OneOfcustomPropertyDefaultValueVariant1(Vec<String>),
}

impl From<String> for OneOfcustomPropertyDefaultValue {
    fn from(value: String) -> Self {
        OneOfcustomPropertyDefaultValue::OneOfcustomPropertyDefaultValueVariant0(value)
    }
}

impl From<Vec<String>> for OneOfcustomPropertyDefaultValue {
    fn from(value: Vec<String>) -> Self {
        OneOfcustomPropertyDefaultValue::OneOfcustomPropertyDefaultValueVariant1(value)
    }
}

#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
#[serde(untagged)]
pub enum OneOfcustomPropertySetPayloadDefaultValue { 
    OneOfcustomPropertySetPayloadDefaultValueVariant0(String),
    OneOfcustomPropertySetPayloadDefaultValueVariant1(Vec<String>),
}

impl From<String> for OneOfcustomPropertySetPayloadDefaultValue {
    fn from(value: String) -> Self {
        OneOfcustomPropertySetPayloadDefaultValue::OneOfcustomPropertySetPayloadDefaultValueVariant0(value)
    }
}

impl From<Vec<String>> for OneOfcustomPropertySetPayloadDefaultValue {
    fn from(value: Vec<String>) -> Self {
        OneOfcustomPropertySetPayloadDefaultValue::OneOfcustomPropertySetPayloadDefaultValueVariant1(value)
    }
}

#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
#[serde(untagged)]
pub enum OneOfcustomPropertyValueValue { 
    OneOfcustomPropertyValueValueVariant0(String),
    OneOfcustomPropertyValueValueVariant1(Vec<String>),
}

impl From<String> for OneOfcustomPropertyValueValue {
    fn from(value: String) -> Self {
        OneOfcustomPropertyValueValue::OneOfcustomPropertyValueValueVariant0(value)
    }
}

impl From<Vec<String>> for OneOfcustomPropertyValueValue {
    fn from(value: Vec<String>) -> Self {
        OneOfcustomPropertyValueValue::OneOfcustomPropertyValueValueVariant1(value)
    }
}

#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
#[serde(untagged)]
pub enum OneOfintegrationOwner { 
    OneOfintegrationOwnerVariant0(SimpleUser),
    OneOfintegrationOwnerVariant1(Enterprise),
}

impl From<SimpleUser> for OneOfintegrationOwner {
    fn from(value: SimpleUser) -> Self {
        OneOfintegrationOwner::OneOfintegrationOwnerVariant0(value)
    }
}

impl From<Enterprise> for OneOfintegrationOwner {
    fn from(value: Enterprise) -> Self {
        OneOfintegrationOwner::OneOfintegrationOwnerVariant1(value)
    }
}

#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
#[serde(untagged)]
pub enum OneOfnullableIntegrationOwner { 
    OneOfnullableIntegrationOwnerVariant0(SimpleUser),
    OneOfnullableIntegrationOwnerVariant1(Enterprise),
}

impl From<SimpleUser> for OneOfnullableIntegrationOwner {
    fn from(value: SimpleUser) -> Self {
        OneOfnullableIntegrationOwner::OneOfnullableIntegrationOwnerVariant0(value)
    }
}

impl From<Enterprise> for OneOfnullableIntegrationOwner {
    fn from(value: Enterprise) -> Self {
        OneOfnullableIntegrationOwner::OneOfnullableIntegrationOwnerVariant1(value)
    }
}

#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
#[serde(untagged)]
pub enum OneOfnullableIssueLabelsItems { 
    OneOfnullableIssueLabelsItemsVariant0(String),
    OneOfnullableIssueLabelsItemsVariant1(HashMap<String, Value>),
}

impl From<String> for OneOfnullableIssueLabelsItems {
    fn from(value: String) -> Self {
        OneOfnullableIssueLabelsItems::OneOfnullableIssueLabelsItemsVariant0(value)
    }
}

impl From<HashMap<String, Value>> for OneOfnullableIssueLabelsItems {
    fn from(value: HashMap<String, Value>) -> Self {
        OneOfnullableIssueLabelsItems::OneOfnullableIssueLabelsItemsVariant1(value)
    }
}

#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
#[serde(untagged)]
pub enum OneOfpageDeploymentId { 
    OneOfpageDeploymentIdVariant0(i32),
    OneOfpageDeploymentIdVariant1(String),
}

impl From<i32> for OneOfpageDeploymentId {
    fn from(value: i32) -> Self {
        OneOfpageDeploymentId::OneOfpageDeploymentIdVariant0(value)
    }
}

impl From<String> for OneOfpageDeploymentId {
    fn from(value: String) -> Self {
        OneOfpageDeploymentId::OneOfpageDeploymentIdVariant1(value)
    }
}

#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
#[serde(untagged)]
pub enum OneOfsecretScanningLocationDetails { 
    OneOfsecretScanningLocationDetailsVariant0(SecretScanningLocationCommit),
    OneOfsecretScanningLocationDetailsVariant1(SecretScanningLocationWikiCommit),
    OneOfsecretScanningLocationDetailsVariant2(SecretScanningLocationIssueTitle),
    OneOfsecretScanningLocationDetailsVariant3(SecretScanningLocationIssueBody),
    OneOfsecretScanningLocationDetailsVariant4(SecretScanningLocationIssueComment),
    OneOfsecretScanningLocationDetailsVariant5(SecretScanningLocationDiscussionTitle),
    OneOfsecretScanningLocationDetailsVariant6(SecretScanningLocationDiscussionBody),
    OneOfsecretScanningLocationDetailsVariant7(SecretScanningLocationDiscussionComment),
    OneOfsecretScanningLocationDetailsVariant8(SecretScanningLocationPullRequestTitle),
    OneOfsecretScanningLocationDetailsVariant9(SecretScanningLocationPullRequestBody),
    OneOfsecretScanningLocationDetailsVariant10(SecretScanningLocationPullRequestComment),
    OneOfsecretScanningLocationDetailsVariant11(SecretScanningLocationPullRequestReview),
    OneOfsecretScanningLocationDetailsVariant12(SecretScanningLocationPullRequestReviewComment),
}

impl From<SecretScanningLocationCommit> for OneOfsecretScanningLocationDetails {
    fn from(value: SecretScanningLocationCommit) -> Self {
        OneOfsecretScanningLocationDetails::OneOfsecretScanningLocationDetailsVariant0(value)
    }
}

impl From<SecretScanningLocationWikiCommit> for OneOfsecretScanningLocationDetails {
    fn from(value: SecretScanningLocationWikiCommit) -> Self {
        OneOfsecretScanningLocationDetails::OneOfsecretScanningLocationDetailsVariant1(value)
    }
}

impl From<SecretScanningLocationIssueTitle> for OneOfsecretScanningLocationDetails {
    fn from(value: SecretScanningLocationIssueTitle) -> Self {
        OneOfsecretScanningLocationDetails::OneOfsecretScanningLocationDetailsVariant2(value)
    }
}

impl From<SecretScanningLocationIssueBody> for OneOfsecretScanningLocationDetails {
    fn from(value: SecretScanningLocationIssueBody) -> Self {
        OneOfsecretScanningLocationDetails::OneOfsecretScanningLocationDetailsVariant3(value)
    }
}

impl From<SecretScanningLocationIssueComment> for OneOfsecretScanningLocationDetails {
    fn from(value: SecretScanningLocationIssueComment) -> Self {
        OneOfsecretScanningLocationDetails::OneOfsecretScanningLocationDetailsVariant4(value)
    }
}

impl From<SecretScanningLocationDiscussionTitle> for OneOfsecretScanningLocationDetails {
    fn from(value: SecretScanningLocationDiscussionTitle) -> Self {
        OneOfsecretScanningLocationDetails::OneOfsecretScanningLocationDetailsVariant5(value)
    }
}

impl From<SecretScanningLocationDiscussionBody> for OneOfsecretScanningLocationDetails {
    fn from(value: SecretScanningLocationDiscussionBody) -> Self {
        OneOfsecretScanningLocationDetails::OneOfsecretScanningLocationDetailsVariant6(value)
    }
}

impl From<SecretScanningLocationDiscussionComment> for OneOfsecretScanningLocationDetails {
    fn from(value: SecretScanningLocationDiscussionComment) -> Self {
        OneOfsecretScanningLocationDetails::OneOfsecretScanningLocationDetailsVariant7(value)
    }
}

impl From<SecretScanningLocationPullRequestTitle> for OneOfsecretScanningLocationDetails {
    fn from(value: SecretScanningLocationPullRequestTitle) -> Self {
        OneOfsecretScanningLocationDetails::OneOfsecretScanningLocationDetailsVariant8(value)
    }
}

impl From<SecretScanningLocationPullRequestBody> for OneOfsecretScanningLocationDetails {
    fn from(value: SecretScanningLocationPullRequestBody) -> Self {
        OneOfsecretScanningLocationDetails::OneOfsecretScanningLocationDetailsVariant9(value)
    }
}

impl From<SecretScanningLocationPullRequestComment> for OneOfsecretScanningLocationDetails {
    fn from(value: SecretScanningLocationPullRequestComment) -> Self {
        OneOfsecretScanningLocationDetails::OneOfsecretScanningLocationDetailsVariant10(value)
    }
}

impl From<SecretScanningLocationPullRequestReview> for OneOfsecretScanningLocationDetails {
    fn from(value: SecretScanningLocationPullRequestReview) -> Self {
        OneOfsecretScanningLocationDetails::OneOfsecretScanningLocationDetailsVariant11(value)
    }
}

impl From<SecretScanningLocationPullRequestReviewComment> for OneOfsecretScanningLocationDetails {
    fn from(value: SecretScanningLocationPullRequestReviewComment) -> Self {
        OneOfsecretScanningLocationDetails::OneOfsecretScanningLocationDetailsVariant12(value)
    }
}

#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
#[serde(untagged)]
pub enum OneOfvalidationerrorErrorsValue { 
    OneOfvalidationerrorErrorsValueVariant0(String),
    OneOfvalidationerrorErrorsValueVariant1(i32),
    OneOfvalidationerrorErrorsValueVariant2(Vec<String>),
}

impl From<String> for OneOfvalidationerrorErrorsValue {
    fn from(value: String) -> Self {
        OneOfvalidationerrorErrorsValue::OneOfvalidationerrorErrorsValueVariant0(value)
    }
}

impl From<i32> for OneOfvalidationerrorErrorsValue {
    fn from(value: i32) -> Self {
        OneOfvalidationerrorErrorsValue::OneOfvalidationerrorErrorsValueVariant1(value)
    }
}

impl From<Vec<String>> for OneOfvalidationerrorErrorsValue {
    fn from(value: Vec<String>) -> Self {
        OneOfvalidationerrorErrorsValue::OneOfvalidationerrorErrorsValueVariant2(value)
    }
}

#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
#[serde(untagged)]
pub enum OneOfwebhookProjectsV2ItemEditedChanges { 
    OneOfwebhookProjectsV2ItemEditedChangesVariant0(HashMap<String, Value>),
}

impl From<HashMap<String, Value>> for OneOfwebhookProjectsV2ItemEditedChanges {
    fn from(value: HashMap<String, Value>) -> Self {
        OneOfwebhookProjectsV2ItemEditedChanges::OneOfwebhookProjectsV2ItemEditedChangesVariant0(value)
    }
}

#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
#[serde(untagged)]
pub enum OneOfwebhookpackagepublishedPackagePackageVersionBody { 
    OneOfwebhookpackagepublishedPackagePackageVersionBodyVariant0(String),
    OneOfwebhookpackagepublishedPackagePackageVersionBodyVariant1(HashMap<String, Value>),
}

impl From<String> for OneOfwebhookpackagepublishedPackagePackageVersionBody {
    fn from(value: String) -> Self {
        OneOfwebhookpackagepublishedPackagePackageVersionBody::OneOfwebhookpackagepublishedPackagePackageVersionBodyVariant0(value)
    }
}

impl From<HashMap<String, Value>> for OneOfwebhookpackagepublishedPackagePackageVersionBody {
    fn from(value: HashMap<String, Value>) -> Self {
        OneOfwebhookpackagepublishedPackagePackageVersionBody::OneOfwebhookpackagepublishedPackagePackageVersionBodyVariant1(value)
    }
}

#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
#[serde(untagged)]
pub enum OneOfwebhookpackagepublishedPackagePackageVersionNugetMetadataId { 
    OneOfwebhookpackagepublishedPackagePackageVersionNugetMetadataIdVariant0(i32),
    OneOfwebhookpackagepublishedPackagePackageVersionNugetMetadataIdVariant1(String),
}

impl From<i32> for OneOfwebhookpackagepublishedPackagePackageVersionNugetMetadataId {
    fn from(value: i32) -> Self {
        OneOfwebhookpackagepublishedPackagePackageVersionNugetMetadataId::OneOfwebhookpackagepublishedPackagePackageVersionNugetMetadataIdVariant0(value)
    }
}

impl From<String> for OneOfwebhookpackagepublishedPackagePackageVersionNugetMetadataId {
    fn from(value: String) -> Self {
        OneOfwebhookpackagepublishedPackagePackageVersionNugetMetadataId::OneOfwebhookpackagepublishedPackagePackageVersionNugetMetadataIdVariant1(value)
    }
}

#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
#[serde(untagged)]
pub enum OneOfwebhookpackagepublishedPackagePackageVersionNugetMetadataValue { 
    OneOfwebhookpackagepublishedPackagePackageVersionNugetMetadataValueVariant0(bool),
    OneOfwebhookpackagepublishedPackagePackageVersionNugetMetadataValueVariant1(String),
    OneOfwebhookpackagepublishedPackagePackageVersionNugetMetadataValueVariant2(i32),
    OneOfwebhookpackagepublishedPackagePackageVersionNugetMetadataValueVariant3(HashMap<String, Value>),
}

impl From<bool> for OneOfwebhookpackagepublishedPackagePackageVersionNugetMetadataValue {
    fn from(value: bool) -> Self {
        OneOfwebhookpackagepublishedPackagePackageVersionNugetMetadataValue::OneOfwebhookpackagepublishedPackagePackageVersionNugetMetadataValueVariant0(value)
    }
}

impl From<String> for OneOfwebhookpackagepublishedPackagePackageVersionNugetMetadataValue {
    fn from(value: String) -> Self {
        OneOfwebhookpackagepublishedPackagePackageVersionNugetMetadataValue::OneOfwebhookpackagepublishedPackagePackageVersionNugetMetadataValueVariant1(value)
    }
}

impl From<i32> for OneOfwebhookpackagepublishedPackagePackageVersionNugetMetadataValue {
    fn from(value: i32) -> Self {
        OneOfwebhookpackagepublishedPackagePackageVersionNugetMetadataValue::OneOfwebhookpackagepublishedPackagePackageVersionNugetMetadataValueVariant2(value)
    }
}

impl From<HashMap<String, Value>> for OneOfwebhookpackagepublishedPackagePackageVersionNugetMetadataValue {
    fn from(value: HashMap<String, Value>) -> Self {
        OneOfwebhookpackagepublishedPackagePackageVersionNugetMetadataValue::OneOfwebhookpackagepublishedPackagePackageVersionNugetMetadataValueVariant3(value)
    }
}

#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
#[serde(untagged)]
pub enum OneOfwebhookpullrequestreviewcommentcreatedPullRequestRequestedReviewersItems { 
    OneOfwebhookpullrequestreviewcommentcreatedPullRequestRequestedReviewersItemsVariant0(HashMap<String, Value>),
}

impl From<HashMap<String, Value>> for OneOfwebhookpullrequestreviewcommentcreatedPullRequestRequestedReviewersItems {
    fn from(value: HashMap<String, Value>) -> Self {
        OneOfwebhookpullrequestreviewcommentcreatedPullRequestRequestedReviewersItems::OneOfwebhookpullrequestreviewcommentcreatedPullRequestRequestedReviewersItemsVariant0(value)
    }
}

#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
#[serde(untagged)]
pub enum OneOfwebhookpullrequestreviewcommentdeletedPullRequestRequestedReviewersItems { 
    OneOfwebhookpullrequestreviewcommentdeletedPullRequestRequestedReviewersItemsVariant0(HashMap<String, Value>),
}

impl From<HashMap<String, Value>> for OneOfwebhookpullrequestreviewcommentdeletedPullRequestRequestedReviewersItems {
    fn from(value: HashMap<String, Value>) -> Self {
        OneOfwebhookpullrequestreviewcommentdeletedPullRequestRequestedReviewersItems::OneOfwebhookpullrequestreviewcommentdeletedPullRequestRequestedReviewersItemsVariant0(value)
    }
}

#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
#[serde(untagged)]
pub enum OneOfwebhookpullrequestreviewcommenteditedPullRequestRequestedReviewersItems { 
    OneOfwebhookpullrequestreviewcommenteditedPullRequestRequestedReviewersItemsVariant0(HashMap<String, Value>),
}

impl From<HashMap<String, Value>> for OneOfwebhookpullrequestreviewcommenteditedPullRequestRequestedReviewersItems {
    fn from(value: HashMap<String, Value>) -> Self {
        OneOfwebhookpullrequestreviewcommenteditedPullRequestRequestedReviewersItems::OneOfwebhookpullrequestreviewcommenteditedPullRequestRequestedReviewersItemsVariant0(value)
    }
}

#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
#[serde(untagged)]
pub enum OneOfwebhookregistrypackagepublishedRegistryPackagePackageVersionBody { 
    OneOfwebhookregistrypackagepublishedRegistryPackagePackageVersionBodyVariant0(String),
    OneOfwebhookregistrypackagepublishedRegistryPackagePackageVersionBodyVariant1(HashMap<String, Value>),
}

impl From<String> for OneOfwebhookregistrypackagepublishedRegistryPackagePackageVersionBody {
    fn from(value: String) -> Self {
        OneOfwebhookregistrypackagepublishedRegistryPackagePackageVersionBody::OneOfwebhookregistrypackagepublishedRegistryPackagePackageVersionBodyVariant0(value)
    }
}

impl From<HashMap<String, Value>> for OneOfwebhookregistrypackagepublishedRegistryPackagePackageVersionBody {
    fn from(value: HashMap<String, Value>) -> Self {
        OneOfwebhookregistrypackagepublishedRegistryPackagePackageVersionBody::OneOfwebhookregistrypackagepublishedRegistryPackagePackageVersionBodyVariant1(value)
    }
}

#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
#[serde(untagged)]
pub enum OneOfwebhookregistrypackagepublishedRegistryPackagePackageVersionNpmMetadataAuthor { 
    OneOfwebhookregistrypackagepublishedRegistryPackagePackageVersionNpmMetadataAuthorVariant0(String),
    OneOfwebhookregistrypackagepublishedRegistryPackagePackageVersionNpmMetadataAuthorVariant1(HashMap<String, Value>),
}

impl From<String> for OneOfwebhookregistrypackagepublishedRegistryPackagePackageVersionNpmMetadataAuthor {
    fn from(value: String) -> Self {
        OneOfwebhookregistrypackagepublishedRegistryPackagePackageVersionNpmMetadataAuthor::OneOfwebhookregistrypackagepublishedRegistryPackagePackageVersionNpmMetadataAuthorVariant0(value)
    }
}

impl From<HashMap<String, Value>> for OneOfwebhookregistrypackagepublishedRegistryPackagePackageVersionNpmMetadataAuthor {
    fn from(value: HashMap<String, Value>) -> Self {
        OneOfwebhookregistrypackagepublishedRegistryPackagePackageVersionNpmMetadataAuthor::OneOfwebhookregistrypackagepublishedRegistryPackagePackageVersionNpmMetadataAuthorVariant1(value)
    }
}

#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
#[serde(untagged)]
pub enum OneOfwebhookregistrypackagepublishedRegistryPackagePackageVersionNpmMetadataBugs { 
    OneOfwebhookregistrypackagepublishedRegistryPackagePackageVersionNpmMetadataBugsVariant0(String),
    OneOfwebhookregistrypackagepublishedRegistryPackagePackageVersionNpmMetadataBugsVariant1(HashMap<String, Value>),
}

impl From<String> for OneOfwebhookregistrypackagepublishedRegistryPackagePackageVersionNpmMetadataBugs {
    fn from(value: String) -> Self {
        OneOfwebhookregistrypackagepublishedRegistryPackagePackageVersionNpmMetadataBugs::OneOfwebhookregistrypackagepublishedRegistryPackagePackageVersionNpmMetadataBugsVariant0(value)
    }
}

impl From<HashMap<String, Value>> for OneOfwebhookregistrypackagepublishedRegistryPackagePackageVersionNpmMetadataBugs {
    fn from(value: HashMap<String, Value>) -> Self {
        OneOfwebhookregistrypackagepublishedRegistryPackagePackageVersionNpmMetadataBugs::OneOfwebhookregistrypackagepublishedRegistryPackagePackageVersionNpmMetadataBugsVariant1(value)
    }
}

#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
#[serde(untagged)]
pub enum OneOfwebhookregistrypackagepublishedRegistryPackagePackageVersionNpmMetadataDirectories { 
    OneOfwebhookregistrypackagepublishedRegistryPackagePackageVersionNpmMetadataDirectoriesVariant0(String),
    OneOfwebhookregistrypackagepublishedRegistryPackagePackageVersionNpmMetadataDirectoriesVariant1(HashMap<String, Value>),
}

impl From<String> for OneOfwebhookregistrypackagepublishedRegistryPackagePackageVersionNpmMetadataDirectories {
    fn from(value: String) -> Self {
        OneOfwebhookregistrypackagepublishedRegistryPackagePackageVersionNpmMetadataDirectories::OneOfwebhookregistrypackagepublishedRegistryPackagePackageVersionNpmMetadataDirectoriesVariant0(value)
    }
}

impl From<HashMap<String, Value>> for OneOfwebhookregistrypackagepublishedRegistryPackagePackageVersionNpmMetadataDirectories {
    fn from(value: HashMap<String, Value>) -> Self {
        OneOfwebhookregistrypackagepublishedRegistryPackagePackageVersionNpmMetadataDirectories::OneOfwebhookregistrypackagepublishedRegistryPackagePackageVersionNpmMetadataDirectoriesVariant1(value)
    }
}

#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
#[serde(untagged)]
pub enum OneOfwebhookregistrypackagepublishedRegistryPackagePackageVersionNpmMetadataDist { 
    OneOfwebhookregistrypackagepublishedRegistryPackagePackageVersionNpmMetadataDistVariant0(String),
    OneOfwebhookregistrypackagepublishedRegistryPackagePackageVersionNpmMetadataDistVariant1(HashMap<String, Value>),
}

impl From<String> for OneOfwebhookregistrypackagepublishedRegistryPackagePackageVersionNpmMetadataDist {
    fn from(value: String) -> Self {
        OneOfwebhookregistrypackagepublishedRegistryPackagePackageVersionNpmMetadataDist::OneOfwebhookregistrypackagepublishedRegistryPackagePackageVersionNpmMetadataDistVariant0(value)
    }
}

impl From<HashMap<String, Value>> for OneOfwebhookregistrypackagepublishedRegistryPackagePackageVersionNpmMetadataDist {
    fn from(value: HashMap<String, Value>) -> Self {
        OneOfwebhookregistrypackagepublishedRegistryPackagePackageVersionNpmMetadataDist::OneOfwebhookregistrypackagepublishedRegistryPackagePackageVersionNpmMetadataDistVariant1(value)
    }
}

#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
#[serde(untagged)]
pub enum OneOfwebhookregistrypackagepublishedRegistryPackagePackageVersionNpmMetadataRepository { 
    OneOfwebhookregistrypackagepublishedRegistryPackagePackageVersionNpmMetadataRepositoryVariant0(String),
    OneOfwebhookregistrypackagepublishedRegistryPackagePackageVersionNpmMetadataRepositoryVariant1(HashMap<String, Value>),
}

impl From<String> for OneOfwebhookregistrypackagepublishedRegistryPackagePackageVersionNpmMetadataRepository {
    fn from(value: String) -> Self {
        OneOfwebhookregistrypackagepublishedRegistryPackagePackageVersionNpmMetadataRepository::OneOfwebhookregistrypackagepublishedRegistryPackagePackageVersionNpmMetadataRepositoryVariant0(value)
    }
}

impl From<HashMap<String, Value>> for OneOfwebhookregistrypackagepublishedRegistryPackagePackageVersionNpmMetadataRepository {
    fn from(value: HashMap<String, Value>) -> Self {
        OneOfwebhookregistrypackagepublishedRegistryPackagePackageVersionNpmMetadataRepository::OneOfwebhookregistrypackagepublishedRegistryPackagePackageVersionNpmMetadataRepositoryVariant1(value)
    }
}

#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
#[serde(untagged)]
pub enum OneOfwebhookregistrypackagepublishedRegistryPackagePackageVersionNugetMetadataId { 
    OneOfwebhookregistrypackagepublishedRegistryPackagePackageVersionNugetMetadataIdVariant0(String),
    OneOfwebhookregistrypackagepublishedRegistryPackagePackageVersionNugetMetadataIdVariant1(HashMap<String, Value>),
    OneOfwebhookregistrypackagepublishedRegistryPackagePackageVersionNugetMetadataIdVariant2(i32),
}

impl From<String> for OneOfwebhookregistrypackagepublishedRegistryPackagePackageVersionNugetMetadataId {
    fn from(value: String) -> Self {
        OneOfwebhookregistrypackagepublishedRegistryPackagePackageVersionNugetMetadataId::OneOfwebhookregistrypackagepublishedRegistryPackagePackageVersionNugetMetadataIdVariant0(value)
    }
}

impl From<HashMap<String, Value>> for OneOfwebhookregistrypackagepublishedRegistryPackagePackageVersionNugetMetadataId {
    fn from(value: HashMap<String, Value>) -> Self {
        OneOfwebhookregistrypackagepublishedRegistryPackagePackageVersionNugetMetadataId::OneOfwebhookregistrypackagepublishedRegistryPackagePackageVersionNugetMetadataIdVariant1(value)
    }
}

impl From<i32> for OneOfwebhookregistrypackagepublishedRegistryPackagePackageVersionNugetMetadataId {
    fn from(value: i32) -> Self {
        OneOfwebhookregistrypackagepublishedRegistryPackagePackageVersionNugetMetadataId::OneOfwebhookregistrypackagepublishedRegistryPackagePackageVersionNugetMetadataIdVariant2(value)
    }
}

#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
#[serde(untagged)]
pub enum OneOfwebhookregistrypackagepublishedRegistryPackagePackageVersionNugetMetadataValue { 
    OneOfwebhookregistrypackagepublishedRegistryPackagePackageVersionNugetMetadataValueVariant0(bool),
    OneOfwebhookregistrypackagepublishedRegistryPackagePackageVersionNugetMetadataValueVariant1(String),
    OneOfwebhookregistrypackagepublishedRegistryPackagePackageVersionNugetMetadataValueVariant2(i32),
    OneOfwebhookregistrypackagepublishedRegistryPackagePackageVersionNugetMetadataValueVariant3(HashMap<String, Value>),
}

impl From<bool> for OneOfwebhookregistrypackagepublishedRegistryPackagePackageVersionNugetMetadataValue {
    fn from(value: bool) -> Self {
        OneOfwebhookregistrypackagepublishedRegistryPackagePackageVersionNugetMetadataValue::OneOfwebhookregistrypackagepublishedRegistryPackagePackageVersionNugetMetadataValueVariant0(value)
    }
}

impl From<String> for OneOfwebhookregistrypackagepublishedRegistryPackagePackageVersionNugetMetadataValue {
    fn from(value: String) -> Self {
        OneOfwebhookregistrypackagepublishedRegistryPackagePackageVersionNugetMetadataValue::OneOfwebhookregistrypackagepublishedRegistryPackagePackageVersionNugetMetadataValueVariant1(value)
    }
}

impl From<i32> for OneOfwebhookregistrypackagepublishedRegistryPackagePackageVersionNugetMetadataValue {
    fn from(value: i32) -> Self {
        OneOfwebhookregistrypackagepublishedRegistryPackagePackageVersionNugetMetadataValue::OneOfwebhookregistrypackagepublishedRegistryPackagePackageVersionNugetMetadataValueVariant2(value)
    }
}

impl From<HashMap<String, Value>> for OneOfwebhookregistrypackagepublishedRegistryPackagePackageVersionNugetMetadataValue {
    fn from(value: HashMap<String, Value>) -> Self {
        OneOfwebhookregistrypackagepublishedRegistryPackagePackageVersionNugetMetadataValue::OneOfwebhookregistrypackagepublishedRegistryPackagePackageVersionNugetMetadataValueVariant3(value)
    }
}

#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
#[serde(untagged)]
pub enum OneOfwebhooksPullRequest5RequestedReviewersItems { 
    OneOfwebhooksPullRequest5RequestedReviewersItemsVariant0(HashMap<String, Value>),
}

impl From<HashMap<String, Value>> for OneOfwebhooksPullRequest5RequestedReviewersItems {
    fn from(value: HashMap<String, Value>) -> Self {
        OneOfwebhooksPullRequest5RequestedReviewersItems::OneOfwebhooksPullRequest5RequestedReviewersItemsVariant0(value)
    }
}

/// Org Hook
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct OrgHook {
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub ping_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub deliveries_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub events: Option<Vec<String>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub active: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub config: Option<OrghookConfig>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub updated_at: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(rename = "type")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub _type: Option<String>,
}

/// Org Membership
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct OrgMembership {
    #[serde(skip_serializing_if="Option::is_none")]
    pub url: Option<String>,
    /// The state of the member in the organization. The `pending` state indicates the user has not yet accepted an invitation.
    #[serde(skip_serializing_if="Option::is_none")]
    pub state: Option<String>,
    /// The user's membership type in the organization.
    #[serde(skip_serializing_if="Option::is_none")]
    pub role: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub organization_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub organization: Option<OrganizationSimple>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub user: Option<NullableSimpleUser>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub permissions: Option<OrgmembershipPermissions>,
}

/// Private registry configuration for an organization
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct OrgPrivateRegistryConfiguration {
    /// The name of the private registry configuration.
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,
    /// The registry type.
    #[serde(skip_serializing_if="Option::is_none")]
    pub registry_type: Option<String>,
    /// The username to use when authenticating with the private registry.
    #[serde(skip_serializing_if="Option::is_none")]
    pub username: Option<String>,
    /// Which type of organization repositories have access to the private registry.
    #[serde(skip_serializing_if="Option::is_none")]
    pub visibility: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub updated_at: Option<chrono::DateTime<chrono::Utc>>,
}

/// Private registry configuration for an organization
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct OrgPrivateRegistryConfigurationWithSelectedRepositories {
    /// The name of the private registry configuration.
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,
    /// The registry type.
    #[serde(skip_serializing_if="Option::is_none")]
    pub registry_type: Option<String>,
    /// The username to use when authenticating with the private registry.
    #[serde(skip_serializing_if="Option::is_none")]
    pub username: Option<String>,
    /// Which type of organization repositories have access to the private registry. `selected` means only the repositories specified by `selected_repository_ids` can access the private registry.
    #[serde(skip_serializing_if="Option::is_none")]
    pub visibility: Option<String>,
    /// An array of repository IDs that can access the organization private registry when `visibility` is set to `selected`.
    #[serde(skip_serializing_if="Option::is_none")]
    pub selected_repository_ids: Option<Vec<i32>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub updated_at: Option<chrono::DateTime<chrono::Utc>>,
}

/// List of custom property values for a repository
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct OrgRepoCustomPropertyValues {
    #[serde(skip_serializing_if="Option::is_none")]
    pub repository_id: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub repository_name: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub repository_full_name: Option<String>,
    /// List of custom property names and associated values
    #[serde(skip_serializing_if="Option::is_none")]
    pub properties: Option<Vec<CustomPropertyValue>>,
}

/// Conditions for an organization ruleset. The branch and tag rulesets conditions object should contain both `repository_name` and `ref_name` properties, or both `repository_id` and `ref_name` properties, or both `repository_property` and `ref_name` properties. The push rulesets conditions object does not require the `ref_name` property. For repository policy rulesets, the conditions object should only contain the `repository_name`, the `repository_id`, or the `repository_property`.
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
#[serde(untagged)]
pub enum OrgRulesetConditions { 
    OrgRulesetConditionsVariant0(Value),
}

impl From<Value> for OrgRulesetConditions {
    fn from(value: Value) -> Self {
        OrgRulesetConditions::OrgRulesetConditionsVariant0(value)
    }
}

impl Display for OrgRulesetConditions {
    fn fmt(&self, f: &mut Formatter) -> fmt::Result {
        match self { 
            OrgRulesetConditions::OrgRulesetConditionsVariant0(value) => write!(f, "{}", value),
        }
    }
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct Organization {
    #[serde(skip_serializing_if="Option::is_none")]
    pub avatar_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub description: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub events_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub hooks_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub html_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub issues_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub login: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub members_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub node_id: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub public_members_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub repos_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub url: Option<String>,
}

/// Secrets for GitHub Actions for an organization.
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct OrganizationActionsSecret {
    /// The name of the secret.
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub updated_at: Option<chrono::DateTime<chrono::Utc>>,
    /// Visibility of a secret
    #[serde(skip_serializing_if="Option::is_none")]
    pub visibility: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub selected_repositories_url: Option<String>,
}

/// Organization variable for GitHub Actions.
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct OrganizationActionsVariable {
    /// The name of the variable.
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,
    /// The value of the variable.
    #[serde(skip_serializing_if="Option::is_none")]
    pub value: Option<String>,
    /// The date and time at which the variable was created, in ISO 8601 format':' YYYY-MM-DDTHH:MM:SSZ.
    #[serde(skip_serializing_if="Option::is_none")]
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The date and time at which the variable was last updated, in ISO 8601 format':' YYYY-MM-DDTHH:MM:SSZ.
    #[serde(skip_serializing_if="Option::is_none")]
    pub updated_at: Option<chrono::DateTime<chrono::Utc>>,
    /// Visibility of a variable
    #[serde(skip_serializing_if="Option::is_none")]
    pub visibility: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub selected_repositories_url: Option<String>,
}

/// Secrets for GitHub Dependabot for an organization.
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct OrganizationDependabotSecret {
    /// The name of the secret.
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub updated_at: Option<chrono::DateTime<chrono::Utc>>,
    /// Visibility of a secret
    #[serde(skip_serializing_if="Option::is_none")]
    pub visibility: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub selected_repositories_url: Option<String>,
}

/// Organization Full
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct OrganizationFull {
    #[serde(skip_serializing_if="Option::is_none")]
    pub login: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub node_id: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub repos_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub events_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub hooks_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub issues_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub members_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub public_members_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub avatar_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub description: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub company: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub blog: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub location: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub email: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub twitter_username: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub is_verified: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub has_organization_projects: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub has_repository_projects: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub public_repos: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub public_gists: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub followers: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub following: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub html_url: Option<String>,
    #[serde(rename = "type")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub _type: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub total_private_repos: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub owned_private_repos: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub private_gists: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub disk_usage: Option<i64>,
    /// The number of collaborators on private repositories.  This field may be null if the number of private repositories is over 50,000.
    #[serde(skip_serializing_if="Option::is_none")]
    pub collaborators: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub billing_email: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub plan: Option<OrganizationfullPlan>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub default_repository_permission: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub members_can_create_repositories: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub two_factor_requirement_enabled: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub members_allowed_repository_creation_type: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub members_can_create_public_repositories: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub members_can_create_private_repositories: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub members_can_create_internal_repositories: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub members_can_create_pages: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub members_can_create_public_pages: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub members_can_create_private_pages: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub members_can_fork_private_repositories: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub web_commit_signoff_required: Option<bool>,
    /// **Endpoint closing down notice.** Please use [code security configurations](https://docs.github.com/rest/code-security/configurations) instead.  Whether GitHub Advanced Security is enabled for new repositories and repositories transferred to this organization.  This field is only visible to organization owners or members of a team with the security manager role.
    #[serde(skip_serializing_if="Option::is_none")]
    pub advanced_security_enabled_for_new_repositories: Option<bool>,
    /// **Endpoint closing down notice.** Please use [code security configurations](https://docs.github.com/rest/code-security/configurations) instead.  Whether Dependabot alerts are automatically enabled for new repositories and repositories transferred to this organization.  This field is only visible to organization owners or members of a team with the security manager role.
    #[serde(skip_serializing_if="Option::is_none")]
    pub dependabot_alerts_enabled_for_new_repositories: Option<bool>,
    /// **Endpoint closing down notice.** Please use [code security configurations](https://docs.github.com/rest/code-security/configurations) instead.  Whether Dependabot security updates are automatically enabled for new repositories and repositories transferred to this organization.  This field is only visible to organization owners or members of a team with the security manager role.
    #[serde(skip_serializing_if="Option::is_none")]
    pub dependabot_security_updates_enabled_for_new_repositories: Option<bool>,
    /// **Endpoint closing down notice.** Please use [code security configurations](https://docs.github.com/rest/code-security/configurations) instead.  Whether dependency graph is automatically enabled for new repositories and repositories transferred to this organization.  This field is only visible to organization owners or members of a team with the security manager role.
    #[serde(skip_serializing_if="Option::is_none")]
    pub dependency_graph_enabled_for_new_repositories: Option<bool>,
    /// **Endpoint closing down notice.** Please use [code security configurations](https://docs.github.com/rest/code-security/configurations) instead.  Whether secret scanning is automatically enabled for new repositories and repositories transferred to this organization.  This field is only visible to organization owners or members of a team with the security manager role.
    #[serde(skip_serializing_if="Option::is_none")]
    pub secret_scanning_enabled_for_new_repositories: Option<bool>,
    /// **Endpoint closing down notice.** Please use [code security configurations](https://docs.github.com/rest/code-security/configurations) instead.  Whether secret scanning push protection is automatically enabled for new repositories and repositories transferred to this organization.  This field is only visible to organization owners or members of a team with the security manager role.
    #[serde(skip_serializing_if="Option::is_none")]
    pub secret_scanning_push_protection_enabled_for_new_repositories: Option<bool>,
    /// Whether a custom link is shown to contributors who are blocked from pushing a secret by push protection.
    #[serde(skip_serializing_if="Option::is_none")]
    pub secret_scanning_push_protection_custom_link_enabled: Option<bool>,
    /// An optional URL string to display to contributors who are blocked from pushing a secret.
    #[serde(skip_serializing_if="Option::is_none")]
    pub secret_scanning_push_protection_custom_link: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub updated_at: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub archived_at: Option<chrono::DateTime<chrono::Utc>>,
    /// Controls whether or not deploy keys may be added and used for repositories in the organization.
    #[serde(skip_serializing_if="Option::is_none")]
    pub deploy_keys_enabled_for_repositories: Option<bool>,
}

/// Organization Invitation
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct OrganizationInvitation {
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub login: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub email: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub role: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub created_at: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub failed_at: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub failed_reason: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub inviter: Option<SimpleUser>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub team_count: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub node_id: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub invitation_teams_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub invitation_source: Option<String>,
}

/// Minimal representation of an organization programmatic access grant for enumerations
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct OrganizationProgrammaticAccessGrant {
    /// Unique identifier of the fine-grained personal access token grant. The `pat_id` used to get details about an approved fine-grained personal access token.
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub owner: Option<SimpleUser>,
    /// Type of repository selection requested.
    #[serde(skip_serializing_if="Option::is_none")]
    pub repository_selection: Option<String>,
    /// URL to the list of repositories the fine-grained personal access token can access. Only follow when `repository_selection` is `subset`.
    #[serde(skip_serializing_if="Option::is_none")]
    pub repositories_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub permissions: Option<OrganizationprogrammaticaccessgrantrequestPermissions>,
    /// Date and time when the fine-grained personal access token was approved to access the organization.
    #[serde(skip_serializing_if="Option::is_none")]
    pub access_granted_at: Option<String>,
    /// Unique identifier of the user's token. This field can also be found in audit log events and the organization's settings for their PAT grants.
    #[serde(skip_serializing_if="Option::is_none")]
    pub token_id: Option<i64>,
    /// The name given to the user's token. This field can also be found in an organization's settings page for Active Tokens.
    #[serde(skip_serializing_if="Option::is_none")]
    pub token_name: Option<String>,
    /// Whether the associated fine-grained personal access token has expired.
    #[serde(skip_serializing_if="Option::is_none")]
    pub token_expired: Option<bool>,
    /// Date and time when the associated fine-grained personal access token expires.
    #[serde(skip_serializing_if="Option::is_none")]
    pub token_expires_at: Option<String>,
    /// Date and time when the associated fine-grained personal access token was last used for authentication.
    #[serde(skip_serializing_if="Option::is_none")]
    pub token_last_used_at: Option<String>,
}

/// Minimal representation of an organization programmatic access grant request for enumerations
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct OrganizationProgrammaticAccessGrantRequest {
    /// Unique identifier of the request for access via fine-grained personal access token. The `pat_request_id` used to review PAT requests.
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<i64>,
    /// Reason for requesting access.
    #[serde(skip_serializing_if="Option::is_none")]
    pub reason: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub owner: Option<SimpleUser>,
    /// Type of repository selection requested.
    #[serde(skip_serializing_if="Option::is_none")]
    pub repository_selection: Option<String>,
    /// URL to the list of repositories requested to be accessed via fine-grained personal access token. Should only be followed when `repository_selection` is `subset`.
    #[serde(skip_serializing_if="Option::is_none")]
    pub repositories_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub permissions: Option<OrganizationprogrammaticaccessgrantrequestPermissions>,
    /// Date and time when the request for access was created.
    #[serde(skip_serializing_if="Option::is_none")]
    pub created_at: Option<String>,
    /// Unique identifier of the user's token. This field can also be found in audit log events and the organization's settings for their PAT grants.
    #[serde(skip_serializing_if="Option::is_none")]
    pub token_id: Option<i64>,
    /// The name given to the user's token. This field can also be found in an organization's settings page for Active Tokens.
    #[serde(skip_serializing_if="Option::is_none")]
    pub token_name: Option<String>,
    /// Whether the associated fine-grained personal access token has expired.
    #[serde(skip_serializing_if="Option::is_none")]
    pub token_expired: Option<bool>,
    /// Date and time when the associated fine-grained personal access token expires.
    #[serde(skip_serializing_if="Option::is_none")]
    pub token_expires_at: Option<String>,
    /// Date and time when the associated fine-grained personal access token was last used for authentication.
    #[serde(skip_serializing_if="Option::is_none")]
    pub token_last_used_at: Option<String>,
}

/// Organization roles
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct OrganizationRole {
    /// The unique identifier of the role.
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<i64>,
    /// The name of the role.
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,
    /// A short description about who this role is for or what permissions it grants.
    #[serde(skip_serializing_if="Option::is_none")]
    pub description: Option<String>,
    /// The system role from which this role inherits permissions.
    #[serde(skip_serializing_if="Option::is_none")]
    pub base_role: Option<String>,
    /// Source answers the question, \"where did this role come from?\"
    #[serde(skip_serializing_if="Option::is_none")]
    pub source: Option<String>,
    /// A list of permissions included in this role.
    #[serde(skip_serializing_if="Option::is_none")]
    pub permissions: Option<Vec<String>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub organization: Option<NullableSimpleUser>,
    /// The date and time the role was created.
    #[serde(skip_serializing_if="Option::is_none")]
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The date and time the role was last updated.
    #[serde(skip_serializing_if="Option::is_none")]
    pub updated_at: Option<chrono::DateTime<chrono::Utc>>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct OrganizationSecretScanningAlert {
    #[serde(skip_serializing_if="Option::is_none")]
    pub number: Option<AlertNumber>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub created_at: Option<AlertCreatedAt>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub updated_at: Option<NullableAlertUpdatedAt>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub url: Option<AlertUrl>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub html_url: Option<AlertHtmlUrl>,
    /// The REST API URL of the code locations for this alert.
    #[serde(skip_serializing_if="Option::is_none")]
    pub locations_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub state: Option<SecretScanningAlertState>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub resolution: Option<SecretScanningAlertResolution>,
    /// The time that the alert was resolved in ISO 8601 format: `YYYY-MM-DDTHH:MM:SSZ`.
    #[serde(skip_serializing_if="Option::is_none")]
    pub resolved_at: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub resolved_by: Option<NullableSimpleUser>,
    /// The type of secret that secret scanning detected.
    #[serde(skip_serializing_if="Option::is_none")]
    pub secret_type: Option<String>,
    /// User-friendly name for the detected secret, matching the `secret_type`. For a list of built-in patterns, see \"[Supported secret scanning patterns](https://docs.github.com/code-security/secret-scanning/introduction/supported-secret-scanning-patterns#supported-secrets).\"
    #[serde(skip_serializing_if="Option::is_none")]
    pub secret_type_display_name: Option<String>,
    /// The secret that was detected.
    #[serde(skip_serializing_if="Option::is_none")]
    pub secret: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub repository: Option<SimpleRepository>,
    /// Whether push protection was bypassed for the detected secret.
    #[serde(skip_serializing_if="Option::is_none")]
    pub push_protection_bypassed: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub push_protection_bypassed_by: Option<NullableSimpleUser>,
    /// The time that push protection was bypassed in ISO 8601 format: `YYYY-MM-DDTHH:MM:SSZ`.
    #[serde(skip_serializing_if="Option::is_none")]
    pub push_protection_bypassed_at: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub push_protection_bypass_request_reviewer: Option<NullableSimpleUser>,
    /// An optional comment when reviewing a push protection bypass.
    #[serde(skip_serializing_if="Option::is_none")]
    pub push_protection_bypass_request_reviewer_comment: Option<String>,
    /// An optional comment when requesting a push protection bypass.
    #[serde(skip_serializing_if="Option::is_none")]
    pub push_protection_bypass_request_comment: Option<String>,
    /// The URL to a push protection bypass request.
    #[serde(skip_serializing_if="Option::is_none")]
    pub push_protection_bypass_request_html_url: Option<String>,
    /// The comment that was optionally added when this alert was closed
    #[serde(skip_serializing_if="Option::is_none")]
    pub resolution_comment: Option<String>,
    /// The token status as of the latest validity check.
    #[serde(skip_serializing_if="Option::is_none")]
    pub validity: Option<String>,
    /// Whether the secret was publicly leaked.
    #[serde(skip_serializing_if="Option::is_none")]
    pub publicly_leaked: Option<bool>,
    /// Whether the detected secret was found in multiple repositories in the same organization or enterprise.
    #[serde(skip_serializing_if="Option::is_none")]
    pub multi_repo: Option<bool>,
}

/// A GitHub organization.
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct OrganizationSimple {
    #[serde(skip_serializing_if="Option::is_none")]
    pub login: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub node_id: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub repos_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub events_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub hooks_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub issues_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub members_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub public_members_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub avatar_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub description: Option<String>,
}

/// A GitHub organization. Webhook payloads contain the `organization` property when the webhook is configured for an organization, or when the event occurs from activity in a repository owned by an organization.
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct OrganizationSimpleWebhooks {
    #[serde(skip_serializing_if="Option::is_none")]
    pub login: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub node_id: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub repos_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub events_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub hooks_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub issues_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub members_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub public_members_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub avatar_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub description: Option<String>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct OrganizationfullPlan {
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub space: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub private_repos: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub filled_seats: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub seats: Option<i64>,
}

/// Permissions requested, categorized by type of permission.
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct OrganizationprogrammaticaccessgrantrequestPermissions {
    #[serde(skip_serializing_if="Option::is_none")]
    pub organization: Option<HashMap<String, String>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub repository: Option<HashMap<String, String>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub other: Option<HashMap<String, String>>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct OrghookConfig {
    #[serde(skip_serializing_if="Option::is_none")]
    pub url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub insecure_ssl: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub content_type: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub secret: Option<String>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct OrgmembershipPermissions {
    #[serde(skip_serializing_if="Option::is_none")]
    pub can_create_repository: Option<bool>,
}

/// The image of runner. To list all available images, use `GET /actions/hosted-runners/images/github-owned` or `GET /actions/hosted-runners/images/partner`.
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct OrgsorgactionshostedrunnersImage {
    /// The unique identifier of the runner image.
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<String>,
    /// The source of the runner image.
    #[serde(skip_serializing_if="Option::is_none")]
    pub source: Option<String>,
    /// The version of the runner image to deploy. This is relevant only for runners using custom images.
    #[serde(skip_serializing_if="Option::is_none")]
    pub version: Option<String>,
}

/// Feature options for secret scanning delegated bypass
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct OrgsorgcodesecurityconfigurationsSecretScanningDelegatedBypassOptions {
    /// The bypass reviewers for secret scanning delegated bypass
    #[serde(skip_serializing_if="Option::is_none")]
    pub reviewers: Option<Vec<OrgsorgcodesecurityconfigurationsSecretScanningDelegatedBypassOptionsReviewers>>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct OrgsorgcodesecurityconfigurationsSecretScanningDelegatedBypassOptionsReviewers {
    /// The ID of the team or role selected as a bypass reviewer
    #[serde(skip_serializing_if="Option::is_none")]
    pub reviewer_id: Option<i64>,
    /// The type of the bypass reviewer
    #[serde(skip_serializing_if="Option::is_none")]
    pub reviewer_type: Option<String>,
}

/// Key/value pairs to provide settings for this webhook.
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct OrgsorghooksConfig {
    #[serde(skip_serializing_if="Option::is_none")]
    pub url: Option<WebhookConfigUrl>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub content_type: Option<WebhookConfigContentType>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub secret: Option<WebhookConfigSecret>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub insecure_ssl: Option<WebhookConfigInsecureSsl>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub username: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub password: Option<String>,
}

/// Key/value pairs to provide settings for this webhook.
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct OrgsorghookshookIdConfig {
    #[serde(skip_serializing_if="Option::is_none")]
    pub url: Option<WebhookConfigUrl>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub content_type: Option<WebhookConfigContentType>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub secret: Option<WebhookConfigSecret>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub insecure_ssl: Option<WebhookConfigInsecureSsl>,
}

/// A software package
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct Package {
    /// Unique identifier of the package.
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<i64>,
    /// The name of the package.
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub package_type: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub html_url: Option<String>,
    /// The number of versions of the package.
    #[serde(skip_serializing_if="Option::is_none")]
    pub version_count: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub visibility: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub owner: Option<NullableSimpleUser>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub repository: Option<NullableMinimalRepository>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub updated_at: Option<chrono::DateTime<chrono::Utc>>,
}

/// A version of a software package
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct PackageVersion {
    /// Unique identifier of the package version.
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<i64>,
    /// The name of the package version.
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub package_html_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub html_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub license: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub description: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub updated_at: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub deleted_at: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub metadata: Option<PackageVersionMetadata>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct PackageVersionMetadata {
    #[serde(skip_serializing_if="Option::is_none")]
    pub package_type: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub container: Option<ContainerMetadata>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub docker: Option<DockerMetadata>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct PackagesBillingUsage {
    /// Sum of the free and paid storage space (GB) for GitHuub Packages.
    #[serde(skip_serializing_if="Option::is_none")]
    pub total_gigabytes_bandwidth_used: Option<i64>,
    /// Total paid storage space (GB) for GitHuub Packages.
    #[serde(skip_serializing_if="Option::is_none")]
    pub total_paid_gigabytes_bandwidth_used: Option<i64>,
    /// Free storage space (GB) for GitHub Packages.
    #[serde(skip_serializing_if="Option::is_none")]
    pub included_gigabytes_bandwidth: Option<i64>,
}

/// The configuration for GitHub Pages for a repository.
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct Page {
    /// The API address for accessing this Page resource.
    #[serde(skip_serializing_if="Option::is_none")]
    pub url: Option<String>,
    /// The status of the most recent build of the Page.
    #[serde(skip_serializing_if="Option::is_none")]
    pub status: Option<String>,
    /// The Pages site's custom domain
    #[serde(skip_serializing_if="Option::is_none")]
    pub cname: Option<String>,
    /// The state if the domain is verified
    #[serde(skip_serializing_if="Option::is_none")]
    pub protected_domain_state: Option<String>,
    /// The timestamp when a pending domain becomes unverified.
    #[serde(skip_serializing_if="Option::is_none")]
    pub pending_domain_unverified_at: Option<chrono::DateTime<chrono::Utc>>,
    /// Whether the Page has a custom 404 page.
    #[serde(skip_serializing_if="Option::is_none")]
    pub custom_404: Option<bool>,
    /// The web address the Page can be accessed from.
    #[serde(skip_serializing_if="Option::is_none")]
    pub html_url: Option<String>,
    /// The process in which the Page will be built.
    #[serde(skip_serializing_if="Option::is_none")]
    pub build_type: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub source: Option<PagesSourceHash>,
    /// Whether the GitHub Pages site is publicly visible. If set to `true`, the site is accessible to anyone on the internet. If set to `false`, the site will only be accessible to users who have at least `read` access to the repository that published the site.
    #[serde(skip_serializing_if="Option::is_none")]
    pub public: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub https_certificate: Option<PagesHttpsCertificate>,
    /// Whether https is enabled on the domain
    #[serde(skip_serializing_if="Option::is_none")]
    pub https_enforced: Option<bool>,
}

/// Page Build
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct PageBuild {
    #[serde(skip_serializing_if="Option::is_none")]
    pub url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub status: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub error: Option<PagebuildError>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub pusher: Option<NullableSimpleUser>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub commit: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub duration: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub updated_at: Option<chrono::DateTime<chrono::Utc>>,
}

/// Page Build Status
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct PageBuildStatus {
    #[serde(skip_serializing_if="Option::is_none")]
    pub url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub status: Option<String>,
}

/// The GitHub Pages deployment status.
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct PageDeployment {
    /// The ID of the GitHub Pages deployment. This is the Git SHA of the deployed commit.
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<OneOfpageDeploymentId>,
    /// The URI to monitor GitHub Pages deployment status.
    #[serde(skip_serializing_if="Option::is_none")]
    pub status_url: Option<String>,
    /// The URI to the deployed GitHub Pages.
    #[serde(skip_serializing_if="Option::is_none")]
    pub page_url: Option<String>,
    /// The URI to the deployed GitHub Pages preview.
    #[serde(skip_serializing_if="Option::is_none")]
    pub preview_url: Option<String>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct PagebuildError {
    #[serde(skip_serializing_if="Option::is_none")]
    pub message: Option<String>,
}

#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PagesDeploymentId { 
    PagesDeploymentIdVariant0(i32),
    PagesDeploymentIdVariant1(String),
}

impl From<i32> for PagesDeploymentId {
    fn from(value: i32) -> Self {
        PagesDeploymentId::PagesDeploymentIdVariant0(value)
    }
}

impl From<String> for PagesDeploymentId {
    fn from(value: String) -> Self {
        PagesDeploymentId::PagesDeploymentIdVariant1(value)
    }
}

impl Display for PagesDeploymentId {
    fn fmt(&self, f: &mut Formatter) -> fmt::Result {
        match self { 
            PagesDeploymentId::PagesDeploymentIdVariant0(value) => write!(f, "{}", value),
            PagesDeploymentId::PagesDeploymentIdVariant1(value) => write!(f, "{}", value),
        }
    }
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct PagesDeploymentStatus {
    /// The current status of the deployment.
    #[serde(skip_serializing_if="Option::is_none")]
    pub status: Option<String>,
}

/// Pages Health Check Status
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct PagesHealthCheck {
    #[serde(skip_serializing_if="Option::is_none")]
    pub domain: Option<PageshealthcheckDomain>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub alt_domain: Option<PageshealthcheckDomain>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct PagesHttpsCertificate {
    #[serde(skip_serializing_if="Option::is_none")]
    pub state: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub description: Option<String>,
    /// Array of the domain set and its alternate name (if it is configured)
    #[serde(skip_serializing_if="Option::is_none")]
    pub domains: Option<Vec<String>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub expires_at: Option<chrono::DateTime<chrono::Utc>>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct PagesSourceHash {
    #[serde(skip_serializing_if="Option::is_none")]
    pub branch: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub path: Option<String>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct PageshealthcheckDomain {
    #[serde(skip_serializing_if="Option::is_none")]
    pub host: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub uri: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub nameservers: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub dns_resolves: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub is_proxied: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub is_cloudflare_ip: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub is_fastly_ip: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub is_old_ip_address: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub is_a_record: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub has_cname_record: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub has_mx_records_present: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub is_valid_domain: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub is_apex_domain: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub should_be_a_record: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub is_cname_to_github_user_domain: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub is_cname_to_pages_dot_github_dot_com: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub is_cname_to_fastly: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub is_pointed_to_github_pages_ip: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub is_non_github_pages_ip_present: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub is_pages_domain: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub is_served_by_pages: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub is_valid: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub reason: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub responds_to_https: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub enforces_https: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub https_error: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub is_https_eligible: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub caa_error: Option<String>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct ParticipationStats {
    #[serde(skip_serializing_if="Option::is_none")]
    pub all: Option<Vec<i32>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub owner: Option<Vec<i32>>,
}

/// Details of a deployment that is waiting for protection rules to pass
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct PendingDeployment {
    #[serde(skip_serializing_if="Option::is_none")]
    pub environment: Option<PendingdeploymentEnvironment>,
    /// The set duration of the wait timer
    #[serde(skip_serializing_if="Option::is_none")]
    pub wait_timer: Option<i64>,
    /// The time that the wait timer began.
    #[serde(skip_serializing_if="Option::is_none")]
    pub wait_timer_started_at: Option<chrono::DateTime<chrono::Utc>>,
    /// Whether the currently authenticated user can approve the deployment
    #[serde(skip_serializing_if="Option::is_none")]
    pub current_user_can_approve: Option<bool>,
    /// The people or teams that may approve jobs that reference the environment. You can list up to six users or teams as reviewers. The reviewers must have at least read access to the repository. Only one of the required reviewers needs to approve the job for it to proceed.
    #[serde(skip_serializing_if="Option::is_none")]
    pub reviewers: Option<Vec<PendingdeploymentReviewers>>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct PendingdeploymentEnvironment {
    /// The id of the environment.
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub node_id: Option<String>,
    /// The name of the environment.
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub html_url: Option<String>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct PendingdeploymentReviewers {
    #[serde(rename = "type")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub _type: Option<DeploymentReviewerType>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub reviewer: Option<AnyOfpendingdeploymentReviewersReviewer>,
}

/// Details of a Personal Access Token Request.
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct PersonalAccessTokenRequest {
    /// Unique identifier of the request for access via fine-grained personal access token. Used as the `pat_request_id` parameter in the list and review API calls.
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub owner: Option<SimpleUser>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub permissions_added: Option<PersonalaccesstokenrequestPermissionsAdded>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub permissions_upgraded: Option<PersonalaccesstokenrequestPermissionsUpgraded>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub permissions_result: Option<PersonalaccesstokenrequestPermissionsResult>,
    /// Type of repository selection requested.
    #[serde(skip_serializing_if="Option::is_none")]
    pub repository_selection: Option<String>,
    /// The number of repositories the token is requesting access to. This field is only populated when `repository_selection` is `subset`.
    #[serde(skip_serializing_if="Option::is_none")]
    pub repository_count: Option<i64>,
    /// An array of repository objects the token is requesting access to. This field is only populated when `repository_selection` is `subset`.
    #[serde(skip_serializing_if="Option::is_none")]
    pub repositories: Option<Vec<WebhooksRepositoriesInner>>,
    /// Date and time when the request for access was created.
    #[serde(skip_serializing_if="Option::is_none")]
    pub created_at: Option<String>,
    /// Unique identifier of the user's token. This field can also be found in audit log events and the organization's settings for their PAT grants.
    #[serde(skip_serializing_if="Option::is_none")]
    pub token_id: Option<i64>,
    /// The name given to the user's token. This field can also be found in an organization's settings page for Active Tokens.
    #[serde(skip_serializing_if="Option::is_none")]
    pub token_name: Option<String>,
    /// Whether the associated fine-grained personal access token has expired.
    #[serde(skip_serializing_if="Option::is_none")]
    pub token_expired: Option<bool>,
    /// Date and time when the associated fine-grained personal access token expires.
    #[serde(skip_serializing_if="Option::is_none")]
    pub token_expires_at: Option<String>,
    /// Date and time when the associated fine-grained personal access token was last used for authentication.
    #[serde(skip_serializing_if="Option::is_none")]
    pub token_last_used_at: Option<String>,
}

/// New requested permissions, categorized by type of permission.
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct PersonalaccesstokenrequestPermissionsAdded {
    #[serde(skip_serializing_if="Option::is_none")]
    pub organization: Option<HashMap<String, String>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub repository: Option<HashMap<String, String>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub other: Option<HashMap<String, String>>,
}

/// Permissions requested, categorized by type of permission. This field incorporates `permissions_added` and `permissions_upgraded`.
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct PersonalaccesstokenrequestPermissionsResult {
    #[serde(skip_serializing_if="Option::is_none")]
    pub organization: Option<HashMap<String, String>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub repository: Option<HashMap<String, String>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub other: Option<HashMap<String, String>>,
}

/// Requested permissions that elevate access for a previously approved request for access, categorized by type of permission.
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct PersonalaccesstokenrequestPermissionsUpgraded {
    #[serde(skip_serializing_if="Option::is_none")]
    pub organization: Option<HashMap<String, String>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub repository: Option<HashMap<String, String>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub other: Option<HashMap<String, String>>,
}

/// Porter Author
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct PorterAuthor {
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub remote_id: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub remote_name: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub email: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub import_url: Option<String>,
}

/// Porter Large File
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct PorterLargeFile {
    #[serde(skip_serializing_if="Option::is_none")]
    pub ref_name: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub path: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub oid: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub size: Option<i64>,
}

/// Whether or not a user who created the job is prevented from approving their own job.
pub type PreventSelfReview = bool;

/// Private User
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct PrivateUser {
    #[serde(skip_serializing_if="Option::is_none")]
    pub login: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub user_view_type: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub node_id: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub avatar_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub gravatar_id: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub html_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub followers_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub following_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub gists_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub starred_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub subscriptions_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub organizations_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub repos_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub events_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub received_events_url: Option<String>,
    #[serde(rename = "type")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub _type: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub site_admin: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub company: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub blog: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub location: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub email: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub notification_email: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub hireable: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub bio: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub twitter_username: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub public_repos: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub public_gists: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub followers: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub following: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub updated_at: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub private_gists: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub total_private_repos: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub owned_private_repos: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub disk_usage: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub collaborators: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub two_factor_authentication: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub plan: Option<PublicuserPlan>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub business_plus: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub ldap_dn: Option<String>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct PostSecurityAdvisoriesCreatePrivateVulnerabilityReport {
    /// A short summary of the advisory.
    #[serde(skip_serializing_if="Option::is_none")]
    pub summary: Option<String>,
    /// A detailed description of what the advisory impacts.
    #[serde(skip_serializing_if="Option::is_none")]
    pub description: Option<String>,
    /// An array of products affected by the vulnerability detailed in a repository security advisory.
    #[serde(skip_serializing_if="Option::is_none")]
    pub vulnerabilities: Option<Vec<RepositoryadvisorycreateVulnerabilities>>,
    /// A list of Common Weakness Enumeration (CWE) IDs.
    #[serde(skip_serializing_if="Option::is_none")]
    pub cwe_ids: Option<Vec<String>>,
    /// The severity of the advisory. You must choose between setting this field or `cvss_vector_string`.
    #[serde(skip_serializing_if="Option::is_none")]
    pub severity: Option<String>,
    /// The CVSS vector that calculates the severity of the advisory. You must choose between setting this field or `severity`.
    #[serde(skip_serializing_if="Option::is_none")]
    pub cvss_vector_string: Option<String>,
    /// Whether to create a temporary private fork of the repository to collaborate on a fix.
    #[serde(skip_serializing_if="Option::is_none")]
    pub start_private_fork: Option<bool>,
}

/// Projects are a way to organize columns and cards of work.
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct Project {
    #[serde(skip_serializing_if="Option::is_none")]
    pub owner_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub html_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub columns_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub node_id: Option<String>,
    /// Name of the project
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,
    /// Body of the project
    #[serde(skip_serializing_if="Option::is_none")]
    pub body: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub number: Option<i64>,
    /// State of the project; either 'open' or 'closed'
    #[serde(skip_serializing_if="Option::is_none")]
    pub state: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub creator: Option<NullableSimpleUser>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub updated_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The baseline permission that all organization members have on this project. Only present if owner is an organization.
    #[serde(skip_serializing_if="Option::is_none")]
    pub organization_permission: Option<String>,
    /// Whether or not this project can be seen by everyone. Only present if owner is an organization.
    #[serde(skip_serializing_if="Option::is_none")]
    pub private: Option<bool>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct ProjectCard {
    #[serde(skip_serializing_if="Option::is_none")]
    pub after_id: Option<i64>,
    /// Whether or not the card is archived
    #[serde(skip_serializing_if="Option::is_none")]
    pub archived: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub column_id: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub column_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub content_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub creator: Option<User3>,
    /// The project card's ID
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub node_id: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub note: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub project_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub updated_at: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub url: Option<String>,
}

/// Project Collaborator Permission
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct ProjectCollaboratorPermission {
    #[serde(skip_serializing_if="Option::is_none")]
    pub permission: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub user: Option<NullableSimpleUser>,
}

/// Project columns contain cards of work.
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct ProjectColumn {
    #[serde(skip_serializing_if="Option::is_none")]
    pub url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub project_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub cards_url: Option<String>,
    /// The unique identifier of the project column
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub node_id: Option<String>,
    /// Name of the project column
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub updated_at: Option<chrono::DateTime<chrono::Utc>>,
}

/// A projects v2 project
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct ProjectsV2 {
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<f64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub node_id: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub owner: Option<SimpleUser>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub creator: Option<SimpleUser>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub title: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub description: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub public: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub closed_at: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub updated_at: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub number: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub short_description: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub deleted_at: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub deleted_by: Option<NullableSimpleUser>,
}

/// An item belonging to a project
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct ProjectsV2Item {
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<f64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub node_id: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub project_node_id: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub content_node_id: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub content_type: Option<ProjectsV2ItemContentType>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub creator: Option<SimpleUser>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub updated_at: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub archived_at: Option<chrono::DateTime<chrono::Utc>>,
}

/// The type of content tracked in a project item
/// Enumeration of values.
/// Since this enum's variants do not hold data, we can easily define them them as `#[repr(C)]`
/// which helps with FFI.
#[allow(non_camel_case_types)]
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq, PartialOrd, Serialize, Deserialize, Eq, Ord)]
pub enum ProjectsV2ItemContentType { 
    #[serde(rename = "Issue")]
    ISSUE,
    #[serde(rename = "PullRequest")]
    PULLREQUEST,
    #[serde(rename = "DraftIssue")]
    DRAFTISSUE,
}

impl Display for ProjectsV2ItemContentType {
    fn fmt(&self, f: &mut Formatter) -> fmt::Result {
        match *self { 
            ProjectsV2ItemContentType::ISSUE => write!(f, "{}", "Issue"),
            ProjectsV2ItemContentType::PULLREQUEST => write!(f, "{}", "PullRequest"),
            ProjectsV2ItemContentType::DRAFTISSUE => write!(f, "{}", "DraftIssue"),
        }
    }
}

impl std::str::FromStr for ProjectsV2ItemContentType {
    type Err = ();
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s {
            "Issue" => Ok(ProjectsV2ItemContentType::ISSUE),
            "PullRequest" => Ok(ProjectsV2ItemContentType::PULLREQUEST),
            "DraftIssue" => Ok(ProjectsV2ItemContentType::DRAFTISSUE),
            _ => Err(()),
        }
    }
}

/// An iteration setting for an iteration field
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct ProjectsV2IterationSetting {
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub title: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub duration: Option<f64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub start_date: Option<String>,
}

/// An option for a single select field
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct ProjectsV2SingleSelectOption {
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub color: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub description: Option<String>,
}

/// An status update belonging to a project
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct ProjectsV2StatusUpdate {
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<f64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub node_id: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub project_node_id: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub creator: Option<SimpleUser>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub updated_at: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub status: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub start_date: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub target_date: Option<chrono::DateTime<chrono::Utc>>,
    /// Body of the status update
    #[serde(skip_serializing_if="Option::is_none")]
    pub body: Option<String>,
}

/// Branch protections protect branches
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct ProtectedBranch {
    #[serde(skip_serializing_if="Option::is_none")]
    pub url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub required_status_checks: Option<StatusCheckPolicy>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub required_pull_request_reviews: Option<ProtectedbranchRequiredPullRequestReviews>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub required_signatures: Option<BranchprotectionRequiredSignatures>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub enforce_admins: Option<ProtectedbranchEnforceAdmins>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub required_linear_history: Option<ProtectedbranchRequiredLinearHistory>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub allow_force_pushes: Option<ProtectedbranchRequiredLinearHistory>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub allow_deletions: Option<ProtectedbranchRequiredLinearHistory>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub restrictions: Option<BranchRestrictionPolicy>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub required_conversation_resolution: Option<BranchprotectionRequiredLinearHistory>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub block_creations: Option<ProtectedbranchRequiredLinearHistory>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub lock_branch: Option<BranchprotectionLockBranch>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub allow_fork_syncing: Option<BranchprotectionAllowForkSyncing>,
}

/// Protected Branch Admin Enforced
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct ProtectedBranchAdminEnforced {
    #[serde(skip_serializing_if="Option::is_none")]
    pub url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub enabled: Option<bool>,
}

/// Protected Branch Pull Request Review
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct ProtectedBranchPullRequestReview {
    #[serde(skip_serializing_if="Option::is_none")]
    pub url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub dismissal_restrictions: Option<ProtectedbranchpullrequestreviewDismissalRestrictions>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub bypass_pull_request_allowances: Option<ProtectedbranchpullrequestreviewBypassPullRequestAllowances>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub dismiss_stale_reviews: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub require_code_owner_reviews: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub required_approving_review_count: Option<u8>,
    /// Whether the most recent push must be approved by someone other than the person who pushed it.
    #[serde(skip_serializing_if="Option::is_none")]
    pub require_last_push_approval: Option<bool>,
}

/// Protected Branch Required Status Check
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct ProtectedBranchRequiredStatusCheck {
    #[serde(skip_serializing_if="Option::is_none")]
    pub url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub enforcement_level: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub contexts: Option<Vec<String>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub checks: Option<Vec<ProtectedbranchrequiredstatuscheckChecks>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub contexts_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub strict: Option<bool>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct ProtectedbranchEnforceAdmins {
    #[serde(skip_serializing_if="Option::is_none")]
    pub url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub enabled: Option<bool>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct ProtectedbranchRequiredLinearHistory {
    #[serde(skip_serializing_if="Option::is_none")]
    pub enabled: Option<bool>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct ProtectedbranchRequiredPullRequestReviews {
    #[serde(skip_serializing_if="Option::is_none")]
    pub url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub dismiss_stale_reviews: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub require_code_owner_reviews: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub required_approving_review_count: Option<i64>,
    /// Whether the most recent push must be approved by someone other than the person who pushed it.
    #[serde(skip_serializing_if="Option::is_none")]
    pub require_last_push_approval: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub dismissal_restrictions: Option<ProtectedbranchRequiredPullRequestReviewsDismissalRestrictions>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub bypass_pull_request_allowances: Option<ProtectedbranchRequiredPullRequestReviewsBypassPullRequestAllowances>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct ProtectedbranchRequiredPullRequestReviewsBypassPullRequestAllowances {
    #[serde(skip_serializing_if="Option::is_none")]
    pub users: Option<Vec<SimpleUser>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub teams: Option<Vec<Team>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub apps: Option<Vec<Integration>>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct ProtectedbranchRequiredPullRequestReviewsDismissalRestrictions {
    #[serde(skip_serializing_if="Option::is_none")]
    pub url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub users_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub teams_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub users: Option<Vec<SimpleUser>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub teams: Option<Vec<Team>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub apps: Option<Vec<Integration>>,
}

/// Allow specific users, teams, or apps to bypass pull request requirements.
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct ProtectedbranchpullrequestreviewBypassPullRequestAllowances {
    /// The list of users allowed to bypass pull request requirements.
    #[serde(skip_serializing_if="Option::is_none")]
    pub users: Option<Vec<SimpleUser>>,
    /// The list of teams allowed to bypass pull request requirements.
    #[serde(skip_serializing_if="Option::is_none")]
    pub teams: Option<Vec<Team>>,
    /// The list of apps allowed to bypass pull request requirements.
    #[serde(skip_serializing_if="Option::is_none")]
    pub apps: Option<Vec<Integration>>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct ProtectedbranchpullrequestreviewDismissalRestrictions {
    /// The list of users with review dismissal access.
    #[serde(skip_serializing_if="Option::is_none")]
    pub users: Option<Vec<SimpleUser>>,
    /// The list of teams with review dismissal access.
    #[serde(skip_serializing_if="Option::is_none")]
    pub teams: Option<Vec<Team>>,
    /// The list of apps with review dismissal access.
    #[serde(skip_serializing_if="Option::is_none")]
    pub apps: Option<Vec<Integration>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub users_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub teams_url: Option<String>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct ProtectedbranchrequiredstatuscheckChecks {
    #[serde(skip_serializing_if="Option::is_none")]
    pub context: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub app_id: Option<i64>,
}

/// Provides details of Public IP for a GitHub-hosted larger runners
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct PublicIp {
    /// Whether public IP is enabled.
    #[serde(skip_serializing_if="Option::is_none")]
    pub enabled: Option<bool>,
    /// The prefix for the public IP.
    #[serde(skip_serializing_if="Option::is_none")]
    pub prefix: Option<String>,
    /// The length of the IP prefix.
    #[serde(skip_serializing_if="Option::is_none")]
    pub length: Option<i64>,
}

/// Public User
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct PublicUser {
    #[serde(skip_serializing_if="Option::is_none")]
    pub login: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub user_view_type: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub node_id: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub avatar_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub gravatar_id: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub html_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub followers_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub following_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub gists_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub starred_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub subscriptions_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub organizations_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub repos_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub events_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub received_events_url: Option<String>,
    #[serde(rename = "type")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub _type: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub site_admin: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub company: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub blog: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub location: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub email: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub notification_email: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub hireable: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub bio: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub twitter_username: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub public_repos: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub public_gists: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub followers: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub following: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub updated_at: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub plan: Option<PublicuserPlan>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub private_gists: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub total_private_repos: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub owned_private_repos: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub disk_usage: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub collaborators: Option<i64>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct PublicuserPlan {
    #[serde(skip_serializing_if="Option::is_none")]
    pub collaborators: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub space: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub private_repos: Option<i64>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct PullRequest {
    #[serde(skip_serializing_if="Option::is_none")]
    pub _links: Option<WebhooksPullRequest5Links>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub active_lock_reason: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub additions: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub assignee: Option<User3>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub assignees: Option<Vec<User3>>,
    /// How the author is associated with the repository.
    #[serde(skip_serializing_if="Option::is_none")]
    pub author_association: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub auto_merge: Option<PullRequestAutoMerge>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub base: Option<PullRequestBase>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub body: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub changed_files: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub closed_at: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub comments: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub comments_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub commits: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub commits_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub deletions: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub diff_url: Option<String>,
    /// Indicates whether or not the pull request is a draft.
    #[serde(skip_serializing_if="Option::is_none")]
    pub draft: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub head: Option<PullRequestHead>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub html_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub issue_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub labels: Option<Vec<Label>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub locked: Option<bool>,
    /// Indicates whether maintainers can modify the pull request.
    #[serde(skip_serializing_if="Option::is_none")]
    pub maintainer_can_modify: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub merge_commit_sha: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub mergeable: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub mergeable_state: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub merged: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub merged_at: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub merged_by: Option<User1>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub milestone: Option<Milestone>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub node_id: Option<String>,
    /// Number uniquely identifying the pull request within its repository.
    #[serde(skip_serializing_if="Option::is_none")]
    pub number: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub patch_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub rebaseable: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub requested_reviewers: Option<Vec<OneOfPullRequestRequestedReviewersItems>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub requested_teams: Option<Vec<Team>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub review_comment_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub review_comments: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub review_comments_url: Option<String>,
    /// State of this Pull Request. Either `open` or `closed`.
    #[serde(skip_serializing_if="Option::is_none")]
    pub state: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub statuses_url: Option<String>,
    /// The title of the pull request.
    #[serde(skip_serializing_if="Option::is_none")]
    pub title: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub updated_at: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub user: Option<User2>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct PullRequest1 {
    #[serde(skip_serializing_if="Option::is_none")]
    pub _links: Option<WebhooksPullRequest5Links>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub active_lock_reason: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub additions: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub assignee: Option<User1>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub assignees: Option<Vec<User5>>,
    /// How the author is associated with the repository.
    #[serde(skip_serializing_if="Option::is_none")]
    pub author_association: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub auto_merge: Option<PullRequestAutoMerge>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub base: Option<PullRequest1Base>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub body: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub changed_files: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub closed_at: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub comments: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub comments_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub commits: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub commits_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub deletions: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub diff_url: Option<String>,
    /// Indicates whether or not the pull request is a draft.
    #[serde(skip_serializing_if="Option::is_none")]
    pub draft: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub head: Option<PullRequestBase>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub html_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub issue_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub labels: Option<Vec<Label>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub locked: Option<bool>,
    /// Indicates whether maintainers can modify the pull request.
    #[serde(skip_serializing_if="Option::is_none")]
    pub maintainer_can_modify: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub merge_commit_sha: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub mergeable: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub mergeable_state: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub merged: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub merged_at: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub merged_by: Option<User1>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub milestone: Option<Milestone1>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub node_id: Option<String>,
    /// Number uniquely identifying the pull request within its repository.
    #[serde(skip_serializing_if="Option::is_none")]
    pub number: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub patch_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub rebaseable: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub requested_reviewers: Option<Vec<OneOfPullRequest1RequestedReviewersItems>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub requested_teams: Option<Vec<Team>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub review_comment_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub review_comments: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub review_comments_url: Option<String>,
    /// State of this Pull Request. Either `open` or `closed`.
    #[serde(skip_serializing_if="Option::is_none")]
    pub state: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub statuses_url: Option<String>,
    /// The title of the pull request.
    #[serde(skip_serializing_if="Option::is_none")]
    pub title: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub updated_at: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub user: Option<User2>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct PullRequest10 {
    #[serde(skip_serializing_if="Option::is_none")]
    pub _links: Option<WebhooksPullRequest5Links>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub active_lock_reason: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub additions: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub assignee: Option<User3>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub assignees: Option<Vec<User4>>,
    /// How the author is associated with the repository.
    #[serde(skip_serializing_if="Option::is_none")]
    pub author_association: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub auto_merge: Option<PullRequestAutoMerge>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub base: Option<PullRequestBase>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub body: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub changed_files: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub closed_at: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub comments: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub comments_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub commits: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub commits_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub deletions: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub diff_url: Option<String>,
    /// Indicates whether or not the pull request is a draft.
    #[serde(skip_serializing_if="Option::is_none")]
    pub draft: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub head: Option<PullRequest10Head>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub html_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub issue_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub labels: Option<Vec<Label>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub locked: Option<bool>,
    /// Indicates whether maintainers can modify the pull request.
    #[serde(skip_serializing_if="Option::is_none")]
    pub maintainer_can_modify: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub merge_commit_sha: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub mergeable: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub mergeable_state: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub merged: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub merged_at: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub merged_by: Option<User1>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub milestone: Option<Milestone>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub node_id: Option<String>,
    /// Number uniquely identifying the pull request within its repository.
    #[serde(skip_serializing_if="Option::is_none")]
    pub number: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub patch_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub rebaseable: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub requested_reviewers: Option<Vec<OneOfPullRequest10RequestedReviewersItems>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub requested_teams: Option<Vec<Team>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub review_comment_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub review_comments: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub review_comments_url: Option<String>,
    /// State of this Pull Request. Either `open` or `closed`.
    #[serde(skip_serializing_if="Option::is_none")]
    pub state: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub statuses_url: Option<String>,
    /// The title of the pull request.
    #[serde(skip_serializing_if="Option::is_none")]
    pub title: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub updated_at: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub user: Option<User2>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct PullRequest10Head {
    #[serde(skip_serializing_if="Option::is_none")]
    pub label: Option<String>,
    #[serde(rename = "ref")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub git_ref: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub repo: Option<Repository10>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub sha: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub user: Option<User>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct PullRequest11 {
    #[serde(skip_serializing_if="Option::is_none")]
    pub _links: Option<WebhooksPullRequest5Links>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub active_lock_reason: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub additions: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub assignee: Option<User3>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub assignees: Option<Vec<User4>>,
    /// How the author is associated with the repository.
    #[serde(skip_serializing_if="Option::is_none")]
    pub author_association: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub auto_merge: Option<PullRequestAutoMerge>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub base: Option<PullRequestHead>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub body: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub changed_files: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub closed_at: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub comments: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub comments_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub commits: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub commits_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub deletions: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub diff_url: Option<String>,
    /// Indicates whether or not the pull request is a draft.
    #[serde(skip_serializing_if="Option::is_none")]
    pub draft: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub head: Option<PullRequestHead>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub html_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub issue_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub labels: Option<Vec<Label>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub locked: Option<bool>,
    /// Indicates whether maintainers can modify the pull request.
    #[serde(skip_serializing_if="Option::is_none")]
    pub maintainer_can_modify: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub merge_commit_sha: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub mergeable: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub mergeable_state: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub merged: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub merged_at: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub merged_by: Option<User3>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub milestone: Option<Milestone>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub node_id: Option<String>,
    /// Number uniquely identifying the pull request within its repository.
    #[serde(skip_serializing_if="Option::is_none")]
    pub number: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub patch_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub rebaseable: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub requested_reviewers: Option<Vec<OneOfPullRequest11RequestedReviewersItems>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub requested_teams: Option<Vec<Team>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub review_comment_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub review_comments: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub review_comments_url: Option<String>,
    /// State of this Pull Request. Either `open` or `closed`.
    #[serde(skip_serializing_if="Option::is_none")]
    pub state: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub statuses_url: Option<String>,
    /// The title of the pull request.
    #[serde(skip_serializing_if="Option::is_none")]
    pub title: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub updated_at: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub user: Option<User2>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct PullRequest12 {
    #[serde(skip_serializing_if="Option::is_none")]
    pub _links: Option<WebhooksPullRequest5Links>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub active_lock_reason: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub additions: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub assignee: Option<User3>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub assignees: Option<Vec<User4>>,
    /// How the author is associated with the repository.
    #[serde(skip_serializing_if="Option::is_none")]
    pub author_association: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub auto_merge: Option<PullRequestAutoMerge>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub base: Option<PullRequestBase>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub body: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub changed_files: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub closed_at: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub comments: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub comments_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub commits: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub commits_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub deletions: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub diff_url: Option<String>,
    /// Indicates whether or not the pull request is a draft.
    #[serde(skip_serializing_if="Option::is_none")]
    pub draft: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub head: Option<PullRequest12Head>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub html_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub issue_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub labels: Option<Vec<Label>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub locked: Option<bool>,
    /// Indicates whether maintainers can modify the pull request.
    #[serde(skip_serializing_if="Option::is_none")]
    pub maintainer_can_modify: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub merge_commit_sha: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub mergeable: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub mergeable_state: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub merged: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub merged_at: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub merged_by: Option<User1>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub milestone: Option<Milestone>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub node_id: Option<String>,
    /// Number uniquely identifying the pull request within its repository.
    #[serde(skip_serializing_if="Option::is_none")]
    pub number: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub patch_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub rebaseable: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub requested_reviewers: Option<Vec<OneOfPullRequest12RequestedReviewersItems>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub requested_teams: Option<Vec<Team>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub review_comment_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub review_comments: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub review_comments_url: Option<String>,
    /// State of this Pull Request. Either `open` or `closed`.
    #[serde(skip_serializing_if="Option::is_none")]
    pub state: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub statuses_url: Option<String>,
    /// The title of the pull request.
    #[serde(skip_serializing_if="Option::is_none")]
    pub title: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub updated_at: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub user: Option<User2>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct PullRequest12Head {
    #[serde(skip_serializing_if="Option::is_none")]
    pub label: Option<String>,
    #[serde(rename = "ref")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub git_ref: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub repo: Option<Repository10>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub sha: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub user: Option<User>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct PullRequest13 {
    #[serde(skip_serializing_if="Option::is_none")]
    pub _links: Option<WebhooksPullRequest5Links>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub active_lock_reason: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub additions: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub assignee: Option<User1>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub assignees: Option<Vec<User5>>,
    /// How the author is associated with the repository.
    #[serde(skip_serializing_if="Option::is_none")]
    pub author_association: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub auto_merge: Option<PullRequestAutoMerge1>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub base: Option<PullRequestBase>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub body: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub changed_files: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub closed_at: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub comments: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub comments_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub commits: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub commits_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub deletions: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub diff_url: Option<String>,
    /// Indicates whether or not the pull request is a draft.
    #[serde(skip_serializing_if="Option::is_none")]
    pub draft: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub head: Option<PullRequestBase>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub html_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub issue_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub labels: Option<Vec<Label>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub locked: Option<bool>,
    /// Indicates whether maintainers can modify the pull request.
    #[serde(skip_serializing_if="Option::is_none")]
    pub maintainer_can_modify: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub merge_commit_sha: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub mergeable: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub mergeable_state: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub merged: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub merged_at: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub merged_by: Option<User1>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub milestone: Option<Milestone1>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub node_id: Option<String>,
    /// Number uniquely identifying the pull request within its repository.
    #[serde(skip_serializing_if="Option::is_none")]
    pub number: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub patch_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub rebaseable: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub requested_reviewers: Option<Vec<OneOfPullRequest13RequestedReviewersItems>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub requested_teams: Option<Vec<Team>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub review_comment_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub review_comments: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub review_comments_url: Option<String>,
    /// State of this Pull Request. Either `open` or `closed`.
    #[serde(skip_serializing_if="Option::is_none")]
    pub state: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub statuses_url: Option<String>,
    /// The title of the pull request.
    #[serde(skip_serializing_if="Option::is_none")]
    pub title: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub updated_at: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub user: Option<User>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct PullRequest1Base {
    #[serde(skip_serializing_if="Option::is_none")]
    pub label: Option<String>,
    #[serde(rename = "ref")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub git_ref: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub repo: Option<Repository4>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub sha: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub user: Option<User>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct PullRequest2 {
    #[serde(skip_serializing_if="Option::is_none")]
    pub _links: Option<WebhooksPullRequest5Links>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub active_lock_reason: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub additions: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub assignee: Option<User1>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub assignees: Option<Vec<User5>>,
    /// How the author is associated with the repository.
    #[serde(skip_serializing_if="Option::is_none")]
    pub author_association: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub auto_merge: Option<PullRequestAutoMerge>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub base: Option<PullRequestBase>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub body: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub changed_files: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub closed_at: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub comments: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub comments_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub commits: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub commits_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub deletions: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub diff_url: Option<String>,
    /// Indicates whether or not the pull request is a draft.
    #[serde(skip_serializing_if="Option::is_none")]
    pub draft: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub head: Option<PullRequest2Head>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub html_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub issue_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub labels: Option<Vec<Label>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub locked: Option<bool>,
    /// Indicates whether maintainers can modify the pull request.
    #[serde(skip_serializing_if="Option::is_none")]
    pub maintainer_can_modify: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub merge_commit_sha: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub mergeable: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub mergeable_state: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub merged: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub merged_at: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub merged_by: Option<User1>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub milestone: Option<Milestone>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub node_id: Option<String>,
    /// Number uniquely identifying the pull request within its repository.
    #[serde(skip_serializing_if="Option::is_none")]
    pub number: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub patch_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub rebaseable: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub requested_reviewers: Option<Vec<OneOfPullRequest2RequestedReviewersItems>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub requested_teams: Option<Vec<Team>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub review_comment_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub review_comments: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub review_comments_url: Option<String>,
    /// State of this Pull Request. Either `open` or `closed`.
    #[serde(skip_serializing_if="Option::is_none")]
    pub state: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub statuses_url: Option<String>,
    /// The title of the pull request.
    #[serde(skip_serializing_if="Option::is_none")]
    pub title: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub updated_at: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub user: Option<User2>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct PullRequest2Head {
    #[serde(skip_serializing_if="Option::is_none")]
    pub label: Option<String>,
    #[serde(rename = "ref")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub git_ref: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub repo: Option<Repository5>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub sha: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub user: Option<User>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct PullRequest3 {
    #[serde(skip_serializing_if="Option::is_none")]
    pub _links: Option<WebhooksPullRequest5Links>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub active_lock_reason: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub additions: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub assignee: Option<User1>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub assignees: Option<Vec<User5>>,
    /// How the author is associated with the repository.
    #[serde(skip_serializing_if="Option::is_none")]
    pub author_association: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub auto_merge: Option<PullRequestAutoMerge>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub base: Option<PullRequestBase>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub body: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub changed_files: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub closed_at: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub comments: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub comments_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub commits: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub commits_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub deletions: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub diff_url: Option<String>,
    /// Indicates whether or not the pull request is a draft.
    #[serde(skip_serializing_if="Option::is_none")]
    pub draft: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub head: Option<PullRequestBase>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub html_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub issue_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub labels: Option<Vec<Label>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub locked: Option<bool>,
    /// Indicates whether maintainers can modify the pull request.
    #[serde(skip_serializing_if="Option::is_none")]
    pub maintainer_can_modify: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub merge_commit_sha: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub mergeable: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub mergeable_state: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub merged: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub merged_at: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub merged_by: Option<User1>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub milestone: Option<Milestone>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub node_id: Option<String>,
    /// Number uniquely identifying the pull request within its repository.
    #[serde(skip_serializing_if="Option::is_none")]
    pub number: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub patch_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub rebaseable: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub requested_reviewers: Option<Vec<OneOfPullRequest3RequestedReviewersItems>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub requested_teams: Option<Vec<Team>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub review_comment_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub review_comments: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub review_comments_url: Option<String>,
    /// State of this Pull Request. Either `open` or `closed`.
    #[serde(skip_serializing_if="Option::is_none")]
    pub state: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub statuses_url: Option<String>,
    /// The title of the pull request.
    #[serde(skip_serializing_if="Option::is_none")]
    pub title: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub updated_at: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub user: Option<User2>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct PullRequest4 {
    #[serde(skip_serializing_if="Option::is_none")]
    pub _links: Option<WebhooksPullRequest5Links>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub active_lock_reason: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub additions: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub assignee: Option<User3>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub assignees: Option<Vec<User4>>,
    /// How the author is associated with the repository.
    #[serde(skip_serializing_if="Option::is_none")]
    pub author_association: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub auto_merge: Option<PullRequestAutoMerge>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub base: Option<PullRequestBase>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub body: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub changed_files: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub closed_at: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub comments: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub comments_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub commits: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub commits_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub deletions: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub diff_url: Option<String>,
    /// Indicates whether or not the pull request is a draft.
    #[serde(skip_serializing_if="Option::is_none")]
    pub draft: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub head: Option<PullRequestHead>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub html_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub issue_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub labels: Option<Vec<Label>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub locked: Option<bool>,
    /// Indicates whether maintainers can modify the pull request.
    #[serde(skip_serializing_if="Option::is_none")]
    pub maintainer_can_modify: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub merge_commit_sha: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub mergeable: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub mergeable_state: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub merged: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub merged_at: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub merged_by: Option<User3>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub milestone: Option<Milestone>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub node_id: Option<String>,
    /// Number uniquely identifying the pull request within its repository.
    #[serde(skip_serializing_if="Option::is_none")]
    pub number: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub patch_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub rebaseable: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub requested_reviewers: Option<Vec<OneOfPullRequest4RequestedReviewersItems>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub requested_teams: Option<Vec<Team>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub review_comment_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub review_comments: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub review_comments_url: Option<String>,
    /// State of this Pull Request. Either `open` or `closed`.
    #[serde(skip_serializing_if="Option::is_none")]
    pub state: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub statuses_url: Option<String>,
    /// The title of the pull request.
    #[serde(skip_serializing_if="Option::is_none")]
    pub title: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub updated_at: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub user: Option<User2>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct PullRequest5 {
    #[serde(skip_serializing_if="Option::is_none")]
    pub _links: Option<WebhooksPullRequest5Links>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub active_lock_reason: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub additions: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub assignee: Option<User1>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub assignees: Option<Vec<User4>>,
    /// How the author is associated with the repository.
    #[serde(skip_serializing_if="Option::is_none")]
    pub author_association: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub auto_merge: Option<PullRequestAutoMerge>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub base: Option<PullRequestBase>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub body: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub changed_files: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub closed_at: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub comments: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub comments_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub commits: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub commits_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub deletions: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub diff_url: Option<String>,
    /// Indicates whether or not the pull request is a draft.
    #[serde(skip_serializing_if="Option::is_none")]
    pub draft: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub head: Option<PullRequestHead>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub html_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub issue_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub labels: Option<Vec<Label>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub locked: Option<bool>,
    /// Indicates whether maintainers can modify the pull request.
    #[serde(skip_serializing_if="Option::is_none")]
    pub maintainer_can_modify: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub merge_commit_sha: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub mergeable: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub mergeable_state: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub merged: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub merged_at: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub merged_by: Option<User3>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub milestone: Option<Milestone1>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub node_id: Option<String>,
    /// Number uniquely identifying the pull request within its repository.
    #[serde(skip_serializing_if="Option::is_none")]
    pub number: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub patch_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub rebaseable: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub requested_reviewers: Option<Vec<OneOfPullRequest5RequestedReviewersItems>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub requested_teams: Option<Vec<Team>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub review_comment_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub review_comments: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub review_comments_url: Option<String>,
    /// State of this Pull Request. Either `open` or `closed`.
    #[serde(skip_serializing_if="Option::is_none")]
    pub state: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub statuses_url: Option<String>,
    /// The title of the pull request.
    #[serde(skip_serializing_if="Option::is_none")]
    pub title: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub updated_at: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub user: Option<User2>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct PullRequest6 {
    #[serde(skip_serializing_if="Option::is_none")]
    pub _links: Option<WebhooksPullRequest5Links>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub active_lock_reason: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub additions: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub assignee: Option<User1>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub assignees: Option<Vec<User1>>,
    /// How the author is associated with the repository.
    #[serde(skip_serializing_if="Option::is_none")]
    pub author_association: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub auto_merge: Option<PullRequestAutoMerge>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub base: Option<PullRequest6Base>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub body: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub changed_files: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub closed_at: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub comments: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub comments_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub commits: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub commits_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub deletions: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub diff_url: Option<String>,
    /// Indicates whether or not the pull request is a draft.
    #[serde(skip_serializing_if="Option::is_none")]
    pub draft: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub head: Option<PullRequestBase>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub html_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub issue_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub labels: Option<Vec<Label>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub locked: Option<bool>,
    /// Indicates whether maintainers can modify the pull request.
    #[serde(skip_serializing_if="Option::is_none")]
    pub maintainer_can_modify: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub merge_commit_sha: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub mergeable: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub mergeable_state: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub merged: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub merged_at: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub merged_by: Option<User1>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub milestone: Option<Milestone1>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub node_id: Option<String>,
    /// Number uniquely identifying the pull request within its repository.
    #[serde(skip_serializing_if="Option::is_none")]
    pub number: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub patch_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub rebaseable: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub requested_reviewers: Option<Vec<OneOfPullRequest6RequestedReviewersItems>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub requested_teams: Option<Vec<Team1>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub review_comment_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub review_comments: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub review_comments_url: Option<String>,
    /// State of this Pull Request. Either `open` or `closed`.
    #[serde(skip_serializing_if="Option::is_none")]
    pub state: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub statuses_url: Option<String>,
    /// The title of the pull request.
    #[serde(skip_serializing_if="Option::is_none")]
    pub title: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub updated_at: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub user: Option<User>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct PullRequest6Base {
    #[serde(skip_serializing_if="Option::is_none")]
    pub label: Option<String>,
    #[serde(rename = "ref")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub git_ref: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub repo: Option<Repository8>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub sha: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub user: Option<User>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct PullRequest7 {
    #[serde(skip_serializing_if="Option::is_none")]
    pub _links: Option<WebhooksPullRequest5Links>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub active_lock_reason: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub additions: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub assignee: Option<User1>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub assignees: Option<Vec<User1>>,
    /// How the author is associated with the repository.
    #[serde(skip_serializing_if="Option::is_none")]
    pub author_association: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub auto_merge: Option<PullRequestAutoMerge>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub base: Option<PullRequestBase>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub body: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub changed_files: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub closed_at: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub comments: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub comments_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub commits: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub commits_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub deletions: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub diff_url: Option<String>,
    /// Indicates whether or not the pull request is a draft.
    #[serde(skip_serializing_if="Option::is_none")]
    pub draft: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub head: Option<PullRequestBase>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub html_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub issue_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub labels: Option<Vec<Label>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub locked: Option<bool>,
    /// Indicates whether maintainers can modify the pull request.
    #[serde(skip_serializing_if="Option::is_none")]
    pub maintainer_can_modify: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub merge_commit_sha: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub mergeable: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub mergeable_state: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub merged: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub merged_at: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub merged_by: Option<User1>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub milestone: Option<Milestone1>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub node_id: Option<String>,
    /// Number uniquely identifying the pull request within its repository.
    #[serde(skip_serializing_if="Option::is_none")]
    pub number: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub patch_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub rebaseable: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub requested_reviewers: Option<Vec<OneOfPullRequest7RequestedReviewersItems>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub requested_teams: Option<Vec<Team1>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub review_comment_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub review_comments: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub review_comments_url: Option<String>,
    /// State of this Pull Request. Either `open` or `closed`.
    #[serde(skip_serializing_if="Option::is_none")]
    pub state: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub statuses_url: Option<String>,
    /// The title of the pull request.
    #[serde(skip_serializing_if="Option::is_none")]
    pub title: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub updated_at: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub user: Option<User>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct PullRequest8 {
    #[serde(skip_serializing_if="Option::is_none")]
    pub _links: Option<WebhooksPullRequest5Links>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub active_lock_reason: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub additions: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub assignee: Option<User3>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub assignees: Option<Vec<User3>>,
    /// How the author is associated with the repository.
    #[serde(skip_serializing_if="Option::is_none")]
    pub author_association: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub auto_merge: Option<PullRequestAutoMerge>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub base: Option<PullRequestBase>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub body: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub changed_files: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub closed_at: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub comments: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub comments_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub commits: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub commits_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub deletions: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub diff_url: Option<String>,
    /// Indicates whether or not the pull request is a draft.
    #[serde(skip_serializing_if="Option::is_none")]
    pub draft: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub head: Option<PullRequestBase>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub html_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub issue_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub labels: Option<Vec<Label>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub locked: Option<bool>,
    /// Indicates whether maintainers can modify the pull request.
    #[serde(skip_serializing_if="Option::is_none")]
    pub maintainer_can_modify: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub merge_commit_sha: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub mergeable: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub mergeable_state: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub merged: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub merged_at: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub merged_by: Option<User1>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub milestone: Option<Milestone>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub node_id: Option<String>,
    /// Number uniquely identifying the pull request within its repository.
    #[serde(skip_serializing_if="Option::is_none")]
    pub number: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub patch_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub rebaseable: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub requested_reviewers: Option<Vec<OneOfPullRequest8RequestedReviewersItems>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub requested_teams: Option<Vec<Team>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub review_comment_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub review_comments: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub review_comments_url: Option<String>,
    /// State of this Pull Request. Either `open` or `closed`.
    #[serde(skip_serializing_if="Option::is_none")]
    pub state: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub statuses_url: Option<String>,
    /// The title of the pull request.
    #[serde(skip_serializing_if="Option::is_none")]
    pub title: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub updated_at: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub user: Option<User2>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct PullRequest9 {
    #[serde(skip_serializing_if="Option::is_none")]
    pub _links: Option<WebhooksPullRequest5Links>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub active_lock_reason: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub additions: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub assignee: Option<User3>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub assignees: Option<Vec<User3>>,
    /// How the author is associated with the repository.
    #[serde(skip_serializing_if="Option::is_none")]
    pub author_association: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub auto_merge: Option<PullRequestAutoMerge>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub base: Option<PullRequestBase>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub body: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub changed_files: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub closed_at: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub comments: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub comments_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub commits: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub commits_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub deletions: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub diff_url: Option<String>,
    /// Indicates whether or not the pull request is a draft.
    #[serde(skip_serializing_if="Option::is_none")]
    pub draft: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub head: Option<PullRequestBase>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub html_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub issue_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub labels: Option<Vec<Label>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub locked: Option<bool>,
    /// Indicates whether maintainers can modify the pull request.
    #[serde(skip_serializing_if="Option::is_none")]
    pub maintainer_can_modify: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub merge_commit_sha: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub mergeable: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub mergeable_state: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub merged: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub merged_at: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub merged_by: Option<User1>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub milestone: Option<Milestone>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub node_id: Option<String>,
    /// Number uniquely identifying the pull request within its repository.
    #[serde(skip_serializing_if="Option::is_none")]
    pub number: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub patch_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub rebaseable: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub requested_reviewers: Option<Vec<OneOfPullRequest9RequestedReviewersItems>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub requested_teams: Option<Vec<Team>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub review_comment_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub review_comments: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub review_comments_url: Option<String>,
    /// State of this Pull Request. Either `open` or `closed`.
    #[serde(skip_serializing_if="Option::is_none")]
    pub state: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub statuses_url: Option<String>,
    /// The title of the pull request.
    #[serde(skip_serializing_if="Option::is_none")]
    pub title: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub updated_at: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub user: Option<User2>,
}

/// The status of auto merging a pull request.
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct PullRequestAutoMerge {
    /// Commit message for the merge commit.
    #[serde(skip_serializing_if="Option::is_none")]
    pub commit_message: Option<String>,
    /// Title for the merge commit message.
    #[serde(skip_serializing_if="Option::is_none")]
    pub commit_title: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub enabled_by: Option<User1>,
    /// The merge method to use.
    #[serde(skip_serializing_if="Option::is_none")]
    pub merge_method: Option<String>,
}

/// The status of auto merging a pull request.
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct PullRequestAutoMerge1 {
    /// Commit message for the merge commit.
    #[serde(skip_serializing_if="Option::is_none")]
    pub commit_message: Option<String>,
    /// Title for the merge commit message.
    #[serde(skip_serializing_if="Option::is_none")]
    pub commit_title: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub enabled_by: Option<User1>,
    /// The merge method to use.
    #[serde(skip_serializing_if="Option::is_none")]
    pub merge_method: Option<String>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct PullRequestBase {
    #[serde(skip_serializing_if="Option::is_none")]
    pub label: Option<String>,
    #[serde(rename = "ref")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub git_ref: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub repo: Option<Repository3>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub sha: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub user: Option<User>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct PullRequestHead {
    #[serde(skip_serializing_if="Option::is_none")]
    pub label: Option<String>,
    #[serde(rename = "ref")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub git_ref: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub repo: Option<Repository3>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub sha: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub user: Option<User>,
}

/// Pull Request Merge Result
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct PullRequestMergeResult {
    #[serde(skip_serializing_if="Option::is_none")]
    pub sha: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub merged: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub message: Option<String>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct PullRequestMinimal {
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub number: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub head: Option<PullrequestminimalHead>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub base: Option<PullrequestminimalHead>,
}

/// Pull Request Reviews are reviews on pull requests.
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct PullRequestReview {
    /// Unique identifier of the review
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub node_id: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub user: Option<NullableSimpleUser>,
    /// The text of the review.
    #[serde(skip_serializing_if="Option::is_none")]
    pub body: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub state: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub html_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub pull_request_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub _links: Option<TimelinereviewedeventLinks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub submitted_at: Option<chrono::DateTime<chrono::Utc>>,
    /// A commit SHA for the review. If the commit object was garbage collected or forcibly deleted, then it no longer exists in Git and this value will be `null`.
    #[serde(skip_serializing_if="Option::is_none")]
    pub commit_id: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub body_html: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub body_text: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub author_association: Option<AuthorAssociation>,
}

/// The [comment](https://docs.github.com/rest/pulls/comments#get-a-review-comment-for-a-pull-request) itself.
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct PullRequestReviewComment {
    #[serde(skip_serializing_if="Option::is_none")]
    pub _links: Option<WebhooksReviewCommentLinks>,
    /// How the author is associated with the repository.
    #[serde(skip_serializing_if="Option::is_none")]
    pub author_association: Option<String>,
    /// The text of the comment.
    #[serde(skip_serializing_if="Option::is_none")]
    pub body: Option<String>,
    /// The SHA of the commit to which the comment applies.
    #[serde(skip_serializing_if="Option::is_none")]
    pub commit_id: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The diff of the line that the comment refers to.
    #[serde(skip_serializing_if="Option::is_none")]
    pub diff_hunk: Option<String>,
    /// HTML URL for the pull request review comment.
    #[serde(skip_serializing_if="Option::is_none")]
    pub html_url: Option<String>,
    /// The ID of the pull request review comment.
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<i64>,
    /// The comment ID to reply to.
    #[serde(skip_serializing_if="Option::is_none")]
    pub in_reply_to_id: Option<i64>,
    /// The line of the blob to which the comment applies. The last line of the range for a multi-line comment
    #[serde(skip_serializing_if="Option::is_none")]
    pub line: Option<i64>,
    /// The node ID of the pull request review comment.
    #[serde(skip_serializing_if="Option::is_none")]
    pub node_id: Option<String>,
    /// The SHA of the original commit to which the comment applies.
    #[serde(skip_serializing_if="Option::is_none")]
    pub original_commit_id: Option<String>,
    /// The line of the blob to which the comment applies. The last line of the range for a multi-line comment
    #[serde(skip_serializing_if="Option::is_none")]
    pub original_line: Option<i64>,
    /// The index of the original line in the diff to which the comment applies.
    #[serde(skip_serializing_if="Option::is_none")]
    pub original_position: Option<i64>,
    /// The first line of the range for a multi-line comment.
    #[serde(skip_serializing_if="Option::is_none")]
    pub original_start_line: Option<i64>,
    /// The relative path of the file to which the comment applies.
    #[serde(skip_serializing_if="Option::is_none")]
    pub path: Option<String>,
    /// The line index in the diff to which the comment applies.
    #[serde(skip_serializing_if="Option::is_none")]
    pub position: Option<i64>,
    /// The ID of the pull request review to which the comment belongs.
    #[serde(skip_serializing_if="Option::is_none")]
    pub pull_request_review_id: Option<i64>,
    /// URL for the pull request that the review comment belongs to.
    #[serde(skip_serializing_if="Option::is_none")]
    pub pull_request_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub reactions: Option<Reactions>,
    /// The side of the first line of the range for a multi-line comment.
    #[serde(skip_serializing_if="Option::is_none")]
    pub side: Option<String>,
    /// The first line of the range for a multi-line comment.
    #[serde(skip_serializing_if="Option::is_none")]
    pub start_line: Option<i64>,
    /// The side of the first line of the range for a multi-line comment.
    #[serde(skip_serializing_if="Option::is_none")]
    pub start_side: Option<String>,
    /// The level at which the comment is targeted, can be a diff line or a file.
    #[serde(skip_serializing_if="Option::is_none")]
    pub subject_type: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub updated_at: Option<chrono::DateTime<chrono::Utc>>,
    /// URL for the pull request review comment
    #[serde(skip_serializing_if="Option::is_none")]
    pub url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub user: Option<User>,
}

/// The [comment](https://docs.github.com/rest/pulls/comments#get-a-review-comment-for-a-pull-request) itself.
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct PullRequestReviewComment1 {
    #[serde(skip_serializing_if="Option::is_none")]
    pub _links: Option<WebhooksReviewCommentLinks>,
    /// How the author is associated with the repository.
    #[serde(skip_serializing_if="Option::is_none")]
    pub author_association: Option<String>,
    /// The text of the comment.
    #[serde(skip_serializing_if="Option::is_none")]
    pub body: Option<String>,
    /// The SHA of the commit to which the comment applies.
    #[serde(skip_serializing_if="Option::is_none")]
    pub commit_id: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The diff of the line that the comment refers to.
    #[serde(skip_serializing_if="Option::is_none")]
    pub diff_hunk: Option<String>,
    /// HTML URL for the pull request review comment.
    #[serde(skip_serializing_if="Option::is_none")]
    pub html_url: Option<String>,
    /// The ID of the pull request review comment.
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<i64>,
    /// The comment ID to reply to.
    #[serde(skip_serializing_if="Option::is_none")]
    pub in_reply_to_id: Option<i64>,
    /// The line of the blob to which the comment applies. The last line of the range for a multi-line comment
    #[serde(skip_serializing_if="Option::is_none")]
    pub line: Option<i64>,
    /// The node ID of the pull request review comment.
    #[serde(skip_serializing_if="Option::is_none")]
    pub node_id: Option<String>,
    /// The SHA of the original commit to which the comment applies.
    #[serde(skip_serializing_if="Option::is_none")]
    pub original_commit_id: Option<String>,
    /// The line of the blob to which the comment applies. The last line of the range for a multi-line comment
    #[serde(skip_serializing_if="Option::is_none")]
    pub original_line: Option<i64>,
    /// The index of the original line in the diff to which the comment applies.
    #[serde(skip_serializing_if="Option::is_none")]
    pub original_position: Option<i64>,
    /// The first line of the range for a multi-line comment.
    #[serde(skip_serializing_if="Option::is_none")]
    pub original_start_line: Option<i64>,
    /// The relative path of the file to which the comment applies.
    #[serde(skip_serializing_if="Option::is_none")]
    pub path: Option<String>,
    /// The line index in the diff to which the comment applies.
    #[serde(skip_serializing_if="Option::is_none")]
    pub position: Option<i64>,
    /// The ID of the pull request review to which the comment belongs.
    #[serde(skip_serializing_if="Option::is_none")]
    pub pull_request_review_id: Option<i64>,
    /// URL for the pull request that the review comment belongs to.
    #[serde(skip_serializing_if="Option::is_none")]
    pub pull_request_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub reactions: Option<Reactions>,
    /// The side of the first line of the range for a multi-line comment.
    #[serde(skip_serializing_if="Option::is_none")]
    pub side: Option<String>,
    /// The first line of the range for a multi-line comment.
    #[serde(skip_serializing_if="Option::is_none")]
    pub start_line: Option<i64>,
    /// The side of the first line of the range for a multi-line comment.
    #[serde(skip_serializing_if="Option::is_none")]
    pub start_side: Option<String>,
    /// The level at which the comment is targeted, can be a diff line or a file.
    #[serde(skip_serializing_if="Option::is_none")]
    pub subject_type: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub updated_at: Option<chrono::DateTime<chrono::Utc>>,
    /// URL for the pull request review comment
    #[serde(skip_serializing_if="Option::is_none")]
    pub url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub user: Option<User2>,
}

/// The [comment](https://docs.github.com/rest/pulls/comments#get-a-review-comment-for-a-pull-request) itself.
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct PullRequestReviewComment2 {
    #[serde(skip_serializing_if="Option::is_none")]
    pub _links: Option<WebhooksReviewCommentLinks>,
    /// How the author is associated with the repository.
    #[serde(skip_serializing_if="Option::is_none")]
    pub author_association: Option<String>,
    /// The text of the comment.
    #[serde(skip_serializing_if="Option::is_none")]
    pub body: Option<String>,
    /// The SHA of the commit to which the comment applies.
    #[serde(skip_serializing_if="Option::is_none")]
    pub commit_id: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The diff of the line that the comment refers to.
    #[serde(skip_serializing_if="Option::is_none")]
    pub diff_hunk: Option<String>,
    /// HTML URL for the pull request review comment.
    #[serde(skip_serializing_if="Option::is_none")]
    pub html_url: Option<String>,
    /// The ID of the pull request review comment.
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<i64>,
    /// The comment ID to reply to.
    #[serde(skip_serializing_if="Option::is_none")]
    pub in_reply_to_id: Option<i64>,
    /// The line of the blob to which the comment applies. The last line of the range for a multi-line comment
    #[serde(skip_serializing_if="Option::is_none")]
    pub line: Option<i64>,
    /// The node ID of the pull request review comment.
    #[serde(skip_serializing_if="Option::is_none")]
    pub node_id: Option<String>,
    /// The SHA of the original commit to which the comment applies.
    #[serde(skip_serializing_if="Option::is_none")]
    pub original_commit_id: Option<String>,
    /// The line of the blob to which the comment applies. The last line of the range for a multi-line comment
    #[serde(skip_serializing_if="Option::is_none")]
    pub original_line: Option<i64>,
    /// The index of the original line in the diff to which the comment applies.
    #[serde(skip_serializing_if="Option::is_none")]
    pub original_position: Option<i64>,
    /// The first line of the range for a multi-line comment.
    #[serde(skip_serializing_if="Option::is_none")]
    pub original_start_line: Option<i64>,
    /// The relative path of the file to which the comment applies.
    #[serde(skip_serializing_if="Option::is_none")]
    pub path: Option<String>,
    /// The line index in the diff to which the comment applies.
    #[serde(skip_serializing_if="Option::is_none")]
    pub position: Option<i64>,
    /// The ID of the pull request review to which the comment belongs.
    #[serde(skip_serializing_if="Option::is_none")]
    pub pull_request_review_id: Option<i64>,
    /// URL for the pull request that the review comment belongs to.
    #[serde(skip_serializing_if="Option::is_none")]
    pub pull_request_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub reactions: Option<Reactions>,
    /// The side of the first line of the range for a multi-line comment.
    #[serde(skip_serializing_if="Option::is_none")]
    pub side: Option<String>,
    /// The first line of the range for a multi-line comment.
    #[serde(skip_serializing_if="Option::is_none")]
    pub start_line: Option<i64>,
    /// The side of the first line of the range for a multi-line comment.
    #[serde(skip_serializing_if="Option::is_none")]
    pub start_side: Option<String>,
    /// The level at which the comment is targeted, can be a diff line or a file.
    #[serde(skip_serializing_if="Option::is_none")]
    pub subject_type: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub updated_at: Option<chrono::DateTime<chrono::Utc>>,
    /// URL for the pull request review comment
    #[serde(skip_serializing_if="Option::is_none")]
    pub url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub user: Option<User>,
}

/// Pull Request Review Request
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct PullRequestReviewRequest {
    #[serde(skip_serializing_if="Option::is_none")]
    pub users: Option<Vec<SimpleUser>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub teams: Option<Vec<Team>>,
}

/// Pull Request Simple
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct PullRequestSimple {
    #[serde(skip_serializing_if="Option::is_none")]
    pub url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub node_id: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub html_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub diff_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub patch_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub issue_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub commits_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub review_comments_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub review_comment_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub comments_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub statuses_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub number: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub state: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub locked: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub title: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub user: Option<NullableSimpleUser>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub body: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub labels: Option<Vec<PullrequestsimpleLabels>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub milestone: Option<NullableMilestone>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub active_lock_reason: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub updated_at: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub closed_at: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub merged_at: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub merge_commit_sha: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub assignee: Option<NullableSimpleUser>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub assignees: Option<Vec<SimpleUser>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub requested_reviewers: Option<Vec<SimpleUser>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub requested_teams: Option<Vec<Team>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub head: Option<PullrequestsimpleHead>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub base: Option<PullrequestsimpleHead>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub _links: Option<PullrequestsimpleLinks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub author_association: Option<AuthorAssociation>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub auto_merge: Option<AutoMerge>,
    /// Indicates whether or not the pull request is a draft.
    #[serde(skip_serializing_if="Option::is_none")]
    pub draft: Option<bool>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct PullRequestWebhook {
    #[serde(skip_serializing_if="Option::is_none")]
    pub url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub node_id: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub html_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub diff_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub patch_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub issue_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub commits_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub review_comments_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub review_comment_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub comments_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub statuses_url: Option<String>,
    /// Number uniquely identifying the pull request within its repository.
    #[serde(skip_serializing_if="Option::is_none")]
    pub number: Option<i64>,
    /// State of this Pull Request. Either `open` or `closed`.
    #[serde(skip_serializing_if="Option::is_none")]
    pub state: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub locked: Option<bool>,
    /// The title of the pull request.
    #[serde(skip_serializing_if="Option::is_none")]
    pub title: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub user: Option<SimpleUser>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub body: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub labels: Option<Vec<PullrequestLabels>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub milestone: Option<NullableMilestone>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub active_lock_reason: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub updated_at: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub closed_at: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub merged_at: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub merge_commit_sha: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub assignee: Option<NullableSimpleUser>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub assignees: Option<Vec<SimpleUser>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub requested_reviewers: Option<Vec<SimpleUser>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub requested_teams: Option<Vec<TeamSimple>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub head: Option<PullrequestHead>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub base: Option<PullrequestHead>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub _links: Option<PullrequestsimpleLinks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub author_association: Option<AuthorAssociation>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub auto_merge: Option<AutoMerge>,
    /// Indicates whether or not the pull request is a draft.
    #[serde(skip_serializing_if="Option::is_none")]
    pub draft: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub merged: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub mergeable: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub rebaseable: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub mergeable_state: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub merged_by: Option<NullableSimpleUser>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub comments: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub review_comments: Option<i64>,
    /// Indicates whether maintainers can modify the pull request.
    #[serde(skip_serializing_if="Option::is_none")]
    pub maintainer_can_modify: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub commits: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub additions: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub deletions: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub changed_files: Option<i64>,
    /// Whether to allow auto-merge for pull requests.
    #[serde(skip_serializing_if="Option::is_none")]
    pub allow_auto_merge: Option<bool>,
    /// Whether to allow updating the pull request's branch.
    #[serde(skip_serializing_if="Option::is_none")]
    pub allow_update_branch: Option<bool>,
    /// Whether to delete head branches when pull requests are merged.
    #[serde(skip_serializing_if="Option::is_none")]
    pub delete_branch_on_merge: Option<bool>,
    /// The default value for a merge commit message. - `PR_TITLE` - default to the pull request's title. - `PR_BODY` - default to the pull request's body. - `BLANK` - default to a blank commit message.
    #[serde(skip_serializing_if="Option::is_none")]
    pub merge_commit_message: Option<String>,
    /// The default value for a merge commit title. - `PR_TITLE` - default to the pull request's title. - `MERGE_MESSAGE` - default to the classic title for a merge message (e.g., \"Merge pull request #123 from branch-name\").
    #[serde(skip_serializing_if="Option::is_none")]
    pub merge_commit_title: Option<String>,
    /// The default value for a squash merge commit message: - `PR_BODY` - default to the pull request's body. - `COMMIT_MESSAGES` - default to the branch's commit messages. - `BLANK` - default to a blank commit message.
    #[serde(skip_serializing_if="Option::is_none")]
    pub squash_merge_commit_message: Option<String>,
    /// The default value for a squash merge commit title: - `PR_TITLE` - default to the pull request's title. - `COMMIT_OR_PR_TITLE` - default to the commit's title (if only one commit) or the pull request's title (when more than one commit).
    #[serde(skip_serializing_if="Option::is_none")]
    pub squash_merge_commit_title: Option<String>,
    /// Whether a squash merge commit can use the pull request title as default. **This property is closing down. Please use `squash_merge_commit_title` instead.**
    #[serde(skip_serializing_if="Option::is_none")]
    pub use_squash_pr_title_as_default: Option<bool>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct PullrequestHead {
    #[serde(skip_serializing_if="Option::is_none")]
    pub label: Option<String>,
    #[serde(rename = "ref")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub git_ref: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub repo: Option<Repository>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub sha: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub user: Option<SimpleUser>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct PullrequestLabels {
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub node_id: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub description: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub color: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub default: Option<bool>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct PullrequestminimalHead {
    #[serde(rename = "ref")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub git_ref: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub sha: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub repo: Option<PullrequestminimalHeadRepo>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct PullrequestminimalHeadRepo {
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct PullrequestreviewcommentLinks {
    #[serde(rename = "self")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub _self: Option<PullrequestreviewcommentLinksSelf>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub html: Option<PullrequestreviewcommentLinksHtml>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub pull_request: Option<PullrequestreviewcommentLinksPullRequest>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct PullrequestreviewcommentLinksHtml {
    #[serde(skip_serializing_if="Option::is_none")]
    pub href: Option<String>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct PullrequestreviewcommentLinksPullRequest {
    #[serde(skip_serializing_if="Option::is_none")]
    pub href: Option<String>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct PullrequestreviewcommentLinksSelf {
    #[serde(skip_serializing_if="Option::is_none")]
    pub href: Option<String>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct PullrequestsimpleHead {
    #[serde(skip_serializing_if="Option::is_none")]
    pub label: Option<String>,
    #[serde(rename = "ref")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub git_ref: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub repo: Option<Repository>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub sha: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub user: Option<NullableSimpleUser>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct PullrequestsimpleLabels {
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub node_id: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub description: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub color: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub default: Option<bool>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct PullrequestsimpleLinks {
    #[serde(skip_serializing_if="Option::is_none")]
    pub comments: Option<Link>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub commits: Option<Link>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub statuses: Option<Link>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub html: Option<Link>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub issue: Option<Link>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub review_comments: Option<Link>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub review_comment: Option<Link>,
    #[serde(rename = "self")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub _self: Option<Link>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct RateLimit {
    #[serde(skip_serializing_if="Option::is_none")]
    pub limit: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub remaining: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub reset: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub used: Option<i64>,
}

/// Rate Limit Overview
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct RateLimitOverview {
    #[serde(skip_serializing_if="Option::is_none")]
    pub resources: Option<RatelimitoverviewResources>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub rate: Option<RateLimit>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct RatelimitoverviewResources {
    #[serde(skip_serializing_if="Option::is_none")]
    pub core: Option<RateLimit>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub graphql: Option<RateLimit>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub search: Option<RateLimit>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub code_search: Option<RateLimit>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub source_import: Option<RateLimit>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub integration_manifest: Option<RateLimit>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub code_scanning_upload: Option<RateLimit>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub actions_runner_registration: Option<RateLimit>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub scim: Option<RateLimit>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub dependency_snapshots: Option<RateLimit>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub code_scanning_autofix: Option<RateLimit>,
}

/// Reactions to conversations provide a way to help people express their feelings more simply and effectively.
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct Reaction {
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub node_id: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub user: Option<NullableSimpleUser>,
    /// The reaction to use
    #[serde(skip_serializing_if="Option::is_none")]
    pub content: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct ReactionRollup {
    #[serde(skip_serializing_if="Option::is_none")]
    pub url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub total_count: Option<i64>,
    #[serde(rename = "+1")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub plus_1: Option<i64>,
    #[serde(rename = "-1")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub minus_1: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub laugh: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub confused: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub heart: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub hooray: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub eyes: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub rocket: Option<i64>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct Reactions {
    #[serde(rename = "+1")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub plus_1: Option<i64>,
    #[serde(rename = "-1")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub minus_1: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub confused: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub eyes: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub heart: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub hooray: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub laugh: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub rocket: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub total_count: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub url: Option<String>,
}

/// A workflow referenced/reused by the initial caller workflow
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct ReferencedWorkflow {
    #[serde(skip_serializing_if="Option::is_none")]
    pub path: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub sha: Option<String>,
    #[serde(rename = "ref")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub git_ref: Option<String>,
}

/// Referrer Traffic
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct ReferrerTraffic {
    #[serde(skip_serializing_if="Option::is_none")]
    pub referrer: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub count: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub uniques: Option<i64>,
}

/// The [release](https://docs.github.com/rest/releases/releases/#get-a-release) object.
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct Release {
    #[serde(skip_serializing_if="Option::is_none")]
    pub assets: Option<Vec<ReleaseAsset>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub assets_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub author: Option<User1>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub body: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub discussion_url: Option<String>,
    /// Whether the release is a draft or published
    #[serde(skip_serializing_if="Option::is_none")]
    pub draft: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub html_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub node_id: Option<String>,
    /// Whether the release is identified as a prerelease or a full release.
    #[serde(skip_serializing_if="Option::is_none")]
    pub prerelease: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub published_at: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub reactions: Option<Reactions>,
    /// The name of the tag.
    #[serde(skip_serializing_if="Option::is_none")]
    pub tag_name: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub tarball_url: Option<String>,
    /// Specifies the commitish value that determines where the Git tag is created from.
    #[serde(skip_serializing_if="Option::is_none")]
    pub target_commitish: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub upload_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub zipball_url: Option<String>,
}

/// Data related to a release.
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct ReleaseAsset {
    #[serde(skip_serializing_if="Option::is_none")]
    pub browser_download_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub content_type: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub download_count: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub label: Option<String>,
    /// The file name of the asset.
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub node_id: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub size: Option<i64>,
    /// State of the release asset.
    #[serde(skip_serializing_if="Option::is_none")]
    pub state: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub updated_at: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub uploader: Option<User5>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub url: Option<String>,
}

/// Generated name and body describing a release
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct ReleaseNotesContent {
    /// The generated name of the release
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,
    /// The generated body describing the contents of the release supporting markdown formatting
    #[serde(skip_serializing_if="Option::is_none")]
    pub body: Option<String>,
}

/// Removed from Project Issue Event
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct RemovedFromProjectIssueEvent {
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub node_id: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub actor: Option<SimpleUser>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub event: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub commit_id: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub commit_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub created_at: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub performed_via_github_app: Option<NullableIntegration>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub project_card: Option<AddedtoprojectissueeventProjectCard>,
}

/// Renamed Issue Event
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct RenamedIssueEvent {
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub node_id: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub actor: Option<SimpleUser>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub event: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub commit_id: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub commit_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub created_at: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub performed_via_github_app: Option<NullableIntegration>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub rename: Option<RenamedissueeventRename>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct RenamedissueeventRename {
    #[serde(skip_serializing_if="Option::is_none")]
    pub from: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub to: Option<String>,
}

/// Set repository secrets for GitHub Codespaces.
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct RepoCodespacesSecret {
    /// The name of the secret.
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub updated_at: Option<chrono::DateTime<chrono::Utc>>,
}

/// Repo Search Result Item
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct RepoSearchResultItem {
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub node_id: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub full_name: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub owner: Option<NullableSimpleUser>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub private: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub html_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub description: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub fork: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub updated_at: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub pushed_at: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub homepage: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub size: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub stargazers_count: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub watchers_count: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub language: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub forks_count: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub open_issues_count: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub master_branch: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub default_branch: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub score: Option<f64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub forks_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub keys_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub collaborators_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub teams_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub hooks_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub issue_events_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub events_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub assignees_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub branches_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub tags_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub blobs_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub git_tags_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub git_refs_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub trees_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub statuses_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub languages_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub stargazers_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub contributors_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub subscribers_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub subscription_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub commits_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub git_commits_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub comments_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub issue_comment_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub contents_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub compare_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub merges_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub archive_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub downloads_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub issues_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub pulls_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub milestones_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub notifications_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub labels_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub releases_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub deployments_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub git_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub ssh_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub clone_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub svn_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub forks: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub open_issues: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub watchers: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub topics: Option<Vec<String>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub mirror_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub has_issues: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub has_projects: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub has_pages: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub has_wiki: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub has_downloads: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub has_discussions: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub archived: Option<bool>,
    /// Returns whether or not this repository disabled.
    #[serde(skip_serializing_if="Option::is_none")]
    pub disabled: Option<bool>,
    /// The repository visibility: public, private, or internal.
    #[serde(skip_serializing_if="Option::is_none")]
    pub visibility: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub license: Option<NullableLicenseSimple>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub permissions: Option<FullrepositoryPermissions>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub text_matches: Option<SearchResultTextMatches>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub temp_clone_token: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub allow_merge_commit: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub allow_squash_merge: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub allow_rebase_merge: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub allow_auto_merge: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub delete_branch_on_merge: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub allow_forking: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub is_template: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub web_commit_signoff_required: Option<bool>,
}

/// A git repository
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct Repository {
    /// Whether to allow auto-merge for pull requests.
    #[serde(skip_serializing_if="Option::is_none")]
    pub allow_auto_merge: Option<bool>,
    /// Whether to allow private forks
    #[serde(skip_serializing_if="Option::is_none")]
    pub allow_forking: Option<bool>,
    /// Whether to allow merge commits for pull requests.
    #[serde(skip_serializing_if="Option::is_none")]
    pub allow_merge_commit: Option<bool>,
    /// Whether to allow rebase merges for pull requests.
    #[serde(skip_serializing_if="Option::is_none")]
    pub allow_rebase_merge: Option<bool>,
    /// Whether to allow squash merges for pull requests.
    #[serde(skip_serializing_if="Option::is_none")]
    pub allow_squash_merge: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub allow_update_branch: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub archive_url: Option<String>,
    /// Whether the repository is archived.
    #[serde(skip_serializing_if="Option::is_none")]
    pub archived: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub assignees_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub blobs_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub branches_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub clone_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub collaborators_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub comments_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub commits_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub compare_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub contents_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub contributors_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub created_at: Option<OneOfRepositoryCreatedAt>,
    /// The default branch of the repository.
    #[serde(skip_serializing_if="Option::is_none")]
    pub default_branch: Option<String>,
    /// Whether to delete head branches when pull requests are merged
    #[serde(skip_serializing_if="Option::is_none")]
    pub delete_branch_on_merge: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub deployments_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub description: Option<String>,
    /// Returns whether or not this repository is disabled.
    #[serde(skip_serializing_if="Option::is_none")]
    pub disabled: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub downloads_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub events_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub fork: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub forks: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub forks_count: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub forks_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub full_name: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub git_commits_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub git_refs_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub git_tags_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub git_url: Option<String>,
    /// Whether downloads are enabled.
    #[serde(skip_serializing_if="Option::is_none")]
    pub has_downloads: Option<bool>,
    /// Whether issues are enabled.
    #[serde(skip_serializing_if="Option::is_none")]
    pub has_issues: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub has_pages: Option<bool>,
    /// Whether projects are enabled.
    #[serde(skip_serializing_if="Option::is_none")]
    pub has_projects: Option<bool>,
    /// Whether the wiki is enabled.
    #[serde(skip_serializing_if="Option::is_none")]
    pub has_wiki: Option<bool>,
    /// Whether discussions are enabled.
    #[serde(skip_serializing_if="Option::is_none")]
    pub has_discussions: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub homepage: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub hooks_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub html_url: Option<String>,
    /// Unique identifier of the repository
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub is_template: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub issue_comment_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub issue_events_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub issues_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub keys_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub labels_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub language: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub languages_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub license: Option<License>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub master_branch: Option<String>,
    /// The default value for a merge commit message.  - `PR_TITLE` - default to the pull request's title. - `PR_BODY` - default to the pull request's body. - `BLANK` - default to a blank commit message.
    #[serde(skip_serializing_if="Option::is_none")]
    pub merge_commit_message: Option<String>,
    /// The default value for a merge commit title.  - `PR_TITLE` - default to the pull request's title. - `MERGE_MESSAGE` - default to the classic title for a merge message (e.g., Merge pull request #123 from branch-name).
    #[serde(skip_serializing_if="Option::is_none")]
    pub merge_commit_title: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub merges_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub milestones_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub mirror_url: Option<String>,
    /// The name of the repository.
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub node_id: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub notifications_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub open_issues: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub open_issues_count: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub organization: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub owner: Option<User1>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub permissions: Option<RepositoryPermissions>,
    /// Whether the repository is private or public.
    #[serde(skip_serializing_if="Option::is_none")]
    pub private: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub public: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub pulls_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub pushed_at: Option<OneOfRepositoryPushedAt>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub releases_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub role_name: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub size: Option<i64>,
    /// The default value for a squash merge commit message:  - `PR_BODY` - default to the pull request's body. - `COMMIT_MESSAGES` - default to the branch's commit messages. - `BLANK` - default to a blank commit message.
    #[serde(skip_serializing_if="Option::is_none")]
    pub squash_merge_commit_message: Option<String>,
    /// The default value for a squash merge commit title:  - `PR_TITLE` - default to the pull request's title. - `COMMIT_OR_PR_TITLE` - default to the commit's title (if only one commit) or the pull request's title (when more than one commit).
    #[serde(skip_serializing_if="Option::is_none")]
    pub squash_merge_commit_title: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub ssh_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub stargazers: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub stargazers_count: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub stargazers_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub statuses_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub subscribers_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub subscription_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub svn_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub tags_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub teams_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub topics: Option<Vec<String>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub trees_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub updated_at: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub url: Option<String>,
    /// Whether a squash merge commit can use the pull request title as default.
    #[serde(skip_serializing_if="Option::is_none")]
    pub use_squash_pr_title_as_default: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub visibility: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub watchers: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub watchers_count: Option<i64>,
    /// Whether to require contributors to sign off on web-based commits
    #[serde(skip_serializing_if="Option::is_none")]
    pub web_commit_signoff_required: Option<bool>,
}

/// A git repository
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct Repository1 {
    /// Whether to allow auto-merge for pull requests.
    #[serde(skip_serializing_if="Option::is_none")]
    pub allow_auto_merge: Option<bool>,
    /// Whether to allow private forks
    #[serde(skip_serializing_if="Option::is_none")]
    pub allow_forking: Option<bool>,
    /// Whether to allow merge commits for pull requests.
    #[serde(skip_serializing_if="Option::is_none")]
    pub allow_merge_commit: Option<bool>,
    /// Whether to allow rebase merges for pull requests.
    #[serde(skip_serializing_if="Option::is_none")]
    pub allow_rebase_merge: Option<bool>,
    /// Whether to allow squash merges for pull requests.
    #[serde(skip_serializing_if="Option::is_none")]
    pub allow_squash_merge: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub allow_update_branch: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub archive_url: Option<String>,
    /// Whether the repository is archived.
    #[serde(skip_serializing_if="Option::is_none")]
    pub archived: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub assignees_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub blobs_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub branches_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub clone_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub collaborators_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub comments_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub commits_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub compare_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub contents_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub contributors_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub created_at: Option<OneOfRepository1CreatedAt>,
    /// The custom properties that were defined for the repository. The keys are the custom property names, and the values are the corresponding custom property values.
    #[serde(skip_serializing_if="Option::is_none")]
    pub custom_properties: Option<HashMap<String, HashMap<String, Value>>>,
    /// The default branch of the repository.
    #[serde(skip_serializing_if="Option::is_none")]
    pub default_branch: Option<String>,
    /// Whether to delete head branches when pull requests are merged
    #[serde(skip_serializing_if="Option::is_none")]
    pub delete_branch_on_merge: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub deployments_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub description: Option<String>,
    /// Returns whether or not this repository is disabled.
    #[serde(skip_serializing_if="Option::is_none")]
    pub disabled: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub downloads_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub events_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub fork: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub forks: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub forks_count: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub forks_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub full_name: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub git_commits_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub git_refs_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub git_tags_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub git_url: Option<String>,
    /// Whether the repository has discussions enabled.
    #[serde(skip_serializing_if="Option::is_none")]
    pub has_discussions: Option<bool>,
    /// Whether downloads are enabled.
    #[serde(skip_serializing_if="Option::is_none")]
    pub has_downloads: Option<bool>,
    /// Whether issues are enabled.
    #[serde(skip_serializing_if="Option::is_none")]
    pub has_issues: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub has_pages: Option<bool>,
    /// Whether projects are enabled.
    #[serde(skip_serializing_if="Option::is_none")]
    pub has_projects: Option<bool>,
    /// Whether the wiki is enabled.
    #[serde(skip_serializing_if="Option::is_none")]
    pub has_wiki: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub homepage: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub hooks_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub html_url: Option<String>,
    /// Unique identifier of the repository
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub is_template: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub issue_comment_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub issue_events_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub issues_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub keys_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub labels_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub language: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub languages_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub license: Option<License>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub master_branch: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub merges_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub milestones_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub mirror_url: Option<String>,
    /// The name of the repository.
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub node_id: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub notifications_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub open_issues: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub open_issues_count: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub organization: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub owner: Option<User1>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub permissions: Option<RepositoryPermissions>,
    /// Whether the repository is private or public.
    #[serde(skip_serializing_if="Option::is_none")]
    pub private: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub public: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub pulls_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub pushed_at: Option<OneOfRepository1PushedAt>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub releases_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub role_name: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub size: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub ssh_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub stargazers: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub stargazers_count: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub stargazers_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub statuses_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub subscribers_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub subscription_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub svn_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub tags_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub teams_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub topics: Option<Vec<String>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub trees_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub updated_at: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub visibility: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub watchers: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub watchers_count: Option<i64>,
    /// Whether to require commit signoff.
    #[serde(skip_serializing_if="Option::is_none")]
    pub web_commit_signoff_required: Option<bool>,
}

/// A git repository
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct Repository10 {
    /// Whether to allow auto-merge for pull requests.
    #[serde(skip_serializing_if="Option::is_none")]
    pub allow_auto_merge: Option<bool>,
    /// Whether to allow private forks
    #[serde(skip_serializing_if="Option::is_none")]
    pub allow_forking: Option<bool>,
    /// Whether to allow merge commits for pull requests.
    #[serde(skip_serializing_if="Option::is_none")]
    pub allow_merge_commit: Option<bool>,
    /// Whether to allow rebase merges for pull requests.
    #[serde(skip_serializing_if="Option::is_none")]
    pub allow_rebase_merge: Option<bool>,
    /// Whether to allow squash merges for pull requests.
    #[serde(skip_serializing_if="Option::is_none")]
    pub allow_squash_merge: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub allow_update_branch: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub archive_url: Option<String>,
    /// Whether the repository is archived.
    #[serde(skip_serializing_if="Option::is_none")]
    pub archived: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub assignees_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub blobs_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub branches_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub clone_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub collaborators_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub comments_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub commits_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub compare_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub contents_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub contributors_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub created_at: Option<OneOfRepository10CreatedAt>,
    /// The default branch of the repository.
    #[serde(skip_serializing_if="Option::is_none")]
    pub default_branch: Option<String>,
    /// Whether to delete head branches when pull requests are merged
    #[serde(skip_serializing_if="Option::is_none")]
    pub delete_branch_on_merge: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub deployments_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub description: Option<String>,
    /// Returns whether or not this repository is disabled.
    #[serde(skip_serializing_if="Option::is_none")]
    pub disabled: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub downloads_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub events_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub fork: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub forks: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub forks_count: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub forks_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub full_name: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub git_commits_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub git_refs_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub git_tags_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub git_url: Option<String>,
    /// Whether downloads are enabled.
    #[serde(skip_serializing_if="Option::is_none")]
    pub has_downloads: Option<bool>,
    /// Whether issues are enabled.
    #[serde(skip_serializing_if="Option::is_none")]
    pub has_issues: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub has_pages: Option<bool>,
    /// Whether projects are enabled.
    #[serde(skip_serializing_if="Option::is_none")]
    pub has_projects: Option<bool>,
    /// Whether the wiki is enabled.
    #[serde(skip_serializing_if="Option::is_none")]
    pub has_wiki: Option<bool>,
    /// Whether discussions are enabled.
    #[serde(skip_serializing_if="Option::is_none")]
    pub has_discussions: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub homepage: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub hooks_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub html_url: Option<String>,
    /// Unique identifier of the repository
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub is_template: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub issue_comment_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub issue_events_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub issues_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub keys_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub labels_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub language: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub languages_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub license: Option<License>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub master_branch: Option<String>,
    /// The default value for a merge commit message.
    #[serde(skip_serializing_if="Option::is_none")]
    pub merge_commit_message: Option<String>,
    /// The default value for a merge commit message title.
    #[serde(skip_serializing_if="Option::is_none")]
    pub merge_commit_title: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub merges_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub milestones_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub mirror_url: Option<String>,
    /// The name of the repository.
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub node_id: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub notifications_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub open_issues: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub open_issues_count: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub organization: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub owner: Option<User1>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub permissions: Option<RepositoryPermissions>,
    /// Whether the repository is private or public.
    #[serde(skip_serializing_if="Option::is_none")]
    pub private: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub public: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub pulls_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub pushed_at: Option<OneOfRepository10PushedAt>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub releases_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub role_name: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub size: Option<i64>,
    /// The default value for a squash merge commit message:  - `PR_BODY` - default to the pull request's body. - `COMMIT_MESSAGES` - default to the branch's commit messages. - `BLANK` - default to a blank commit message.
    #[serde(skip_serializing_if="Option::is_none")]
    pub squash_merge_commit_message: Option<String>,
    /// The default value for a squash merge commit title:  - `PR_TITLE` - default to the pull request's title. - `COMMIT_OR_PR_TITLE` - default to the commit's title (if only one commit) or the pull request's title (when more than one commit).
    #[serde(skip_serializing_if="Option::is_none")]
    pub squash_merge_commit_title: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub ssh_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub stargazers: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub stargazers_count: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub stargazers_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub statuses_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub subscribers_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub subscription_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub svn_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub tags_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub teams_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub topics: Option<Vec<String>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub trees_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub updated_at: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub url: Option<String>,
    /// Whether a squash merge commit can use the pull request title as default. **This property is closing down. Please use `squash_merge_commit_title` instead.
    #[serde(skip_serializing_if="Option::is_none")]
    pub use_squash_pr_title_as_default: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub visibility: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub watchers: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub watchers_count: Option<i64>,
    /// Whether to require contributors to sign off on web-based commits
    #[serde(skip_serializing_if="Option::is_none")]
    pub web_commit_signoff_required: Option<bool>,
}

/// A git repository
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct Repository11 {
    /// Whether to allow auto-merge for pull requests.
    #[serde(skip_serializing_if="Option::is_none")]
    pub allow_auto_merge: Option<bool>,
    /// Whether to allow private forks
    #[serde(skip_serializing_if="Option::is_none")]
    pub allow_forking: Option<bool>,
    /// Whether to allow merge commits for pull requests.
    #[serde(skip_serializing_if="Option::is_none")]
    pub allow_merge_commit: Option<bool>,
    /// Whether to allow rebase merges for pull requests.
    #[serde(skip_serializing_if="Option::is_none")]
    pub allow_rebase_merge: Option<bool>,
    /// Whether to allow squash merges for pull requests.
    #[serde(skip_serializing_if="Option::is_none")]
    pub allow_squash_merge: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub allow_update_branch: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub archive_url: Option<String>,
    /// Whether the repository is archived.
    #[serde(skip_serializing_if="Option::is_none")]
    pub archived: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub assignees_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub blobs_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub branches_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub clone_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub collaborators_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub comments_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub commits_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub compare_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub contents_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub contributors_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub created_at: Option<OneOfRepository11CreatedAt>,
    /// The custom properties that were defined for the repository. The keys are the custom property names, and the values are the corresponding custom property values.
    #[serde(skip_serializing_if="Option::is_none")]
    pub custom_properties: Option<HashMap<String, HashMap<String, Value>>>,
    /// The default branch of the repository.
    #[serde(skip_serializing_if="Option::is_none")]
    pub default_branch: Option<String>,
    /// Whether to delete head branches when pull requests are merged
    #[serde(skip_serializing_if="Option::is_none")]
    pub delete_branch_on_merge: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub deployments_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub description: Option<String>,
    /// Returns whether or not this repository is disabled.
    #[serde(skip_serializing_if="Option::is_none")]
    pub disabled: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub downloads_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub events_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub fork: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub forks: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub forks_count: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub forks_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub full_name: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub git_commits_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub git_refs_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub git_tags_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub git_url: Option<String>,
    /// Whether downloads are enabled.
    #[serde(skip_serializing_if="Option::is_none")]
    pub has_downloads: Option<bool>,
    /// Whether issues are enabled.
    #[serde(skip_serializing_if="Option::is_none")]
    pub has_issues: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub has_pages: Option<bool>,
    /// Whether projects are enabled.
    #[serde(skip_serializing_if="Option::is_none")]
    pub has_projects: Option<bool>,
    /// Whether the wiki is enabled.
    #[serde(skip_serializing_if="Option::is_none")]
    pub has_wiki: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub homepage: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub hooks_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub html_url: Option<String>,
    /// Unique identifier of the repository
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub is_template: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub issue_comment_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub issue_events_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub issues_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub keys_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub labels_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub language: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub languages_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub license: Option<License>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub master_branch: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub merges_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub milestones_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub mirror_url: Option<String>,
    /// The name of the repository.
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub node_id: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub notifications_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub open_issues: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub open_issues_count: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub organization: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub owner: Option<User1>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub permissions: Option<RepositoryPermissions>,
    /// Whether the repository is private or public.
    #[serde(skip_serializing_if="Option::is_none")]
    pub private: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub public: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub pulls_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub pushed_at: Option<OneOfRepository11PushedAt>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub releases_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub role_name: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub size: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub ssh_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub stargazers: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub stargazers_count: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub stargazers_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub statuses_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub subscribers_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub subscription_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub svn_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub tags_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub teams_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub topics: Option<Vec<String>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub trees_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub updated_at: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub visibility: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub watchers: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub watchers_count: Option<i64>,
}

/// A git repository
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct Repository2 {
    /// Whether to allow auto-merge for pull requests.
    #[serde(skip_serializing_if="Option::is_none")]
    pub allow_auto_merge: Option<bool>,
    /// Whether to allow private forks
    #[serde(skip_serializing_if="Option::is_none")]
    pub allow_forking: Option<bool>,
    /// Whether to allow merge commits for pull requests.
    #[serde(skip_serializing_if="Option::is_none")]
    pub allow_merge_commit: Option<bool>,
    /// Whether to allow rebase merges for pull requests.
    #[serde(skip_serializing_if="Option::is_none")]
    pub allow_rebase_merge: Option<bool>,
    /// Whether to allow squash merges for pull requests.
    #[serde(skip_serializing_if="Option::is_none")]
    pub allow_squash_merge: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub allow_update_branch: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub archive_url: Option<String>,
    /// Whether the repository is archived.
    #[serde(skip_serializing_if="Option::is_none")]
    pub archived: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub assignees_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub blobs_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub branches_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub clone_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub collaborators_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub comments_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub commits_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub compare_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub contents_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub contributors_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub created_at: Option<OneOfRepository2CreatedAt>,
    /// The custom properties that were defined for the repository. The keys are the custom property names, and the values are the corresponding custom property values.
    #[serde(skip_serializing_if="Option::is_none")]
    pub custom_properties: Option<HashMap<String, HashMap<String, Value>>>,
    /// The default branch of the repository.
    #[serde(skip_serializing_if="Option::is_none")]
    pub default_branch: Option<String>,
    /// Whether to delete head branches when pull requests are merged
    #[serde(skip_serializing_if="Option::is_none")]
    pub delete_branch_on_merge: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub deployments_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub description: Option<String>,
    /// Returns whether or not this repository is disabled.
    #[serde(skip_serializing_if="Option::is_none")]
    pub disabled: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub downloads_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub events_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub fork: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub forks: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub forks_count: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub forks_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub full_name: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub git_commits_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub git_refs_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub git_tags_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub git_url: Option<String>,
    /// Whether downloads are enabled.
    #[serde(skip_serializing_if="Option::is_none")]
    pub has_downloads: Option<bool>,
    /// Whether issues are enabled.
    #[serde(skip_serializing_if="Option::is_none")]
    pub has_issues: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub has_pages: Option<bool>,
    /// Whether projects are enabled.
    #[serde(skip_serializing_if="Option::is_none")]
    pub has_projects: Option<bool>,
    /// Whether the wiki is enabled.
    #[serde(skip_serializing_if="Option::is_none")]
    pub has_wiki: Option<bool>,
    /// Whether discussions are enabled.
    #[serde(skip_serializing_if="Option::is_none")]
    pub has_discussions: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub homepage: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub hooks_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub html_url: Option<String>,
    /// Unique identifier of the repository
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub is_template: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub issue_comment_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub issue_events_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub issues_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub keys_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub labels_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub language: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub languages_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub license: Option<License>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub master_branch: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub merges_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub milestones_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub mirror_url: Option<String>,
    /// The name of the repository.
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub node_id: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub notifications_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub open_issues: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub open_issues_count: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub organization: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub owner: Option<User1>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub permissions: Option<RepositoryPermissions>,
    /// Whether the repository is private or public.
    #[serde(skip_serializing_if="Option::is_none")]
    pub private: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub public: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub pulls_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub pushed_at: Option<OneOfRepository2PushedAt>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub releases_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub role_name: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub size: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub ssh_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub stargazers: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub stargazers_count: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub stargazers_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub statuses_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub subscribers_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub subscription_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub svn_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub tags_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub teams_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub topics: Option<Vec<String>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub trees_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub updated_at: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub visibility: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub watchers: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub watchers_count: Option<i64>,
    /// Whether to require contributors to sign off on web-based commits
    #[serde(skip_serializing_if="Option::is_none")]
    pub web_commit_signoff_required: Option<bool>,
}

/// A git repository
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct Repository3 {
    /// Whether to allow auto-merge for pull requests.
    #[serde(skip_serializing_if="Option::is_none")]
    pub allow_auto_merge: Option<bool>,
    /// Whether to allow private forks
    #[serde(skip_serializing_if="Option::is_none")]
    pub allow_forking: Option<bool>,
    /// Whether to allow merge commits for pull requests.
    #[serde(skip_serializing_if="Option::is_none")]
    pub allow_merge_commit: Option<bool>,
    /// Whether to allow rebase merges for pull requests.
    #[serde(skip_serializing_if="Option::is_none")]
    pub allow_rebase_merge: Option<bool>,
    /// Whether to allow squash merges for pull requests.
    #[serde(skip_serializing_if="Option::is_none")]
    pub allow_squash_merge: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub allow_update_branch: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub archive_url: Option<String>,
    /// Whether the repository is archived.
    #[serde(skip_serializing_if="Option::is_none")]
    pub archived: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub assignees_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub blobs_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub branches_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub clone_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub collaborators_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub comments_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub commits_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub compare_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub contents_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub contributors_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub created_at: Option<OneOfRepository3CreatedAt>,
    /// The default branch of the repository.
    #[serde(skip_serializing_if="Option::is_none")]
    pub default_branch: Option<String>,
    /// Whether to delete head branches when pull requests are merged
    #[serde(skip_serializing_if="Option::is_none")]
    pub delete_branch_on_merge: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub deployments_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub description: Option<String>,
    /// Returns whether or not this repository is disabled.
    #[serde(skip_serializing_if="Option::is_none")]
    pub disabled: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub downloads_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub events_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub fork: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub forks: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub forks_count: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub forks_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub full_name: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub git_commits_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub git_refs_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub git_tags_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub git_url: Option<String>,
    /// Whether downloads are enabled.
    #[serde(skip_serializing_if="Option::is_none")]
    pub has_downloads: Option<bool>,
    /// Whether issues are enabled.
    #[serde(skip_serializing_if="Option::is_none")]
    pub has_issues: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub has_pages: Option<bool>,
    /// Whether projects are enabled.
    #[serde(skip_serializing_if="Option::is_none")]
    pub has_projects: Option<bool>,
    /// Whether the wiki is enabled.
    #[serde(skip_serializing_if="Option::is_none")]
    pub has_wiki: Option<bool>,
    /// Whether discussions are enabled.
    #[serde(skip_serializing_if="Option::is_none")]
    pub has_discussions: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub homepage: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub hooks_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub html_url: Option<String>,
    /// Unique identifier of the repository
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub is_template: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub issue_comment_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub issue_events_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub issues_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub keys_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub labels_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub language: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub languages_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub license: Option<License>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub master_branch: Option<String>,
    /// The default value for a merge commit message.  - `PR_TITLE` - default to the pull request's title. - `PR_BODY` - default to the pull request's body. - `BLANK` - default to a blank commit message.
    #[serde(skip_serializing_if="Option::is_none")]
    pub merge_commit_message: Option<String>,
    /// The default value for a merge commit title.  - `PR_TITLE` - default to the pull request's title. - `MERGE_MESSAGE` - default to the classic title for a merge message (e.g., Merge pull request #123 from branch-name).
    #[serde(skip_serializing_if="Option::is_none")]
    pub merge_commit_title: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub merges_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub milestones_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub mirror_url: Option<String>,
    /// The name of the repository.
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub node_id: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub notifications_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub open_issues: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub open_issues_count: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub organization: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub owner: Option<User1>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub permissions: Option<RepositoryPermissions>,
    /// Whether the repository is private or public.
    #[serde(skip_serializing_if="Option::is_none")]
    pub private: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub public: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub pulls_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub pushed_at: Option<OneOfRepository3PushedAt>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub releases_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub role_name: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub size: Option<i64>,
    /// The default value for a squash merge commit message:  - `PR_BODY` - default to the pull request's body. - `COMMIT_MESSAGES` - default to the branch's commit messages. - `BLANK` - default to a blank commit message.
    #[serde(skip_serializing_if="Option::is_none")]
    pub squash_merge_commit_message: Option<String>,
    /// The default value for a squash merge commit title:  - `PR_TITLE` - default to the pull request's title. - `COMMIT_OR_PR_TITLE` - default to the commit's title (if only one commit) or the pull request's title (when more than one commit).
    #[serde(skip_serializing_if="Option::is_none")]
    pub squash_merge_commit_title: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub ssh_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub stargazers: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub stargazers_count: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub stargazers_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub statuses_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub subscribers_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub subscription_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub svn_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub tags_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub teams_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub topics: Option<Vec<String>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub trees_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub updated_at: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub url: Option<String>,
    /// Whether a squash merge commit can use the pull request title as default. **This property is closing down. Please use `squash_merge_commit_title` instead.
    #[serde(skip_serializing_if="Option::is_none")]
    pub use_squash_pr_title_as_default: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub visibility: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub watchers: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub watchers_count: Option<i64>,
    /// Whether to require contributors to sign off on web-based commits
    #[serde(skip_serializing_if="Option::is_none")]
    pub web_commit_signoff_required: Option<bool>,
}

/// A git repository
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct Repository4 {
    /// Whether to allow auto-merge for pull requests.
    #[serde(skip_serializing_if="Option::is_none")]
    pub allow_auto_merge: Option<bool>,
    /// Whether to allow private forks
    #[serde(skip_serializing_if="Option::is_none")]
    pub allow_forking: Option<bool>,
    /// Whether to allow merge commits for pull requests.
    #[serde(skip_serializing_if="Option::is_none")]
    pub allow_merge_commit: Option<bool>,
    /// Whether to allow rebase merges for pull requests.
    #[serde(skip_serializing_if="Option::is_none")]
    pub allow_rebase_merge: Option<bool>,
    /// Whether to allow squash merges for pull requests.
    #[serde(skip_serializing_if="Option::is_none")]
    pub allow_squash_merge: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub allow_update_branch: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub archive_url: Option<String>,
    /// Whether the repository is archived.
    #[serde(skip_serializing_if="Option::is_none")]
    pub archived: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub assignees_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub blobs_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub branches_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub clone_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub collaborators_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub comments_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub commits_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub compare_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub contents_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub contributors_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub created_at: Option<OneOfRepository4CreatedAt>,
    /// The default branch of the repository.
    #[serde(skip_serializing_if="Option::is_none")]
    pub default_branch: Option<String>,
    /// Whether to delete head branches when pull requests are merged
    #[serde(skip_serializing_if="Option::is_none")]
    pub delete_branch_on_merge: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub deployments_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub description: Option<String>,
    /// Returns whether or not this repository is disabled.
    #[serde(skip_serializing_if="Option::is_none")]
    pub disabled: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub downloads_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub events_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub fork: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub forks: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub forks_count: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub forks_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub full_name: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub git_commits_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub git_refs_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub git_tags_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub git_url: Option<String>,
    /// Whether downloads are enabled.
    #[serde(skip_serializing_if="Option::is_none")]
    pub has_downloads: Option<bool>,
    /// Whether issues are enabled.
    #[serde(skip_serializing_if="Option::is_none")]
    pub has_issues: Option<bool>,
    /// Whether discussions are enabled.
    #[serde(skip_serializing_if="Option::is_none")]
    pub has_discussions: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub has_pages: Option<bool>,
    /// Whether projects are enabled.
    #[serde(skip_serializing_if="Option::is_none")]
    pub has_projects: Option<bool>,
    /// Whether the wiki is enabled.
    #[serde(skip_serializing_if="Option::is_none")]
    pub has_wiki: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub homepage: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub hooks_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub html_url: Option<String>,
    /// Unique identifier of the repository
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub is_template: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub issue_comment_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub issue_events_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub issues_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub keys_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub labels_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub language: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub languages_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub license: Option<License>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub master_branch: Option<String>,
    /// The default value for a merge commit message.  - `PR_TITLE` - default to the pull request's title. - `PR_BODY` - default to the pull request's body. - `BLANK` - default to a blank commit message.
    #[serde(skip_serializing_if="Option::is_none")]
    pub merge_commit_message: Option<String>,
    /// The default value for a merge commit title.  - `PR_TITLE` - default to the pull request's title. - `MERGE_MESSAGE` - default to the classic title for a merge message (e.g., Merge pull request #123 from branch-name).
    #[serde(skip_serializing_if="Option::is_none")]
    pub merge_commit_title: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub merges_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub milestones_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub mirror_url: Option<String>,
    /// The name of the repository.
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub node_id: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub notifications_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub open_issues: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub open_issues_count: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub organization: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub owner: Option<User1>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub permissions: Option<RepositoryPermissions>,
    /// Whether the repository is private or public.
    #[serde(skip_serializing_if="Option::is_none")]
    pub private: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub public: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub pulls_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub pushed_at: Option<OneOfRepository4PushedAt>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub releases_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub role_name: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub size: Option<i64>,
    /// The default value for a squash merge commit message:  - `PR_BODY` - default to the pull request's body. - `COMMIT_MESSAGES` - default to the branch's commit messages. - `BLANK` - default to a blank commit message.
    #[serde(skip_serializing_if="Option::is_none")]
    pub squash_merge_commit_message: Option<String>,
    /// The default value for a squash merge commit title:  - `PR_TITLE` - default to the pull request's title. - `COMMIT_OR_PR_TITLE` - default to the commit's title (if only one commit) or the pull request's title (when more than one commit).
    #[serde(skip_serializing_if="Option::is_none")]
    pub squash_merge_commit_title: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub ssh_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub stargazers: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub stargazers_count: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub stargazers_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub statuses_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub subscribers_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub subscription_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub svn_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub tags_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub teams_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub topics: Option<Vec<String>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub trees_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub updated_at: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub url: Option<String>,
    /// Whether a squash merge commit can use the pull request title as default. **This property is closing down. Please use `squash_merge_commit_title` instead.
    #[serde(skip_serializing_if="Option::is_none")]
    pub use_squash_pr_title_as_default: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub visibility: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub watchers: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub watchers_count: Option<i64>,
    /// Whether to require contributors to sign off on web-based commits
    #[serde(skip_serializing_if="Option::is_none")]
    pub web_commit_signoff_required: Option<bool>,
}

/// A git repository
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct Repository5 {
    /// Whether to allow auto-merge for pull requests.
    #[serde(skip_serializing_if="Option::is_none")]
    pub allow_auto_merge: Option<bool>,
    /// Whether to allow private forks
    #[serde(skip_serializing_if="Option::is_none")]
    pub allow_forking: Option<bool>,
    /// Whether to allow merge commits for pull requests.
    #[serde(skip_serializing_if="Option::is_none")]
    pub allow_merge_commit: Option<bool>,
    /// Whether to allow rebase merges for pull requests.
    #[serde(skip_serializing_if="Option::is_none")]
    pub allow_rebase_merge: Option<bool>,
    /// Whether to allow squash merges for pull requests.
    #[serde(skip_serializing_if="Option::is_none")]
    pub allow_squash_merge: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub allow_update_branch: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub archive_url: Option<String>,
    /// Whether the repository is archived.
    #[serde(skip_serializing_if="Option::is_none")]
    pub archived: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub assignees_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub blobs_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub branches_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub clone_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub collaborators_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub comments_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub commits_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub compare_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub contents_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub contributors_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub created_at: Option<OneOfRepository5CreatedAt>,
    /// The default branch of the repository.
    #[serde(skip_serializing_if="Option::is_none")]
    pub default_branch: Option<String>,
    /// Whether to delete head branches when pull requests are merged
    #[serde(skip_serializing_if="Option::is_none")]
    pub delete_branch_on_merge: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub deployments_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub description: Option<String>,
    /// Returns whether or not this repository is disabled.
    #[serde(skip_serializing_if="Option::is_none")]
    pub disabled: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub downloads_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub events_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub fork: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub forks: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub forks_count: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub forks_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub full_name: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub git_commits_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub git_refs_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub git_tags_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub git_url: Option<String>,
    /// Whether downloads are enabled.
    #[serde(skip_serializing_if="Option::is_none")]
    pub has_downloads: Option<bool>,
    /// Whether issues are enabled.
    #[serde(skip_serializing_if="Option::is_none")]
    pub has_issues: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub has_pages: Option<bool>,
    /// Whether projects are enabled.
    #[serde(skip_serializing_if="Option::is_none")]
    pub has_projects: Option<bool>,
    /// Whether the wiki is enabled.
    #[serde(skip_serializing_if="Option::is_none")]
    pub has_wiki: Option<bool>,
    /// Whether discussions are enabled.
    #[serde(skip_serializing_if="Option::is_none")]
    pub has_discussions: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub homepage: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub hooks_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub html_url: Option<String>,
    /// Unique identifier of the repository
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub is_template: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub issue_comment_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub issue_events_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub issues_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub keys_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub labels_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub language: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub languages_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub license: Option<License>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub master_branch: Option<String>,
    /// The default value for a merge commit message.  - `PR_TITLE` - default to the pull request's title. - `PR_BODY` - default to the pull request's body. - `BLANK` - default to a blank commit message.
    #[serde(skip_serializing_if="Option::is_none")]
    pub merge_commit_message: Option<String>,
    /// The default value for a merge commit title.  - `PR_TITLE` - default to the pull request's title. - `MERGE_MESSAGE` - default to the classic title for a merge message (e.g., Merge pull request #123 from branch-name).
    #[serde(skip_serializing_if="Option::is_none")]
    pub merge_commit_title: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub merges_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub milestones_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub mirror_url: Option<String>,
    /// The name of the repository.
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub node_id: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub notifications_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub open_issues: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub open_issues_count: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub organization: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub owner: Option<User1>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub permissions: Option<RepositoryPermissions>,
    /// Whether the repository is private or public.
    #[serde(skip_serializing_if="Option::is_none")]
    pub private: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub public: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub pulls_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub pushed_at: Option<OneOfRepository5PushedAt>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub releases_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub role_name: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub size: Option<i64>,
    /// The default value for a squash merge commit message:  - `PR_BODY` - default to the pull request's body. - `COMMIT_MESSAGES` - default to the branch's commit messages. - `BLANK` - default to a blank commit message.
    #[serde(skip_serializing_if="Option::is_none")]
    pub squash_merge_commit_message: Option<String>,
    /// The default value for a squash merge commit title:  - `PR_TITLE` - default to the pull request's title. - `COMMIT_OR_PR_TITLE` - default to the commit's title (if only one commit) or the pull request's title (when more than one commit).
    #[serde(skip_serializing_if="Option::is_none")]
    pub squash_merge_commit_title: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub ssh_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub stargazers: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub stargazers_count: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub stargazers_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub statuses_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub subscribers_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub subscription_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub svn_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub tags_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub teams_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub topics: Option<Vec<String>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub trees_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub updated_at: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub url: Option<String>,
    /// Whether a squash merge commit can use the pull request title as default. **This property is closing down. Please use `squash_merge_commit_title` instead.
    #[serde(skip_serializing_if="Option::is_none")]
    pub use_squash_pr_title_as_default: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub visibility: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub watchers: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub watchers_count: Option<i64>,
    /// Whether to require contributors to sign off on web-based commits
    #[serde(skip_serializing_if="Option::is_none")]
    pub web_commit_signoff_required: Option<bool>,
}

/// A git repository
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct Repository6 {
    /// Whether to allow auto-merge for pull requests.
    #[serde(skip_serializing_if="Option::is_none")]
    pub allow_auto_merge: Option<bool>,
    /// Whether to allow private forks
    #[serde(skip_serializing_if="Option::is_none")]
    pub allow_forking: Option<bool>,
    /// Whether to allow merge commits for pull requests.
    #[serde(skip_serializing_if="Option::is_none")]
    pub allow_merge_commit: Option<bool>,
    /// Whether to allow rebase merges for pull requests.
    #[serde(skip_serializing_if="Option::is_none")]
    pub allow_rebase_merge: Option<bool>,
    /// Whether to allow squash merges for pull requests.
    #[serde(skip_serializing_if="Option::is_none")]
    pub allow_squash_merge: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub allow_update_branch: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub archive_url: Option<String>,
    /// Whether the repository is archived.
    #[serde(skip_serializing_if="Option::is_none")]
    pub archived: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub assignees_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub blobs_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub branches_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub clone_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub collaborators_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub comments_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub commits_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub compare_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub contents_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub contributors_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub created_at: Option<OneOfRepository6CreatedAt>,
    /// The default branch of the repository.
    #[serde(skip_serializing_if="Option::is_none")]
    pub default_branch: Option<String>,
    /// Whether to delete head branches when pull requests are merged
    #[serde(skip_serializing_if="Option::is_none")]
    pub delete_branch_on_merge: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub deployments_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub description: Option<String>,
    /// Returns whether or not this repository is disabled.
    #[serde(skip_serializing_if="Option::is_none")]
    pub disabled: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub downloads_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub events_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub fork: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub forks: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub forks_count: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub forks_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub full_name: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub git_commits_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub git_refs_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub git_tags_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub git_url: Option<String>,
    /// Whether downloads are enabled.
    #[serde(skip_serializing_if="Option::is_none")]
    pub has_downloads: Option<bool>,
    /// Whether issues are enabled.
    #[serde(skip_serializing_if="Option::is_none")]
    pub has_issues: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub has_pages: Option<bool>,
    /// Whether projects are enabled.
    #[serde(skip_serializing_if="Option::is_none")]
    pub has_projects: Option<bool>,
    /// Whether the wiki is enabled.
    #[serde(skip_serializing_if="Option::is_none")]
    pub has_wiki: Option<bool>,
    /// Whether discussions are enabled.
    #[serde(skip_serializing_if="Option::is_none")]
    pub has_discussions: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub homepage: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub hooks_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub html_url: Option<String>,
    /// Unique identifier of the repository
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub is_template: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub issue_comment_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub issue_events_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub issues_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub keys_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub labels_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub language: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub languages_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub license: Option<License>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub master_branch: Option<String>,
    /// The default value for a merge commit message.  - `PR_TITLE` - default to the pull request's title. - `PR_BODY` - default to the pull request's body. - `BLANK` - default to a blank commit message.
    #[serde(skip_serializing_if="Option::is_none")]
    pub merge_commit_message: Option<String>,
    /// The default value for a merge commit title.  - `PR_TITLE` - default to the pull request's title. - `MERGE_MESSAGE` - default to the classic title for a merge message (e.g., Merge pull request #123 from branch-name).
    #[serde(skip_serializing_if="Option::is_none")]
    pub merge_commit_title: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub merges_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub milestones_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub mirror_url: Option<String>,
    /// The name of the repository.
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub node_id: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub notifications_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub open_issues: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub open_issues_count: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub organization: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub owner: Option<User1>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub permissions: Option<RepositoryPermissions>,
    /// Whether the repository is private or public.
    #[serde(skip_serializing_if="Option::is_none")]
    pub private: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub public: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub pulls_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub pushed_at: Option<OneOfRepository6PushedAt>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub releases_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub role_name: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub size: Option<i64>,
    /// The default value for a squash merge commit message:  - `PR_BODY` - default to the pull request's body. - `COMMIT_MESSAGES` - default to the branch's commit messages. - `BLANK` - default to a blank commit message.
    #[serde(skip_serializing_if="Option::is_none")]
    pub squash_merge_commit_message: Option<String>,
    /// The default value for a squash merge commit title:  - `PR_TITLE` - default to the pull request's title. - `COMMIT_OR_PR_TITLE` - default to the commit's title (if only one commit) or the pull request's title (when more than one commit).
    #[serde(skip_serializing_if="Option::is_none")]
    pub squash_merge_commit_title: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub ssh_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub stargazers: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub stargazers_count: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub stargazers_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub statuses_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub subscribers_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub subscription_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub svn_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub tags_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub teams_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub topics: Option<Vec<String>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub trees_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub updated_at: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub url: Option<String>,
    /// Whether a squash merge commit can use the pull request title as default. **This property is closing down. Please use `squash_merge_commit_title` instead.
    #[serde(skip_serializing_if="Option::is_none")]
    pub use_squash_pr_title_as_default: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub visibility: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub watchers: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub watchers_count: Option<i64>,
    /// Whether to require contributors to sign off on web-based commits
    #[serde(skip_serializing_if="Option::is_none")]
    pub web_commit_signoff_required: Option<bool>,
}

/// A git repository
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct Repository7 {
    /// Whether to allow auto-merge for pull requests.
    #[serde(skip_serializing_if="Option::is_none")]
    pub allow_auto_merge: Option<bool>,
    /// Whether to allow private forks
    #[serde(skip_serializing_if="Option::is_none")]
    pub allow_forking: Option<bool>,
    /// Whether to allow merge commits for pull requests.
    #[serde(skip_serializing_if="Option::is_none")]
    pub allow_merge_commit: Option<bool>,
    /// Whether to allow rebase merges for pull requests.
    #[serde(skip_serializing_if="Option::is_none")]
    pub allow_rebase_merge: Option<bool>,
    /// Whether to allow squash merges for pull requests.
    #[serde(skip_serializing_if="Option::is_none")]
    pub allow_squash_merge: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub allow_update_branch: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub archive_url: Option<String>,
    /// Whether the repository is archived.
    #[serde(skip_serializing_if="Option::is_none")]
    pub archived: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub assignees_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub blobs_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub branches_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub clone_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub collaborators_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub comments_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub commits_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub compare_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub contents_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub contributors_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub created_at: Option<OneOfRepository7CreatedAt>,
    /// The default branch of the repository.
    #[serde(skip_serializing_if="Option::is_none")]
    pub default_branch: Option<String>,
    /// Whether to delete head branches when pull requests are merged
    #[serde(skip_serializing_if="Option::is_none")]
    pub delete_branch_on_merge: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub deployments_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub description: Option<String>,
    /// Returns whether or not this repository is disabled.
    #[serde(skip_serializing_if="Option::is_none")]
    pub disabled: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub downloads_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub events_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub fork: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub forks: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub forks_count: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub forks_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub full_name: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub git_commits_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub git_refs_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub git_tags_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub git_url: Option<String>,
    /// Whether downloads are enabled.
    #[serde(skip_serializing_if="Option::is_none")]
    pub has_downloads: Option<bool>,
    /// Whether issues are enabled.
    #[serde(skip_serializing_if="Option::is_none")]
    pub has_issues: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub has_pages: Option<bool>,
    /// Whether projects are enabled.
    #[serde(skip_serializing_if="Option::is_none")]
    pub has_projects: Option<bool>,
    /// Whether the wiki is enabled.
    #[serde(skip_serializing_if="Option::is_none")]
    pub has_wiki: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub homepage: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub hooks_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub html_url: Option<String>,
    /// Unique identifier of the repository
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub is_template: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub issue_comment_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub issue_events_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub issues_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub keys_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub labels_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub language: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub languages_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub license: Option<License>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub master_branch: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub merges_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub milestones_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub mirror_url: Option<String>,
    /// The name of the repository.
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub node_id: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub notifications_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub open_issues: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub open_issues_count: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub organization: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub owner: Option<User1>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub permissions: Option<RepositoryPermissions>,
    /// Whether the repository is private or public.
    #[serde(skip_serializing_if="Option::is_none")]
    pub private: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub public: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub pulls_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub pushed_at: Option<OneOfRepository7PushedAt>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub releases_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub role_name: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub size: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub ssh_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub stargazers: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub stargazers_count: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub stargazers_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub statuses_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub subscribers_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub subscription_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub svn_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub tags_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub teams_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub topics: Option<Vec<String>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub trees_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub updated_at: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub visibility: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub watchers: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub watchers_count: Option<i64>,
}

/// A git repository
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct Repository8 {
    /// Whether to allow auto-merge for pull requests.
    #[serde(skip_serializing_if="Option::is_none")]
    pub allow_auto_merge: Option<bool>,
    /// Whether to allow private forks
    #[serde(skip_serializing_if="Option::is_none")]
    pub allow_forking: Option<bool>,
    /// Whether to allow merge commits for pull requests.
    #[serde(skip_serializing_if="Option::is_none")]
    pub allow_merge_commit: Option<bool>,
    /// Whether to allow rebase merges for pull requests.
    #[serde(skip_serializing_if="Option::is_none")]
    pub allow_rebase_merge: Option<bool>,
    /// Whether to allow squash merges for pull requests.
    #[serde(skip_serializing_if="Option::is_none")]
    pub allow_squash_merge: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub allow_update_branch: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub archive_url: Option<String>,
    /// Whether the repository is archived.
    #[serde(skip_serializing_if="Option::is_none")]
    pub archived: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub assignees_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub blobs_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub branches_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub clone_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub collaborators_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub comments_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub commits_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub compare_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub contents_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub contributors_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub created_at: Option<OneOfRepository8CreatedAt>,
    /// The default branch of the repository.
    #[serde(skip_serializing_if="Option::is_none")]
    pub default_branch: Option<String>,
    /// Whether to delete head branches when pull requests are merged
    #[serde(skip_serializing_if="Option::is_none")]
    pub delete_branch_on_merge: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub deployments_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub description: Option<String>,
    /// Returns whether or not this repository is disabled.
    #[serde(skip_serializing_if="Option::is_none")]
    pub disabled: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub downloads_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub events_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub fork: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub forks: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub forks_count: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub forks_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub full_name: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub git_commits_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub git_refs_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub git_tags_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub git_url: Option<String>,
    /// Whether downloads are enabled.
    #[serde(skip_serializing_if="Option::is_none")]
    pub has_downloads: Option<bool>,
    /// Whether issues are enabled.
    #[serde(skip_serializing_if="Option::is_none")]
    pub has_issues: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub has_pages: Option<bool>,
    /// Whether projects are enabled.
    #[serde(skip_serializing_if="Option::is_none")]
    pub has_projects: Option<bool>,
    /// Whether the wiki is enabled.
    #[serde(skip_serializing_if="Option::is_none")]
    pub has_wiki: Option<bool>,
    /// Whether discussions are enabled.
    #[serde(skip_serializing_if="Option::is_none")]
    pub has_discussions: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub homepage: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub hooks_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub html_url: Option<String>,
    /// Unique identifier of the repository
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub is_template: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub issue_comment_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub issue_events_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub issues_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub keys_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub labels_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub language: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub languages_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub license: Option<License>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub master_branch: Option<String>,
    /// The default value for a merge commit message.  - `PR_TITLE` - default to the pull request's title. - `PR_BODY` - default to the pull request's body. - `BLANK` - default to a blank commit message.
    #[serde(skip_serializing_if="Option::is_none")]
    pub merge_commit_message: Option<String>,
    /// The default value for a merge commit title.  - `PR_TITLE` - default to the pull request's title. - `MERGE_MESSAGE` - default to the classic title for a merge message (e.g., Merge pull request #123 from branch-name).
    #[serde(skip_serializing_if="Option::is_none")]
    pub merge_commit_title: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub merges_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub milestones_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub mirror_url: Option<String>,
    /// The name of the repository.
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub node_id: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub notifications_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub open_issues: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub open_issues_count: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub organization: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub owner: Option<User1>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub permissions: Option<RepositoryPermissions>,
    /// Whether the repository is private or public.
    #[serde(skip_serializing_if="Option::is_none")]
    pub private: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub public: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub pulls_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub pushed_at: Option<OneOfRepository8PushedAt>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub releases_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub role_name: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub size: Option<i64>,
    /// The default value for a squash merge commit message.
    #[serde(skip_serializing_if="Option::is_none")]
    pub squash_merge_commit_message: Option<String>,
    /// The default value for a squash merge commit title.
    #[serde(skip_serializing_if="Option::is_none")]
    pub squash_merge_commit_title: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub ssh_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub stargazers: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub stargazers_count: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub stargazers_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub statuses_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub subscribers_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub subscription_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub svn_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub tags_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub teams_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub topics: Option<Vec<String>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub trees_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub updated_at: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub url: Option<String>,
    /// Whether a squash merge commit can use the pull request title as default. **This property is closing down. Please use `squash_merge_commit_title` instead.
    #[serde(skip_serializing_if="Option::is_none")]
    pub use_squash_pr_title_as_default: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub visibility: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub watchers: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub watchers_count: Option<i64>,
    /// Whether to require contributors to sign off on web-based commits
    #[serde(skip_serializing_if="Option::is_none")]
    pub web_commit_signoff_required: Option<bool>,
}

/// A git repository
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct Repository9 {
    /// Whether to allow auto-merge for pull requests.
    #[serde(skip_serializing_if="Option::is_none")]
    pub allow_auto_merge: Option<bool>,
    /// Whether to allow private forks
    #[serde(skip_serializing_if="Option::is_none")]
    pub allow_forking: Option<bool>,
    /// Whether to allow merge commits for pull requests.
    #[serde(skip_serializing_if="Option::is_none")]
    pub allow_merge_commit: Option<bool>,
    /// Whether to allow rebase merges for pull requests.
    #[serde(skip_serializing_if="Option::is_none")]
    pub allow_rebase_merge: Option<bool>,
    /// Whether to allow squash merges for pull requests.
    #[serde(skip_serializing_if="Option::is_none")]
    pub allow_squash_merge: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub allow_update_branch: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub archive_url: Option<String>,
    /// Whether the repository is archived.
    #[serde(skip_serializing_if="Option::is_none")]
    pub archived: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub assignees_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub blobs_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub branches_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub clone_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub collaborators_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub comments_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub commits_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub compare_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub contents_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub contributors_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub created_at: Option<OneOfRepository9CreatedAt>,
    /// The default branch of the repository.
    #[serde(skip_serializing_if="Option::is_none")]
    pub default_branch: Option<String>,
    /// Whether to delete head branches when pull requests are merged
    #[serde(skip_serializing_if="Option::is_none")]
    pub delete_branch_on_merge: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub deployments_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub description: Option<String>,
    /// Returns whether or not this repository is disabled.
    #[serde(skip_serializing_if="Option::is_none")]
    pub disabled: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub downloads_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub events_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub fork: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub forks: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub forks_count: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub forks_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub full_name: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub git_commits_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub git_refs_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub git_tags_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub git_url: Option<String>,
    /// Whether downloads are enabled.
    #[serde(skip_serializing_if="Option::is_none")]
    pub has_downloads: Option<bool>,
    /// Whether issues are enabled.
    #[serde(skip_serializing_if="Option::is_none")]
    pub has_issues: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub has_pages: Option<bool>,
    /// Whether projects are enabled.
    #[serde(skip_serializing_if="Option::is_none")]
    pub has_projects: Option<bool>,
    /// Whether the wiki is enabled.
    #[serde(skip_serializing_if="Option::is_none")]
    pub has_wiki: Option<bool>,
    /// Whether discussions are enabled.
    #[serde(skip_serializing_if="Option::is_none")]
    pub has_discussions: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub homepage: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub hooks_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub html_url: Option<String>,
    /// Unique identifier of the repository
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub is_template: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub issue_comment_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub issue_events_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub issues_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub keys_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub labels_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub language: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub languages_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub license: Option<License>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub master_branch: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub merges_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub milestones_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub mirror_url: Option<String>,
    /// The name of the repository.
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub node_id: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub notifications_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub open_issues: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub open_issues_count: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub organization: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub owner: Option<User1>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub permissions: Option<RepositoryPermissions>,
    /// Whether the repository is private or public.
    #[serde(skip_serializing_if="Option::is_none")]
    pub private: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub public: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub pulls_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub pushed_at: Option<OneOfRepository9PushedAt>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub releases_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub role_name: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub size: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub ssh_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub stargazers: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub stargazers_count: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub stargazers_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub statuses_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub subscribers_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub subscription_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub svn_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub tags_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub teams_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub topics: Option<Vec<String>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub trees_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub updated_at: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub visibility: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub watchers: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub watchers_count: Option<i64>,
    /// Whether to require contributors to sign off on web-based commits
    #[serde(skip_serializing_if="Option::is_none")]
    pub web_commit_signoff_required: Option<bool>,
}

/// A repository security advisory.
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct RepositoryAdvisory {
    /// The GitHub Security Advisory ID.
    #[serde(skip_serializing_if="Option::is_none")]
    pub ghsa_id: Option<String>,
    /// The Common Vulnerabilities and Exposures (CVE) ID.
    #[serde(skip_serializing_if="Option::is_none")]
    pub cve_id: Option<String>,
    /// The API URL for the advisory.
    #[serde(skip_serializing_if="Option::is_none")]
    pub url: Option<String>,
    /// The URL for the advisory.
    #[serde(skip_serializing_if="Option::is_none")]
    pub html_url: Option<String>,
    /// A short summary of the advisory.
    #[serde(skip_serializing_if="Option::is_none")]
    pub summary: Option<String>,
    /// A detailed description of what the advisory entails.
    #[serde(skip_serializing_if="Option::is_none")]
    pub description: Option<String>,
    /// The severity of the advisory.
    #[serde(skip_serializing_if="Option::is_none")]
    pub severity: Option<String>,
    /// The author of the advisory.
    #[serde(skip_serializing_if="Option::is_none")]
    pub author: Option<AllOfrepositoryAdvisoryAuthor>,
    /// The publisher of the advisory.
    #[serde(skip_serializing_if="Option::is_none")]
    pub publisher: Option<AllOfrepositoryAdvisoryPublisher>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub identifiers: Option<Vec<GlobaladvisoryIdentifiers>>,
    /// The state of the advisory.
    #[serde(skip_serializing_if="Option::is_none")]
    pub state: Option<String>,
    /// The date and time of when the advisory was created, in ISO 8601 format.
    #[serde(skip_serializing_if="Option::is_none")]
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The date and time of when the advisory was last updated, in ISO 8601 format.
    #[serde(skip_serializing_if="Option::is_none")]
    pub updated_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The date and time of when the advisory was published, in ISO 8601 format.
    #[serde(skip_serializing_if="Option::is_none")]
    pub published_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The date and time of when the advisory was closed, in ISO 8601 format.
    #[serde(skip_serializing_if="Option::is_none")]
    pub closed_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The date and time of when the advisory was withdrawn, in ISO 8601 format.
    #[serde(skip_serializing_if="Option::is_none")]
    pub withdrawn_at: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub submission: Option<RepositoryadvisorySubmission>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub vulnerabilities: Option<Vec<RepositoryAdvisoryVulnerability>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub cvss: Option<GlobaladvisoryCvss>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub cvss_severities: Option<CvssSeverities>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub cwes: Option<Vec<GlobaladvisoryCwes>>,
    /// A list of only the CWE IDs.
    #[serde(skip_serializing_if="Option::is_none")]
    pub cwe_ids: Option<Vec<String>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub credits: Option<Vec<RepositoryadvisoryCredits>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub credits_detailed: Option<Vec<RepositoryAdvisoryCredit>>,
    /// A list of users that collaborate on the advisory.
    #[serde(skip_serializing_if="Option::is_none")]
    pub collaborating_users: Option<Vec<SimpleUser>>,
    /// A list of teams that collaborate on the advisory.
    #[serde(skip_serializing_if="Option::is_none")]
    pub collaborating_teams: Option<Vec<Team>>,
    /// A temporary private fork of the advisory's repository for collaborating on a fix.
    #[serde(skip_serializing_if="Option::is_none")]
    pub private_fork: Option<AllOfrepositoryAdvisoryPrivateFork>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct PostSecurityAdvisoriesCreateRepositoryAdvisory {
    /// A short summary of the advisory.
    #[serde(skip_serializing_if="Option::is_none")]
    pub summary: Option<String>,
    /// A detailed description of what the advisory impacts.
    #[serde(skip_serializing_if="Option::is_none")]
    pub description: Option<String>,
    /// The Common Vulnerabilities and Exposures (CVE) ID.
    #[serde(skip_serializing_if="Option::is_none")]
    pub cve_id: Option<String>,
    /// A product affected by the vulnerability detailed in a repository security advisory.
    #[serde(skip_serializing_if="Option::is_none")]
    pub vulnerabilities: Option<Vec<RepositoryadvisorycreateVulnerabilities>>,
    /// A list of Common Weakness Enumeration (CWE) IDs.
    #[serde(skip_serializing_if="Option::is_none")]
    pub cwe_ids: Option<Vec<String>>,
    /// A list of users receiving credit for their participation in the security advisory.
    #[serde(skip_serializing_if="Option::is_none")]
    pub credits: Option<Vec<RepositoryadvisorycreateCredits>>,
    /// The severity of the advisory. You must choose between setting this field or `cvss_vector_string`.
    #[serde(skip_serializing_if="Option::is_none")]
    pub severity: Option<String>,
    /// The CVSS vector that calculates the severity of the advisory. You must choose between setting this field or `severity`.
    #[serde(skip_serializing_if="Option::is_none")]
    pub cvss_vector_string: Option<String>,
    /// Whether to create a temporary private fork of the repository to collaborate on a fix.
    #[serde(skip_serializing_if="Option::is_none")]
    pub start_private_fork: Option<bool>,
}

/// A credit given to a user for a repository security advisory.
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct RepositoryAdvisoryCredit {
    #[serde(skip_serializing_if="Option::is_none")]
    pub user: Option<SimpleUser>,
    #[serde(rename = "type")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub _type: Option<SecurityAdvisoryCreditTypes>,
    /// The state of the user's acceptance of the credit.
    #[serde(skip_serializing_if="Option::is_none")]
    pub state: Option<String>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct PatchSecurityAdvisoriesUpdateRepositoryAdvisory {
    /// A short summary of the advisory.
    #[serde(skip_serializing_if="Option::is_none")]
    pub summary: Option<String>,
    /// A detailed description of what the advisory impacts.
    #[serde(skip_serializing_if="Option::is_none")]
    pub description: Option<String>,
    /// The Common Vulnerabilities and Exposures (CVE) ID.
    #[serde(skip_serializing_if="Option::is_none")]
    pub cve_id: Option<String>,
    /// A product affected by the vulnerability detailed in a repository security advisory.
    #[serde(skip_serializing_if="Option::is_none")]
    pub vulnerabilities: Option<Vec<RepositoryadvisorycreateVulnerabilities>>,
    /// A list of Common Weakness Enumeration (CWE) IDs.
    #[serde(skip_serializing_if="Option::is_none")]
    pub cwe_ids: Option<Vec<String>>,
    /// A list of users receiving credit for their participation in the security advisory.
    #[serde(skip_serializing_if="Option::is_none")]
    pub credits: Option<Vec<RepositoryadvisorycreateCredits>>,
    /// The severity of the advisory. You must choose between setting this field or `cvss_vector_string`.
    #[serde(skip_serializing_if="Option::is_none")]
    pub severity: Option<String>,
    /// The CVSS vector that calculates the severity of the advisory. You must choose between setting this field or `severity`.
    #[serde(skip_serializing_if="Option::is_none")]
    pub cvss_vector_string: Option<String>,
    /// The state of the advisory.
    #[serde(skip_serializing_if="Option::is_none")]
    pub state: Option<String>,
    /// A list of usernames who have been granted write access to the advisory.
    #[serde(skip_serializing_if="Option::is_none")]
    pub collaborating_users: Option<Vec<String>>,
    /// A list of team slugs which have been granted write access to the advisory.
    #[serde(skip_serializing_if="Option::is_none")]
    pub collaborating_teams: Option<Vec<String>>,
}

/// A product affected by the vulnerability detailed in a repository security advisory.
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct RepositoryAdvisoryVulnerability {
    #[serde(skip_serializing_if="Option::is_none")]
    pub package: Option<VulnerabilityPackage>,
    /// The range of the package versions affected by the vulnerability.
    #[serde(skip_serializing_if="Option::is_none")]
    pub vulnerable_version_range: Option<String>,
    /// The package version(s) that resolve the vulnerability.
    #[serde(skip_serializing_if="Option::is_none")]
    pub patched_versions: Option<String>,
    /// The functions in the package that are affected.
    #[serde(skip_serializing_if="Option::is_none")]
    pub vulnerable_functions: Option<Vec<String>>,
}

/// Repository Collaborator Permission
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct RepositoryCollaboratorPermission {
    #[serde(skip_serializing_if="Option::is_none")]
    pub permission: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub role_name: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub user: Option<NullableCollaborator>,
}

/// Repository invitations let you manage who you collaborate with.
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct RepositoryInvitation {
    /// Unique identifier of the repository invitation.
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub repository: Option<MinimalRepository>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub invitee: Option<NullableSimpleUser>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub inviter: Option<NullableSimpleUser>,
    /// The permission associated with the invitation.
    #[serde(skip_serializing_if="Option::is_none")]
    pub permissions: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
    /// Whether or not the invitation has expired
    #[serde(skip_serializing_if="Option::is_none")]
    pub expired: Option<bool>,
    /// URL for the repository invitation
    #[serde(skip_serializing_if="Option::is_none")]
    pub url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub html_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub node_id: Option<String>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct RepositoryLite {
    #[serde(skip_serializing_if="Option::is_none")]
    pub archive_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub assignees_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub blobs_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub branches_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub collaborators_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub comments_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub commits_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub compare_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub contents_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub contributors_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub deployments_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub description: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub downloads_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub events_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub fork: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub forks_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub full_name: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub git_commits_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub git_refs_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub git_tags_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub hooks_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub html_url: Option<String>,
    /// Unique identifier of the repository
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub issue_comment_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub issue_events_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub issues_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub keys_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub labels_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub languages_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub merges_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub milestones_url: Option<String>,
    /// The name of the repository.
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub node_id: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub notifications_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub owner: Option<User1>,
    /// Whether the repository is private or public.
    #[serde(skip_serializing_if="Option::is_none")]
    pub private: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub pulls_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub releases_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub stargazers_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub statuses_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub subscribers_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub subscription_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub tags_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub teams_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub trees_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub url: Option<String>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct RepositoryLite1 {
    #[serde(skip_serializing_if="Option::is_none")]
    pub archive_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub assignees_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub blobs_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub branches_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub collaborators_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub comments_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub commits_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub compare_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub contents_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub contributors_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub deployments_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub description: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub downloads_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub events_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub fork: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub forks_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub full_name: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub git_commits_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub git_refs_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub git_tags_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub hooks_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub html_url: Option<String>,
    /// Unique identifier of the repository
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub issue_comment_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub issue_events_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub issues_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub keys_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub labels_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub languages_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub merges_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub milestones_url: Option<String>,
    /// The name of the repository.
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub node_id: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub notifications_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub owner: Option<User5>,
    /// Whether the repository is private or public.
    #[serde(skip_serializing_if="Option::is_none")]
    pub private: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub pulls_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub releases_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub stargazers_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub statuses_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub subscribers_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub subscription_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub tags_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub teams_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub trees_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub url: Option<String>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct RepositoryLite2 {
    #[serde(skip_serializing_if="Option::is_none")]
    pub archive_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub assignees_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub blobs_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub branches_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub collaborators_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub comments_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub commits_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub compare_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub contents_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub contributors_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub deployments_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub description: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub downloads_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub events_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub fork: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub forks_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub full_name: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub git_commits_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub git_refs_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub git_tags_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub hooks_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub html_url: Option<String>,
    /// Unique identifier of the repository
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub issue_comment_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub issue_events_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub issues_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub keys_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub labels_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub languages_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub merges_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub milestones_url: Option<String>,
    /// The name of the repository.
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub node_id: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub notifications_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub owner: Option<User5>,
    /// Whether the repository is private or public.
    #[serde(skip_serializing_if="Option::is_none")]
    pub private: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub pulls_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub releases_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub stargazers_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub statuses_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub subscribers_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub subscription_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub tags_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub teams_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub trees_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub url: Option<String>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct RepositoryPermissions {
    #[serde(skip_serializing_if="Option::is_none")]
    pub admin: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub maintain: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub pull: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub push: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub triage: Option<bool>,
}

/// A repository rule.
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
#[serde(untagged)]
pub enum RepositoryRule { 
    RepositoryRuleVariant0(RepositoryRuleCreation),
    RepositoryRuleVariant1(RepositoryRuleUpdate),
    RepositoryRuleVariant2(RepositoryRuleDeletion),
    RepositoryRuleVariant3(RepositoryRuleRequiredLinearHistory),
    RepositoryRuleVariant4(RepositoryRuleMergeQueue),
    RepositoryRuleVariant5(RepositoryRuleRequiredDeployments),
    RepositoryRuleVariant6(RepositoryRuleRequiredSignatures),
    RepositoryRuleVariant7(RepositoryRulePullRequest),
    RepositoryRuleVariant8(RepositoryRuleRequiredStatusChecks),
    RepositoryRuleVariant9(RepositoryRuleNonFastForward),
    RepositoryRuleVariant10(RepositoryRuleCommitMessagePattern),
    RepositoryRuleVariant11(RepositoryRuleCommitAuthorEmailPattern),
    RepositoryRuleVariant12(RepositoryRuleCommitterEmailPattern),
    RepositoryRuleVariant13(RepositoryRuleBranchNamePattern),
    RepositoryRuleVariant14(RepositoryRuleTagNamePattern),
    RepositoryRuleVariant15(HashMap<String, String>),
    RepositoryRuleVariant16(RepositoryRuleWorkflows),
    RepositoryRuleVariant17(RepositoryRuleCodeScanning),
}

impl From<RepositoryRuleCreation> for RepositoryRule {
    fn from(value: RepositoryRuleCreation) -> Self {
        RepositoryRule::RepositoryRuleVariant0(value)
    }
}

impl From<RepositoryRuleUpdate> for RepositoryRule {
    fn from(value: RepositoryRuleUpdate) -> Self {
        RepositoryRule::RepositoryRuleVariant1(value)
    }
}

impl From<RepositoryRuleDeletion> for RepositoryRule {
    fn from(value: RepositoryRuleDeletion) -> Self {
        RepositoryRule::RepositoryRuleVariant2(value)
    }
}

impl From<RepositoryRuleRequiredLinearHistory> for RepositoryRule {
    fn from(value: RepositoryRuleRequiredLinearHistory) -> Self {
        RepositoryRule::RepositoryRuleVariant3(value)
    }
}

impl From<RepositoryRuleMergeQueue> for RepositoryRule {
    fn from(value: RepositoryRuleMergeQueue) -> Self {
        RepositoryRule::RepositoryRuleVariant4(value)
    }
}

impl From<RepositoryRuleRequiredDeployments> for RepositoryRule {
    fn from(value: RepositoryRuleRequiredDeployments) -> Self {
        RepositoryRule::RepositoryRuleVariant5(value)
    }
}

impl From<RepositoryRuleRequiredSignatures> for RepositoryRule {
    fn from(value: RepositoryRuleRequiredSignatures) -> Self {
        RepositoryRule::RepositoryRuleVariant6(value)
    }
}

impl From<RepositoryRulePullRequest> for RepositoryRule {
    fn from(value: RepositoryRulePullRequest) -> Self {
        RepositoryRule::RepositoryRuleVariant7(value)
    }
}

impl From<RepositoryRuleRequiredStatusChecks> for RepositoryRule {
    fn from(value: RepositoryRuleRequiredStatusChecks) -> Self {
        RepositoryRule::RepositoryRuleVariant8(value)
    }
}

impl From<RepositoryRuleNonFastForward> for RepositoryRule {
    fn from(value: RepositoryRuleNonFastForward) -> Self {
        RepositoryRule::RepositoryRuleVariant9(value)
    }
}

impl From<RepositoryRuleCommitMessagePattern> for RepositoryRule {
    fn from(value: RepositoryRuleCommitMessagePattern) -> Self {
        RepositoryRule::RepositoryRuleVariant10(value)
    }
}

impl From<RepositoryRuleCommitAuthorEmailPattern> for RepositoryRule {
    fn from(value: RepositoryRuleCommitAuthorEmailPattern) -> Self {
        RepositoryRule::RepositoryRuleVariant11(value)
    }
}

impl From<RepositoryRuleCommitterEmailPattern> for RepositoryRule {
    fn from(value: RepositoryRuleCommitterEmailPattern) -> Self {
        RepositoryRule::RepositoryRuleVariant12(value)
    }
}

impl From<RepositoryRuleBranchNamePattern> for RepositoryRule {
    fn from(value: RepositoryRuleBranchNamePattern) -> Self {
        RepositoryRule::RepositoryRuleVariant13(value)
    }
}

impl From<RepositoryRuleTagNamePattern> for RepositoryRule {
    fn from(value: RepositoryRuleTagNamePattern) -> Self {
        RepositoryRule::RepositoryRuleVariant14(value)
    }
}

impl From<HashMap<String, String>> for RepositoryRule {
    fn from(value: HashMap<String, String>) -> Self {
        RepositoryRule::RepositoryRuleVariant15(value)
    }
}

impl From<RepositoryRuleWorkflows> for RepositoryRule {
    fn from(value: RepositoryRuleWorkflows) -> Self {
        RepositoryRule::RepositoryRuleVariant16(value)
    }
}

impl From<RepositoryRuleCodeScanning> for RepositoryRule {
    fn from(value: RepositoryRuleCodeScanning) -> Self {
        RepositoryRule::RepositoryRuleVariant17(value)
    }
}

/// Parameters to be used for the branch_name_pattern rule
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct RepositoryRuleBranchNamePattern {
    #[serde(rename = "type")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub _type: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub parameters: Option<RepositoryrulecommitmessagepatternParameters>,
}

/// Choose which tools must provide code scanning results before the reference is updated. When configured, code scanning must be enabled and have results for both the commit and the reference being updated.
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct RepositoryRuleCodeScanning {
    #[serde(rename = "type")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub _type: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub parameters: Option<RepositoryrulecodescanningParameters>,
}

/// Parameters to be used for the commit_author_email_pattern rule
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct RepositoryRuleCommitAuthorEmailPattern {
    #[serde(rename = "type")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub _type: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub parameters: Option<RepositoryrulecommitmessagepatternParameters>,
}

/// Parameters to be used for the commit_message_pattern rule
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct RepositoryRuleCommitMessagePattern {
    #[serde(rename = "type")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub _type: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub parameters: Option<RepositoryrulecommitmessagepatternParameters>,
}

/// Parameters to be used for the committer_email_pattern rule
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct RepositoryRuleCommitterEmailPattern {
    #[serde(rename = "type")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub _type: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub parameters: Option<RepositoryrulecommitmessagepatternParameters>,
}

/// Only allow users with bypass permission to create matching refs.
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct RepositoryRuleCreation {
    #[serde(rename = "type")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub _type: Option<String>,
}

/// Only allow users with bypass permissions to delete matching refs.
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct RepositoryRuleDeletion {
    #[serde(rename = "type")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub _type: Option<String>,
}

/// A repository rule with ruleset details.
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
#[serde(untagged)]
pub enum RepositoryRuleDetailed { 
    RepositoryRuleDetailedVariant0(Value),
}

impl From<Value> for RepositoryRuleDetailed {
    fn from(value: Value) -> Self {
        RepositoryRuleDetailed::RepositoryRuleDetailedVariant0(value)
    }
}

impl Display for RepositoryRuleDetailed {
    fn fmt(&self, f: &mut Formatter) -> fmt::Result {
        match self { 
            RepositoryRuleDetailed::RepositoryRuleDetailedVariant0(value) => write!(f, "{}", value),
        }
    }
}

/// The enforcement level of the ruleset. `evaluate` allows admins to test rules before enforcing them. Admins can view insights on the Rule Insights page (`evaluate` is only available with GitHub Enterprise).
/// Enumeration of values.
/// Since this enum's variants do not hold data, we can easily define them them as `#[repr(C)]`
/// which helps with FFI.
#[allow(non_camel_case_types)]
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq, PartialOrd, Serialize, Deserialize, Eq, Ord)]
pub enum RepositoryRuleEnforcement { 
    #[serde(rename = "disabled")]
    DISABLED,
    #[serde(rename = "active")]
    ACTIVE,
    #[serde(rename = "evaluate")]
    EVALUATE,
}

impl Display for RepositoryRuleEnforcement {
    fn fmt(&self, f: &mut Formatter) -> fmt::Result {
        match *self { 
            RepositoryRuleEnforcement::DISABLED => write!(f, "{}", "disabled"),
            RepositoryRuleEnforcement::ACTIVE => write!(f, "{}", "active"),
            RepositoryRuleEnforcement::EVALUATE => write!(f, "{}", "evaluate"),
        }
    }
}

impl std::str::FromStr for RepositoryRuleEnforcement {
    type Err = ();
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s {
            "disabled" => Ok(RepositoryRuleEnforcement::DISABLED),
            "active" => Ok(RepositoryRuleEnforcement::ACTIVE),
            "evaluate" => Ok(RepositoryRuleEnforcement::EVALUATE),
            _ => Err(()),
        }
    }
}

/// Merges must be performed via a merge queue.
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct RepositoryRuleMergeQueue {
    #[serde(rename = "type")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub _type: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub parameters: Option<RepositoryrulemergequeueParameters>,
}

/// Prevent users with push access from force pushing to refs.
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct RepositoryRuleNonFastForward {
    #[serde(rename = "type")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub _type: Option<String>,
}

/// A tool that must provide code scanning results for this rule to pass.
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct RepositoryRuleParamsCodeScanningTool {
    /// The severity level at which code scanning results that raise alerts block a reference update. For more information on alert severity levels, see \"[About code scanning alerts](https://docs.github.com/code-security/code-scanning/managing-code-scanning-alerts/about-code-scanning-alerts#about-alert-severity-and-security-severity-levels).\"
    #[serde(skip_serializing_if="Option::is_none")]
    pub alerts_threshold: Option<String>,
    /// The severity level at which code scanning results that raise security alerts block a reference update. For more information on security severity levels, see \"[About code scanning alerts](https://docs.github.com/code-security/code-scanning/managing-code-scanning-alerts/about-code-scanning-alerts#about-alert-severity-and-security-severity-levels).\"
    #[serde(skip_serializing_if="Option::is_none")]
    pub security_alerts_threshold: Option<String>,
    /// The name of a code scanning tool
    #[serde(skip_serializing_if="Option::is_none")]
    pub tool: Option<String>,
}

/// A reviewing team, and file patterns describing which files they must approve changes to.
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct RepositoryRuleParamsRequiredReviewerConfiguration {
    /// Array of file patterns. Pull requests which change matching files must be approved by the specified team. File patterns use the same syntax as `.gitignore` files.
    #[serde(skip_serializing_if="Option::is_none")]
    pub file_patterns: Option<Vec<String>>,
    /// Minimum number of approvals required from the specified team. If set to zero, the team will be added to the pull request but approval is optional.
    #[serde(skip_serializing_if="Option::is_none")]
    pub minimum_approvals: Option<i64>,
    /// Node ID of the team which must review changes to matching files.
    #[serde(skip_serializing_if="Option::is_none")]
    pub reviewer_id: Option<String>,
}

/// Restricted commit
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct RepositoryRuleParamsRestrictedCommits {
    /// Full or abbreviated commit hash to reject
    #[serde(skip_serializing_if="Option::is_none")]
    pub oid: Option<String>,
    /// Reason for restriction
    #[serde(skip_serializing_if="Option::is_none")]
    pub reason: Option<String>,
}

/// Required status check
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct RepositoryRuleParamsStatusCheckConfiguration {
    /// The status check context name that must be present on the commit.
    #[serde(skip_serializing_if="Option::is_none")]
    pub context: Option<String>,
    /// The optional integration ID that this status check must originate from.
    #[serde(skip_serializing_if="Option::is_none")]
    pub integration_id: Option<i64>,
}

/// A workflow that must run for this rule to pass
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct RepositoryRuleParamsWorkflowFileReference {
    /// The path to the workflow file
    #[serde(skip_serializing_if="Option::is_none")]
    pub path: Option<String>,
    /// The ref (branch or tag) of the workflow file to use
    #[serde(rename = "ref")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub git_ref: Option<String>,
    /// The ID of the repository where the workflow is defined
    #[serde(skip_serializing_if="Option::is_none")]
    pub repository_id: Option<i64>,
    /// The commit SHA of the workflow file to use
    #[serde(skip_serializing_if="Option::is_none")]
    pub sha: Option<String>,
}

/// Require all commits be made to a non-target branch and submitted via a pull request before they can be merged.
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct RepositoryRulePullRequest {
    #[serde(rename = "type")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub _type: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub parameters: Option<RepositoryrulepullrequestParameters>,
}

/// Choose which environments must be successfully deployed to before refs can be pushed into a ref that matches this rule.
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct RepositoryRuleRequiredDeployments {
    #[serde(rename = "type")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub _type: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub parameters: Option<RepositoryrulerequireddeploymentsParameters>,
}

/// Prevent merge commits from being pushed to matching refs.
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct RepositoryRuleRequiredLinearHistory {
    #[serde(rename = "type")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub _type: Option<String>,
}

/// Commits pushed to matching refs must have verified signatures.
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct RepositoryRuleRequiredSignatures {
    #[serde(rename = "type")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub _type: Option<String>,
}

/// Choose which status checks must pass before the ref is updated. When enabled, commits must first be pushed to another ref where the checks pass.
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct RepositoryRuleRequiredStatusChecks {
    #[serde(rename = "type")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub _type: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub parameters: Option<RepositoryrulerequiredstatuschecksParameters>,
}

/// User-defined metadata to store domain-specific information limited to 8 keys with scalar values.
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct RepositoryRuleRulesetInfo {
    /// The type of source for the ruleset that includes this rule.
    #[serde(skip_serializing_if="Option::is_none")]
    pub ruleset_source_type: Option<String>,
    /// The name of the source of the ruleset that includes this rule.
    #[serde(skip_serializing_if="Option::is_none")]
    pub ruleset_source: Option<String>,
    /// The ID of the ruleset that includes this rule.
    #[serde(skip_serializing_if="Option::is_none")]
    pub ruleset_id: Option<i64>,
}

/// Parameters to be used for the tag_name_pattern rule
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct RepositoryRuleTagNamePattern {
    #[serde(rename = "type")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub _type: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub parameters: Option<RepositoryrulecommitmessagepatternParameters>,
}

/// Only allow users with bypass permission to update matching refs.
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct RepositoryRuleUpdate {
    #[serde(rename = "type")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub _type: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub parameters: Option<RepositoryruleupdateParameters>,
}

/// Repository rule violation was detected
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct RepositoryRuleViolationError {
    #[serde(skip_serializing_if="Option::is_none")]
    pub message: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub documentation_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub status: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub metadata: Option<RepositoryruleviolationerrorMetadata>,
}

/// Require all changes made to a targeted branch to pass the specified workflows before they can be merged.
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct RepositoryRuleWorkflows {
    #[serde(rename = "type")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub _type: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub parameters: Option<RepositoryruleworkflowsParameters>,
}

/// A set of rules to apply when specified conditions are met.
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct RepositoryRuleset {
    /// The ID of the ruleset
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<i64>,
    /// The name of the ruleset
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,
    /// The target of the ruleset
    #[serde(skip_serializing_if="Option::is_none")]
    pub target: Option<String>,
    /// The type of the source of the ruleset
    #[serde(skip_serializing_if="Option::is_none")]
    pub source_type: Option<String>,
    /// The name of the source
    #[serde(skip_serializing_if="Option::is_none")]
    pub source: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub enforcement: Option<RepositoryRuleEnforcement>,
    /// The actors that can bypass the rules in this ruleset
    #[serde(skip_serializing_if="Option::is_none")]
    pub bypass_actors: Option<Vec<RepositoryRulesetBypassActor>>,
    /// The bypass type of the user making the API request for this ruleset. This field is only returned when querying the repository-level endpoint.
    #[serde(skip_serializing_if="Option::is_none")]
    pub current_user_can_bypass: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub node_id: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub _links: Option<RepositoryrulesetLinks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub conditions: Option<AnyOfrepositoryRulesetConditions>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub rules: Option<Vec<RepositoryRule>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub updated_at: Option<chrono::DateTime<chrono::Utc>>,
}

/// An actor that can bypass rules in a ruleset
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct RepositoryRulesetBypassActor {
    /// The ID of the actor that can bypass a ruleset. If `actor_type` is `OrganizationAdmin`, this should be `1`. If `actor_type` is `DeployKey`, this should be null. `OrganizationAdmin` is not applicable for personal repositories.
    #[serde(skip_serializing_if="Option::is_none")]
    pub actor_id: Option<i64>,
    /// The type of actor that can bypass a ruleset.
    #[serde(skip_serializing_if="Option::is_none")]
    pub actor_type: Option<String>,
    /// When the specified actor can bypass the ruleset. `pull_request` means that an actor can only bypass rules on pull requests. `pull_request` is not applicable for the `DeployKey` actor type. Also, `pull_request` is only applicable to branch rulesets.
    #[serde(skip_serializing_if="Option::is_none")]
    pub bypass_mode: Option<String>,
}

/// Parameters for a repository ruleset ref name condition
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct RepositoryRulesetConditions {
    #[serde(skip_serializing_if="Option::is_none")]
    pub ref_name: Option<RepositoryrulesetconditionsRefName>,
}

/// Parameters for a repository ID condition
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct RepositoryRulesetConditionsRepositoryIdTarget {
    #[serde(skip_serializing_if="Option::is_none")]
    pub repository_id: Option<RepositoryrulesetconditionsrepositoryidtargetRepositoryId>,
}

/// Parameters for a repository name condition
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct RepositoryRulesetConditionsRepositoryNameTarget {
    #[serde(skip_serializing_if="Option::is_none")]
    pub repository_name: Option<RepositoryrulesetconditionsrepositorynametargetRepositoryName>,
}

/// Parameters for a targeting a repository property
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct RepositoryRulesetConditionsRepositoryPropertySpec {
    /// The name of the repository property to target
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,
    /// The values to match for the repository property
    #[serde(skip_serializing_if="Option::is_none")]
    pub property_values: Option<Vec<String>>,
    /// The source of the repository property. Defaults to 'custom' if not specified.
    #[serde(skip_serializing_if="Option::is_none")]
    pub source: Option<String>,
}

/// Parameters for a repository property condition
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct RepositoryRulesetConditionsRepositoryPropertyTarget {
    #[serde(skip_serializing_if="Option::is_none")]
    pub repository_property: Option<RepositoryrulesetconditionsrepositorypropertytargetRepositoryProperty>,
}

/// Repository invitations let you manage who you collaborate with.
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct RepositorySubscription {
    /// Determines if notifications should be received from this repository.
    #[serde(skip_serializing_if="Option::is_none")]
    pub subscribed: Option<bool>,
    /// Determines if all notifications should be blocked from this repository.
    #[serde(skip_serializing_if="Option::is_none")]
    pub ignored: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub reason: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub repository_url: Option<String>,
}

/// The security alert of the vulnerable dependency.
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct RepositoryVulnerabilityAlertAlert {
    #[serde(skip_serializing_if="Option::is_none")]
    pub affected_package_name: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub affected_range: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub created_at: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub dismiss_comment: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub dismiss_reason: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub dismissed_at: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub dismisser: Option<User1>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub external_identifier: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub external_reference: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub fix_reason: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub fixed_at: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub fixed_in: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub ghsa_id: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub node_id: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub number: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub severity: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub state: Option<String>,
}

/// The security alert of the vulnerable dependency.
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct RepositoryVulnerabilityAlertAlert1 {
    #[serde(skip_serializing_if="Option::is_none")]
    pub affected_package_name: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub affected_range: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub created_at: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub dismiss_reason: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub dismissed_at: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub dismisser: Option<User5>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub external_identifier: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub external_reference: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub fix_reason: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub fixed_at: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub fixed_in: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub ghsa_id: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub node_id: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub number: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub severity: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub state: Option<String>,
}

/// The repository on GitHub where the event occurred. Webhook payloads contain the `repository` property when the event occurs from activity in a repository.
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct RepositoryWebhooks {
    /// Unique identifier of the repository
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub node_id: Option<String>,
    /// The name of the repository.
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub full_name: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub license: Option<NullableLicenseSimple>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub organization: Option<NullableSimpleUser>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub forks: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub permissions: Option<RepositoryPermissions>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub owner: Option<SimpleUser>,
    /// Whether the repository is private or public.
    #[serde(skip_serializing_if="Option::is_none")]
    pub private: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub html_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub description: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub fork: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub archive_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub assignees_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub blobs_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub branches_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub collaborators_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub comments_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub commits_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub compare_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub contents_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub contributors_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub deployments_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub downloads_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub events_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub forks_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub git_commits_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub git_refs_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub git_tags_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub git_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub issue_comment_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub issue_events_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub issues_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub keys_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub labels_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub languages_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub merges_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub milestones_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub notifications_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub pulls_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub releases_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub ssh_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub stargazers_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub statuses_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub subscribers_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub subscription_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub tags_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub teams_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub trees_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub clone_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub mirror_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub hooks_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub svn_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub homepage: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub language: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub forks_count: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub stargazers_count: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub watchers_count: Option<i64>,
    /// The size of the repository, in kilobytes. Size is calculated hourly. When a repository is initially created, the size is 0.
    #[serde(skip_serializing_if="Option::is_none")]
    pub size: Option<i64>,
    /// The default branch of the repository.
    #[serde(skip_serializing_if="Option::is_none")]
    pub default_branch: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub open_issues_count: Option<i64>,
    /// Whether this repository acts as a template that can be used to generate new repositories.
    #[serde(skip_serializing_if="Option::is_none")]
    pub is_template: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub topics: Option<Vec<String>>,
    /// The custom properties that were defined for the repository. The keys are the custom property names, and the values are the corresponding custom property values.
    #[serde(skip_serializing_if="Option::is_none")]
    pub custom_properties: Option<HashMap<String, HashMap<String, Value>>>,
    /// Whether issues are enabled.
    #[serde(skip_serializing_if="Option::is_none")]
    pub has_issues: Option<bool>,
    /// Whether projects are enabled.
    #[serde(skip_serializing_if="Option::is_none")]
    pub has_projects: Option<bool>,
    /// Whether the wiki is enabled.
    #[serde(skip_serializing_if="Option::is_none")]
    pub has_wiki: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub has_pages: Option<bool>,
    /// Whether downloads are enabled.
    #[serde(skip_serializing_if="Option::is_none")]
    pub has_downloads: Option<bool>,
    /// Whether discussions are enabled.
    #[serde(skip_serializing_if="Option::is_none")]
    pub has_discussions: Option<bool>,
    /// Whether the repository is archived.
    #[serde(skip_serializing_if="Option::is_none")]
    pub archived: Option<bool>,
    /// Returns whether or not this repository disabled.
    #[serde(skip_serializing_if="Option::is_none")]
    pub disabled: Option<bool>,
    /// The repository visibility: public, private, or internal.
    #[serde(skip_serializing_if="Option::is_none")]
    pub visibility: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub pushed_at: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub updated_at: Option<chrono::DateTime<chrono::Utc>>,
    /// Whether to allow rebase merges for pull requests.
    #[serde(skip_serializing_if="Option::is_none")]
    pub allow_rebase_merge: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub template_repository: Option<RepositorywebhooksTemplateRepository>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub temp_clone_token: Option<String>,
    /// Whether to allow squash merges for pull requests.
    #[serde(skip_serializing_if="Option::is_none")]
    pub allow_squash_merge: Option<bool>,
    /// Whether to allow Auto-merge to be used on pull requests.
    #[serde(skip_serializing_if="Option::is_none")]
    pub allow_auto_merge: Option<bool>,
    /// Whether to delete head branches when pull requests are merged
    #[serde(skip_serializing_if="Option::is_none")]
    pub delete_branch_on_merge: Option<bool>,
    /// Whether or not a pull request head branch that is behind its base branch can always be updated even if it is not required to be up to date before merging.
    #[serde(skip_serializing_if="Option::is_none")]
    pub allow_update_branch: Option<bool>,
    /// Whether a squash merge commit can use the pull request title as default. **This property is closing down. Please use `squash_merge_commit_title` instead.
    #[serde(skip_serializing_if="Option::is_none")]
    pub use_squash_pr_title_as_default: Option<bool>,
    /// The default value for a squash merge commit title:  - `PR_TITLE` - default to the pull request's title. - `COMMIT_OR_PR_TITLE` - default to the commit's title (if only one commit) or the pull request's title (when more than one commit).
    #[serde(skip_serializing_if="Option::is_none")]
    pub squash_merge_commit_title: Option<String>,
    /// The default value for a squash merge commit message:  - `PR_BODY` - default to the pull request's body. - `COMMIT_MESSAGES` - default to the branch's commit messages. - `BLANK` - default to a blank commit message.
    #[serde(skip_serializing_if="Option::is_none")]
    pub squash_merge_commit_message: Option<String>,
    /// The default value for a merge commit title.  - `PR_TITLE` - default to the pull request's title. - `MERGE_MESSAGE` - default to the classic title for a merge message (e.g., Merge pull request #123 from branch-name).
    #[serde(skip_serializing_if="Option::is_none")]
    pub merge_commit_title: Option<String>,
    /// The default value for a merge commit message.  - `PR_TITLE` - default to the pull request's title. - `PR_BODY` - default to the pull request's body. - `BLANK` - default to a blank commit message.
    #[serde(skip_serializing_if="Option::is_none")]
    pub merge_commit_message: Option<String>,
    /// Whether to allow merge commits for pull requests.
    #[serde(skip_serializing_if="Option::is_none")]
    pub allow_merge_commit: Option<bool>,
    /// Whether to allow forking this repo
    #[serde(skip_serializing_if="Option::is_none")]
    pub allow_forking: Option<bool>,
    /// Whether to require contributors to sign off on web-based commits
    #[serde(skip_serializing_if="Option::is_none")]
    pub web_commit_signoff_required: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub subscribers_count: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub network_count: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub open_issues: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub watchers: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub master_branch: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub starred_at: Option<String>,
    /// Whether anonymous git access is enabled for this repository
    #[serde(skip_serializing_if="Option::is_none")]
    pub anonymous_access_enabled: Option<bool>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct RepositoryadvisoryCredits {
    /// The username of the user credited.
    #[serde(skip_serializing_if="Option::is_none")]
    pub login: Option<String>,
    #[serde(rename = "type")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub _type: Option<SecurityAdvisoryCreditTypes>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct RepositoryadvisorySubmission {
    /// Whether a private vulnerability report was accepted by the repository's administrators.
    #[serde(skip_serializing_if="Option::is_none")]
    pub accepted: Option<bool>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct RepositoryadvisorycreateCredits {
    /// The username of the user credited.
    #[serde(skip_serializing_if="Option::is_none")]
    pub login: Option<String>,
    #[serde(rename = "type")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub _type: Option<SecurityAdvisoryCreditTypes>,
}

/// The name of the package affected by the vulnerability.
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct RepositoryadvisorycreatePackage {
    #[serde(skip_serializing_if="Option::is_none")]
    pub ecosystem: Option<SecurityAdvisoryEcosystems>,
    /// The unique package name within its ecosystem.
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct RepositoryadvisorycreateVulnerabilities {
    #[serde(skip_serializing_if="Option::is_none")]
    pub package: Option<RepositoryadvisorycreatePackage>,
    /// The range of the package versions affected by the vulnerability.
    #[serde(skip_serializing_if="Option::is_none")]
    pub vulnerable_version_range: Option<String>,
    /// The package version(s) that resolve the vulnerability.
    #[serde(skip_serializing_if="Option::is_none")]
    pub patched_versions: Option<String>,
    /// The functions in the package that are affected.
    #[serde(skip_serializing_if="Option::is_none")]
    pub vulnerable_functions: Option<Vec<String>>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct RepositoryruleParameters {
    /// The file paths that are restricted from being pushed to the commit graph.
    #[serde(skip_serializing_if="Option::is_none")]
    pub restricted_file_paths: Option<Vec<String>>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct RepositoryruleParameters1 {
    /// The maximum amount of characters allowed in file paths
    #[serde(skip_serializing_if="Option::is_none")]
    pub max_file_path_length: Option<u16>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct RepositoryruleParameters2 {
    /// The file extensions that are restricted from being pushed to the commit graph.
    #[serde(skip_serializing_if="Option::is_none")]
    pub restricted_file_extensions: Option<Vec<String>>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct RepositoryruleParameters3 {
    /// The maximum file size allowed in megabytes. This limit does not apply to Git Large File Storage (Git LFS).
    #[serde(skip_serializing_if="Option::is_none")]
    pub max_file_size: Option<u8>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct RepositoryrulecodescanningParameters {
    /// Tools that must provide code scanning results for this rule to pass.
    #[serde(skip_serializing_if="Option::is_none")]
    pub code_scanning_tools: Option<Vec<RepositoryRuleParamsCodeScanningTool>>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct RepositoryrulecommitmessagepatternParameters {
    /// How this rule will appear to users.
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,
    /// If true, the rule will fail if the pattern matches.
    #[serde(skip_serializing_if="Option::is_none")]
    pub negate: Option<bool>,
    /// The operator to use for matching.
    #[serde(skip_serializing_if="Option::is_none")]
    pub operator: Option<String>,
    /// The pattern to match with.
    #[serde(skip_serializing_if="Option::is_none")]
    pub pattern: Option<String>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct RepositoryrulemergequeueParameters {
    /// Maximum time for a required status check to report a conclusion. After this much time has elapsed, checks that have not reported a conclusion will be assumed to have failed
    #[serde(skip_serializing_if="Option::is_none")]
    pub check_response_timeout_minutes: Option<u16>,
    /// When set to ALLGREEN, the merge commit created by merge queue for each PR in the group must pass all required checks to merge. When set to HEADGREEN, only the commit at the head of the merge group, i.e. the commit containing changes from all of the PRs in the group, must pass its required checks to merge.
    #[serde(skip_serializing_if="Option::is_none")]
    pub grouping_strategy: Option<String>,
    /// Limit the number of queued pull requests requesting checks and workflow runs at the same time.
    #[serde(skip_serializing_if="Option::is_none")]
    pub max_entries_to_build: Option<u8>,
    /// The maximum number of PRs that will be merged together in a group.
    #[serde(skip_serializing_if="Option::is_none")]
    pub max_entries_to_merge: Option<u8>,
    /// Method to use when merging changes from queued pull requests.
    #[serde(skip_serializing_if="Option::is_none")]
    pub merge_method: Option<String>,
    /// The minimum number of PRs that will be merged together in a group.
    #[serde(skip_serializing_if="Option::is_none")]
    pub min_entries_to_merge: Option<u8>,
    /// The time merge queue should wait after the first PR is added to the queue for the minimum group size to be met. After this time has elapsed, the minimum group size will be ignored and a smaller group will be merged.
    #[serde(skip_serializing_if="Option::is_none")]
    pub min_entries_to_merge_wait_minutes: Option<u16>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct RepositoryrulepullrequestParameters {
    /// When merging pull requests, you can allow any combination of merge commits, squashing, or rebasing. At least one option must be enabled.
    #[serde(skip_serializing_if="Option::is_none")]
    pub allowed_merge_methods: Option<Vec<String>>,
    /// New, reviewable commits pushed will dismiss previous pull request review approvals.
    #[serde(skip_serializing_if="Option::is_none")]
    pub dismiss_stale_reviews_on_push: Option<bool>,
    /// Require an approving review in pull requests that modify files that have a designated code owner.
    #[serde(skip_serializing_if="Option::is_none")]
    pub require_code_owner_review: Option<bool>,
    /// Whether the most recent reviewable push must be approved by someone other than the person who pushed it.
    #[serde(skip_serializing_if="Option::is_none")]
    pub require_last_push_approval: Option<bool>,
    /// The number of approving reviews that are required before a pull request can be merged.
    #[serde(skip_serializing_if="Option::is_none")]
    pub required_approving_review_count: Option<u8>,
    /// All conversations on code must be resolved before a pull request can be merged.
    #[serde(skip_serializing_if="Option::is_none")]
    pub required_review_thread_resolution: Option<bool>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct RepositoryrulerequireddeploymentsParameters {
    /// The environments that must be successfully deployed to before branches can be merged.
    #[serde(skip_serializing_if="Option::is_none")]
    pub required_deployment_environments: Option<Vec<String>>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct RepositoryrulerequiredstatuschecksParameters {
    /// Allow repositories and branches to be created if a check would otherwise prohibit it.
    #[serde(skip_serializing_if="Option::is_none")]
    pub do_not_enforce_on_create: Option<bool>,
    /// Status checks that are required.
    #[serde(skip_serializing_if="Option::is_none")]
    pub required_status_checks: Option<Vec<RepositoryRuleParamsStatusCheckConfiguration>>,
    /// Whether pull requests targeting a matching branch must be tested with the latest code. This setting will not take effect unless at least one status check is enabled.
    #[serde(skip_serializing_if="Option::is_none")]
    pub strict_required_status_checks_policy: Option<bool>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct RepositoryrulesetLinks {
    #[serde(rename = "self")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub _self: Option<RepositoryrulesetLinksSelf>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub html: Option<RepositoryrulesetLinksHtml>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct RepositoryrulesetLinksHtml {
    /// The html URL of the ruleset
    #[serde(skip_serializing_if="Option::is_none")]
    pub href: Option<String>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct RepositoryrulesetLinksSelf {
    /// The URL of the ruleset
    #[serde(skip_serializing_if="Option::is_none")]
    pub href: Option<String>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct RepositoryrulesetconditionsRefName {
    /// Array of ref names or patterns to include. One of these patterns must match for the condition to pass. Also accepts `~DEFAULT_BRANCH` to include the default branch or `~ALL` to include all branches.
    #[serde(skip_serializing_if="Option::is_none")]
    pub include: Option<Vec<String>>,
    /// Array of ref names or patterns to exclude. The condition will not pass if any of these patterns match.
    #[serde(skip_serializing_if="Option::is_none")]
    pub exclude: Option<Vec<String>>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct RepositoryrulesetconditionsrepositoryidtargetRepositoryId {
    /// The repository IDs that the ruleset applies to. One of these IDs must match for the condition to pass.
    #[serde(skip_serializing_if="Option::is_none")]
    pub repository_ids: Option<Vec<i32>>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct RepositoryrulesetconditionsrepositorynametargetRepositoryName {
    /// Array of repository names or patterns to include. One of these patterns must match for the condition to pass. Also accepts `~ALL` to include all repositories.
    #[serde(skip_serializing_if="Option::is_none")]
    pub include: Option<Vec<String>>,
    /// Array of repository names or patterns to exclude. The condition will not pass if any of these patterns match.
    #[serde(skip_serializing_if="Option::is_none")]
    pub exclude: Option<Vec<String>>,
    /// Whether renaming of target repositories is prevented.
    #[serde(skip_serializing_if="Option::is_none")]
    pub protected: Option<bool>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct RepositoryrulesetconditionsrepositorypropertytargetRepositoryProperty {
    /// The repository properties and values to include. All of these properties must match for the condition to pass.
    #[serde(skip_serializing_if="Option::is_none")]
    pub include: Option<Vec<RepositoryRulesetConditionsRepositoryPropertySpec>>,
    /// The repository properties and values to exclude. The condition will not pass if any of these properties match.
    #[serde(skip_serializing_if="Option::is_none")]
    pub exclude: Option<Vec<RepositoryRulesetConditionsRepositoryPropertySpec>>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct RepositoryruleupdateParameters {
    /// Branch can pull changes from its upstream repository
    #[serde(skip_serializing_if="Option::is_none")]
    pub update_allows_fetch_and_merge: Option<bool>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct RepositoryruleviolationerrorMetadata {
    #[serde(skip_serializing_if="Option::is_none")]
    pub secret_scanning: Option<RepositoryruleviolationerrorMetadataSecretScanning>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct RepositoryruleviolationerrorMetadataSecretScanning {
    #[serde(skip_serializing_if="Option::is_none")]
    pub bypass_placeholders: Option<Vec<RepositoryruleviolationerrorMetadataSecretScanningBypassPlaceholders>>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct RepositoryruleviolationerrorMetadataSecretScanningBypassPlaceholders {
    #[serde(skip_serializing_if="Option::is_none")]
    pub placeholder_id: Option<SecretScanningPushProtectionBypassPlaceholderId>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub token_type: Option<String>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct RepositoryruleworkflowsParameters {
    /// Allow repositories and branches to be created if a check would otherwise prohibit it.
    #[serde(skip_serializing_if="Option::is_none")]
    pub do_not_enforce_on_create: Option<bool>,
    /// Workflows that must pass for this rule to pass.
    #[serde(skip_serializing_if="Option::is_none")]
    pub workflows: Option<Vec<RepositoryRuleParamsWorkflowFileReference>>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct RepositorywebhooksTemplateRepository {
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub node_id: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub full_name: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub owner: Option<RepositorywebhooksTemplateRepositoryOwner>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub private: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub html_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub description: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub fork: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub archive_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub assignees_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub blobs_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub branches_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub collaborators_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub comments_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub commits_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub compare_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub contents_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub contributors_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub deployments_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub downloads_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub events_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub forks_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub git_commits_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub git_refs_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub git_tags_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub git_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub issue_comment_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub issue_events_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub issues_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub keys_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub labels_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub languages_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub merges_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub milestones_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub notifications_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub pulls_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub releases_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub ssh_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub stargazers_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub statuses_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub subscribers_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub subscription_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub tags_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub teams_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub trees_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub clone_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub mirror_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub hooks_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub svn_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub homepage: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub language: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub forks_count: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub stargazers_count: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub watchers_count: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub size: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub default_branch: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub open_issues_count: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub is_template: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub topics: Option<Vec<String>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub has_issues: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub has_projects: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub has_wiki: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub has_pages: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub has_downloads: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub archived: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub disabled: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub visibility: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub pushed_at: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub created_at: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub updated_at: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub permissions: Option<MinimalrepositoryPermissions>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub allow_rebase_merge: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub temp_clone_token: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub allow_squash_merge: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub allow_auto_merge: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub delete_branch_on_merge: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub allow_update_branch: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub use_squash_pr_title_as_default: Option<bool>,
    /// The default value for a squash merge commit title:  - `PR_TITLE` - default to the pull request's title. - `COMMIT_OR_PR_TITLE` - default to the commit's title (if only one commit) or the pull request's title (when more than one commit).
    #[serde(skip_serializing_if="Option::is_none")]
    pub squash_merge_commit_title: Option<String>,
    /// The default value for a squash merge commit message:  - `PR_BODY` - default to the pull request's body. - `COMMIT_MESSAGES` - default to the branch's commit messages. - `BLANK` - default to a blank commit message.
    #[serde(skip_serializing_if="Option::is_none")]
    pub squash_merge_commit_message: Option<String>,
    /// The default value for a merge commit title.  - `PR_TITLE` - default to the pull request's title. - `MERGE_MESSAGE` - default to the classic title for a merge message (e.g., Merge pull request #123 from branch-name).
    #[serde(skip_serializing_if="Option::is_none")]
    pub merge_commit_title: Option<String>,
    /// The default value for a merge commit message.  - `PR_TITLE` - default to the pull request's title. - `PR_BODY` - default to the pull request's body. - `BLANK` - default to a blank commit message.
    #[serde(skip_serializing_if="Option::is_none")]
    pub merge_commit_message: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub allow_merge_commit: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub subscribers_count: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub network_count: Option<i64>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct RepositorywebhooksTemplateRepositoryOwner {
    #[serde(skip_serializing_if="Option::is_none")]
    pub login: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub node_id: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub avatar_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub gravatar_id: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub html_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub followers_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub following_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub gists_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub starred_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub subscriptions_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub organizations_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub repos_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub events_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub received_events_url: Option<String>,
    #[serde(rename = "type")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub _type: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub site_admin: Option<bool>,
}

/// Specify which security and analysis features to enable or disable for the repository.  To use this parameter, you must have admin permissions for the repository or be an owner or security manager for the organization that owns the repository. For more information, see \"[Managing security managers in your organization](https://docs.github.com/organizations/managing-peoples-access-to-your-organization-with-roles/managing-security-managers-in-your-organization).\"  For example, to enable GitHub Advanced Security, use this data in the body of the `PATCH` request: `{ \"security_and_analysis\": {\"advanced_security\": { \"status\": \"enabled\" } } }`.  You can check which security and analysis features are currently enabled by using a `GET /repos/{owner}/{repo}` request.
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct ReposownerrepoSecurityAndAnalysis {
    #[serde(skip_serializing_if="Option::is_none")]
    pub advanced_security: Option<ReposownerrepoSecurityAndAnalysisAdvancedSecurity>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub secret_scanning: Option<ReposownerrepoSecurityAndAnalysisSecretScanning>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub secret_scanning_push_protection: Option<ReposownerrepoSecurityAndAnalysisSecretScanningPushProtection>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub secret_scanning_ai_detection: Option<ReposownerrepoSecurityAndAnalysisSecretScanningAiDetection>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub secret_scanning_non_provider_patterns: Option<ReposownerrepoSecurityAndAnalysisSecretScanningNonProviderPatterns>,
}

/// Use the `status` property to enable or disable GitHub Advanced Security for this repository. For more information, see \"[About GitHub Advanced Security](/github/getting-started-with-github/learning-about-github/about-github-advanced-security).\"
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct ReposownerrepoSecurityAndAnalysisAdvancedSecurity {
    /// Can be `enabled` or `disabled`.
    #[serde(skip_serializing_if="Option::is_none")]
    pub status: Option<String>,
}

/// Use the `status` property to enable or disable secret scanning for this repository. For more information, see \"[About secret scanning](/code-security/secret-security/about-secret-scanning).\"
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct ReposownerrepoSecurityAndAnalysisSecretScanning {
    /// Can be `enabled` or `disabled`.
    #[serde(skip_serializing_if="Option::is_none")]
    pub status: Option<String>,
}

/// Use the `status` property to enable or disable secret scanning AI detection for this repository. For more information, see \"[Responsible detection of generic secrets with AI](https://docs.github.com/code-security/secret-scanning/using-advanced-secret-scanning-and-push-protection-features/generic-secret-detection/responsible-ai-generic-secrets).\"
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct ReposownerrepoSecurityAndAnalysisSecretScanningAiDetection {
    /// Can be `enabled` or `disabled`.
    #[serde(skip_serializing_if="Option::is_none")]
    pub status: Option<String>,
}

/// Use the `status` property to enable or disable secret scanning non-provider patterns for this repository. For more information, see \"[Supported secret scanning patterns](/code-security/secret-scanning/introduction/supported-secret-scanning-patterns#supported-secrets).\"
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct ReposownerrepoSecurityAndAnalysisSecretScanningNonProviderPatterns {
    /// Can be `enabled` or `disabled`.
    #[serde(skip_serializing_if="Option::is_none")]
    pub status: Option<String>,
}

/// Use the `status` property to enable or disable secret scanning push protection for this repository. For more information, see \"[Protecting pushes with secret scanning](/code-security/secret-scanning/protecting-pushes-with-secret-scanning).\"
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct ReposownerrepoSecurityAndAnalysisSecretScanningPushProtection {
    /// Can be `enabled` or `disabled`.
    #[serde(skip_serializing_if="Option::is_none")]
    pub status: Option<String>,
}

/// The attestation's Sigstore Bundle. Refer to the [Sigstore Bundle Specification](https://github.com/sigstore/protobuf-specs/blob/main/protos/sigstore_bundle.proto) for more information.
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct ReposownerrepoattestationsBundle {
    #[serde(rename = "mediaType")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub media_type: Option<String>,
    #[serde(rename = "verificationMaterial")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub verification_material: Option<HashMap<String, HashMap<String, Value>>>,
    #[serde(rename = "dsseEnvelope")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub dsse_envelope: Option<HashMap<String, HashMap<String, Value>>>,
}

/// Require at least one approving review on a pull request, before merging. Set to `null` to disable.
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct ReposownerrepobranchesbranchprotectionRequiredPullRequestReviews {
    #[serde(skip_serializing_if="Option::is_none")]
    pub dismissal_restrictions: Option<ReposownerrepobranchesbranchprotectionRequiredPullRequestReviewsDismissalRestrictions>,
    /// Set to `true` if you want to automatically dismiss approving reviews when someone pushes a new commit.
    #[serde(skip_serializing_if="Option::is_none")]
    pub dismiss_stale_reviews: Option<bool>,
    /// Blocks merging pull requests until [code owners](https://docs.github.com/articles/about-code-owners/) review them.
    #[serde(skip_serializing_if="Option::is_none")]
    pub require_code_owner_reviews: Option<bool>,
    /// Specify the number of reviewers required to approve pull requests. Use a number between 1 and 6 or 0 to not require reviewers.
    #[serde(skip_serializing_if="Option::is_none")]
    pub required_approving_review_count: Option<i64>,
    /// Whether the most recent push must be approved by someone other than the person who pushed it. Default: `false`.
    #[serde(skip_serializing_if="Option::is_none")]
    pub require_last_push_approval: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub bypass_pull_request_allowances: Option<ReposownerrepobranchesbranchprotectionRequiredPullRequestReviewsBypassPullRequestAllowances>,
}

/// Allow specific users, teams, or apps to bypass pull request requirements.
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct ReposownerrepobranchesbranchprotectionRequiredPullRequestReviewsBypassPullRequestAllowances {
    /// The list of user `login`s allowed to bypass pull request requirements.
    #[serde(skip_serializing_if="Option::is_none")]
    pub users: Option<Vec<String>>,
    /// The list of team `slug`s allowed to bypass pull request requirements.
    #[serde(skip_serializing_if="Option::is_none")]
    pub teams: Option<Vec<String>>,
    /// The list of app `slug`s allowed to bypass pull request requirements.
    #[serde(skip_serializing_if="Option::is_none")]
    pub apps: Option<Vec<String>>,
}

/// Specify which users, teams, and apps can dismiss pull request reviews. Pass an empty `dismissal_restrictions` object to disable. User and team `dismissal_restrictions` are only available for organization-owned repositories. Omit this parameter for personal repositories.
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct ReposownerrepobranchesbranchprotectionRequiredPullRequestReviewsDismissalRestrictions {
    /// The list of user `login`s with dismissal access
    #[serde(skip_serializing_if="Option::is_none")]
    pub users: Option<Vec<String>>,
    /// The list of team `slug`s with dismissal access
    #[serde(skip_serializing_if="Option::is_none")]
    pub teams: Option<Vec<String>>,
    /// The list of app `slug`s with dismissal access
    #[serde(skip_serializing_if="Option::is_none")]
    pub apps: Option<Vec<String>>,
}

/// Require status checks to pass before merging. Set to `null` to disable.
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct ReposownerrepobranchesbranchprotectionRequiredStatusChecks {
    /// Require branches to be up to date before merging.
    #[serde(skip_serializing_if="Option::is_none")]
    pub strict: Option<bool>,
    /// **Closing down notice**: The list of status checks to require in order to merge into this branch. If any of these checks have recently been set by a particular GitHub App, they will be required to come from that app in future for the branch to merge. Use `checks` instead of `contexts` for more fine-grained control.
    #[serde(skip_serializing_if="Option::is_none")]
    pub contexts: Option<Vec<String>>,
    /// The list of status checks to require in order to merge into this branch.
    #[serde(skip_serializing_if="Option::is_none")]
    pub checks: Option<Vec<ReposownerrepobranchesbranchprotectionRequiredStatusChecksChecks>>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct ReposownerrepobranchesbranchprotectionRequiredStatusChecksChecks {
    /// The name of the required check
    #[serde(skip_serializing_if="Option::is_none")]
    pub context: Option<String>,
    /// The ID of the GitHub App that must provide this check. Omit this field to automatically select the GitHub App that has recently provided this check, or any app if it was not set by a GitHub App. Pass -1 to explicitly allow any app to set the status.
    #[serde(skip_serializing_if="Option::is_none")]
    pub app_id: Option<i64>,
}

/// Restrict who can push to the protected branch. User, app, and team `restrictions` are only available for organization-owned repositories. Set to `null` to disable.
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct ReposownerrepobranchesbranchprotectionRestrictions {
    /// The list of user `login`s with push access
    #[serde(skip_serializing_if="Option::is_none")]
    pub users: Option<Vec<String>>,
    /// The list of team `slug`s with push access
    #[serde(skip_serializing_if="Option::is_none")]
    pub teams: Option<Vec<String>>,
    /// The list of app `slug`s with push access
    #[serde(skip_serializing_if="Option::is_none")]
    pub apps: Option<Vec<String>>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct ReposownerrepocheckrunsActions {
    /// The text to be displayed on a button in the web UI. The maximum size is 20 characters.
    #[serde(skip_serializing_if="Option::is_none")]
    pub label: Option<String>,
    /// A short explanation of what this action would do. The maximum size is 40 characters.
    #[serde(skip_serializing_if="Option::is_none")]
    pub description: Option<String>,
    /// A reference for the action on the integrator's system. The maximum size is 20 characters.
    #[serde(skip_serializing_if="Option::is_none")]
    pub identifier: Option<String>,
}

/// Check runs can accept a variety of data in the `output` object, including a `title` and `summary` and can optionally provide descriptive details about the run.
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct ReposownerrepocheckrunsOutput {
    /// The title of the check run.
    #[serde(skip_serializing_if="Option::is_none")]
    pub title: Option<String>,
    /// The summary of the check run. This parameter supports Markdown. **Maximum length**: 65535 characters.
    #[serde(skip_serializing_if="Option::is_none")]
    pub summary: Option<String>,
    /// The details of the check run. This parameter supports Markdown. **Maximum length**: 65535 characters.
    #[serde(skip_serializing_if="Option::is_none")]
    pub text: Option<String>,
    /// Adds information from your analysis to specific lines of code. Annotations are visible on GitHub in the **Checks** and **Files changed** tab of the pull request. The Checks API limits the number of annotations to a maximum of 50 per API request. To create more than 50 annotations, you have to make multiple requests to the [Update a check run](https://docs.github.com/rest/checks/runs#update-a-check-run) endpoint. Each time you update the check run, annotations are appended to the list of annotations that already exist for the check run. GitHub Actions are limited to 10 warning annotations and 10 error annotations per step. For details about how you can view annotations on GitHub, see \"[About status checks](https://docs.github.com/articles/about-status-checks#checks)\".
    #[serde(skip_serializing_if="Option::is_none")]
    pub annotations: Option<Vec<ReposownerrepocheckrunsOutputAnnotations>>,
    /// Adds images to the output displayed in the GitHub pull request UI.
    #[serde(skip_serializing_if="Option::is_none")]
    pub images: Option<Vec<ReposownerrepocheckrunsOutputImages>>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct ReposownerrepocheckrunsOutputAnnotations {
    /// The path of the file to add an annotation to. For example, `assets/css/main.css`.
    #[serde(skip_serializing_if="Option::is_none")]
    pub path: Option<String>,
    /// The start line of the annotation. Line numbers start at 1.
    #[serde(skip_serializing_if="Option::is_none")]
    pub start_line: Option<i64>,
    /// The end line of the annotation.
    #[serde(skip_serializing_if="Option::is_none")]
    pub end_line: Option<i64>,
    /// The start column of the annotation. Annotations only support `start_column` and `end_column` on the same line. Omit this parameter if `start_line` and `end_line` have different values. Column numbers start at 1.
    #[serde(skip_serializing_if="Option::is_none")]
    pub start_column: Option<i64>,
    /// The end column of the annotation. Annotations only support `start_column` and `end_column` on the same line. Omit this parameter if `start_line` and `end_line` have different values.
    #[serde(skip_serializing_if="Option::is_none")]
    pub end_column: Option<i64>,
    /// The level of the annotation.
    #[serde(skip_serializing_if="Option::is_none")]
    pub annotation_level: Option<String>,
    /// A short description of the feedback for these lines of code. The maximum size is 64 KB.
    #[serde(skip_serializing_if="Option::is_none")]
    pub message: Option<String>,
    /// The title that represents the annotation. The maximum size is 255 characters.
    #[serde(skip_serializing_if="Option::is_none")]
    pub title: Option<String>,
    /// Details about this annotation. The maximum size is 64 KB.
    #[serde(skip_serializing_if="Option::is_none")]
    pub raw_details: Option<String>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct ReposownerrepocheckrunsOutputImages {
    /// The alternative text for the image.
    #[serde(skip_serializing_if="Option::is_none")]
    pub alt: Option<String>,
    /// The full URL of the image.
    #[serde(skip_serializing_if="Option::is_none")]
    pub image_url: Option<String>,
    /// A short image description.
    #[serde(skip_serializing_if="Option::is_none")]
    pub caption: Option<String>,
}

/// Check runs can accept a variety of data in the `output` object, including a `title` and `summary` and can optionally provide descriptive details about the run.
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct ReposownerrepocheckrunscheckRunIdOutput {
    /// **Required**.
    #[serde(skip_serializing_if="Option::is_none")]
    pub title: Option<String>,
    /// Can contain Markdown.
    #[serde(skip_serializing_if="Option::is_none")]
    pub summary: Option<String>,
    /// Can contain Markdown.
    #[serde(skip_serializing_if="Option::is_none")]
    pub text: Option<String>,
    /// Adds information from your analysis to specific lines of code. Annotations are visible in GitHub's pull request UI. Annotations are visible in GitHub's pull request UI. The Checks API limits the number of annotations to a maximum of 50 per API request. To create more than 50 annotations, you have to make multiple requests to the [Update a check run](https://docs.github.com/rest/checks/runs#update-a-check-run) endpoint. Each time you update the check run, annotations are appended to the list of annotations that already exist for the check run. GitHub Actions are limited to 10 warning annotations and 10 error annotations per step. For details about annotations in the UI, see \"[About status checks](https://docs.github.com/articles/about-status-checks#checks)\".
    #[serde(skip_serializing_if="Option::is_none")]
    pub annotations: Option<Vec<ReposownerrepocheckrunsOutputAnnotations>>,
    /// Adds images to the output displayed in the GitHub pull request UI.
    #[serde(skip_serializing_if="Option::is_none")]
    pub images: Option<Vec<ReposownerrepocheckrunsOutputImages>>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct ReposownerrepochecksuitespreferencesAutoTriggerChecks {
    /// The `id` of the GitHub App.
    #[serde(skip_serializing_if="Option::is_none")]
    pub app_id: Option<i64>,
    /// Set to `true` to enable automatic creation of CheckSuite events upon pushes to the repository, or `false` to disable them.
    #[serde(skip_serializing_if="Option::is_none")]
    pub setting: Option<bool>,
}

/// The author of the file. Default: The `committer` or the authenticated user if you omit `committer`.
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct ReposownerrepocontentspathAuthor {
    /// The name of the author or committer of the commit. You'll receive a `422` status code if `name` is omitted.
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,
    /// The email of the author or committer of the commit. You'll receive a `422` status code if `email` is omitted.
    #[serde(skip_serializing_if="Option::is_none")]
    pub email: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub date: Option<String>,
}

/// object containing information about the author.
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct ReposownerrepocontentspathAuthor1 {
    /// The name of the author (or committer) of the commit
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,
    /// The email of the author (or committer) of the commit
    #[serde(skip_serializing_if="Option::is_none")]
    pub email: Option<String>,
}

/// The person that committed the file. Default: the authenticated user.
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct ReposownerrepocontentspathCommitter {
    /// The name of the author or committer of the commit. You'll receive a `422` status code if `name` is omitted.
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,
    /// The email of the author or committer of the commit. You'll receive a `422` status code if `email` is omitted.
    #[serde(skip_serializing_if="Option::is_none")]
    pub email: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub date: Option<String>,
}

/// object containing information about the committer.
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct ReposownerrepocontentspathCommitter1 {
    /// The name of the author (or committer) of the commit
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,
    /// The email of the author (or committer) of the commit
    #[serde(skip_serializing_if="Option::is_none")]
    pub email: Option<String>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct ReposownerrepoenvironmentsenvironmentNameReviewers {
    #[serde(rename = "type")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub _type: Option<DeploymentReviewerType>,
    /// The id of the user or team who can review the deployment
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<i64>,
}

/// Information about the author of the commit. By default, the `author` will be the authenticated user and the current date. See the `author` and `committer` object below for details.
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct ReposownerrepogitcommitsAuthor {
    /// The name of the author (or committer) of the commit
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,
    /// The email of the author (or committer) of the commit
    #[serde(skip_serializing_if="Option::is_none")]
    pub email: Option<String>,
    /// Indicates when this commit was authored (or committed). This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.
    #[serde(skip_serializing_if="Option::is_none")]
    pub date: Option<chrono::DateTime<chrono::Utc>>,
}

/// Information about the person who is making the commit. By default, `committer` will use the information set in `author`. See the `author` and `committer` object below for details.
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct ReposownerrepogitcommitsCommitter {
    /// The name of the author (or committer) of the commit
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,
    /// The email of the author (or committer) of the commit
    #[serde(skip_serializing_if="Option::is_none")]
    pub email: Option<String>,
    /// Indicates when this commit was authored (or committed). This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.
    #[serde(skip_serializing_if="Option::is_none")]
    pub date: Option<chrono::DateTime<chrono::Utc>>,
}

/// An object with information about the individual creating the tag.
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct ReposownerrepogittagsTagger {
    /// The name of the author of the tag
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,
    /// The email of the author of the tag
    #[serde(skip_serializing_if="Option::is_none")]
    pub email: Option<String>,
    /// When this object was tagged. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.
    #[serde(skip_serializing_if="Option::is_none")]
    pub date: Option<chrono::DateTime<chrono::Utc>>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct ReposownerrepogittreesTree {
    /// The file referenced in the tree.
    #[serde(skip_serializing_if="Option::is_none")]
    pub path: Option<String>,
    /// The file mode; one of `100644` for file (blob), `100755` for executable (blob), `040000` for subdirectory (tree), `160000` for submodule (commit), or `120000` for a blob that specifies the path of a symlink.
    #[serde(skip_serializing_if="Option::is_none")]
    pub mode: Option<String>,
    /// Either `blob`, `tree`, or `commit`.
    #[serde(rename = "type")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub _type: Option<String>,
    /// The SHA1 checksum ID of the object in the tree. Also called `tree.sha`. If the value is `null` then the file will be deleted.      **Note:** Use either `tree.sha` or `content` to specify the contents of the entry. Using both `tree.sha` and `content` will return an error.
    #[serde(skip_serializing_if="Option::is_none")]
    pub sha: Option<String>,
    /// The content you want this file to have. GitHub will write this blob out and use that SHA for this entry. Use either this, or `tree.sha`.      **Note:** Use either `tree.sha` or `content` to specify the contents of the entry. Using both `tree.sha` and `content` will return an error.
    #[serde(skip_serializing_if="Option::is_none")]
    pub content: Option<String>,
}

/// Key/value pairs to provide settings for this webhook.
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct ReposownerrepohooksConfig {
    #[serde(skip_serializing_if="Option::is_none")]
    pub url: Option<WebhookConfigUrl>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub content_type: Option<WebhookConfigContentType>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub secret: Option<WebhookConfigSecret>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub insecure_ssl: Option<WebhookConfigInsecureSsl>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct ReposownerrepoissuesissueNumberlabelsLabels {
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,
}

/// The source branch and directory used to publish your Pages site.
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct ReposownerrepopagesSource {
    /// The repository branch used to publish your site's source files.
    #[serde(skip_serializing_if="Option::is_none")]
    pub branch: Option<String>,
    /// The repository directory that includes the source files for the Pages site. Allowed paths are `/` or `/docs`. Default: `/`
    #[serde(skip_serializing_if="Option::is_none")]
    pub path: Option<String>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct ReposownerrepopullspullNumberreviewsComments {
    /// The relative path to the file that necessitates a review comment.
    #[serde(skip_serializing_if="Option::is_none")]
    pub path: Option<String>,
    /// The position in the diff where you want to add a review comment. Note this value is not the same as the line number in the file. The `position` value equals the number of lines down from the first \"@@\" hunk header in the file you want to add a comment. The line just below the \"@@\" line is position 1, the next line is position 2, and so on. The position in the diff continues to increase through lines of whitespace and additional hunks until the beginning of a new file.
    #[serde(skip_serializing_if="Option::is_none")]
    pub position: Option<i64>,
    /// Text of the review comment.
    #[serde(skip_serializing_if="Option::is_none")]
    pub body: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub line: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub side: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub start_line: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub start_side: Option<String>,
}

/// Legacy Review Comment
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct ReviewComment {
    #[serde(skip_serializing_if="Option::is_none")]
    pub url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub pull_request_review_id: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub node_id: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub diff_hunk: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub path: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub position: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub original_position: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub commit_id: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub original_commit_id: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub in_reply_to_id: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub user: Option<NullableSimpleUser>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub body: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub updated_at: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub html_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub pull_request_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub author_association: Option<AuthorAssociation>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub _links: Option<ReviewcommentLinks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub body_text: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub body_html: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub reactions: Option<ReactionRollup>,
    /// The side of the first line of the range for a multi-line comment.
    #[serde(skip_serializing_if="Option::is_none")]
    pub side: Option<String>,
    /// The side of the first line of the range for a multi-line comment.
    #[serde(skip_serializing_if="Option::is_none")]
    pub start_side: Option<String>,
    /// The line of the blob to which the comment applies. The last line of the range for a multi-line comment
    #[serde(skip_serializing_if="Option::is_none")]
    pub line: Option<i64>,
    /// The original line of the blob to which the comment applies. The last line of the range for a multi-line comment
    #[serde(skip_serializing_if="Option::is_none")]
    pub original_line: Option<i64>,
    /// The first line of the range for a multi-line comment.
    #[serde(skip_serializing_if="Option::is_none")]
    pub start_line: Option<i64>,
    /// The original first line of the range for a multi-line comment.
    #[serde(skip_serializing_if="Option::is_none")]
    pub original_start_line: Option<i64>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct ReviewCustomGatesCommentRequired {
    /// The name of the environment to approve or reject.
    #[serde(skip_serializing_if="Option::is_none")]
    pub environment_name: Option<String>,
    /// Comment associated with the pending deployment protection rule. **Required when state is not provided.**
    #[serde(skip_serializing_if="Option::is_none")]
    pub comment: Option<String>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct ReviewCustomGatesStateRequired {
    /// The name of the environment to approve or reject.
    #[serde(skip_serializing_if="Option::is_none")]
    pub environment_name: Option<String>,
    /// Whether to approve or reject deployment to the specified environments.
    #[serde(skip_serializing_if="Option::is_none")]
    pub state: Option<String>,
    /// Optional comment to include with the review.
    #[serde(skip_serializing_if="Option::is_none")]
    pub comment: Option<String>,
}

/// Review Dismissed Issue Event
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct ReviewDismissedIssueEvent {
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub node_id: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub actor: Option<SimpleUser>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub event: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub commit_id: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub commit_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub created_at: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub performed_via_github_app: Option<NullableIntegration>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub dismissed_review: Option<ReviewdismissedissueeventDismissedReview>,
}

/// Review Request Removed Issue Event
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct ReviewRequestRemovedIssueEvent {
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub node_id: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub actor: Option<SimpleUser>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub event: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub commit_id: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub commit_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub created_at: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub performed_via_github_app: Option<NullableIntegration>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub review_requester: Option<SimpleUser>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub requested_team: Option<Team>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub requested_reviewer: Option<SimpleUser>,
}

/// Review Requested Issue Event
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct ReviewRequestedIssueEvent {
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub node_id: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub actor: Option<SimpleUser>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub event: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub commit_id: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub commit_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub created_at: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub performed_via_github_app: Option<NullableIntegration>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub review_requester: Option<SimpleUser>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub requested_team: Option<Team>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub requested_reviewer: Option<SimpleUser>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct ReviewcommentLinks {
    #[serde(rename = "self")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub _self: Option<Link>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub html: Option<Link>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub pull_request: Option<Link>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct ReviewdismissedissueeventDismissedReview {
    #[serde(skip_serializing_if="Option::is_none")]
    pub state: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub review_id: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub dismissal_message: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub dismissal_commit_id: Option<String>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct Root {
    #[serde(skip_serializing_if="Option::is_none")]
    pub current_user_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub current_user_authorizations_html_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub authorizations_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub code_search_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub commit_search_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub emails_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub emojis_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub events_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub feeds_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub followers_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub following_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub gists_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub hub_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub issue_search_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub issues_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub keys_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub label_search_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub notifications_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub organization_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub organization_repositories_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub organization_teams_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub public_gists_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub rate_limit_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub repository_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub repository_search_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub current_user_repositories_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub starred_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub starred_gists_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub topic_search_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub user_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub user_organizations_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub user_repositories_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub user_search_url: Option<String>,
}

/// Response
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct RuleSuite {
    /// The unique identifier of the rule insight.
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<i64>,
    /// The number that identifies the user.
    #[serde(skip_serializing_if="Option::is_none")]
    pub actor_id: Option<i64>,
    /// The handle for the GitHub user account.
    #[serde(skip_serializing_if="Option::is_none")]
    pub actor_name: Option<String>,
    /// The first commit sha before the push evaluation.
    #[serde(skip_serializing_if="Option::is_none")]
    pub before_sha: Option<String>,
    /// The last commit sha in the push evaluation.
    #[serde(skip_serializing_if="Option::is_none")]
    pub after_sha: Option<String>,
    /// The ref name that the evaluation ran on.
    #[serde(rename = "ref")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub git_ref: Option<String>,
    /// The ID of the repository associated with the rule evaluation.
    #[serde(skip_serializing_if="Option::is_none")]
    pub repository_id: Option<i64>,
    /// The name of the repository without the `.git` extension.
    #[serde(skip_serializing_if="Option::is_none")]
    pub repository_name: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub pushed_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The result of the rule evaluations for rules with the `active` enforcement status.
    #[serde(skip_serializing_if="Option::is_none")]
    pub result: Option<String>,
    /// The result of the rule evaluations for rules with the `active` and `evaluate` enforcement statuses, demonstrating whether rules would pass or fail if all rules in the rule suite were `active`. Null if no rules with `evaluate` enforcement status were run.
    #[serde(skip_serializing_if="Option::is_none")]
    pub evaluation_result: Option<String>,
    /// Details on the evaluated rules.
    #[serde(skip_serializing_if="Option::is_none")]
    pub rule_evaluations: Option<Vec<RulesuiteRuleEvaluations>>,
}

/// Response
pub type RuleSuites = Vec<RulesuitesInner>;

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct RulesuiteRuleEvaluations {
    #[serde(skip_serializing_if="Option::is_none")]
    pub rule_source: Option<RulesuiteRuleSource>,
    /// The enforcement level of this rule source.
    #[serde(skip_serializing_if="Option::is_none")]
    pub enforcement: Option<String>,
    /// The result of the evaluation of the individual rule.
    #[serde(skip_serializing_if="Option::is_none")]
    pub result: Option<String>,
    /// The type of rule.
    #[serde(skip_serializing_if="Option::is_none")]
    pub rule_type: Option<String>,
    /// The detailed failure message for the rule. Null if the rule passed.
    #[serde(skip_serializing_if="Option::is_none")]
    pub details: Option<String>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct RulesuiteRuleSource {
    /// The type of rule source.
    #[serde(rename = "type")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub _type: Option<String>,
    /// The ID of the rule source.
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<i64>,
    /// The name of the rule source.
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct RulesuitesInner {
    /// The unique identifier of the rule insight.
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<i64>,
    /// The number that identifies the user.
    #[serde(skip_serializing_if="Option::is_none")]
    pub actor_id: Option<i64>,
    /// The handle for the GitHub user account.
    #[serde(skip_serializing_if="Option::is_none")]
    pub actor_name: Option<String>,
    /// The first commit sha before the push evaluation.
    #[serde(skip_serializing_if="Option::is_none")]
    pub before_sha: Option<String>,
    /// The last commit sha in the push evaluation.
    #[serde(skip_serializing_if="Option::is_none")]
    pub after_sha: Option<String>,
    /// The ref name that the evaluation ran on.
    #[serde(rename = "ref")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub git_ref: Option<String>,
    /// The ID of the repository associated with the rule evaluation.
    #[serde(skip_serializing_if="Option::is_none")]
    pub repository_id: Option<i64>,
    /// The name of the repository without the `.git` extension.
    #[serde(skip_serializing_if="Option::is_none")]
    pub repository_name: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub pushed_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The result of the rule evaluations for rules with the `active` enforcement status.
    #[serde(skip_serializing_if="Option::is_none")]
    pub result: Option<String>,
    /// The result of the rule evaluations for rules with the `active` and `evaluate` enforcement statuses, demonstrating whether rules would pass or fail if all rules in the rule suite were `active`.
    #[serde(skip_serializing_if="Option::is_none")]
    pub evaluation_result: Option<String>,
}

/// A self hosted runner
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct Runner {
    /// The id of the runner.
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<i64>,
    /// The id of the runner group.
    #[serde(skip_serializing_if="Option::is_none")]
    pub runner_group_id: Option<i64>,
    /// The name of the runner.
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,
    /// The Operating System of the runner.
    #[serde(skip_serializing_if="Option::is_none")]
    pub os: Option<String>,
    /// The status of the runner.
    #[serde(skip_serializing_if="Option::is_none")]
    pub status: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub busy: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub labels: Option<Vec<RunnerLabel>>,
}

/// Runner Application
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct RunnerApplication {
    #[serde(skip_serializing_if="Option::is_none")]
    pub os: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub architecture: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub download_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub filename: Option<String>,
    /// A short lived bearer token used to download the runner, if needed.
    #[serde(skip_serializing_if="Option::is_none")]
    pub temp_download_token: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub sha256_checksum: Option<String>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct RunnerGroupsOrg {
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<f64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub visibility: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub default: Option<bool>,
    /// Link to the selected repositories resource for this runner group. Not present unless visibility was set to `selected`
    #[serde(skip_serializing_if="Option::is_none")]
    pub selected_repositories_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub runners_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub hosted_runners_url: Option<String>,
    /// The identifier of a hosted compute network configuration.
    #[serde(skip_serializing_if="Option::is_none")]
    pub network_configuration_id: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub inherited: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub inherited_allows_public_repositories: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub allows_public_repositories: Option<bool>,
    /// If `true`, the `restricted_to_workflows` and `selected_workflows` fields cannot be modified.
    #[serde(skip_serializing_if="Option::is_none")]
    pub workflow_restrictions_read_only: Option<bool>,
    /// If `true`, the runner group will be restricted to running only the workflows specified in the `selected_workflows` array.
    #[serde(skip_serializing_if="Option::is_none")]
    pub restricted_to_workflows: Option<bool>,
    /// List of workflows the runner group should be allowed to run. This setting will be ignored unless `restricted_to_workflows` is set to `true`.
    #[serde(skip_serializing_if="Option::is_none")]
    pub selected_workflows: Option<Vec<String>>,
}

/// A label for a self hosted runner
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct RunnerLabel {
    /// Unique identifier of the label.
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<i64>,
    /// Name of the label.
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,
    /// The type of label. Read-only labels are applied automatically when the runner is configured.
    #[serde(rename = "type")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub _type: Option<String>,
}

/// Scim Error
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct ScimError {
    #[serde(skip_serializing_if="Option::is_none")]
    pub message: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub documentation_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub detail: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub status: Option<i64>,
    #[serde(rename = "scimType")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub scim_type: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub schemas: Option<Vec<String>>,
}

pub type SearchResultTextMatches = Vec<SearchresulttextmatchesInner>;

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct SearchresulttextmatchesInner {
    #[serde(skip_serializing_if="Option::is_none")]
    pub object_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub object_type: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub property: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub fragment: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub matches: Option<Vec<Value>>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct SecretScanningAlert {
    #[serde(skip_serializing_if="Option::is_none")]
    pub number: Option<AlertNumber>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub created_at: Option<AlertCreatedAt>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub updated_at: Option<NullableAlertUpdatedAt>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub url: Option<AlertUrl>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub html_url: Option<AlertHtmlUrl>,
    /// The REST API URL of the code locations for this alert.
    #[serde(skip_serializing_if="Option::is_none")]
    pub locations_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub state: Option<SecretScanningAlertState>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub resolution: Option<SecretScanningAlertResolution>,
    /// The time that the alert was resolved in ISO 8601 format: `YYYY-MM-DDTHH:MM:SSZ`.
    #[serde(skip_serializing_if="Option::is_none")]
    pub resolved_at: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub resolved_by: Option<NullableSimpleUser>,
    /// An optional comment to resolve an alert.
    #[serde(skip_serializing_if="Option::is_none")]
    pub resolution_comment: Option<String>,
    /// The type of secret that secret scanning detected.
    #[serde(skip_serializing_if="Option::is_none")]
    pub secret_type: Option<String>,
    /// User-friendly name for the detected secret, matching the `secret_type`. For a list of built-in patterns, see \"[Supported secret scanning patterns](https://docs.github.com/code-security/secret-scanning/introduction/supported-secret-scanning-patterns#supported-secrets).\"
    #[serde(skip_serializing_if="Option::is_none")]
    pub secret_type_display_name: Option<String>,
    /// The secret that was detected.
    #[serde(skip_serializing_if="Option::is_none")]
    pub secret: Option<String>,
    /// Whether push protection was bypassed for the detected secret.
    #[serde(skip_serializing_if="Option::is_none")]
    pub push_protection_bypassed: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub push_protection_bypassed_by: Option<NullableSimpleUser>,
    /// The time that push protection was bypassed in ISO 8601 format: `YYYY-MM-DDTHH:MM:SSZ`.
    #[serde(skip_serializing_if="Option::is_none")]
    pub push_protection_bypassed_at: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub push_protection_bypass_request_reviewer: Option<NullableSimpleUser>,
    /// An optional comment when reviewing a push protection bypass.
    #[serde(skip_serializing_if="Option::is_none")]
    pub push_protection_bypass_request_reviewer_comment: Option<String>,
    /// An optional comment when requesting a push protection bypass.
    #[serde(skip_serializing_if="Option::is_none")]
    pub push_protection_bypass_request_comment: Option<String>,
    /// The URL to a push protection bypass request.
    #[serde(skip_serializing_if="Option::is_none")]
    pub push_protection_bypass_request_html_url: Option<String>,
    /// The token status as of the latest validity check.
    #[serde(skip_serializing_if="Option::is_none")]
    pub validity: Option<String>,
    /// Whether the detected secret was publicly leaked.
    #[serde(skip_serializing_if="Option::is_none")]
    pub publicly_leaked: Option<bool>,
    /// Whether the detected secret was found in multiple repositories under the same organization or enterprise.
    #[serde(skip_serializing_if="Option::is_none")]
    pub multi_repo: Option<bool>,
}

/// **Required when the `state` is `resolved`.** The reason for resolving the alert.
/// Enumeration of values.
/// Since this enum's variants do not hold data, we can easily define them them as `#[repr(C)]`
/// which helps with FFI.
#[allow(non_camel_case_types)]
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq, PartialOrd, Serialize, Deserialize, Eq, Ord)]
pub enum SecretScanningAlertResolution { 
    #[serde(rename = "false_positive")]
    FALSE_POSITIVE,
    #[serde(rename = "wont_fix")]
    WONT_FIX,
    #[serde(rename = "revoked")]
    REVOKED,
    #[serde(rename = "used_in_tests")]
    USED_IN_TESTS,
}

impl Display for SecretScanningAlertResolution {
    fn fmt(&self, f: &mut Formatter) -> fmt::Result {
        match *self { 
            SecretScanningAlertResolution::FALSE_POSITIVE => write!(f, "{}", "false_positive"),
            SecretScanningAlertResolution::WONT_FIX => write!(f, "{}", "wont_fix"),
            SecretScanningAlertResolution::REVOKED => write!(f, "{}", "revoked"),
            SecretScanningAlertResolution::USED_IN_TESTS => write!(f, "{}", "used_in_tests"),
        }
    }
}

impl std::str::FromStr for SecretScanningAlertResolution {
    type Err = ();
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s {
            "false_positive" => Ok(SecretScanningAlertResolution::FALSE_POSITIVE),
            "wont_fix" => Ok(SecretScanningAlertResolution::WONT_FIX),
            "revoked" => Ok(SecretScanningAlertResolution::REVOKED),
            "used_in_tests" => Ok(SecretScanningAlertResolution::USED_IN_TESTS),
            _ => Err(()),
        }
    }
}

/// An optional comment when closing an alert. Cannot be updated or deleted. Must be `null` when changing `state` to `open`.
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct SecretScanningAlertResolutionComment {
}

/// The reason for resolving the alert.
/// Enumeration of values.
/// Since this enum's variants do not hold data, we can easily define them them as `#[repr(C)]`
/// which helps with FFI.
#[allow(non_camel_case_types)]
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq, PartialOrd, Serialize, Deserialize, Eq, Ord)]
pub enum SecretScanningAlertResolutionWebhook { 
    #[serde(rename = "false_positive")]
    FALSE_POSITIVE,
    #[serde(rename = "wont_fix")]
    WONT_FIX,
    #[serde(rename = "revoked")]
    REVOKED,
    #[serde(rename = "used_in_tests")]
    USED_IN_TESTS,
    #[serde(rename = "pattern_deleted")]
    PATTERN_DELETED,
    #[serde(rename = "pattern_edited")]
    PATTERN_EDITED,
}

impl Display for SecretScanningAlertResolutionWebhook {
    fn fmt(&self, f: &mut Formatter) -> fmt::Result {
        match *self { 
            SecretScanningAlertResolutionWebhook::FALSE_POSITIVE => write!(f, "{}", "false_positive"),
            SecretScanningAlertResolutionWebhook::WONT_FIX => write!(f, "{}", "wont_fix"),
            SecretScanningAlertResolutionWebhook::REVOKED => write!(f, "{}", "revoked"),
            SecretScanningAlertResolutionWebhook::USED_IN_TESTS => write!(f, "{}", "used_in_tests"),
            SecretScanningAlertResolutionWebhook::PATTERN_DELETED => write!(f, "{}", "pattern_deleted"),
            SecretScanningAlertResolutionWebhook::PATTERN_EDITED => write!(f, "{}", "pattern_edited"),
        }
    }
}

impl std::str::FromStr for SecretScanningAlertResolutionWebhook {
    type Err = ();
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s {
            "false_positive" => Ok(SecretScanningAlertResolutionWebhook::FALSE_POSITIVE),
            "wont_fix" => Ok(SecretScanningAlertResolutionWebhook::WONT_FIX),
            "revoked" => Ok(SecretScanningAlertResolutionWebhook::REVOKED),
            "used_in_tests" => Ok(SecretScanningAlertResolutionWebhook::USED_IN_TESTS),
            "pattern_deleted" => Ok(SecretScanningAlertResolutionWebhook::PATTERN_DELETED),
            "pattern_edited" => Ok(SecretScanningAlertResolutionWebhook::PATTERN_EDITED),
            _ => Err(()),
        }
    }
}

/// Sets the state of the secret scanning alert. You must provide `resolution` when you set the state to `resolved`.
/// Enumeration of values.
/// Since this enum's variants do not hold data, we can easily define them them as `#[repr(C)]`
/// which helps with FFI.
#[allow(non_camel_case_types)]
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq, PartialOrd, Serialize, Deserialize, Eq, Ord)]
pub enum SecretScanningAlertState { 
    #[serde(rename = "open")]
    OPEN,
    #[serde(rename = "resolved")]
    RESOLVED,
}

impl Display for SecretScanningAlertState {
    fn fmt(&self, f: &mut Formatter) -> fmt::Result {
        match *self { 
            SecretScanningAlertState::OPEN => write!(f, "{}", "open"),
            SecretScanningAlertState::RESOLVED => write!(f, "{}", "resolved"),
        }
    }
}

impl std::str::FromStr for SecretScanningAlertState {
    type Err = ();
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s {
            "open" => Ok(SecretScanningAlertState::OPEN),
            "resolved" => Ok(SecretScanningAlertState::RESOLVED),
            _ => Err(()),
        }
    }
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct SecretScanningAlertWebhook {
    #[serde(skip_serializing_if="Option::is_none")]
    pub number: Option<AlertNumber>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub created_at: Option<AlertCreatedAt>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub updated_at: Option<NullableAlertUpdatedAt>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub url: Option<AlertUrl>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub html_url: Option<AlertHtmlUrl>,
    /// The REST API URL of the code locations for this alert.
    #[serde(skip_serializing_if="Option::is_none")]
    pub locations_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub resolution: Option<SecretScanningAlertResolutionWebhook>,
    /// The time that the alert was resolved in ISO 8601 format: `YYYY-MM-DDTHH:MM:SSZ`.
    #[serde(skip_serializing_if="Option::is_none")]
    pub resolved_at: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub resolved_by: Option<NullableSimpleUser>,
    /// An optional comment to resolve an alert.
    #[serde(skip_serializing_if="Option::is_none")]
    pub resolution_comment: Option<String>,
    /// The type of secret that secret scanning detected.
    #[serde(skip_serializing_if="Option::is_none")]
    pub secret_type: Option<String>,
    /// User-friendly name for the detected secret, matching the `secret_type`. For a list of built-in patterns, see \"[Supported secret scanning patterns](https://docs.github.com/code-security/secret-scanning/introduction/supported-secret-scanning-patterns#supported-secrets).\"
    #[serde(skip_serializing_if="Option::is_none")]
    pub secret_type_display_name: Option<String>,
    /// The token status as of the latest validity check.
    #[serde(skip_serializing_if="Option::is_none")]
    pub validity: Option<String>,
    /// Whether push protection was bypassed for the detected secret.
    #[serde(skip_serializing_if="Option::is_none")]
    pub push_protection_bypassed: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub push_protection_bypassed_by: Option<NullableSimpleUser>,
    /// The time that push protection was bypassed in ISO 8601 format: `YYYY-MM-DDTHH:MM:SSZ`.
    #[serde(skip_serializing_if="Option::is_none")]
    pub push_protection_bypassed_at: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub push_protection_bypass_request_reviewer: Option<NullableSimpleUser>,
    /// An optional comment when reviewing a push protection bypass.
    #[serde(skip_serializing_if="Option::is_none")]
    pub push_protection_bypass_request_reviewer_comment: Option<String>,
    /// An optional comment when requesting a push protection bypass.
    #[serde(skip_serializing_if="Option::is_none")]
    pub push_protection_bypass_request_comment: Option<String>,
    /// The URL to a push protection bypass request.
    #[serde(skip_serializing_if="Option::is_none")]
    pub push_protection_bypass_request_html_url: Option<String>,
    /// Whether the detected secret was publicly leaked.
    #[serde(skip_serializing_if="Option::is_none")]
    pub publicly_leaked: Option<bool>,
    /// Whether the detected secret was found in multiple repositories in the same organization or business.
    #[serde(skip_serializing_if="Option::is_none")]
    pub multi_repo: Option<bool>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct SecretScanningLocation {
    /// The location type. Because secrets may be found in different types of resources (ie. code, comments, issues, pull requests, discussions), this field identifies the type of resource where the secret was found.
    #[serde(rename = "type")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub _type: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub details: Option<OneOfsecretScanningLocationDetails>,
}

/// Represents a 'commit' secret scanning location type. This location type shows that a secret was detected inside a commit to a repository.
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct SecretScanningLocationCommit {
    /// The file path in the repository
    #[serde(skip_serializing_if="Option::is_none")]
    pub path: Option<String>,
    /// Line number at which the secret starts in the file
    #[serde(skip_serializing_if="Option::is_none")]
    pub start_line: Option<f64>,
    /// Line number at which the secret ends in the file
    #[serde(skip_serializing_if="Option::is_none")]
    pub end_line: Option<f64>,
    /// The column at which the secret starts within the start line when the file is interpreted as 8BIT ASCII
    #[serde(skip_serializing_if="Option::is_none")]
    pub start_column: Option<f64>,
    /// The column at which the secret ends within the end line when the file is interpreted as 8BIT ASCII
    #[serde(skip_serializing_if="Option::is_none")]
    pub end_column: Option<f64>,
    /// SHA-1 hash ID of the associated blob
    #[serde(skip_serializing_if="Option::is_none")]
    pub blob_sha: Option<String>,
    /// The API URL to get the associated blob resource
    #[serde(skip_serializing_if="Option::is_none")]
    pub blob_url: Option<String>,
    /// SHA-1 hash ID of the associated commit
    #[serde(skip_serializing_if="Option::is_none")]
    pub commit_sha: Option<String>,
    /// The API URL to get the associated commit resource
    #[serde(skip_serializing_if="Option::is_none")]
    pub commit_url: Option<String>,
}

/// Represents a 'discussion_body' secret scanning location type. This location type shows that a secret was detected in the body of a discussion.
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct SecretScanningLocationDiscussionBody {
    /// The URL to the discussion where the secret was detected.
    #[serde(skip_serializing_if="Option::is_none")]
    pub discussion_body_url: Option<String>,
}

/// Represents a 'discussion_comment' secret scanning location type. This location type shows that a secret was detected in a comment on a discussion.
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct SecretScanningLocationDiscussionComment {
    /// The API URL to get the discussion comment where the secret was detected.
    #[serde(skip_serializing_if="Option::is_none")]
    pub discussion_comment_url: Option<String>,
}

/// Represents a 'discussion_title' secret scanning location type. This location type shows that a secret was detected in the title of a discussion.
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct SecretScanningLocationDiscussionTitle {
    /// The URL to the discussion where the secret was detected.
    #[serde(skip_serializing_if="Option::is_none")]
    pub discussion_title_url: Option<String>,
}

/// Represents an 'issue_body' secret scanning location type. This location type shows that a secret was detected in the body of an issue.
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct SecretScanningLocationIssueBody {
    /// The API URL to get the issue where the secret was detected.
    #[serde(skip_serializing_if="Option::is_none")]
    pub issue_body_url: Option<String>,
}

/// Represents an 'issue_comment' secret scanning location type. This location type shows that a secret was detected in a comment on an issue.
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct SecretScanningLocationIssueComment {
    /// The API URL to get the issue comment where the secret was detected.
    #[serde(skip_serializing_if="Option::is_none")]
    pub issue_comment_url: Option<String>,
}

/// Represents an 'issue_title' secret scanning location type. This location type shows that a secret was detected in the title of an issue.
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct SecretScanningLocationIssueTitle {
    /// The API URL to get the issue where the secret was detected.
    #[serde(skip_serializing_if="Option::is_none")]
    pub issue_title_url: Option<String>,
}

/// Represents a 'pull_request_body' secret scanning location type. This location type shows that a secret was detected in the body of a pull request.
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct SecretScanningLocationPullRequestBody {
    /// The API URL to get the pull request where the secret was detected.
    #[serde(skip_serializing_if="Option::is_none")]
    pub pull_request_body_url: Option<String>,
}

/// Represents a 'pull_request_comment' secret scanning location type. This location type shows that a secret was detected in a comment on a pull request.
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct SecretScanningLocationPullRequestComment {
    /// The API URL to get the pull request comment where the secret was detected.
    #[serde(skip_serializing_if="Option::is_none")]
    pub pull_request_comment_url: Option<String>,
}

/// Represents a 'pull_request_review' secret scanning location type. This location type shows that a secret was detected in a review on a pull request.
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct SecretScanningLocationPullRequestReview {
    /// The API URL to get the pull request review where the secret was detected.
    #[serde(skip_serializing_if="Option::is_none")]
    pub pull_request_review_url: Option<String>,
}

/// Represents a 'pull_request_review_comment' secret scanning location type. This location type shows that a secret was detected in a review comment on a pull request.
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct SecretScanningLocationPullRequestReviewComment {
    /// The API URL to get the pull request review comment where the secret was detected.
    #[serde(skip_serializing_if="Option::is_none")]
    pub pull_request_review_comment_url: Option<String>,
}

/// Represents a 'pull_request_title' secret scanning location type. This location type shows that a secret was detected in the title of a pull request.
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct SecretScanningLocationPullRequestTitle {
    /// The API URL to get the pull request where the secret was detected.
    #[serde(skip_serializing_if="Option::is_none")]
    pub pull_request_title_url: Option<String>,
}

/// Represents a 'wiki_commit' secret scanning location type. This location type shows that a secret was detected inside a commit to a repository wiki.
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct SecretScanningLocationWikiCommit {
    /// The file path of the wiki page
    #[serde(skip_serializing_if="Option::is_none")]
    pub path: Option<String>,
    /// Line number at which the secret starts in the file
    #[serde(skip_serializing_if="Option::is_none")]
    pub start_line: Option<f64>,
    /// Line number at which the secret ends in the file
    #[serde(skip_serializing_if="Option::is_none")]
    pub end_line: Option<f64>,
    /// The column at which the secret starts within the start line when the file is interpreted as 8-bit ASCII.
    #[serde(skip_serializing_if="Option::is_none")]
    pub start_column: Option<f64>,
    /// The column at which the secret ends within the end line when the file is interpreted as 8-bit ASCII.
    #[serde(skip_serializing_if="Option::is_none")]
    pub end_column: Option<f64>,
    /// SHA-1 hash ID of the associated blob
    #[serde(skip_serializing_if="Option::is_none")]
    pub blob_sha: Option<String>,
    /// The GitHub URL to get the associated wiki page
    #[serde(skip_serializing_if="Option::is_none")]
    pub page_url: Option<String>,
    /// SHA-1 hash ID of the associated commit
    #[serde(skip_serializing_if="Option::is_none")]
    pub commit_sha: Option<String>,
    /// The GitHub URL to get the associated wiki commit
    #[serde(skip_serializing_if="Option::is_none")]
    pub commit_url: Option<String>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct SecretScanningPushProtectionBypass {
    #[serde(skip_serializing_if="Option::is_none")]
    pub reason: Option<SecretScanningPushProtectionBypassReason>,
    /// The time that the bypass will expire in ISO 8601 format: `YYYY-MM-DDTHH:MM:SSZ`.
    #[serde(skip_serializing_if="Option::is_none")]
    pub expire_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The token type this bypass is for.
    #[serde(skip_serializing_if="Option::is_none")]
    pub token_type: Option<String>,
}

/// The ID of the push protection bypass placeholder. This value is returned on any push protected routes.
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct SecretScanningPushProtectionBypassPlaceholderId {
}

/// The reason for bypassing push protection.
/// Enumeration of values.
/// Since this enum's variants do not hold data, we can easily define them them as `#[repr(C)]`
/// which helps with FFI.
#[allow(non_camel_case_types)]
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq, PartialOrd, Serialize, Deserialize, Eq, Ord)]
pub enum SecretScanningPushProtectionBypassReason { 
    #[serde(rename = "false_positive")]
    FALSE_POSITIVE,
    #[serde(rename = "used_in_tests")]
    USED_IN_TESTS,
    #[serde(rename = "will_fix_later")]
    WILL_FIX_LATER,
}

impl Display for SecretScanningPushProtectionBypassReason {
    fn fmt(&self, f: &mut Formatter) -> fmt::Result {
        match *self { 
            SecretScanningPushProtectionBypassReason::FALSE_POSITIVE => write!(f, "{}", "false_positive"),
            SecretScanningPushProtectionBypassReason::USED_IN_TESTS => write!(f, "{}", "used_in_tests"),
            SecretScanningPushProtectionBypassReason::WILL_FIX_LATER => write!(f, "{}", "will_fix_later"),
        }
    }
}

impl std::str::FromStr for SecretScanningPushProtectionBypassReason {
    type Err = ();
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s {
            "false_positive" => Ok(SecretScanningPushProtectionBypassReason::FALSE_POSITIVE),
            "used_in_tests" => Ok(SecretScanningPushProtectionBypassReason::USED_IN_TESTS),
            "will_fix_later" => Ok(SecretScanningPushProtectionBypassReason::WILL_FIX_LATER),
            _ => Err(()),
        }
    }
}

/// Information on a single scan performed by secret scanning on the repository
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct SecretScanningScan {
    /// The type of scan
    #[serde(rename = "type")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub _type: Option<String>,
    /// The state of the scan. Either \"completed\", \"running\", or \"pending\"
    #[serde(skip_serializing_if="Option::is_none")]
    pub status: Option<String>,
    /// The time that the scan was completed. Empty if the scan is running
    #[serde(skip_serializing_if="Option::is_none")]
    pub completed_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The time that the scan was started. Empty if the scan is pending
    #[serde(skip_serializing_if="Option::is_none")]
    pub started_at: Option<chrono::DateTime<chrono::Utc>>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct SecretScanningScanHistory {
    #[serde(skip_serializing_if="Option::is_none")]
    pub incremental_scans: Option<Vec<SecretScanningScan>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub pattern_update_scans: Option<Vec<SecretScanningScan>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub backfill_scans: Option<Vec<SecretScanningScan>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub custom_pattern_backfill_scans: Option<Vec<AllOfsecretScanningScanHistoryCustomPatternBackfillScansItems>>,
}

/// The type of credit the user is receiving.
/// Enumeration of values.
/// Since this enum's variants do not hold data, we can easily define them them as `#[repr(C)]`
/// which helps with FFI.
#[allow(non_camel_case_types)]
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq, PartialOrd, Serialize, Deserialize, Eq, Ord)]
pub enum SecurityAdvisoryCreditTypes { 
    #[serde(rename = "analyst")]
    ANALYST,
    #[serde(rename = "finder")]
    FINDER,
    #[serde(rename = "reporter")]
    REPORTER,
    #[serde(rename = "coordinator")]
    COORDINATOR,
    #[serde(rename = "remediation_developer")]
    REMEDIATION_DEVELOPER,
    #[serde(rename = "remediation_reviewer")]
    REMEDIATION_REVIEWER,
    #[serde(rename = "remediation_verifier")]
    REMEDIATION_VERIFIER,
    #[serde(rename = "tool")]
    TOOL,
    #[serde(rename = "sponsor")]
    SPONSOR,
    #[serde(rename = "other")]
    OTHER,
}

impl Display for SecurityAdvisoryCreditTypes {
    fn fmt(&self, f: &mut Formatter) -> fmt::Result {
        match *self { 
            SecurityAdvisoryCreditTypes::ANALYST => write!(f, "{}", "analyst"),
            SecurityAdvisoryCreditTypes::FINDER => write!(f, "{}", "finder"),
            SecurityAdvisoryCreditTypes::REPORTER => write!(f, "{}", "reporter"),
            SecurityAdvisoryCreditTypes::COORDINATOR => write!(f, "{}", "coordinator"),
            SecurityAdvisoryCreditTypes::REMEDIATION_DEVELOPER => write!(f, "{}", "remediation_developer"),
            SecurityAdvisoryCreditTypes::REMEDIATION_REVIEWER => write!(f, "{}", "remediation_reviewer"),
            SecurityAdvisoryCreditTypes::REMEDIATION_VERIFIER => write!(f, "{}", "remediation_verifier"),
            SecurityAdvisoryCreditTypes::TOOL => write!(f, "{}", "tool"),
            SecurityAdvisoryCreditTypes::SPONSOR => write!(f, "{}", "sponsor"),
            SecurityAdvisoryCreditTypes::OTHER => write!(f, "{}", "other"),
        }
    }
}

impl std::str::FromStr for SecurityAdvisoryCreditTypes {
    type Err = ();
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s {
            "analyst" => Ok(SecurityAdvisoryCreditTypes::ANALYST),
            "finder" => Ok(SecurityAdvisoryCreditTypes::FINDER),
            "reporter" => Ok(SecurityAdvisoryCreditTypes::REPORTER),
            "coordinator" => Ok(SecurityAdvisoryCreditTypes::COORDINATOR),
            "remediation_developer" => Ok(SecurityAdvisoryCreditTypes::REMEDIATION_DEVELOPER),
            "remediation_reviewer" => Ok(SecurityAdvisoryCreditTypes::REMEDIATION_REVIEWER),
            "remediation_verifier" => Ok(SecurityAdvisoryCreditTypes::REMEDIATION_VERIFIER),
            "tool" => Ok(SecurityAdvisoryCreditTypes::TOOL),
            "sponsor" => Ok(SecurityAdvisoryCreditTypes::SPONSOR),
            "other" => Ok(SecurityAdvisoryCreditTypes::OTHER),
            _ => Err(()),
        }
    }
}

/// The package's language or package management ecosystem.
/// Enumeration of values.
/// Since this enum's variants do not hold data, we can easily define them them as `#[repr(C)]`
/// which helps with FFI.
#[allow(non_camel_case_types)]
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq, PartialOrd, Serialize, Deserialize, Eq, Ord)]
pub enum SecurityAdvisoryEcosystems { 
    #[serde(rename = "rubygems")]
    RUBYGEMS,
    #[serde(rename = "npm")]
    NPM,
    #[serde(rename = "pip")]
    PIP,
    #[serde(rename = "maven")]
    MAVEN,
    #[serde(rename = "nuget")]
    NUGET,
    #[serde(rename = "composer")]
    COMPOSER,
    #[serde(rename = "go")]
    GO,
    #[serde(rename = "rust")]
    RUST,
    #[serde(rename = "erlang")]
    ERLANG,
    #[serde(rename = "actions")]
    ACTIONS,
    #[serde(rename = "pub")]
    PUB,
    #[serde(rename = "other")]
    OTHER,
    #[serde(rename = "swift")]
    SWIFT,
}

impl Display for SecurityAdvisoryEcosystems {
    fn fmt(&self, f: &mut Formatter) -> fmt::Result {
        match *self { 
            SecurityAdvisoryEcosystems::RUBYGEMS => write!(f, "{}", "rubygems"),
            SecurityAdvisoryEcosystems::NPM => write!(f, "{}", "npm"),
            SecurityAdvisoryEcosystems::PIP => write!(f, "{}", "pip"),
            SecurityAdvisoryEcosystems::MAVEN => write!(f, "{}", "maven"),
            SecurityAdvisoryEcosystems::NUGET => write!(f, "{}", "nuget"),
            SecurityAdvisoryEcosystems::COMPOSER => write!(f, "{}", "composer"),
            SecurityAdvisoryEcosystems::GO => write!(f, "{}", "go"),
            SecurityAdvisoryEcosystems::RUST => write!(f, "{}", "rust"),
            SecurityAdvisoryEcosystems::ERLANG => write!(f, "{}", "erlang"),
            SecurityAdvisoryEcosystems::ACTIONS => write!(f, "{}", "actions"),
            SecurityAdvisoryEcosystems::PUB => write!(f, "{}", "pub"),
            SecurityAdvisoryEcosystems::OTHER => write!(f, "{}", "other"),
            SecurityAdvisoryEcosystems::SWIFT => write!(f, "{}", "swift"),
        }
    }
}

impl std::str::FromStr for SecurityAdvisoryEcosystems {
    type Err = ();
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s {
            "rubygems" => Ok(SecurityAdvisoryEcosystems::RUBYGEMS),
            "npm" => Ok(SecurityAdvisoryEcosystems::NPM),
            "pip" => Ok(SecurityAdvisoryEcosystems::PIP),
            "maven" => Ok(SecurityAdvisoryEcosystems::MAVEN),
            "nuget" => Ok(SecurityAdvisoryEcosystems::NUGET),
            "composer" => Ok(SecurityAdvisoryEcosystems::COMPOSER),
            "go" => Ok(SecurityAdvisoryEcosystems::GO),
            "rust" => Ok(SecurityAdvisoryEcosystems::RUST),
            "erlang" => Ok(SecurityAdvisoryEcosystems::ERLANG),
            "actions" => Ok(SecurityAdvisoryEcosystems::ACTIONS),
            "pub" => Ok(SecurityAdvisoryEcosystems::PUB),
            "other" => Ok(SecurityAdvisoryEcosystems::OTHER),
            "swift" => Ok(SecurityAdvisoryEcosystems::SWIFT),
            _ => Err(()),
        }
    }
}

/// The EPSS scores as calculated by the [Exploit Prediction Scoring System](https://www.first.org/epss).
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct SecurityAdvisoryEpss {
    #[serde(skip_serializing_if="Option::is_none")]
    pub percentage: Option<f64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub percentile: Option<f64>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct SecurityAndAnalysis {
    #[serde(skip_serializing_if="Option::is_none")]
    pub advanced_security: Option<SecurityandanalysisAdvancedSecurity>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub dependabot_security_updates: Option<SecurityandanalysisDependabotSecurityUpdates>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub secret_scanning: Option<SecurityandanalysisAdvancedSecurity>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub secret_scanning_push_protection: Option<SecurityandanalysisAdvancedSecurity>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub secret_scanning_non_provider_patterns: Option<SecurityandanalysisAdvancedSecurity>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub secret_scanning_ai_detection: Option<SecurityandanalysisAdvancedSecurity>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct SecurityandanalysisAdvancedSecurity {
    #[serde(skip_serializing_if="Option::is_none")]
    pub status: Option<String>,
}

/// Enable or disable Dependabot security updates for the repository.
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct SecurityandanalysisDependabotSecurityUpdates {
    /// The enablement status of Dependabot security updates for the repository.
    #[serde(skip_serializing_if="Option::is_none")]
    pub status: Option<String>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct PutActionsSetAllowedActionsRepository {
    /// Whether GitHub-owned actions are allowed. For example, this includes the actions in the `actions` organization.
    #[serde(skip_serializing_if="Option::is_none")]
    pub github_owned_allowed: Option<bool>,
    /// Whether actions from GitHub Marketplace verified creators are allowed. Set to `true` to allow all actions by GitHub Marketplace verified creators.
    #[serde(skip_serializing_if="Option::is_none")]
    pub verified_allowed: Option<bool>,
    /// Specifies a list of string-matching patterns to allow specific action(s) and reusable workflow(s). Wildcards, tags, and SHAs are allowed. For example, `monalisa/octocat@*`, `monalisa/octocat@v2`, `monalisa/_*`.  > [!NOTE] > The `patterns_allowed` setting only applies to public repositories.
    #[serde(skip_serializing_if="Option::is_none")]
    pub patterns_allowed: Option<Vec<String>>,
}

/// The API URL to use to get or set the actions and reusable workflows that are allowed to run, when `allowed_actions` is set to `selected`.
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct SelectedActionsUrl {
}

/// Short Blob
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct ShortBlob {
    #[serde(skip_serializing_if="Option::is_none")]
    pub url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub sha: Option<String>,
}

/// Short Branch
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct ShortBranch {
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub commit: Option<ShortbranchCommit>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub protected: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub protection: Option<BranchProtection>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub protection_url: Option<String>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct ShortbranchCommit {
    #[serde(skip_serializing_if="Option::is_none")]
    pub sha: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub url: Option<String>,
}

/// Sigstore Bundle v0.1
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct SigstoreBundle0 {
    #[serde(rename = "mediaType")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub media_type: Option<String>,
    #[serde(rename = "verificationMaterial")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub verification_material: Option<Sigstorebundle0VerificationMaterial>,
    #[serde(rename = "dsseEnvelope")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub dsse_envelope: Option<Sigstorebundle0DsseEnvelope>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct Sigstorebundle0DsseEnvelope {
    #[serde(skip_serializing_if="Option::is_none")]
    pub payload: Option<String>,
    #[serde(rename = "payloadType")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub payload_type: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub signatures: Option<Vec<Sigstorebundle0DsseEnvelopeSignatures>>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct Sigstorebundle0DsseEnvelopeSignatures {
    #[serde(skip_serializing_if="Option::is_none")]
    pub sig: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub keyid: Option<String>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct Sigstorebundle0VerificationMaterial {
    #[serde(rename = "x509CertificateChain")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub x509_certificate_chain: Option<Sigstorebundle0VerificationMaterialX509CertificateChain>,
    #[serde(rename = "tlogEntries")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub tlog_entries: Option<Vec<Sigstorebundle0VerificationMaterialTlogEntries>>,
    #[serde(rename = "timestampVerificationData")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub timestamp_verification_data: Option<String>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct Sigstorebundle0VerificationMaterialInclusionPromise {
    #[serde(rename = "signedEntryTimestamp")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub signed_entry_timestamp: Option<String>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct Sigstorebundle0VerificationMaterialKindVersion {
    #[serde(skip_serializing_if="Option::is_none")]
    pub kind: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub version: Option<String>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct Sigstorebundle0VerificationMaterialLogId {
    #[serde(rename = "keyId")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub key_id: Option<String>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct Sigstorebundle0VerificationMaterialTlogEntries {
    #[serde(rename = "logIndex")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub log_index: Option<String>,
    #[serde(rename = "logId")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub log_id: Option<Sigstorebundle0VerificationMaterialLogId>,
    #[serde(rename = "kindVersion")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub kind_version: Option<Sigstorebundle0VerificationMaterialKindVersion>,
    #[serde(rename = "integratedTime")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub integrated_time: Option<String>,
    #[serde(rename = "inclusionPromise")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub inclusion_promise: Option<Sigstorebundle0VerificationMaterialInclusionPromise>,
    #[serde(rename = "inclusionProof")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub inclusion_proof: Option<String>,
    #[serde(rename = "canonicalizedBody")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub canonicalized_body: Option<String>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct Sigstorebundle0VerificationMaterialX509CertificateChain {
    #[serde(skip_serializing_if="Option::is_none")]
    pub certificates: Option<Vec<Sigstorebundle0VerificationMaterialX509CertificateChainCertificates>>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct Sigstorebundle0VerificationMaterialX509CertificateChainCertificates {
    #[serde(rename = "rawBytes")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub raw_bytes: Option<String>,
}

/// A suite of checks performed on the code of a given code change
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct SimpleCheckSuite {
    #[serde(skip_serializing_if="Option::is_none")]
    pub after: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub app: Option<Integration>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub before: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub conclusion: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub head_branch: Option<String>,
    /// The SHA of the head commit that is being checked.
    #[serde(skip_serializing_if="Option::is_none")]
    pub head_sha: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub node_id: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub pull_requests: Option<Vec<PullRequestMinimal>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub repository: Option<MinimalRepository>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub status: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub updated_at: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub url: Option<String>,
}

/// A GitHub Classroom classroom
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct SimpleClassroom {
    /// Unique identifier of the classroom.
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<i64>,
    /// The name of the classroom.
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,
    /// Returns whether classroom is archived or not.
    #[serde(skip_serializing_if="Option::is_none")]
    pub archived: Option<bool>,
    /// The url of the classroom on GitHub Classroom.
    #[serde(skip_serializing_if="Option::is_none")]
    pub url: Option<String>,
}

/// A GitHub Classroom assignment
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct SimpleClassroomAssignment {
    /// Unique identifier of the repository.
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<i64>,
    /// Whether an accepted assignment creates a public repository.
    #[serde(skip_serializing_if="Option::is_none")]
    pub public_repo: Option<bool>,
    /// Assignment title.
    #[serde(skip_serializing_if="Option::is_none")]
    pub title: Option<String>,
    /// Whether it's a Group Assignment or Individual Assignment.
    #[serde(rename = "type")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub _type: Option<String>,
    /// The link that a student can use to accept the assignment.
    #[serde(skip_serializing_if="Option::is_none")]
    pub invite_link: Option<String>,
    /// Whether the invitation link is enabled. Visiting an enabled invitation link will accept the assignment.
    #[serde(skip_serializing_if="Option::is_none")]
    pub invitations_enabled: Option<bool>,
    /// Sluggified name of the assignment.
    #[serde(skip_serializing_if="Option::is_none")]
    pub slug: Option<String>,
    /// Whether students are admins on created repository on accepted assignment.
    #[serde(skip_serializing_if="Option::is_none")]
    pub students_are_repo_admins: Option<bool>,
    /// Whether feedback pull request will be created on assignment acceptance.
    #[serde(skip_serializing_if="Option::is_none")]
    pub feedback_pull_requests_enabled: Option<bool>,
    /// The maximum allowable teams for the assignment.
    #[serde(skip_serializing_if="Option::is_none")]
    pub max_teams: Option<i64>,
    /// The maximum allowable members per team.
    #[serde(skip_serializing_if="Option::is_none")]
    pub max_members: Option<i64>,
    /// The selected editor for the assignment.
    #[serde(skip_serializing_if="Option::is_none")]
    pub editor: Option<String>,
    /// The number of students that have accepted the assignment.
    #[serde(skip_serializing_if="Option::is_none")]
    pub accepted: Option<i64>,
    /// The number of students that have submitted the assignment.
    #[serde(skip_serializing_if="Option::is_none")]
    pub submitted: Option<i64>,
    /// The number of students that have passed the assignment.
    #[serde(skip_serializing_if="Option::is_none")]
    pub passing: Option<i64>,
    /// The programming language used in the assignment.
    #[serde(skip_serializing_if="Option::is_none")]
    pub language: Option<String>,
    /// The time at which the assignment is due.
    #[serde(skip_serializing_if="Option::is_none")]
    pub deadline: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub classroom: Option<SimpleClassroom>,
}

/// A GitHub organization.
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct SimpleClassroomOrganization {
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub login: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub node_id: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub html_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub avatar_url: Option<String>,
}

/// A GitHub repository view for Classroom
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct SimpleClassroomRepository {
    /// A unique identifier of the repository.
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<i64>,
    /// The full, globally unique name of the repository.
    #[serde(skip_serializing_if="Option::is_none")]
    pub full_name: Option<String>,
    /// The URL to view the repository on GitHub.com.
    #[serde(skip_serializing_if="Option::is_none")]
    pub html_url: Option<String>,
    /// The GraphQL identifier of the repository.
    #[serde(skip_serializing_if="Option::is_none")]
    pub node_id: Option<String>,
    /// Whether the repository is private.
    #[serde(skip_serializing_if="Option::is_none")]
    pub private: Option<bool>,
    /// The default branch for the repository.
    #[serde(skip_serializing_if="Option::is_none")]
    pub default_branch: Option<String>,
}

/// A GitHub user simplified for Classroom.
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct SimpleClassroomUser {
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub login: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub avatar_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub html_url: Option<String>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct SimpleCommit {
    #[serde(skip_serializing_if="Option::is_none")]
    pub author: Option<Committer>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub committer: Option<Committer>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub message: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub timestamp: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub tree_id: Option<String>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct SimpleCommitStatus {
    #[serde(skip_serializing_if="Option::is_none")]
    pub description: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub node_id: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub state: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub context: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub target_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub required: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub avatar_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub updated_at: Option<chrono::DateTime<chrono::Utc>>,
}

/// The GitHub App installation. Webhook payloads contain the `installation` property when the event is configured for and sent to a GitHub App. For more information, see \"[Using webhooks with GitHub Apps](https://docs.github.com/apps/creating-github-apps/registering-a-github-app/using-webhooks-with-github-apps).\"
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct SimpleInstallation {
    /// The ID of the installation.
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<i64>,
    /// The global node ID of the installation.
    #[serde(skip_serializing_if="Option::is_none")]
    pub node_id: Option<String>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct SimplePullRequest {
    #[serde(skip_serializing_if="Option::is_none")]
    pub _links: Option<WebhooksPullRequest5Links>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub active_lock_reason: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub assignee: Option<User3>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub assignees: Option<Vec<User4>>,
    /// How the author is associated with the repository.
    #[serde(skip_serializing_if="Option::is_none")]
    pub author_association: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub auto_merge: Option<PullRequestAutoMerge>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub base: Option<PullRequestBase>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub body: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub closed_at: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub comments_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub commits_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub created_at: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub diff_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub draft: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub head: Option<PullRequestBase>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub html_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub issue_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub labels: Option<Vec<Label>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub locked: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub merge_commit_sha: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub merged_at: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub milestone: Option<Milestone1>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub node_id: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub number: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub patch_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub requested_reviewers: Option<Vec<OneOfSimplePullRequestRequestedReviewersItems>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub requested_teams: Option<Vec<Team>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub review_comment_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub review_comments_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub state: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub statuses_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub title: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub updated_at: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub user: Option<User2>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct SimplePullRequest1 {
    #[serde(skip_serializing_if="Option::is_none")]
    pub _links: Option<WebhooksPullRequest5Links>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub active_lock_reason: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub assignee: Option<User3>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub assignees: Option<Vec<User4>>,
    /// How the author is associated with the repository.
    #[serde(skip_serializing_if="Option::is_none")]
    pub author_association: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub auto_merge: Option<PullRequestAutoMerge>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub base: Option<SimplePullRequest1Base>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub body: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub closed_at: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub comments_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub commits_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub created_at: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub diff_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub draft: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub head: Option<SimplePullRequest1Base>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub html_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub issue_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub labels: Option<Vec<Label>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub locked: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub merge_commit_sha: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub merged_at: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub milestone: Option<Milestone>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub node_id: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub number: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub patch_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub requested_reviewers: Option<Vec<OneOfSimplePullRequest1RequestedReviewersItems>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub requested_teams: Option<Vec<Team>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub review_comment_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub review_comments_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub state: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub statuses_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub title: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub updated_at: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub user: Option<User2>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct SimplePullRequest1Base {
    #[serde(skip_serializing_if="Option::is_none")]
    pub label: Option<String>,
    #[serde(rename = "ref")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub git_ref: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub repo: Option<Repository7>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub sha: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub user: Option<User>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct SimplePullRequest2 {
    #[serde(skip_serializing_if="Option::is_none")]
    pub _links: Option<WebhooksPullRequest5Links>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub active_lock_reason: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub assignee: Option<User3>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub assignees: Option<Vec<User4>>,
    /// How the author is associated with the repository.
    #[serde(skip_serializing_if="Option::is_none")]
    pub author_association: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub auto_merge: Option<PullRequestAutoMerge>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub base: Option<PullRequestBase>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub body: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub closed_at: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub comments_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub commits_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub created_at: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub diff_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub draft: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub head: Option<PullRequestHead>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub html_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub issue_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub labels: Option<Vec<Label>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub locked: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub merge_commit_sha: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub merged_at: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub milestone: Option<Milestone>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub node_id: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub number: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub patch_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub requested_reviewers: Option<Vec<OneOfSimplePullRequest2RequestedReviewersItems>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub requested_teams: Option<Vec<Team>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub review_comment_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub review_comments_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub state: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub statuses_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub title: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub updated_at: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub user: Option<User2>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct SimplePullRequest3 {
    #[serde(skip_serializing_if="Option::is_none")]
    pub _links: Option<WebhooksPullRequest5Links>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub active_lock_reason: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub assignee: Option<User1>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub assignees: Option<Vec<User5>>,
    /// How the author is associated with the repository.
    #[serde(skip_serializing_if="Option::is_none")]
    pub author_association: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub auto_merge: Option<PullRequestAutoMerge>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub base: Option<SimplePullRequest3Base>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub body: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub closed_at: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub comments_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub commits_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub created_at: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub diff_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub draft: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub head: Option<SimplePullRequest3Head>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub html_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub issue_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub labels: Option<Vec<Label>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub locked: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub merge_commit_sha: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub merged_at: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub milestone: Option<Milestone1>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub node_id: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub number: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub patch_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub requested_reviewers: Option<Vec<OneOfSimplePullRequest3RequestedReviewersItems>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub requested_teams: Option<Vec<Team>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub review_comment_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub review_comments_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub state: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub statuses_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub title: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub updated_at: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub user: Option<User2>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct SimplePullRequest3Base {
    #[serde(skip_serializing_if="Option::is_none")]
    pub label: Option<String>,
    #[serde(rename = "ref")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub git_ref: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub repo: Option<Repository9>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub sha: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub user: Option<User>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct SimplePullRequest3Head {
    #[serde(skip_serializing_if="Option::is_none")]
    pub label: Option<String>,
    #[serde(rename = "ref")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub git_ref: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub repo: Option<Repository9>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub sha: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub user: Option<User>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct SimplePullRequest4 {
    #[serde(skip_serializing_if="Option::is_none")]
    pub _links: Option<WebhooksPullRequest5Links>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub active_lock_reason: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub assignee: Option<User1>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub assignees: Option<Vec<User5>>,
    /// How the author is associated with the repository.
    #[serde(skip_serializing_if="Option::is_none")]
    pub author_association: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub auto_merge: Option<PullRequestAutoMerge1>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub base: Option<SimplePullRequest3Base>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub body: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub closed_at: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub comments_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub commits_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub created_at: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub diff_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub draft: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub head: Option<SimplePullRequest3Base>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub html_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub issue_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub labels: Option<Vec<Label>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub locked: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub merge_commit_sha: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub merged_at: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub milestone: Option<Milestone1>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub node_id: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub number: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub patch_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub requested_reviewers: Option<Vec<OneOfSimplePullRequest4RequestedReviewersItems>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub requested_teams: Option<Vec<Team>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub review_comment_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub review_comments_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub state: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub statuses_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub title: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub updated_at: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub user: Option<User>,
}

/// A GitHub repository.
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct SimpleRepository {
    /// A unique identifier of the repository.
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<i64>,
    /// The GraphQL identifier of the repository.
    #[serde(skip_serializing_if="Option::is_none")]
    pub node_id: Option<String>,
    /// The name of the repository.
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,
    /// The full, globally unique, name of the repository.
    #[serde(skip_serializing_if="Option::is_none")]
    pub full_name: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub owner: Option<SimpleUser>,
    /// Whether the repository is private.
    #[serde(skip_serializing_if="Option::is_none")]
    pub private: Option<bool>,
    /// The URL to view the repository on GitHub.com.
    #[serde(skip_serializing_if="Option::is_none")]
    pub html_url: Option<String>,
    /// The repository description.
    #[serde(skip_serializing_if="Option::is_none")]
    pub description: Option<String>,
    /// Whether the repository is a fork.
    #[serde(skip_serializing_if="Option::is_none")]
    pub fork: Option<bool>,
    /// The URL to get more information about the repository from the GitHub API.
    #[serde(skip_serializing_if="Option::is_none")]
    pub url: Option<String>,
    /// A template for the API URL to download the repository as an archive.
    #[serde(skip_serializing_if="Option::is_none")]
    pub archive_url: Option<String>,
    /// A template for the API URL to list the available assignees for issues in the repository.
    #[serde(skip_serializing_if="Option::is_none")]
    pub assignees_url: Option<String>,
    /// A template for the API URL to create or retrieve a raw Git blob in the repository.
    #[serde(skip_serializing_if="Option::is_none")]
    pub blobs_url: Option<String>,
    /// A template for the API URL to get information about branches in the repository.
    #[serde(skip_serializing_if="Option::is_none")]
    pub branches_url: Option<String>,
    /// A template for the API URL to get information about collaborators of the repository.
    #[serde(skip_serializing_if="Option::is_none")]
    pub collaborators_url: Option<String>,
    /// A template for the API URL to get information about comments on the repository.
    #[serde(skip_serializing_if="Option::is_none")]
    pub comments_url: Option<String>,
    /// A template for the API URL to get information about commits on the repository.
    #[serde(skip_serializing_if="Option::is_none")]
    pub commits_url: Option<String>,
    /// A template for the API URL to compare two commits or refs.
    #[serde(skip_serializing_if="Option::is_none")]
    pub compare_url: Option<String>,
    /// A template for the API URL to get the contents of the repository.
    #[serde(skip_serializing_if="Option::is_none")]
    pub contents_url: Option<String>,
    /// A template for the API URL to list the contributors to the repository.
    #[serde(skip_serializing_if="Option::is_none")]
    pub contributors_url: Option<String>,
    /// The API URL to list the deployments of the repository.
    #[serde(skip_serializing_if="Option::is_none")]
    pub deployments_url: Option<String>,
    /// The API URL to list the downloads on the repository.
    #[serde(skip_serializing_if="Option::is_none")]
    pub downloads_url: Option<String>,
    /// The API URL to list the events of the repository.
    #[serde(skip_serializing_if="Option::is_none")]
    pub events_url: Option<String>,
    /// The API URL to list the forks of the repository.
    #[serde(skip_serializing_if="Option::is_none")]
    pub forks_url: Option<String>,
    /// A template for the API URL to get information about Git commits of the repository.
    #[serde(skip_serializing_if="Option::is_none")]
    pub git_commits_url: Option<String>,
    /// A template for the API URL to get information about Git refs of the repository.
    #[serde(skip_serializing_if="Option::is_none")]
    pub git_refs_url: Option<String>,
    /// A template for the API URL to get information about Git tags of the repository.
    #[serde(skip_serializing_if="Option::is_none")]
    pub git_tags_url: Option<String>,
    /// A template for the API URL to get information about issue comments on the repository.
    #[serde(skip_serializing_if="Option::is_none")]
    pub issue_comment_url: Option<String>,
    /// A template for the API URL to get information about issue events on the repository.
    #[serde(skip_serializing_if="Option::is_none")]
    pub issue_events_url: Option<String>,
    /// A template for the API URL to get information about issues on the repository.
    #[serde(skip_serializing_if="Option::is_none")]
    pub issues_url: Option<String>,
    /// A template for the API URL to get information about deploy keys on the repository.
    #[serde(skip_serializing_if="Option::is_none")]
    pub keys_url: Option<String>,
    /// A template for the API URL to get information about labels of the repository.
    #[serde(skip_serializing_if="Option::is_none")]
    pub labels_url: Option<String>,
    /// The API URL to get information about the languages of the repository.
    #[serde(skip_serializing_if="Option::is_none")]
    pub languages_url: Option<String>,
    /// The API URL to merge branches in the repository.
    #[serde(skip_serializing_if="Option::is_none")]
    pub merges_url: Option<String>,
    /// A template for the API URL to get information about milestones of the repository.
    #[serde(skip_serializing_if="Option::is_none")]
    pub milestones_url: Option<String>,
    /// A template for the API URL to get information about notifications on the repository.
    #[serde(skip_serializing_if="Option::is_none")]
    pub notifications_url: Option<String>,
    /// A template for the API URL to get information about pull requests on the repository.
    #[serde(skip_serializing_if="Option::is_none")]
    pub pulls_url: Option<String>,
    /// A template for the API URL to get information about releases on the repository.
    #[serde(skip_serializing_if="Option::is_none")]
    pub releases_url: Option<String>,
    /// The API URL to list the stargazers on the repository.
    #[serde(skip_serializing_if="Option::is_none")]
    pub stargazers_url: Option<String>,
    /// A template for the API URL to get information about statuses of a commit.
    #[serde(skip_serializing_if="Option::is_none")]
    pub statuses_url: Option<String>,
    /// The API URL to list the subscribers on the repository.
    #[serde(skip_serializing_if="Option::is_none")]
    pub subscribers_url: Option<String>,
    /// The API URL to subscribe to notifications for this repository.
    #[serde(skip_serializing_if="Option::is_none")]
    pub subscription_url: Option<String>,
    /// The API URL to get information about tags on the repository.
    #[serde(skip_serializing_if="Option::is_none")]
    pub tags_url: Option<String>,
    /// The API URL to list the teams on the repository.
    #[serde(skip_serializing_if="Option::is_none")]
    pub teams_url: Option<String>,
    /// A template for the API URL to create or retrieve a raw Git tree of the repository.
    #[serde(skip_serializing_if="Option::is_none")]
    pub trees_url: Option<String>,
    /// The API URL to list the hooks on the repository.
    #[serde(skip_serializing_if="Option::is_none")]
    pub hooks_url: Option<String>,
}

/// A GitHub user.
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct SimpleUser {
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub email: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub login: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub node_id: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub avatar_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub gravatar_id: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub html_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub followers_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub following_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub gists_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub starred_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub subscriptions_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub organizations_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub repos_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub events_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub received_events_url: Option<String>,
    #[serde(rename = "type")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub _type: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub site_admin: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub starred_at: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub user_view_type: Option<String>,
}

/// Create a new snapshot of a repository's dependencies.
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct PostDependencyGraphCreateRepositorySnapshot {
    /// The version of the repository snapshot submission.
    #[serde(skip_serializing_if="Option::is_none")]
    pub version: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub job: Option<SnapshotJob>,
    /// The commit SHA associated with this dependency snapshot. Maximum length: 40 characters.
    #[serde(skip_serializing_if="Option::is_none")]
    pub sha: Option<String>,
    /// The repository branch that triggered this snapshot.
    #[serde(rename = "ref")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub git_ref: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub detector: Option<SnapshotDetector>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub metadata: Option<Metadata>,
    /// A collection of package manifests, which are a collection of related dependencies declared in a file or representing a logical group of dependencies.
    #[serde(skip_serializing_if="Option::is_none")]
    pub manifests: Option<HashMap<String, Manifest>>,
    /// The time at which the snapshot was scanned.
    #[serde(skip_serializing_if="Option::is_none")]
    pub scanned: Option<chrono::DateTime<chrono::Utc>>,
}

/// A description of the detector used.
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct SnapshotDetector {
    /// The name of the detector used.
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,
    /// The version of the detector used.
    #[serde(skip_serializing_if="Option::is_none")]
    pub version: Option<String>,
    /// The url of the detector used.
    #[serde(skip_serializing_if="Option::is_none")]
    pub url: Option<String>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct SnapshotJob {
    /// The external ID of the job.
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<String>,
    /// Correlator provides a key that is used to group snapshots submitted over time. Only the \"latest\" submitted snapshot for a given combination of `job.correlator` and `detector.name` will be considered when calculating a repository's current dependencies. Correlator should be as unique as it takes to distinguish all detection runs for a given \"wave\" of CI workflow you run. If you're using GitHub Actions, a good default value for this could be the environment variables GITHUB_WORKFLOW and GITHUB_JOB concatenated together. If you're using a build matrix, then you'll also need to add additional key(s) to distinguish between each submission inside a matrix variation.
    #[serde(skip_serializing_if="Option::is_none")]
    pub correlator: Option<String>,
    /// The url for the job.
    #[serde(skip_serializing_if="Option::is_none")]
    pub html_url: Option<String>,
}

/// Social media account
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct SocialAccount {
    #[serde(skip_serializing_if="Option::is_none")]
    pub provider: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub url: Option<String>,
}

/// The `tier_changed` and `pending_tier_change` will include the original tier before the change or pending change. For more information, see the pending tier change payload.
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct SponsorshipTier {
    #[serde(skip_serializing_if="Option::is_none")]
    pub created_at: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub description: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub is_custom_ammount: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub is_custom_amount: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub is_one_time: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub monthly_price_in_cents: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub monthly_price_in_dollars: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub node_id: Option<String>,
}

/// A public SSH key used to sign Git commits
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct SshSigningKey {
    #[serde(skip_serializing_if="Option::is_none")]
    pub key: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub title: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
}

/// Stargazer
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct Stargazer {
    #[serde(skip_serializing_if="Option::is_none")]
    pub starred_at: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub user: Option<NullableSimpleUser>,
}

/// Starred Repository
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct StarredRepository {
    #[serde(skip_serializing_if="Option::is_none")]
    pub starred_at: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub repo: Option<Repository>,
}

/// State Change Issue Event
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct StateChangeIssueEvent {
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub node_id: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub actor: Option<SimpleUser>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub event: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub commit_id: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub commit_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub created_at: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub performed_via_github_app: Option<NullableIntegration>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub state_reason: Option<String>,
}

/// Provides details of static public IP limits for GitHub-hosted Hosted Runners
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct StaticPublicIpLimitsForGitHubhostedHostedRunners_ {
    /// The maximum number of static public IP addresses that can be used for Hosted Runners.
    #[serde(skip_serializing_if="Option::is_none")]
    pub maximum: Option<i64>,
    /// The current number of static public IP addresses in use by Hosted Runners.
    #[serde(skip_serializing_if="Option::is_none")]
    pub current_usage: Option<i64>,
}

/// The status of a commit.
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct Status {
    #[serde(skip_serializing_if="Option::is_none")]
    pub url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub avatar_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub node_id: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub state: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub description: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub target_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub context: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub created_at: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub updated_at: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub creator: Option<NullableSimpleUser>,
}

/// Status Check Policy
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct StatusCheckPolicy {
    #[serde(skip_serializing_if="Option::is_none")]
    pub url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub strict: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub contexts: Option<Vec<String>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub checks: Option<Vec<StatuscheckpolicyChecks>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub contexts_url: Option<String>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct StatuscheckpolicyChecks {
    #[serde(skip_serializing_if="Option::is_none")]
    pub context: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub app_id: Option<i64>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct SubIssuesSummary {
    #[serde(skip_serializing_if="Option::is_none")]
    pub total: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub completed: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub percent_completed: Option<i64>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct SubissuesSummary {
    #[serde(skip_serializing_if="Option::is_none")]
    pub total: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub completed: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub percent_completed: Option<i64>,
}

/// Tag
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct Tag {
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub commit: Option<ShortbranchCommit>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub zipball_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub tarball_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub node_id: Option<String>,
}

/// Tag protection
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct TagProtection {
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub created_at: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub updated_at: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub enabled: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub pattern: Option<String>,
}

/// Groups of organization members that gives permissions on specified repositories.
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct Team {
    #[serde(skip_serializing_if="Option::is_none")]
    pub deleted: Option<bool>,
    /// Description of the team
    #[serde(skip_serializing_if="Option::is_none")]
    pub description: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub html_url: Option<String>,
    /// Unique identifier of the team
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub members_url: Option<String>,
    /// Name of the team
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub node_id: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub parent: Option<WebhooksPullRequest5Parent>,
    /// Permission that the team will have for its repositories
    #[serde(skip_serializing_if="Option::is_none")]
    pub permission: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub privacy: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub repositories_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub slug: Option<String>,
    /// URL for the team
    #[serde(skip_serializing_if="Option::is_none")]
    pub url: Option<String>,
}

/// Groups of organization members that gives permissions on specified repositories.
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct Team1 {
    #[serde(skip_serializing_if="Option::is_none")]
    pub deleted: Option<bool>,
    /// Description of the team
    #[serde(skip_serializing_if="Option::is_none")]
    pub description: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub html_url: Option<String>,
    /// Unique identifier of the team
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub members_url: Option<String>,
    /// Name of the team
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub node_id: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub parent: Option<WebhooksPullRequest5Parent>,
    /// Permission that the team will have for its repositories
    #[serde(skip_serializing_if="Option::is_none")]
    pub permission: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub privacy: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub repositories_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub slug: Option<String>,
    /// URL for the team
    #[serde(skip_serializing_if="Option::is_none")]
    pub url: Option<String>,
}

/// A team discussion is a persistent record of a free-form conversation within a team.
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct TeamDiscussion {
    #[serde(skip_serializing_if="Option::is_none")]
    pub author: Option<NullableSimpleUser>,
    /// The main text of the discussion.
    #[serde(skip_serializing_if="Option::is_none")]
    pub body: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub body_html: Option<String>,
    /// The current version of the body content. If provided, this update operation will be rejected if the given version does not match the latest version on the server.
    #[serde(skip_serializing_if="Option::is_none")]
    pub body_version: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub comments_count: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub comments_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub last_edited_at: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub html_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub node_id: Option<String>,
    /// The unique sequence number of a team discussion.
    #[serde(skip_serializing_if="Option::is_none")]
    pub number: Option<i64>,
    /// Whether or not this discussion should be pinned for easy retrieval.
    #[serde(skip_serializing_if="Option::is_none")]
    pub pinned: Option<bool>,
    /// Whether or not this discussion should be restricted to team members and organization owners.
    #[serde(skip_serializing_if="Option::is_none")]
    pub private: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub team_url: Option<String>,
    /// The title of the discussion.
    #[serde(skip_serializing_if="Option::is_none")]
    pub title: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub updated_at: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub reactions: Option<ReactionRollup>,
}

/// A reply to a discussion within a team.
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct TeamDiscussionComment {
    #[serde(skip_serializing_if="Option::is_none")]
    pub author: Option<NullableSimpleUser>,
    /// The main text of the comment.
    #[serde(skip_serializing_if="Option::is_none")]
    pub body: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub body_html: Option<String>,
    /// The current version of the body content. If provided, this update operation will be rejected if the given version does not match the latest version on the server.
    #[serde(skip_serializing_if="Option::is_none")]
    pub body_version: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub last_edited_at: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub discussion_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub html_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub node_id: Option<String>,
    /// The unique sequence number of a team discussion comment.
    #[serde(skip_serializing_if="Option::is_none")]
    pub number: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub updated_at: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub reactions: Option<ReactionRollup>,
}

/// Groups of organization members that gives permissions on specified repositories.
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct TeamFull {
    /// Unique identifier of the team
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub node_id: Option<String>,
    /// URL for the team
    #[serde(skip_serializing_if="Option::is_none")]
    pub url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub html_url: Option<String>,
    /// Name of the team
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub slug: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub description: Option<String>,
    /// The level of privacy this team should have
    #[serde(skip_serializing_if="Option::is_none")]
    pub privacy: Option<String>,
    /// The notification setting the team has set
    #[serde(skip_serializing_if="Option::is_none")]
    pub notification_setting: Option<String>,
    /// Permission that the team will have for its repositories
    #[serde(skip_serializing_if="Option::is_none")]
    pub permission: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub members_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub repositories_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub parent: Option<NullableTeamSimple>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub members_count: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub repos_count: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub updated_at: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub organization: Option<TeamOrganization>,
    /// Distinguished Name (DN) that team maps to within LDAP environment
    #[serde(skip_serializing_if="Option::is_none")]
    pub ldap_dn: Option<String>,
}

/// Team Membership
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct TeamMembership {
    #[serde(skip_serializing_if="Option::is_none")]
    pub url: Option<String>,
    /// The role of the user in the team.
    #[serde(skip_serializing_if="Option::is_none")]
    pub role: Option<String>,
    /// The state of the user's membership in the team.
    #[serde(skip_serializing_if="Option::is_none")]
    pub state: Option<String>,
}

/// Team Organization
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct TeamOrganization {
    #[serde(skip_serializing_if="Option::is_none")]
    pub login: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub node_id: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub repos_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub events_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub hooks_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub issues_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub members_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub public_members_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub avatar_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub description: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub company: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub blog: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub location: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub email: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub twitter_username: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub is_verified: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub has_organization_projects: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub has_repository_projects: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub public_repos: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub public_gists: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub followers: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub following: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub html_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(rename = "type")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub _type: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub total_private_repos: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub owned_private_repos: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub private_gists: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub disk_usage: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub collaborators: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub billing_email: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub plan: Option<OrganizationfullPlan>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub default_repository_permission: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub members_can_create_repositories: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub two_factor_requirement_enabled: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub members_allowed_repository_creation_type: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub members_can_create_public_repositories: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub members_can_create_private_repositories: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub members_can_create_internal_repositories: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub members_can_create_pages: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub members_can_create_public_pages: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub members_can_create_private_pages: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub members_can_fork_private_repositories: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub web_commit_signoff_required: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub updated_at: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub archived_at: Option<chrono::DateTime<chrono::Utc>>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct TeamPermissions {
    #[serde(skip_serializing_if="Option::is_none")]
    pub pull: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub triage: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub push: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub maintain: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub admin: Option<bool>,
}

/// A team's access to a project.
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct TeamProject {
    #[serde(skip_serializing_if="Option::is_none")]
    pub owner_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub html_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub columns_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub node_id: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub body: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub number: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub state: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub creator: Option<SimpleUser>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub created_at: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub updated_at: Option<String>,
    /// The organization permission for this project. Only present when owner is an organization.
    #[serde(skip_serializing_if="Option::is_none")]
    pub organization_permission: Option<String>,
    /// Whether the project is private or not. Only present when owner is an organization.
    #[serde(skip_serializing_if="Option::is_none")]
    pub private: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub permissions: Option<TeamprojectPermissions>,
}

/// A team's access to a repository.
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct TeamRepository {
    /// Unique identifier of the repository
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub node_id: Option<String>,
    /// The name of the repository.
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub full_name: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub license: Option<NullableLicenseSimple>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub forks: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub permissions: Option<RepositoryPermissions>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub role_name: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub owner: Option<NullableSimpleUser>,
    /// Whether the repository is private or public.
    #[serde(skip_serializing_if="Option::is_none")]
    pub private: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub html_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub description: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub fork: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub archive_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub assignees_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub blobs_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub branches_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub collaborators_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub comments_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub commits_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub compare_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub contents_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub contributors_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub deployments_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub downloads_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub events_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub forks_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub git_commits_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub git_refs_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub git_tags_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub git_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub issue_comment_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub issue_events_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub issues_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub keys_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub labels_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub languages_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub merges_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub milestones_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub notifications_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub pulls_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub releases_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub ssh_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub stargazers_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub statuses_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub subscribers_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub subscription_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub tags_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub teams_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub trees_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub clone_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub mirror_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub hooks_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub svn_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub homepage: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub language: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub forks_count: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub stargazers_count: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub watchers_count: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub size: Option<i64>,
    /// The default branch of the repository.
    #[serde(skip_serializing_if="Option::is_none")]
    pub default_branch: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub open_issues_count: Option<i64>,
    /// Whether this repository acts as a template that can be used to generate new repositories.
    #[serde(skip_serializing_if="Option::is_none")]
    pub is_template: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub topics: Option<Vec<String>>,
    /// Whether issues are enabled.
    #[serde(skip_serializing_if="Option::is_none")]
    pub has_issues: Option<bool>,
    /// Whether projects are enabled.
    #[serde(skip_serializing_if="Option::is_none")]
    pub has_projects: Option<bool>,
    /// Whether the wiki is enabled.
    #[serde(skip_serializing_if="Option::is_none")]
    pub has_wiki: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub has_pages: Option<bool>,
    /// Whether downloads are enabled.
    #[serde(skip_serializing_if="Option::is_none")]
    pub has_downloads: Option<bool>,
    /// Whether the repository is archived.
    #[serde(skip_serializing_if="Option::is_none")]
    pub archived: Option<bool>,
    /// Returns whether or not this repository disabled.
    #[serde(skip_serializing_if="Option::is_none")]
    pub disabled: Option<bool>,
    /// The repository visibility: public, private, or internal.
    #[serde(skip_serializing_if="Option::is_none")]
    pub visibility: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub pushed_at: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub updated_at: Option<chrono::DateTime<chrono::Utc>>,
    /// Whether to allow rebase merges for pull requests.
    #[serde(skip_serializing_if="Option::is_none")]
    pub allow_rebase_merge: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub temp_clone_token: Option<String>,
    /// Whether to allow squash merges for pull requests.
    #[serde(skip_serializing_if="Option::is_none")]
    pub allow_squash_merge: Option<bool>,
    /// Whether to allow Auto-merge to be used on pull requests.
    #[serde(skip_serializing_if="Option::is_none")]
    pub allow_auto_merge: Option<bool>,
    /// Whether to delete head branches when pull requests are merged
    #[serde(skip_serializing_if="Option::is_none")]
    pub delete_branch_on_merge: Option<bool>,
    /// Whether to allow merge commits for pull requests.
    #[serde(skip_serializing_if="Option::is_none")]
    pub allow_merge_commit: Option<bool>,
    /// Whether to allow forking this repo
    #[serde(skip_serializing_if="Option::is_none")]
    pub allow_forking: Option<bool>,
    /// Whether to require contributors to sign off on web-based commits
    #[serde(skip_serializing_if="Option::is_none")]
    pub web_commit_signoff_required: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub subscribers_count: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub network_count: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub open_issues: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub watchers: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub master_branch: Option<String>,
}

/// The Relationship a Team has with a role.
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct TeamRoleAssignment {
    /// Determines if the team has a direct, indirect, or mixed relationship to a role
    #[serde(skip_serializing_if="Option::is_none")]
    pub assignment: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub node_id: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub slug: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub description: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub privacy: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub notification_setting: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub permission: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub permissions: Option<TeamPermissions>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub html_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub members_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub repositories_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub parent: Option<NullableTeamSimple>,
}

/// Groups of organization members that gives permissions on specified repositories.
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct TeamSimple {
    /// Unique identifier of the team
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub node_id: Option<String>,
    /// URL for the team
    #[serde(skip_serializing_if="Option::is_none")]
    pub url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub members_url: Option<String>,
    /// Name of the team
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,
    /// Description of the team
    #[serde(skip_serializing_if="Option::is_none")]
    pub description: Option<String>,
    /// Permission that the team will have for its repositories
    #[serde(skip_serializing_if="Option::is_none")]
    pub permission: Option<String>,
    /// The level of privacy this team should have
    #[serde(skip_serializing_if="Option::is_none")]
    pub privacy: Option<String>,
    /// The notification setting the team has set
    #[serde(skip_serializing_if="Option::is_none")]
    pub notification_setting: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub html_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub repositories_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub slug: Option<String>,
    /// Distinguished Name (DN) that team maps to within LDAP environment
    #[serde(skip_serializing_if="Option::is_none")]
    pub ldap_dn: Option<String>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct TeamprojectPermissions {
    #[serde(skip_serializing_if="Option::is_none")]
    pub read: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub write: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub admin: Option<bool>,
}

/// Thread
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct Thread {
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub repository: Option<MinimalRepository>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub subject: Option<ThreadSubject>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub reason: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub unread: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub updated_at: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub last_read_at: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub subscription_url: Option<String>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct ThreadSubject {
    #[serde(skip_serializing_if="Option::is_none")]
    pub title: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub latest_comment_url: Option<String>,
    #[serde(rename = "type")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub _type: Option<String>,
}

/// Thread Subscription
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct ThreadSubscription {
    #[serde(skip_serializing_if="Option::is_none")]
    pub subscribed: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub ignored: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub reason: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub thread_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub repository_url: Option<String>,
}

/// Timeline Assigned Issue Event
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct TimelineAssignedIssueEvent {
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub node_id: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub actor: Option<SimpleUser>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub event: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub commit_id: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub commit_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub created_at: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub performed_via_github_app: Option<NullableIntegration>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub assignee: Option<SimpleUser>,
}

/// Timeline Comment Event
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct TimelineCommentEvent {
    #[serde(skip_serializing_if="Option::is_none")]
    pub event: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub actor: Option<SimpleUser>,
    /// Unique identifier of the issue comment
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub node_id: Option<String>,
    /// URL for the issue comment
    #[serde(skip_serializing_if="Option::is_none")]
    pub url: Option<String>,
    /// Contents of the issue comment
    #[serde(skip_serializing_if="Option::is_none")]
    pub body: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub body_text: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub body_html: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub html_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub user: Option<SimpleUser>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub updated_at: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub issue_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub author_association: Option<AuthorAssociation>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub performed_via_github_app: Option<NullableIntegration>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub reactions: Option<ReactionRollup>,
}

/// Timeline Commit Commented Event
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct TimelineCommitCommentedEvent {
    #[serde(skip_serializing_if="Option::is_none")]
    pub event: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub node_id: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub commit_id: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub comments: Option<Vec<CommitComment>>,
}

/// Timeline Committed Event
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct TimelineCommittedEvent {
    #[serde(skip_serializing_if="Option::is_none")]
    pub event: Option<String>,
    /// SHA for the commit
    #[serde(skip_serializing_if="Option::is_none")]
    pub sha: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub node_id: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub author: Option<GitcommitAuthor>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub committer: Option<GitcommitAuthor>,
    /// Message describing the purpose of the commit
    #[serde(skip_serializing_if="Option::is_none")]
    pub message: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub tree: Option<GitcommitTree>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub parents: Option<Vec<GitcommitParents>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub verification: Option<GitcommitVerification>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub html_url: Option<String>,
}

/// Timeline Cross Referenced Event
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct TimelineCrossReferencedEvent {
    #[serde(skip_serializing_if="Option::is_none")]
    pub event: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub actor: Option<SimpleUser>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub updated_at: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub source: Option<TimelinecrossreferencedeventSource>,
}

/// Timeline Event
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TimelineIssueEvents { 
    TimelineIssueEventsVariant0(LabeledIssueEvent),
    TimelineIssueEventsVariant1(UnlabeledIssueEvent),
    TimelineIssueEventsVariant2(MilestonedIssueEvent),
    TimelineIssueEventsVariant3(DemilestonedIssueEvent),
    TimelineIssueEventsVariant4(RenamedIssueEvent),
    TimelineIssueEventsVariant5(ReviewRequestedIssueEvent),
    TimelineIssueEventsVariant6(ReviewRequestRemovedIssueEvent),
    TimelineIssueEventsVariant7(ReviewDismissedIssueEvent),
    TimelineIssueEventsVariant8(LockedIssueEvent),
    TimelineIssueEventsVariant9(AddedToProjectIssueEvent),
    TimelineIssueEventsVariant10(MovedColumnInProjectIssueEvent),
    TimelineIssueEventsVariant11(RemovedFromProjectIssueEvent),
    TimelineIssueEventsVariant12(ConvertedNoteToIssueIssueEvent),
    TimelineIssueEventsVariant13(TimelineCommentEvent),
    TimelineIssueEventsVariant14(TimelineCrossReferencedEvent),
    TimelineIssueEventsVariant15(TimelineCommittedEvent),
    TimelineIssueEventsVariant16(TimelineReviewedEvent),
    TimelineIssueEventsVariant17(TimelineLineCommentedEvent),
    TimelineIssueEventsVariant18(TimelineCommitCommentedEvent),
    TimelineIssueEventsVariant19(TimelineAssignedIssueEvent),
    TimelineIssueEventsVariant20(TimelineUnassignedIssueEvent),
    TimelineIssueEventsVariant21(StateChangeIssueEvent),
}

impl From<LabeledIssueEvent> for TimelineIssueEvents {
    fn from(value: LabeledIssueEvent) -> Self {
        TimelineIssueEvents::TimelineIssueEventsVariant0(value)
    }
}

impl From<UnlabeledIssueEvent> for TimelineIssueEvents {
    fn from(value: UnlabeledIssueEvent) -> Self {
        TimelineIssueEvents::TimelineIssueEventsVariant1(value)
    }
}

impl From<MilestonedIssueEvent> for TimelineIssueEvents {
    fn from(value: MilestonedIssueEvent) -> Self {
        TimelineIssueEvents::TimelineIssueEventsVariant2(value)
    }
}

impl From<DemilestonedIssueEvent> for TimelineIssueEvents {
    fn from(value: DemilestonedIssueEvent) -> Self {
        TimelineIssueEvents::TimelineIssueEventsVariant3(value)
    }
}

impl From<RenamedIssueEvent> for TimelineIssueEvents {
    fn from(value: RenamedIssueEvent) -> Self {
        TimelineIssueEvents::TimelineIssueEventsVariant4(value)
    }
}

impl From<ReviewRequestedIssueEvent> for TimelineIssueEvents {
    fn from(value: ReviewRequestedIssueEvent) -> Self {
        TimelineIssueEvents::TimelineIssueEventsVariant5(value)
    }
}

impl From<ReviewRequestRemovedIssueEvent> for TimelineIssueEvents {
    fn from(value: ReviewRequestRemovedIssueEvent) -> Self {
        TimelineIssueEvents::TimelineIssueEventsVariant6(value)
    }
}

impl From<ReviewDismissedIssueEvent> for TimelineIssueEvents {
    fn from(value: ReviewDismissedIssueEvent) -> Self {
        TimelineIssueEvents::TimelineIssueEventsVariant7(value)
    }
}

impl From<LockedIssueEvent> for TimelineIssueEvents {
    fn from(value: LockedIssueEvent) -> Self {
        TimelineIssueEvents::TimelineIssueEventsVariant8(value)
    }
}

impl From<AddedToProjectIssueEvent> for TimelineIssueEvents {
    fn from(value: AddedToProjectIssueEvent) -> Self {
        TimelineIssueEvents::TimelineIssueEventsVariant9(value)
    }
}

impl From<MovedColumnInProjectIssueEvent> for TimelineIssueEvents {
    fn from(value: MovedColumnInProjectIssueEvent) -> Self {
        TimelineIssueEvents::TimelineIssueEventsVariant10(value)
    }
}

impl From<RemovedFromProjectIssueEvent> for TimelineIssueEvents {
    fn from(value: RemovedFromProjectIssueEvent) -> Self {
        TimelineIssueEvents::TimelineIssueEventsVariant11(value)
    }
}

impl From<ConvertedNoteToIssueIssueEvent> for TimelineIssueEvents {
    fn from(value: ConvertedNoteToIssueIssueEvent) -> Self {
        TimelineIssueEvents::TimelineIssueEventsVariant12(value)
    }
}

impl From<TimelineCommentEvent> for TimelineIssueEvents {
    fn from(value: TimelineCommentEvent) -> Self {
        TimelineIssueEvents::TimelineIssueEventsVariant13(value)
    }
}

impl From<TimelineCrossReferencedEvent> for TimelineIssueEvents {
    fn from(value: TimelineCrossReferencedEvent) -> Self {
        TimelineIssueEvents::TimelineIssueEventsVariant14(value)
    }
}

impl From<TimelineCommittedEvent> for TimelineIssueEvents {
    fn from(value: TimelineCommittedEvent) -> Self {
        TimelineIssueEvents::TimelineIssueEventsVariant15(value)
    }
}

impl From<TimelineReviewedEvent> for TimelineIssueEvents {
    fn from(value: TimelineReviewedEvent) -> Self {
        TimelineIssueEvents::TimelineIssueEventsVariant16(value)
    }
}

impl From<TimelineLineCommentedEvent> for TimelineIssueEvents {
    fn from(value: TimelineLineCommentedEvent) -> Self {
        TimelineIssueEvents::TimelineIssueEventsVariant17(value)
    }
}

impl From<TimelineCommitCommentedEvent> for TimelineIssueEvents {
    fn from(value: TimelineCommitCommentedEvent) -> Self {
        TimelineIssueEvents::TimelineIssueEventsVariant18(value)
    }
}

impl From<TimelineAssignedIssueEvent> for TimelineIssueEvents {
    fn from(value: TimelineAssignedIssueEvent) -> Self {
        TimelineIssueEvents::TimelineIssueEventsVariant19(value)
    }
}

impl From<TimelineUnassignedIssueEvent> for TimelineIssueEvents {
    fn from(value: TimelineUnassignedIssueEvent) -> Self {
        TimelineIssueEvents::TimelineIssueEventsVariant20(value)
    }
}

impl From<StateChangeIssueEvent> for TimelineIssueEvents {
    fn from(value: StateChangeIssueEvent) -> Self {
        TimelineIssueEvents::TimelineIssueEventsVariant21(value)
    }
}

/// Timeline Line Commented Event
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct TimelineLineCommentedEvent {
    #[serde(skip_serializing_if="Option::is_none")]
    pub event: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub node_id: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub comments: Option<Vec<PullRequestReviewComment>>,
}

/// Timeline Reviewed Event
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct TimelineReviewedEvent {
    #[serde(skip_serializing_if="Option::is_none")]
    pub event: Option<String>,
    /// Unique identifier of the review
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub node_id: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub user: Option<SimpleUser>,
    /// The text of the review.
    #[serde(skip_serializing_if="Option::is_none")]
    pub body: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub state: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub html_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub pull_request_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub _links: Option<TimelinereviewedeventLinks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub submitted_at: Option<chrono::DateTime<chrono::Utc>>,
    /// A commit SHA for the review.
    #[serde(skip_serializing_if="Option::is_none")]
    pub commit_id: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub body_html: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub body_text: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub author_association: Option<AuthorAssociation>,
}

/// Timeline Unassigned Issue Event
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct TimelineUnassignedIssueEvent {
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub node_id: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub actor: Option<SimpleUser>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub event: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub commit_id: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub commit_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub created_at: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub performed_via_github_app: Option<NullableIntegration>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub assignee: Option<SimpleUser>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct TimelinecrossreferencedeventSource {
    #[serde(rename = "type")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub _type: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub issue: Option<Issue>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct TimelinereviewedeventLinks {
    #[serde(skip_serializing_if="Option::is_none")]
    pub html: Option<TimelinereviewedeventLinksHtml>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub pull_request: Option<TimelinereviewedeventLinksHtml>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct TimelinereviewedeventLinksHtml {
    #[serde(skip_serializing_if="Option::is_none")]
    pub href: Option<String>,
}

/// A topic aggregates entities that are related to a subject.
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct Topic {
    #[serde(skip_serializing_if="Option::is_none")]
    pub names: Option<Vec<String>>,
}

/// Topic Search Result Item
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct TopicSearchResultItem {
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub display_name: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub short_description: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub description: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub created_by: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub released: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub updated_at: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub featured: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub curated: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub score: Option<f64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub repository_count: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub logo_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub text_matches: Option<SearchResultTextMatches>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub related: Option<Vec<TopicsearchresultitemRelated>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub aliases: Option<Vec<TopicsearchresultitemRelated>>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct TopicsearchresultitemRelated {
    #[serde(skip_serializing_if="Option::is_none")]
    pub topic_relation: Option<TopicsearchresultitemTopicRelation>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct TopicsearchresultitemTopicRelation {
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub topic_id: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub relation_type: Option<String>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct Traffic {
    #[serde(skip_serializing_if="Option::is_none")]
    pub timestamp: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub uniques: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub count: Option<i64>,
}

/// Unassigned Issue Event
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct UnassignedIssueEvent {
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub node_id: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub actor: Option<SimpleUser>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub event: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub commit_id: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub commit_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub created_at: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub performed_via_github_app: Option<NullableIntegration>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub assignee: Option<SimpleUser>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub assigner: Option<SimpleUser>,
}

/// Unlabeled Issue Event
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct UnlabeledIssueEvent {
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub node_id: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub actor: Option<SimpleUser>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub event: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub commit_id: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub commit_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub created_at: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub performed_via_github_app: Option<NullableIntegration>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub label: Option<LabeledissueeventLabel>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct User {
    #[serde(skip_serializing_if="Option::is_none")]
    pub avatar_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub deleted: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub email: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub events_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub followers_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub following_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub gists_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub gravatar_id: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub html_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub login: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub node_id: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub organizations_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub received_events_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub repos_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub site_admin: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub starred_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub subscriptions_url: Option<String>,
    #[serde(rename = "type")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub _type: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub user_view_type: Option<String>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct User1 {
    #[serde(skip_serializing_if="Option::is_none")]
    pub avatar_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub deleted: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub email: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub events_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub followers_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub following_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub gists_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub gravatar_id: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub html_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub login: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub node_id: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub organizations_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub received_events_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub repos_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub site_admin: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub starred_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub subscriptions_url: Option<String>,
    #[serde(rename = "type")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub _type: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub user_view_type: Option<String>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct User2 {
    #[serde(skip_serializing_if="Option::is_none")]
    pub avatar_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub deleted: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub email: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub events_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub followers_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub following_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub gists_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub gravatar_id: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub html_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub login: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub node_id: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub organizations_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub received_events_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub repos_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub site_admin: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub starred_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub subscriptions_url: Option<String>,
    #[serde(rename = "type")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub _type: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub user_view_type: Option<String>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct User3 {
    #[serde(skip_serializing_if="Option::is_none")]
    pub avatar_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub deleted: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub email: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub events_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub followers_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub following_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub gists_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub gravatar_id: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub html_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub login: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub node_id: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub organizations_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub received_events_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub repos_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub site_admin: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub starred_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub subscriptions_url: Option<String>,
    #[serde(rename = "type")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub _type: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub user_view_type: Option<String>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct User4 {
    #[serde(skip_serializing_if="Option::is_none")]
    pub avatar_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub deleted: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub email: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub events_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub followers_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub following_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub gists_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub gravatar_id: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub html_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub login: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub node_id: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub organizations_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub received_events_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub repos_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub site_admin: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub starred_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub subscriptions_url: Option<String>,
    #[serde(rename = "type")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub _type: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub url: Option<String>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct User5 {
    #[serde(skip_serializing_if="Option::is_none")]
    pub avatar_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub deleted: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub email: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub events_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub followers_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub following_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub gists_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub gravatar_id: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub html_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub login: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub node_id: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub organizations_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub received_events_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub repos_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub site_admin: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub starred_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub subscriptions_url: Option<String>,
    #[serde(rename = "type")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub _type: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub url: Option<String>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct User6 {
    #[serde(skip_serializing_if="Option::is_none")]
    pub avatar_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub deleted: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub email: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub events_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub followers_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub following_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub gists_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub gravatar_id: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub html_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub login: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub node_id: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub organizations_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub received_events_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub repos_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub site_admin: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub starred_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub subscriptions_url: Option<String>,
    #[serde(rename = "type")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub _type: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub user_view_type: Option<String>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct User7 {
    #[serde(skip_serializing_if="Option::is_none")]
    pub avatar_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub deleted: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub email: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub events_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub followers_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub following_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub gists_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub gravatar_id: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub html_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub login: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub node_id: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub organizations_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub received_events_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub repos_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub site_admin: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub starred_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub subscriptions_url: Option<String>,
    #[serde(rename = "type")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub _type: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub user_view_type: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub url: Option<String>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct User8 {
    #[serde(skip_serializing_if="Option::is_none")]
    pub avatar_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub deleted: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub email: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub events_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub followers_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub following_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub gists_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub gravatar_id: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub html_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub login: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub node_id: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub organizations_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub received_events_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub repos_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub site_admin: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub starred_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub subscriptions_url: Option<String>,
    #[serde(rename = "type")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub _type: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub url: Option<String>,
}

/// User Marketplace Purchase
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct UserMarketplacePurchase {
    #[serde(skip_serializing_if="Option::is_none")]
    pub billing_cycle: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub next_billing_date: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub unit_count: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub on_free_trial: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub free_trial_ends_on: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub updated_at: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub account: Option<MarketplaceAccount>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub plan: Option<MarketplaceListingPlan>,
}

/// The Relationship a User has with a role.
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct UserRoleAssignment {
    /// Determines if the user has a direct, indirect, or mixed relationship to a role
    #[serde(skip_serializing_if="Option::is_none")]
    pub assignment: Option<String>,
    /// Team the user has gotten the role through
    #[serde(skip_serializing_if="Option::is_none")]
    pub inherited_from: Option<Vec<TeamSimple>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub email: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub login: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub node_id: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub avatar_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub gravatar_id: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub html_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub followers_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub following_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub gists_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub starred_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub subscriptions_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub organizations_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub repos_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub events_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub received_events_url: Option<String>,
    #[serde(rename = "type")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub _type: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub site_admin: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub starred_at: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub user_view_type: Option<String>,
}

/// User Search Result Item
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct UserSearchResultItem {
    #[serde(skip_serializing_if="Option::is_none")]
    pub login: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub node_id: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub avatar_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub gravatar_id: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub html_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub followers_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub subscriptions_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub organizations_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub repos_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub received_events_url: Option<String>,
    #[serde(rename = "type")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub _type: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub score: Option<f64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub following_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub gists_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub starred_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub events_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub public_repos: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub public_gists: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub followers: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub following: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub updated_at: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub bio: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub email: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub location: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub site_admin: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub hireable: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub text_matches: Option<SearchResultTextMatches>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub blog: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub company: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub suspended_at: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub user_view_type: Option<String>,
}

/// Pull request number for this codespace
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct UsercodespacesPullRequest {
    /// Pull request number
    #[serde(skip_serializing_if="Option::is_none")]
    pub pull_request_number: Option<i64>,
    /// Repository id for this codespace
    #[serde(skip_serializing_if="Option::is_none")]
    pub repository_id: Option<i64>,
}

/// Validation Error
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct ValidationError {
    #[serde(skip_serializing_if="Option::is_none")]
    pub message: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub documentation_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub errors: Option<Vec<ValidationerrorErrors>>,
}

/// Validation Error Simple
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct ValidationErrorSimple {
    #[serde(skip_serializing_if="Option::is_none")]
    pub message: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub documentation_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub errors: Option<Vec<String>>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct ValidationerrorErrors {
    #[serde(skip_serializing_if="Option::is_none")]
    pub resource: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub field: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub message: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub code: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub index: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub value: Option<OneOfvalidationerrorErrorsValue>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct Verification {
    #[serde(skip_serializing_if="Option::is_none")]
    pub verified: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub reason: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub payload: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub signature: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub verified_at: Option<String>,
}

/// View Traffic
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct ViewTraffic {
    #[serde(skip_serializing_if="Option::is_none")]
    pub count: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub uniques: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub views: Option<Vec<Traffic>>,
}

/// A vulnerability describing the product and its affected versions within a GitHub Security Advisory.
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct Vulnerability {
    #[serde(skip_serializing_if="Option::is_none")]
    pub package: Option<VulnerabilityPackage>,
    /// The range of the package versions affected by the vulnerability.
    #[serde(skip_serializing_if="Option::is_none")]
    pub vulnerable_version_range: Option<String>,
    /// The package version that resolves the vulnerability.
    #[serde(skip_serializing_if="Option::is_none")]
    pub first_patched_version: Option<String>,
    /// The functions in the package that are affected by the vulnerability.
    #[serde(skip_serializing_if="Option::is_none")]
    pub vulnerable_functions: Option<Vec<String>>,
}

/// The name of the package affected by the vulnerability.
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct VulnerabilityPackage {
    #[serde(skip_serializing_if="Option::is_none")]
    pub ecosystem: Option<SecurityAdvisoryEcosystems>,
    /// The unique package name within its ecosystem.
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,
}

/// The amount of time to delay a job after the job is initially triggered. The time (in minutes) must be an integer between 0 and 43,200 (30 days).
pub type WaitTimer = i32;

/// The webhook that is being pinged
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct Webhook {
    /// Determines whether the hook is actually triggered for the events it subscribes to.
    #[serde(skip_serializing_if="Option::is_none")]
    pub active: Option<bool>,
    /// Only included for GitHub Apps. When you register a new GitHub App, GitHub sends a ping event to the webhook URL you specified during registration. The GitHub App ID sent in this field is required for authenticating an app.
    #[serde(skip_serializing_if="Option::is_none")]
    pub app_id: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub config: Option<WebhookConfig>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub deliveries_url: Option<String>,
    /// Determines what events the hook is triggered for. Default: ['push'].
    #[serde(skip_serializing_if="Option::is_none")]
    pub events: Option<Vec<String>>,
    /// Unique identifier of the webhook.
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub last_response: Option<HookResponse>,
    /// The type of webhook. The only valid value is 'web'.
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub ping_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub test_url: Option<String>,
    #[serde(rename = "type")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub _type: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub updated_at: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub url: Option<String>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhookBranchProtectionConfigurationDisabled {
    #[serde(skip_serializing_if="Option::is_none")]
    pub action: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub enterprise: Option<EnterpriseWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub organization: Option<OrganizationSimpleWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub repository: Option<RepositoryWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub sender: Option<SimpleUser>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhookBranchProtectionConfigurationEnabled {
    #[serde(skip_serializing_if="Option::is_none")]
    pub action: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub enterprise: Option<EnterpriseWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub organization: Option<OrganizationSimpleWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub repository: Option<RepositoryWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub sender: Option<SimpleUser>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhookBranchProtectionRuleCreated {
    #[serde(skip_serializing_if="Option::is_none")]
    pub action: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub enterprise: Option<EnterpriseWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub organization: Option<OrganizationSimpleWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub repository: Option<RepositoryWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub rule: Option<WebhooksRule>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub sender: Option<SimpleUser>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhookBranchProtectionRuleDeleted {
    #[serde(skip_serializing_if="Option::is_none")]
    pub action: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub enterprise: Option<EnterpriseWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub organization: Option<OrganizationSimpleWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub repository: Option<RepositoryWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub rule: Option<WebhooksRule>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub sender: Option<SimpleUser>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhookBranchProtectionRuleEdited {
    #[serde(skip_serializing_if="Option::is_none")]
    pub action: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub changes: Option<WebhookbranchprotectionruleeditedChanges>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub enterprise: Option<EnterpriseWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub organization: Option<OrganizationSimpleWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub repository: Option<RepositoryWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub rule: Option<WebhooksRule>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub sender: Option<SimpleUser>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhookCheckRunCompleted {
    #[serde(skip_serializing_if="Option::is_none")]
    pub action: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub check_run: Option<CheckRunWithSimpleCheckSuite>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub organization: Option<OrganizationSimpleWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub repository: Option<RepositoryWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub sender: Option<SimpleUser>,
}

/// The check_run.completed webhook encoded with URL encoding
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhookCheckRunCompletedFormEncoded {
    /// A URL-encoded string of the check_run.completed JSON payload. The decoded payload is a JSON object.
    #[serde(skip_serializing_if="Option::is_none")]
    pub payload: Option<String>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhookCheckRunCreated {
    #[serde(skip_serializing_if="Option::is_none")]
    pub action: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub check_run: Option<CheckRunWithSimpleCheckSuite>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub organization: Option<OrganizationSimpleWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub repository: Option<RepositoryWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub sender: Option<SimpleUser>,
}

/// The check_run.created webhook encoded with URL encoding
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhookCheckRunCreatedFormEncoded {
    /// A URL-encoded string of the check_run.created JSON payload. The decoded payload is a JSON object.
    #[serde(skip_serializing_if="Option::is_none")]
    pub payload: Option<String>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhookCheckRunRequestedAction {
    #[serde(skip_serializing_if="Option::is_none")]
    pub action: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub check_run: Option<CheckRunWithSimpleCheckSuite>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub organization: Option<OrganizationSimpleWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub repository: Option<RepositoryWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub requested_action: Option<WebhookcheckrunrequestedactionRequestedAction>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub sender: Option<SimpleUser>,
}

/// The check_run.requested_action webhook encoded with URL encoding
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhookCheckRunRequestedActionFormEncoded {
    /// A URL-encoded string of the check_run.requested_action JSON payload. The decoded payload is a JSON object.
    #[serde(skip_serializing_if="Option::is_none")]
    pub payload: Option<String>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhookCheckRunRerequested {
    #[serde(skip_serializing_if="Option::is_none")]
    pub action: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub check_run: Option<CheckRunWithSimpleCheckSuite>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub organization: Option<OrganizationSimpleWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub repository: Option<RepositoryWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub sender: Option<SimpleUser>,
}

/// The check_run.rerequested webhook encoded with URL encoding
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhookCheckRunRerequestedFormEncoded {
    /// A URL-encoded string of the check_run.rerequested JSON payload. The decoded payload is a JSON object.
    #[serde(skip_serializing_if="Option::is_none")]
    pub payload: Option<String>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhookCheckSuiteCompleted {
    #[serde(skip_serializing_if="Option::is_none")]
    pub action: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub check_suite: Option<WebhookchecksuitecompletedCheckSuite>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub enterprise: Option<EnterpriseWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub organization: Option<OrganizationSimpleWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub repository: Option<RepositoryWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub sender: Option<SimpleUser>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhookCheckSuiteRequested {
    #[serde(skip_serializing_if="Option::is_none")]
    pub action: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub check_suite: Option<WebhookchecksuiterequestedCheckSuite>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub enterprise: Option<EnterpriseWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub organization: Option<OrganizationSimpleWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub repository: Option<RepositoryWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub sender: Option<SimpleUser>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhookCheckSuiteRerequested {
    #[serde(skip_serializing_if="Option::is_none")]
    pub action: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub check_suite: Option<WebhookchecksuitererequestedCheckSuite>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub enterprise: Option<EnterpriseWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub organization: Option<OrganizationSimpleWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub repository: Option<RepositoryWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub sender: Option<SimpleUser>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhookCodeScanningAlertAppearedInBranch {
    #[serde(skip_serializing_if="Option::is_none")]
    pub action: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub alert: Option<WebhookcodescanningalertappearedinbranchAlert>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub commit_oid: Option<WebhooksCodeScanningCommitOid>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub enterprise: Option<EnterpriseWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub organization: Option<OrganizationSimpleWebhooks>,
    #[serde(rename = "ref")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub git_ref: Option<WebhooksCodeScanningRef>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub repository: Option<RepositoryWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub sender: Option<SimpleUser>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhookCodeScanningAlertClosedByUser {
    #[serde(skip_serializing_if="Option::is_none")]
    pub action: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub alert: Option<WebhookcodescanningalertclosedbyuserAlert>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub commit_oid: Option<WebhooksCodeScanningCommitOid>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub enterprise: Option<EnterpriseWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub organization: Option<OrganizationSimpleWebhooks>,
    #[serde(rename = "ref")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub git_ref: Option<WebhooksCodeScanningRef>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub repository: Option<RepositoryWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub sender: Option<SimpleUser>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhookCodeScanningAlertCreated {
    #[serde(skip_serializing_if="Option::is_none")]
    pub action: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub alert: Option<WebhookcodescanningalertcreatedAlert>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub commit_oid: Option<WebhooksCodeScanningCommitOid>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub enterprise: Option<EnterpriseWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub organization: Option<OrganizationSimpleWebhooks>,
    #[serde(rename = "ref")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub git_ref: Option<WebhooksCodeScanningRef>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub repository: Option<RepositoryWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub sender: Option<SimpleUser>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhookCodeScanningAlertFixed {
    #[serde(skip_serializing_if="Option::is_none")]
    pub action: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub alert: Option<WebhookcodescanningalertfixedAlert>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub commit_oid: Option<WebhooksCodeScanningCommitOid>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub enterprise: Option<EnterpriseWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub organization: Option<OrganizationSimpleWebhooks>,
    #[serde(rename = "ref")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub git_ref: Option<WebhooksCodeScanningRef>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub repository: Option<RepositoryWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub sender: Option<SimpleUser>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhookCodeScanningAlertReopened {
    #[serde(skip_serializing_if="Option::is_none")]
    pub action: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub alert: Option<WebhookcodescanningalertreopenedAlert>,
    /// The commit SHA of the code scanning alert. When the action is `reopened_by_user` or `closed_by_user`, the event was triggered by the `sender` and this value will be empty.
    #[serde(skip_serializing_if="Option::is_none")]
    pub commit_oid: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub enterprise: Option<EnterpriseWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub organization: Option<OrganizationSimpleWebhooks>,
    /// The Git reference of the code scanning alert. When the action is `reopened_by_user` or `closed_by_user`, the event was triggered by the `sender` and this value will be empty.
    #[serde(rename = "ref")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub git_ref: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub repository: Option<RepositoryWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub sender: Option<SimpleUser>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhookCodeScanningAlertReopenedByUser {
    #[serde(skip_serializing_if="Option::is_none")]
    pub action: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub alert: Option<WebhookcodescanningalertreopenedbyuserAlert>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub commit_oid: Option<WebhooksCodeScanningCommitOid>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub enterprise: Option<EnterpriseWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub organization: Option<OrganizationSimpleWebhooks>,
    #[serde(rename = "ref")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub git_ref: Option<WebhooksCodeScanningRef>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub repository: Option<RepositoryWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub sender: Option<SimpleUser>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhookCommitCommentCreated {
    /// The action performed. Can be `created`.
    #[serde(skip_serializing_if="Option::is_none")]
    pub action: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub comment: Option<WebhookcommitcommentcreatedComment>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub enterprise: Option<EnterpriseWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub organization: Option<OrganizationSimpleWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub repository: Option<RepositoryWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub sender: Option<SimpleUser>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhookConfig {
    #[serde(skip_serializing_if="Option::is_none")]
    pub content_type: Option<WebhookConfigContentType>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub insecure_ssl: Option<WebhookConfigInsecureSsl>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub secret: Option<WebhookConfigSecret>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub url: Option<WebhookConfigUrl>,
}

/// The media type used to serialize the payloads. Supported values include `json` and `form`. The default is `form`.
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhookConfigContentType {
}

#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
#[serde(untagged)]
pub enum WebhookConfigInsecureSsl { 
    WebhookConfigInsecureSslVariant0(String),
    WebhookConfigInsecureSslVariant1(f64),
}

impl From<String> for WebhookConfigInsecureSsl {
    fn from(value: String) -> Self {
        WebhookConfigInsecureSsl::WebhookConfigInsecureSslVariant0(value)
    }
}

impl From<f64> for WebhookConfigInsecureSsl {
    fn from(value: f64) -> Self {
        WebhookConfigInsecureSsl::WebhookConfigInsecureSslVariant1(value)
    }
}

impl Display for WebhookConfigInsecureSsl {
    fn fmt(&self, f: &mut Formatter) -> fmt::Result {
        match self { 
            WebhookConfigInsecureSsl::WebhookConfigInsecureSslVariant0(value) => write!(f, "{}", value),
            WebhookConfigInsecureSsl::WebhookConfigInsecureSslVariant1(value) => write!(f, "{}", value),
        }
    }
}

/// If provided, the `secret` will be used as the `key` to generate the HMAC hex digest value for [delivery signature headers](https://docs.github.com/webhooks/event-payloads/#delivery-headers).
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhookConfigSecret {
}

/// The URL to which the payloads will be delivered.
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhookConfigUrl {
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhookCreate {
    /// The repository's current description.
    #[serde(skip_serializing_if="Option::is_none")]
    pub description: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub enterprise: Option<EnterpriseWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    /// The name of the repository's default branch (usually `main`).
    #[serde(skip_serializing_if="Option::is_none")]
    pub master_branch: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub organization: Option<OrganizationSimpleWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub pusher_type: Option<WebhooksDeployPusherType>,
    #[serde(rename = "ref")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub git_ref: Option<WebhooksRef0>,
    /// The type of Git ref object created in the repository.
    #[serde(skip_serializing_if="Option::is_none")]
    pub ref_type: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub repository: Option<RepositoryWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub sender: Option<SimpleUser>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhookCustomPropertyCreated {
    #[serde(skip_serializing_if="Option::is_none")]
    pub action: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub definition: Option<CustomProperty>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub enterprise: Option<EnterpriseWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub organization: Option<OrganizationSimpleWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub sender: Option<SimpleUser>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhookCustomPropertyDeleted {
    #[serde(skip_serializing_if="Option::is_none")]
    pub action: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub definition: Option<WebhookcustompropertydeletedDefinition>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub enterprise: Option<EnterpriseWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub organization: Option<OrganizationSimpleWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub sender: Option<SimpleUser>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhookCustomPropertyUpdated {
    #[serde(skip_serializing_if="Option::is_none")]
    pub action: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub definition: Option<CustomProperty>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub enterprise: Option<EnterpriseWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub organization: Option<OrganizationSimpleWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub sender: Option<SimpleUser>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhookCustomPropertyValuesUpdated {
    #[serde(skip_serializing_if="Option::is_none")]
    pub action: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub enterprise: Option<EnterpriseWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub repository: Option<RepositoryWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub organization: Option<OrganizationSimpleWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub sender: Option<SimpleUser>,
    /// The new custom property values for the repository.
    #[serde(skip_serializing_if="Option::is_none")]
    pub new_property_values: Option<Vec<CustomPropertyValue>>,
    /// The old custom property values for the repository.
    #[serde(skip_serializing_if="Option::is_none")]
    pub old_property_values: Option<Vec<CustomPropertyValue>>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhookDelete {
    #[serde(skip_serializing_if="Option::is_none")]
    pub enterprise: Option<EnterpriseWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub organization: Option<OrganizationSimpleWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub pusher_type: Option<WebhooksDeployPusherType>,
    #[serde(rename = "ref")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub git_ref: Option<WebhooksRef0>,
    /// The type of Git ref object deleted in the repository.
    #[serde(skip_serializing_if="Option::is_none")]
    pub ref_type: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub repository: Option<RepositoryWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub sender: Option<SimpleUser>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhookDependabotAlertAutoDismissed {
    #[serde(skip_serializing_if="Option::is_none")]
    pub action: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub alert: Option<DependabotAlert>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub organization: Option<OrganizationSimpleWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub enterprise: Option<EnterpriseWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub repository: Option<RepositoryWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub sender: Option<SimpleUser>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhookDependabotAlertAutoReopened {
    #[serde(skip_serializing_if="Option::is_none")]
    pub action: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub alert: Option<DependabotAlert>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub organization: Option<OrganizationSimpleWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub enterprise: Option<EnterpriseWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub repository: Option<RepositoryWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub sender: Option<SimpleUser>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhookDependabotAlertCreated {
    #[serde(skip_serializing_if="Option::is_none")]
    pub action: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub alert: Option<DependabotAlert>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub organization: Option<OrganizationSimpleWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub enterprise: Option<EnterpriseWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub repository: Option<RepositoryWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub sender: Option<SimpleUser>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhookDependabotAlertDismissed {
    #[serde(skip_serializing_if="Option::is_none")]
    pub action: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub alert: Option<DependabotAlert>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub organization: Option<OrganizationSimpleWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub enterprise: Option<EnterpriseWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub repository: Option<RepositoryWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub sender: Option<SimpleUser>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhookDependabotAlertFixed {
    #[serde(skip_serializing_if="Option::is_none")]
    pub action: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub alert: Option<DependabotAlert>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub organization: Option<OrganizationSimpleWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub enterprise: Option<EnterpriseWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub repository: Option<RepositoryWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub sender: Option<SimpleUser>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhookDependabotAlertReintroduced {
    #[serde(skip_serializing_if="Option::is_none")]
    pub action: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub alert: Option<DependabotAlert>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub organization: Option<OrganizationSimpleWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub enterprise: Option<EnterpriseWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub repository: Option<RepositoryWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub sender: Option<SimpleUser>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhookDependabotAlertReopened {
    #[serde(skip_serializing_if="Option::is_none")]
    pub action: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub alert: Option<DependabotAlert>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub organization: Option<OrganizationSimpleWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub enterprise: Option<EnterpriseWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub repository: Option<RepositoryWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub sender: Option<SimpleUser>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhookDeployKeyCreated {
    #[serde(skip_serializing_if="Option::is_none")]
    pub action: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub enterprise: Option<EnterpriseWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub key: Option<WebhooksDeployKey>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub organization: Option<OrganizationSimpleWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub repository: Option<RepositoryWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub sender: Option<SimpleUser>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhookDeployKeyDeleted {
    #[serde(skip_serializing_if="Option::is_none")]
    pub action: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub enterprise: Option<EnterpriseWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub key: Option<WebhooksDeployKey>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub organization: Option<OrganizationSimpleWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub repository: Option<RepositoryWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub sender: Option<SimpleUser>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhookDeploymentCreated {
    #[serde(skip_serializing_if="Option::is_none")]
    pub action: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub deployment: Option<Deployment>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub enterprise: Option<EnterpriseWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub organization: Option<OrganizationSimpleWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub repository: Option<RepositoryWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub sender: Option<SimpleUser>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub workflow: Option<WebhooksWorkflow>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub workflow_run: Option<DeploymentWorkflowRun>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhookDeploymentProtectionRuleRequested {
    #[serde(skip_serializing_if="Option::is_none")]
    pub action: Option<String>,
    /// The name of the environment that has the deployment protection rule.
    #[serde(skip_serializing_if="Option::is_none")]
    pub environment: Option<String>,
    /// The event that triggered the deployment protection rule.
    #[serde(skip_serializing_if="Option::is_none")]
    pub event: Option<String>,
    /// The URL to review the deployment protection rule.
    #[serde(skip_serializing_if="Option::is_none")]
    pub deployment_callback_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub deployment: Option<Deployment>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub pull_requests: Option<Vec<PullRequest>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub repository: Option<RepositoryWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub organization: Option<OrganizationSimpleWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub sender: Option<SimpleUser>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhookDeploymentReviewApproved {
    #[serde(skip_serializing_if="Option::is_none")]
    pub action: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub approver: Option<WebhooksApprover>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub comment: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub enterprise: Option<EnterpriseWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub organization: Option<OrganizationSimpleWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub repository: Option<RepositoryWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub reviewers: Option<WebhooksReviewers>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub sender: Option<SimpleUser>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub since: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub workflow_job_run: Option<WebhooksWorkflowJobRun>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub workflow_job_runs: Option<Vec<WebhookdeploymentreviewapprovedWorkflowJobRuns>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub workflow_run: Option<DeploymentWorkflowRun1>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhookDeploymentReviewRejected {
    #[serde(skip_serializing_if="Option::is_none")]
    pub action: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub approver: Option<WebhooksApprover>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub comment: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub enterprise: Option<EnterpriseWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub organization: Option<OrganizationSimpleWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub repository: Option<RepositoryWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub reviewers: Option<WebhooksReviewers>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub sender: Option<SimpleUser>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub since: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub workflow_job_run: Option<WebhooksWorkflowJobRun>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub workflow_job_runs: Option<Vec<WebhookdeploymentreviewrejectedWorkflowJobRuns>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub workflow_run: Option<DeploymentWorkflowRun2>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhookDeploymentReviewRequested {
    #[serde(skip_serializing_if="Option::is_none")]
    pub action: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub enterprise: Option<EnterpriseWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub environment: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub organization: Option<OrganizationSimpleWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub repository: Option<RepositoryWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub requestor: Option<WebhooksUser>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub reviewers: Option<Vec<WebhookdeploymentreviewrequestedReviewers>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub sender: Option<SimpleUser>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub since: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub workflow_job_run: Option<WebhookdeploymentreviewrequestedWorkflowJobRun>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub workflow_run: Option<DeploymentWorkflowRun3>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhookDeploymentStatusCreated {
    #[serde(skip_serializing_if="Option::is_none")]
    pub action: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub check_run: Option<WebhookdeploymentstatuscreatedCheckRun>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub deployment: Option<Deployment1>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub deployment_status: Option<WebhookdeploymentstatuscreatedDeploymentStatus>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub enterprise: Option<EnterpriseWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub organization: Option<OrganizationSimpleWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub repository: Option<RepositoryWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub sender: Option<SimpleUser>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub workflow: Option<WebhooksWorkflow>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub workflow_run: Option<DeploymentWorkflowRun4>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhookDiscussionAnswered {
    #[serde(skip_serializing_if="Option::is_none")]
    pub action: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub answer: Option<WebhooksAnswer>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub discussion: Option<Discussion>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub enterprise: Option<EnterpriseWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub organization: Option<OrganizationSimpleWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub repository: Option<RepositoryWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub sender: Option<SimpleUser>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhookDiscussionCategoryChanged {
    #[serde(skip_serializing_if="Option::is_none")]
    pub action: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub changes: Option<WebhookdiscussioncategorychangedChanges>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub discussion: Option<Discussion>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub enterprise: Option<EnterpriseWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub organization: Option<OrganizationSimpleWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub repository: Option<RepositoryWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub sender: Option<SimpleUser>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhookDiscussionClosed {
    #[serde(skip_serializing_if="Option::is_none")]
    pub action: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub discussion: Option<Discussion>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub enterprise: Option<EnterpriseWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub organization: Option<OrganizationSimpleWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub repository: Option<RepositoryWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub sender: Option<SimpleUser>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhookDiscussionCommentCreated {
    #[serde(skip_serializing_if="Option::is_none")]
    pub action: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub comment: Option<WebhooksComment>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub discussion: Option<Discussion>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub enterprise: Option<EnterpriseWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub organization: Option<OrganizationSimpleWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub repository: Option<RepositoryWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub sender: Option<SimpleUser>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhookDiscussionCommentDeleted {
    #[serde(skip_serializing_if="Option::is_none")]
    pub action: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub comment: Option<WebhooksComment>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub discussion: Option<Discussion>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub enterprise: Option<EnterpriseWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub organization: Option<OrganizationSimpleWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub repository: Option<RepositoryWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub sender: Option<SimpleUser>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhookDiscussionCommentEdited {
    #[serde(skip_serializing_if="Option::is_none")]
    pub action: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub changes: Option<WebhookdiscussioncommenteditedChanges>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub comment: Option<WebhooksComment>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub discussion: Option<Discussion>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub enterprise: Option<EnterpriseWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub organization: Option<OrganizationSimpleWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub repository: Option<RepositoryWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub sender: Option<SimpleUser>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhookDiscussionCreated {
    #[serde(skip_serializing_if="Option::is_none")]
    pub action: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub discussion: Option<Discussion>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub enterprise: Option<EnterpriseWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub organization: Option<OrganizationSimpleWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub repository: Option<RepositoryWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub sender: Option<SimpleUser>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhookDiscussionDeleted {
    #[serde(skip_serializing_if="Option::is_none")]
    pub action: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub discussion: Option<Discussion>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub enterprise: Option<EnterpriseWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub organization: Option<OrganizationSimpleWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub repository: Option<RepositoryWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub sender: Option<SimpleUser>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhookDiscussionEdited {
    #[serde(skip_serializing_if="Option::is_none")]
    pub action: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub changes: Option<WebhookdiscussioneditedChanges>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub discussion: Option<Discussion>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub enterprise: Option<EnterpriseWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub organization: Option<OrganizationSimpleWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub repository: Option<RepositoryWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub sender: Option<SimpleUser>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhookDiscussionLabeled {
    #[serde(skip_serializing_if="Option::is_none")]
    pub action: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub discussion: Option<Discussion>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub enterprise: Option<EnterpriseWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub label: Option<WebhooksLabel>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub organization: Option<OrganizationSimpleWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub repository: Option<RepositoryWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub sender: Option<SimpleUser>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhookDiscussionLocked {
    #[serde(skip_serializing_if="Option::is_none")]
    pub action: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub discussion: Option<Discussion>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub enterprise: Option<EnterpriseWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub organization: Option<OrganizationSimpleWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub repository: Option<RepositoryWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub sender: Option<SimpleUser>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhookDiscussionPinned {
    #[serde(skip_serializing_if="Option::is_none")]
    pub action: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub discussion: Option<Discussion>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub enterprise: Option<EnterpriseWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub organization: Option<OrganizationSimpleWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub repository: Option<RepositoryWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub sender: Option<SimpleUser>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhookDiscussionReopened {
    #[serde(skip_serializing_if="Option::is_none")]
    pub action: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub discussion: Option<Discussion>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub enterprise: Option<EnterpriseWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub organization: Option<OrganizationSimpleWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub repository: Option<RepositoryWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub sender: Option<SimpleUser>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhookDiscussionTransferred {
    #[serde(skip_serializing_if="Option::is_none")]
    pub action: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub changes: Option<WebhookdiscussiontransferredChanges>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub discussion: Option<Discussion>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub enterprise: Option<EnterpriseWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub organization: Option<OrganizationSimpleWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub repository: Option<RepositoryWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub sender: Option<SimpleUser>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhookDiscussionUnanswered {
    #[serde(skip_serializing_if="Option::is_none")]
    pub action: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub discussion: Option<Discussion>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub old_answer: Option<WebhooksAnswer>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub organization: Option<OrganizationSimpleWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub repository: Option<RepositoryWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub sender: Option<SimpleUser>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhookDiscussionUnlabeled {
    #[serde(skip_serializing_if="Option::is_none")]
    pub action: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub discussion: Option<Discussion>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub enterprise: Option<EnterpriseWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub label: Option<WebhooksLabel>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub organization: Option<OrganizationSimpleWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub repository: Option<RepositoryWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub sender: Option<SimpleUser>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhookDiscussionUnlocked {
    #[serde(skip_serializing_if="Option::is_none")]
    pub action: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub discussion: Option<Discussion>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub enterprise: Option<EnterpriseWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub organization: Option<OrganizationSimpleWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub repository: Option<RepositoryWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub sender: Option<SimpleUser>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhookDiscussionUnpinned {
    #[serde(skip_serializing_if="Option::is_none")]
    pub action: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub discussion: Option<Discussion>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub enterprise: Option<EnterpriseWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub organization: Option<OrganizationSimpleWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub repository: Option<RepositoryWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub sender: Option<SimpleUser>,
}

/// A user forks a repository.
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhookFork {
    #[serde(skip_serializing_if="Option::is_none")]
    pub enterprise: Option<EnterpriseWebhooks>,
    /// The created [`repository`](https://docs.github.com/rest/repos/repos#get-a-repository) resource.
    #[serde(skip_serializing_if="Option::is_none")]
    pub forkee: Option<AllOfwebhookForkForkee>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub organization: Option<OrganizationSimpleWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub repository: Option<RepositoryWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub sender: Option<SimpleUser>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhookGithubAppAuthorizationRevoked {
    #[serde(skip_serializing_if="Option::is_none")]
    pub action: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub sender: Option<SimpleUser>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhookGollum {
    #[serde(skip_serializing_if="Option::is_none")]
    pub enterprise: Option<EnterpriseWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub organization: Option<OrganizationSimpleWebhooks>,
    /// The pages that were updated.
    #[serde(skip_serializing_if="Option::is_none")]
    pub pages: Option<Vec<WebhookgollumPages>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub repository: Option<RepositoryWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub sender: Option<SimpleUser>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhookInstallationCreated {
    #[serde(skip_serializing_if="Option::is_none")]
    pub action: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub enterprise: Option<EnterpriseWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub installation: Option<Installation>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub organization: Option<OrganizationSimpleWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub repositories: Option<WebhooksRepositories>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub repository: Option<RepositoryWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub requester: Option<WebhooksUser>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub sender: Option<SimpleUser>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhookInstallationDeleted {
    #[serde(skip_serializing_if="Option::is_none")]
    pub action: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub enterprise: Option<EnterpriseWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub installation: Option<Installation>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub organization: Option<OrganizationSimpleWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub repositories: Option<WebhooksRepositories>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub repository: Option<RepositoryWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub requester: Option<Value>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub sender: Option<SimpleUser>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhookInstallationNewPermissionsAccepted {
    #[serde(skip_serializing_if="Option::is_none")]
    pub action: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub enterprise: Option<EnterpriseWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub installation: Option<Installation>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub organization: Option<OrganizationSimpleWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub repositories: Option<WebhooksRepositories>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub repository: Option<RepositoryWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub requester: Option<Value>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub sender: Option<SimpleUser>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhookInstallationRepositoriesAdded {
    #[serde(skip_serializing_if="Option::is_none")]
    pub action: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub enterprise: Option<EnterpriseWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub installation: Option<Installation>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub organization: Option<OrganizationSimpleWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub repositories_added: Option<WebhooksRepositoriesAdded>,
    /// An array of repository objects, which were removed from the installation.
    #[serde(skip_serializing_if="Option::is_none")]
    pub repositories_removed: Option<Vec<WebhookinstallationrepositoriesaddedRepositoriesRemoved>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub repository: Option<RepositoryWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub repository_selection: Option<WebhooksRepositorySelection>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub requester: Option<WebhooksUser>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub sender: Option<SimpleUser>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhookInstallationRepositoriesRemoved {
    #[serde(skip_serializing_if="Option::is_none")]
    pub action: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub enterprise: Option<EnterpriseWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub installation: Option<Installation>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub organization: Option<OrganizationSimpleWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub repositories_added: Option<WebhooksRepositoriesAdded>,
    /// An array of repository objects, which were removed from the installation.
    #[serde(skip_serializing_if="Option::is_none")]
    pub repositories_removed: Option<Vec<WebhooksRepositoriesInner>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub repository: Option<RepositoryWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub repository_selection: Option<WebhooksRepositorySelection>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub requester: Option<WebhooksUser>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub sender: Option<SimpleUser>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhookInstallationSuspend {
    #[serde(skip_serializing_if="Option::is_none")]
    pub action: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub enterprise: Option<EnterpriseWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub installation: Option<Installation>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub organization: Option<OrganizationSimpleWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub repositories: Option<WebhooksRepositories>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub repository: Option<RepositoryWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub requester: Option<Value>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub sender: Option<SimpleUser>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhookInstallationTargetRenamed {
    #[serde(skip_serializing_if="Option::is_none")]
    pub account: Option<WebhookinstallationtargetrenamedAccount>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub action: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub changes: Option<WebhookinstallationtargetrenamedChanges>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub enterprise: Option<EnterpriseWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub organization: Option<OrganizationSimpleWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub repository: Option<RepositoryWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub sender: Option<SimpleUser>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub target_type: Option<String>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhookInstallationUnsuspend {
    #[serde(skip_serializing_if="Option::is_none")]
    pub action: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub enterprise: Option<EnterpriseWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub installation: Option<Installation>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub organization: Option<OrganizationSimpleWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub repositories: Option<WebhooksRepositories>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub repository: Option<RepositoryWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub requester: Option<Value>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub sender: Option<SimpleUser>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhookIssueCommentCreated {
    #[serde(skip_serializing_if="Option::is_none")]
    pub action: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub comment: Option<IssueComment>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub enterprise: Option<EnterpriseWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    /// The [issue](https://docs.github.com/rest/issues/issues#get-an-issue) the comment belongs to.
    #[serde(skip_serializing_if="Option::is_none")]
    pub issue: Option<AllOfwebhookIssueCommentCreatedIssue>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub organization: Option<OrganizationSimpleWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub repository: Option<RepositoryWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub sender: Option<SimpleUser>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhookIssueCommentDeleted {
    #[serde(skip_serializing_if="Option::is_none")]
    pub action: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub comment: Option<WebhooksIssueComment>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub enterprise: Option<EnterpriseWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    /// The [issue](https://docs.github.com/rest/issues/issues#get-an-issue) the comment belongs to.
    #[serde(skip_serializing_if="Option::is_none")]
    pub issue: Option<AllOfwebhookIssueCommentDeletedIssue>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub organization: Option<OrganizationSimpleWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub repository: Option<RepositoryWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub sender: Option<SimpleUser>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhookIssueCommentEdited {
    #[serde(skip_serializing_if="Option::is_none")]
    pub action: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub changes: Option<WebhooksChanges>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub comment: Option<WebhooksIssueComment>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub enterprise: Option<EnterpriseWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    /// The [issue](https://docs.github.com/rest/issues/issues#get-an-issue) the comment belongs to.
    #[serde(skip_serializing_if="Option::is_none")]
    pub issue: Option<AllOfwebhookIssueCommentEditedIssue>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub organization: Option<OrganizationSimpleWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub repository: Option<RepositoryWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub sender: Option<SimpleUser>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhookIssuesAssigned {
    /// The action that was performed.
    #[serde(skip_serializing_if="Option::is_none")]
    pub action: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub assignee: Option<WebhooksUser>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub enterprise: Option<EnterpriseWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub issue: Option<WebhooksIssue>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub organization: Option<OrganizationSimpleWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub repository: Option<RepositoryWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub sender: Option<SimpleUser>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhookIssuesClosed {
    /// The action that was performed.
    #[serde(skip_serializing_if="Option::is_none")]
    pub action: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub enterprise: Option<EnterpriseWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    /// The [issue](https://docs.github.com/rest/issues/issues#get-an-issue) itself.
    #[serde(skip_serializing_if="Option::is_none")]
    pub issue: Option<AllOfwebhookIssuesClosedIssue>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub organization: Option<OrganizationSimpleWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub repository: Option<RepositoryWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub sender: Option<SimpleUser>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhookIssuesDeleted {
    #[serde(skip_serializing_if="Option::is_none")]
    pub action: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub enterprise: Option<EnterpriseWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub issue: Option<Issue>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub organization: Option<OrganizationSimpleWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub repository: Option<RepositoryWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub sender: Option<SimpleUser>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhookIssuesDemilestoned {
    #[serde(skip_serializing_if="Option::is_none")]
    pub action: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub enterprise: Option<EnterpriseWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub issue: Option<Issue1>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub milestone: Option<WebhooksMilestone>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub organization: Option<OrganizationSimpleWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub repository: Option<RepositoryWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub sender: Option<SimpleUser>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhookIssuesEdited {
    #[serde(skip_serializing_if="Option::is_none")]
    pub action: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub changes: Option<WebhookissueseditedChanges>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub enterprise: Option<EnterpriseWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub issue: Option<Issue2>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub label: Option<WebhooksLabel>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub organization: Option<OrganizationSimpleWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub repository: Option<RepositoryWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub sender: Option<SimpleUser>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhookIssuesLabeled {
    #[serde(skip_serializing_if="Option::is_none")]
    pub action: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub enterprise: Option<EnterpriseWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub issue: Option<Issue3>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub label: Option<WebhooksLabel>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub organization: Option<OrganizationSimpleWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub repository: Option<RepositoryWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub sender: Option<SimpleUser>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhookIssuesLocked {
    #[serde(skip_serializing_if="Option::is_none")]
    pub action: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub enterprise: Option<EnterpriseWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub issue: Option<Issue4>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub organization: Option<OrganizationSimpleWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub repository: Option<RepositoryWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub sender: Option<SimpleUser>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhookIssuesMilestoned {
    #[serde(skip_serializing_if="Option::is_none")]
    pub action: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub enterprise: Option<EnterpriseWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub issue: Option<Issue5>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub milestone: Option<WebhooksMilestone>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub organization: Option<OrganizationSimpleWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub repository: Option<RepositoryWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub sender: Option<SimpleUser>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhookIssuesOpened {
    #[serde(skip_serializing_if="Option::is_none")]
    pub action: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub changes: Option<WebhookissuesopenedChanges>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub enterprise: Option<EnterpriseWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub issue: Option<Issue7>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub organization: Option<OrganizationSimpleWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub repository: Option<RepositoryWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub sender: Option<SimpleUser>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhookIssuesPinned {
    #[serde(skip_serializing_if="Option::is_none")]
    pub action: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub enterprise: Option<EnterpriseWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub issue: Option<WebhooksIssue2>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub organization: Option<OrganizationSimpleWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub repository: Option<RepositoryWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub sender: Option<SimpleUser>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhookIssuesReopened {
    #[serde(skip_serializing_if="Option::is_none")]
    pub action: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub enterprise: Option<EnterpriseWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub issue: Option<Issue8>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub organization: Option<OrganizationSimpleWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub repository: Option<RepositoryWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub sender: Option<SimpleUser>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhookIssuesTransferred {
    #[serde(skip_serializing_if="Option::is_none")]
    pub action: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub changes: Option<WebhookissuestransferredChanges>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub enterprise: Option<EnterpriseWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub issue: Option<WebhooksIssue2>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub organization: Option<OrganizationSimpleWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub repository: Option<RepositoryWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub sender: Option<SimpleUser>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhookIssuesUnassigned {
    /// The action that was performed.
    #[serde(skip_serializing_if="Option::is_none")]
    pub action: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub assignee: Option<WebhooksUserMannequin>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub enterprise: Option<EnterpriseWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub issue: Option<WebhooksIssue>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub organization: Option<OrganizationSimpleWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub repository: Option<RepositoryWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub sender: Option<SimpleUser>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhookIssuesUnlabeled {
    #[serde(skip_serializing_if="Option::is_none")]
    pub action: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub enterprise: Option<EnterpriseWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub issue: Option<WebhooksIssue>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub label: Option<WebhooksLabel>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub organization: Option<OrganizationSimpleWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub repository: Option<RepositoryWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub sender: Option<SimpleUser>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhookIssuesUnlocked {
    #[serde(skip_serializing_if="Option::is_none")]
    pub action: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub enterprise: Option<EnterpriseWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub issue: Option<Issue9>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub organization: Option<OrganizationSimpleWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub repository: Option<RepositoryWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub sender: Option<SimpleUser>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhookIssuesUnpinned {
    #[serde(skip_serializing_if="Option::is_none")]
    pub action: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub enterprise: Option<EnterpriseWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub issue: Option<WebhooksIssue2>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub organization: Option<OrganizationSimpleWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub repository: Option<RepositoryWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub sender: Option<SimpleUser>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhookLabelCreated {
    #[serde(skip_serializing_if="Option::is_none")]
    pub action: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub enterprise: Option<EnterpriseWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub label: Option<WebhooksLabel>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub organization: Option<OrganizationSimpleWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub repository: Option<RepositoryWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub sender: Option<SimpleUser>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhookLabelDeleted {
    #[serde(skip_serializing_if="Option::is_none")]
    pub action: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub enterprise: Option<EnterpriseWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub label: Option<WebhooksLabel>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub organization: Option<OrganizationSimpleWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub repository: Option<RepositoryWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub sender: Option<SimpleUser>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhookLabelEdited {
    #[serde(skip_serializing_if="Option::is_none")]
    pub action: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub changes: Option<WebhooklabeleditedChanges>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub enterprise: Option<EnterpriseWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub label: Option<WebhooksLabel>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub organization: Option<OrganizationSimpleWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub repository: Option<RepositoryWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub sender: Option<SimpleUser>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhookMarketplacePurchaseCancelled {
    #[serde(skip_serializing_if="Option::is_none")]
    pub action: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub effective_date: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub enterprise: Option<EnterpriseWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub marketplace_purchase: Option<WebhooksMarketplacePurchase>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub organization: Option<OrganizationSimpleWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub previous_marketplace_purchase: Option<WebhooksPreviousMarketplacePurchase>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub repository: Option<RepositoryWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub sender: Option<SimpleUser>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhookMarketplacePurchaseChanged {
    #[serde(skip_serializing_if="Option::is_none")]
    pub action: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub effective_date: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub enterprise: Option<EnterpriseWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub marketplace_purchase: Option<WebhooksMarketplacePurchase>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub organization: Option<OrganizationSimpleWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub previous_marketplace_purchase: Option<MarketplacePurchase>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub repository: Option<RepositoryWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub sender: Option<SimpleUser>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhookMarketplacePurchasePendingChange {
    #[serde(skip_serializing_if="Option::is_none")]
    pub action: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub effective_date: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub enterprise: Option<EnterpriseWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub marketplace_purchase: Option<WebhooksMarketplacePurchase>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub organization: Option<OrganizationSimpleWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub previous_marketplace_purchase: Option<MarketplacePurchase1>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub repository: Option<RepositoryWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub sender: Option<SimpleUser>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhookMarketplacePurchasePendingChangeCancelled {
    #[serde(skip_serializing_if="Option::is_none")]
    pub action: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub effective_date: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub enterprise: Option<EnterpriseWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub marketplace_purchase: Option<MarketplacePurchase2>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub organization: Option<OrganizationSimpleWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub previous_marketplace_purchase: Option<WebhooksPreviousMarketplacePurchase>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub repository: Option<RepositoryWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub sender: Option<SimpleUser>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhookMarketplacePurchasePurchased {
    #[serde(skip_serializing_if="Option::is_none")]
    pub action: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub effective_date: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub enterprise: Option<EnterpriseWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub marketplace_purchase: Option<WebhooksMarketplacePurchase>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub organization: Option<OrganizationSimpleWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub previous_marketplace_purchase: Option<WebhooksPreviousMarketplacePurchase>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub repository: Option<RepositoryWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub sender: Option<SimpleUser>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhookMemberAdded {
    #[serde(skip_serializing_if="Option::is_none")]
    pub action: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub changes: Option<WebhookmemberaddedChanges>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub enterprise: Option<EnterpriseWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub member: Option<WebhooksUser>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub organization: Option<OrganizationSimpleWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub repository: Option<RepositoryWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub sender: Option<SimpleUser>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhookMemberEdited {
    #[serde(skip_serializing_if="Option::is_none")]
    pub action: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub changes: Option<WebhookmembereditedChanges>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub enterprise: Option<EnterpriseWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub member: Option<WebhooksUser>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub organization: Option<OrganizationSimpleWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub repository: Option<RepositoryWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub sender: Option<SimpleUser>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhookMemberRemoved {
    #[serde(skip_serializing_if="Option::is_none")]
    pub action: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub enterprise: Option<EnterpriseWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub member: Option<WebhooksUser>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub organization: Option<OrganizationSimpleWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub repository: Option<RepositoryWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub sender: Option<SimpleUser>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhookMembershipAdded {
    #[serde(skip_serializing_if="Option::is_none")]
    pub action: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub enterprise: Option<EnterpriseWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub member: Option<WebhooksUser>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub organization: Option<OrganizationSimpleWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub repository: Option<RepositoryWebhooks>,
    /// The scope of the membership. Currently, can only be `team`.
    #[serde(skip_serializing_if="Option::is_none")]
    pub scope: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub sender: Option<User1>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub team: Option<WebhooksTeam>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhookMembershipRemoved {
    #[serde(skip_serializing_if="Option::is_none")]
    pub action: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub enterprise: Option<EnterpriseWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub member: Option<WebhooksUser>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub organization: Option<OrganizationSimpleWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub repository: Option<RepositoryWebhooks>,
    /// The scope of the membership. Currently, can only be `team`.
    #[serde(skip_serializing_if="Option::is_none")]
    pub scope: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub sender: Option<User1>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub team: Option<WebhooksTeam>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhookMergeGroupChecksRequested {
    #[serde(skip_serializing_if="Option::is_none")]
    pub action: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub merge_group: Option<MergeGroup>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub organization: Option<OrganizationSimpleWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub repository: Option<RepositoryWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub sender: Option<SimpleUser>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhookMergeGroupDestroyed {
    #[serde(skip_serializing_if="Option::is_none")]
    pub action: Option<String>,
    /// Explains why the merge group is being destroyed. The group could have been merged, removed from the queue (dequeued), or invalidated by an earlier queue entry being dequeued (invalidated).
    #[serde(skip_serializing_if="Option::is_none")]
    pub reason: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub merge_group: Option<MergeGroup>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub organization: Option<OrganizationSimpleWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub repository: Option<RepositoryWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub sender: Option<SimpleUser>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhookMetaDeleted {
    #[serde(skip_serializing_if="Option::is_none")]
    pub action: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub enterprise: Option<EnterpriseWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub hook: Option<WebhookmetadeletedHook>,
    /// The id of the modified webhook.
    #[serde(skip_serializing_if="Option::is_none")]
    pub hook_id: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub organization: Option<OrganizationSimpleWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub repository: Option<NullableRepositoryWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub sender: Option<SimpleUser>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhookMilestoneClosed {
    #[serde(skip_serializing_if="Option::is_none")]
    pub action: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub enterprise: Option<EnterpriseWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub milestone: Option<WebhooksMilestone>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub organization: Option<OrganizationSimpleWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub repository: Option<RepositoryWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub sender: Option<SimpleUser>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhookMilestoneCreated {
    #[serde(skip_serializing_if="Option::is_none")]
    pub action: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub enterprise: Option<EnterpriseWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub milestone: Option<WebhooksMilestone3>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub organization: Option<OrganizationSimpleWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub repository: Option<RepositoryWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub sender: Option<SimpleUser>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhookMilestoneDeleted {
    #[serde(skip_serializing_if="Option::is_none")]
    pub action: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub enterprise: Option<EnterpriseWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub milestone: Option<WebhooksMilestone>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub organization: Option<OrganizationSimpleWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub repository: Option<RepositoryWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub sender: Option<SimpleUser>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhookMilestoneEdited {
    #[serde(skip_serializing_if="Option::is_none")]
    pub action: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub changes: Option<WebhookmilestoneeditedChanges>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub enterprise: Option<EnterpriseWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub milestone: Option<WebhooksMilestone>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub organization: Option<OrganizationSimpleWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub repository: Option<RepositoryWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub sender: Option<SimpleUser>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhookMilestoneOpened {
    #[serde(skip_serializing_if="Option::is_none")]
    pub action: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub enterprise: Option<EnterpriseWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub milestone: Option<WebhooksMilestone3>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub organization: Option<OrganizationSimpleWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub repository: Option<RepositoryWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub sender: Option<SimpleUser>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhookOrgBlockBlocked {
    #[serde(skip_serializing_if="Option::is_none")]
    pub action: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub blocked_user: Option<WebhooksUser>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub enterprise: Option<EnterpriseWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub organization: Option<OrganizationSimpleWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub repository: Option<RepositoryWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub sender: Option<SimpleUser>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhookOrgBlockUnblocked {
    #[serde(skip_serializing_if="Option::is_none")]
    pub action: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub blocked_user: Option<WebhooksUser>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub enterprise: Option<EnterpriseWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub organization: Option<OrganizationSimpleWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub repository: Option<RepositoryWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub sender: Option<SimpleUser>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhookOrganizationDeleted {
    #[serde(skip_serializing_if="Option::is_none")]
    pub action: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub enterprise: Option<EnterpriseWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub membership: Option<WebhooksMembership>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub organization: Option<OrganizationSimpleWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub repository: Option<RepositoryWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub sender: Option<SimpleUser>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhookOrganizationMemberAdded {
    #[serde(skip_serializing_if="Option::is_none")]
    pub action: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub enterprise: Option<EnterpriseWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub membership: Option<WebhooksMembership>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub organization: Option<OrganizationSimpleWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub repository: Option<RepositoryWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub sender: Option<SimpleUser>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhookOrganizationMemberInvited {
    #[serde(skip_serializing_if="Option::is_none")]
    pub action: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub enterprise: Option<EnterpriseWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub invitation: Option<WebhookorganizationmemberinvitedInvitation>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub organization: Option<OrganizationSimpleWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub repository: Option<RepositoryWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub sender: Option<SimpleUser>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub user: Option<WebhooksUser>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhookOrganizationMemberRemoved {
    #[serde(skip_serializing_if="Option::is_none")]
    pub action: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub enterprise: Option<EnterpriseWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub membership: Option<WebhooksMembership>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub organization: Option<OrganizationSimpleWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub repository: Option<RepositoryWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub sender: Option<SimpleUser>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhookOrganizationRenamed {
    #[serde(skip_serializing_if="Option::is_none")]
    pub action: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub changes: Option<WebhookorganizationrenamedChanges>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub enterprise: Option<EnterpriseWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub membership: Option<WebhooksMembership>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub organization: Option<OrganizationSimpleWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub repository: Option<RepositoryWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub sender: Option<SimpleUser>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhookPackagePublished {
    #[serde(skip_serializing_if="Option::is_none")]
    pub action: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub enterprise: Option<EnterpriseWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub organization: Option<OrganizationSimpleWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub package: Option<WebhookpackagepublishedPackage>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub repository: Option<RepositoryWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub sender: Option<SimpleUser>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhookPackageUpdated {
    #[serde(skip_serializing_if="Option::is_none")]
    pub action: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub enterprise: Option<EnterpriseWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub organization: Option<OrganizationSimpleWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub package: Option<WebhookpackageupdatedPackage>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub repository: Option<RepositoryWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub sender: Option<SimpleUser>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhookPageBuild {
    #[serde(skip_serializing_if="Option::is_none")]
    pub build: Option<WebhookpagebuildBuild>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub enterprise: Option<EnterpriseWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub organization: Option<OrganizationSimpleWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub repository: Option<RepositoryWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub sender: Option<SimpleUser>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhookPersonalAccessTokenRequestApproved {
    #[serde(skip_serializing_if="Option::is_none")]
    pub action: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub personal_access_token_request: Option<PersonalAccessTokenRequest>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub enterprise: Option<EnterpriseWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub organization: Option<OrganizationSimpleWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub sender: Option<SimpleUser>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub installation: Option<SimpleInstallation>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhookPersonalAccessTokenRequestCancelled {
    #[serde(skip_serializing_if="Option::is_none")]
    pub action: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub personal_access_token_request: Option<PersonalAccessTokenRequest>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub enterprise: Option<EnterpriseWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub organization: Option<OrganizationSimpleWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub sender: Option<SimpleUser>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub installation: Option<SimpleInstallation>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhookPersonalAccessTokenRequestCreated {
    #[serde(skip_serializing_if="Option::is_none")]
    pub action: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub personal_access_token_request: Option<PersonalAccessTokenRequest>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub enterprise: Option<EnterpriseWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub organization: Option<OrganizationSimpleWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub sender: Option<SimpleUser>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub installation: Option<SimpleInstallation>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhookPersonalAccessTokenRequestDenied {
    #[serde(skip_serializing_if="Option::is_none")]
    pub action: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub personal_access_token_request: Option<PersonalAccessTokenRequest>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub organization: Option<OrganizationSimpleWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub enterprise: Option<EnterpriseWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub sender: Option<SimpleUser>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub installation: Option<SimpleInstallation>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhookPing {
    #[serde(skip_serializing_if="Option::is_none")]
    pub hook: Option<Webhook>,
    /// The ID of the webhook that triggered the ping.
    #[serde(skip_serializing_if="Option::is_none")]
    pub hook_id: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub organization: Option<OrganizationSimpleWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub repository: Option<RepositoryWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub sender: Option<SimpleUser>,
    /// Random string of GitHub zen.
    #[serde(skip_serializing_if="Option::is_none")]
    pub zen: Option<String>,
}

/// The webhooks ping payload encoded with URL encoding.
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhookPingFormEncoded {
    /// A URL-encoded string of the ping JSON payload. The decoded payload is a JSON object.
    #[serde(skip_serializing_if="Option::is_none")]
    pub payload: Option<String>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhookProjectCardConverted {
    #[serde(skip_serializing_if="Option::is_none")]
    pub action: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub changes: Option<WebhookprojectcardconvertedChanges>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub enterprise: Option<EnterpriseWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub organization: Option<OrganizationSimpleWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub project_card: Option<WebhooksProjectCard>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub repository: Option<RepositoryWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub sender: Option<SimpleUser>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhookProjectCardCreated {
    #[serde(skip_serializing_if="Option::is_none")]
    pub action: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub enterprise: Option<EnterpriseWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub organization: Option<OrganizationSimpleWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub project_card: Option<WebhooksProjectCard>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub repository: Option<RepositoryWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub sender: Option<SimpleUser>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhookProjectCardDeleted {
    #[serde(skip_serializing_if="Option::is_none")]
    pub action: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub enterprise: Option<EnterpriseWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub organization: Option<OrganizationSimpleWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub project_card: Option<ProjectCard>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub repository: Option<NullableRepositoryWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub sender: Option<SimpleUser>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhookProjectCardEdited {
    #[serde(skip_serializing_if="Option::is_none")]
    pub action: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub changes: Option<WebhookprojectcardeditedChanges>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub enterprise: Option<EnterpriseWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub organization: Option<OrganizationSimpleWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub project_card: Option<WebhooksProjectCard>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub repository: Option<RepositoryWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub sender: Option<SimpleUser>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhookProjectCardMoved {
    #[serde(skip_serializing_if="Option::is_none")]
    pub action: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub changes: Option<WebhookprojectcardmovedChanges>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub enterprise: Option<EnterpriseWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub organization: Option<OrganizationSimpleWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub project_card: Option<AllOfwebhookProjectCardMovedProjectCard>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub repository: Option<RepositoryWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub sender: Option<SimpleUser>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhookProjectClosed {
    #[serde(skip_serializing_if="Option::is_none")]
    pub action: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub enterprise: Option<EnterpriseWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub organization: Option<OrganizationSimpleWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub project: Option<WebhooksProject>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub repository: Option<RepositoryWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub sender: Option<SimpleUser>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhookProjectColumnCreated {
    #[serde(skip_serializing_if="Option::is_none")]
    pub action: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub enterprise: Option<EnterpriseWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub organization: Option<OrganizationSimpleWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub project_column: Option<WebhooksProjectColumn>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub repository: Option<RepositoryWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub sender: Option<SimpleUser>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhookProjectColumnDeleted {
    #[serde(skip_serializing_if="Option::is_none")]
    pub action: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub enterprise: Option<EnterpriseWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub organization: Option<OrganizationSimpleWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub project_column: Option<WebhooksProjectColumn>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub repository: Option<NullableRepositoryWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub sender: Option<SimpleUser>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhookProjectColumnEdited {
    #[serde(skip_serializing_if="Option::is_none")]
    pub action: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub changes: Option<WebhookprojectcolumneditedChanges>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub enterprise: Option<EnterpriseWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub organization: Option<OrganizationSimpleWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub project_column: Option<WebhooksProjectColumn>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub repository: Option<RepositoryWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub sender: Option<SimpleUser>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhookProjectColumnMoved {
    #[serde(skip_serializing_if="Option::is_none")]
    pub action: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub enterprise: Option<EnterpriseWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub organization: Option<OrganizationSimpleWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub project_column: Option<WebhooksProjectColumn>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub repository: Option<RepositoryWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub sender: Option<SimpleUser>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhookProjectCreated {
    #[serde(skip_serializing_if="Option::is_none")]
    pub action: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub enterprise: Option<EnterpriseWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub organization: Option<OrganizationSimpleWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub project: Option<WebhooksProject>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub repository: Option<RepositoryWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub sender: Option<SimpleUser>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhookProjectDeleted {
    #[serde(skip_serializing_if="Option::is_none")]
    pub action: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub enterprise: Option<EnterpriseWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub organization: Option<OrganizationSimpleWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub project: Option<WebhooksProject>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub repository: Option<NullableRepositoryWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub sender: Option<SimpleUser>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhookProjectEdited {
    #[serde(skip_serializing_if="Option::is_none")]
    pub action: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub changes: Option<WebhookprojecteditedChanges>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub enterprise: Option<EnterpriseWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub organization: Option<OrganizationSimpleWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub project: Option<WebhooksProject>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub repository: Option<RepositoryWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub sender: Option<SimpleUser>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhookProjectReopened {
    #[serde(skip_serializing_if="Option::is_none")]
    pub action: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub enterprise: Option<EnterpriseWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub organization: Option<OrganizationSimpleWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub project: Option<WebhooksProject>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub repository: Option<RepositoryWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub sender: Option<SimpleUser>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhookProjectsV2ItemArchived {
    #[serde(skip_serializing_if="Option::is_none")]
    pub action: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub changes: Option<WebhooksProjectChanges>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub organization: Option<OrganizationSimpleWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub projects_v2_item: Option<ProjectsV2Item>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub sender: Option<SimpleUser>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhookProjectsV2ItemConverted {
    #[serde(skip_serializing_if="Option::is_none")]
    pub action: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub changes: Option<Webhookprojectsv2itemconvertedChanges>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub organization: Option<OrganizationSimpleWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub projects_v2_item: Option<ProjectsV2Item>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub sender: Option<SimpleUser>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhookProjectsV2ItemCreated {
    #[serde(skip_serializing_if="Option::is_none")]
    pub action: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub organization: Option<OrganizationSimpleWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub projects_v2_item: Option<ProjectsV2Item>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub sender: Option<SimpleUser>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhookProjectsV2ItemDeleted {
    #[serde(skip_serializing_if="Option::is_none")]
    pub action: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub organization: Option<OrganizationSimpleWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub projects_v2_item: Option<ProjectsV2Item>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub sender: Option<SimpleUser>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhookProjectsV2ItemEdited {
    #[serde(skip_serializing_if="Option::is_none")]
    pub action: Option<String>,
    /// The changes made to the item may involve modifications in the item's fields and draft issue body. It includes altered values for text, number, date, single select, and iteration fields, along with the GraphQL node ID of the changed field.
    #[serde(skip_serializing_if="Option::is_none")]
    pub changes: Option<OneOfwebhookProjectsV2ItemEditedChanges>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub organization: Option<OrganizationSimpleWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub projects_v2_item: Option<ProjectsV2Item>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub sender: Option<SimpleUser>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhookProjectsV2ItemReordered {
    #[serde(skip_serializing_if="Option::is_none")]
    pub action: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub changes: Option<Webhookprojectsv2itemreorderedChanges>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub organization: Option<OrganizationSimpleWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub projects_v2_item: Option<ProjectsV2Item>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub sender: Option<SimpleUser>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhookProjectsV2ItemRestored {
    #[serde(skip_serializing_if="Option::is_none")]
    pub action: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub changes: Option<WebhooksProjectChanges>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub organization: Option<OrganizationSimpleWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub projects_v2_item: Option<ProjectsV2Item>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub sender: Option<SimpleUser>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhookProjectsV2ProjectClosed {
    #[serde(skip_serializing_if="Option::is_none")]
    pub action: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub organization: Option<OrganizationSimpleWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub projects_v2: Option<ProjectsV2>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub sender: Option<SimpleUser>,
}

/// A project was created
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhookProjectsV2ProjectCreated {
    #[serde(skip_serializing_if="Option::is_none")]
    pub action: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub organization: Option<OrganizationSimpleWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub projects_v2: Option<ProjectsV2>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub sender: Option<SimpleUser>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhookProjectsV2ProjectDeleted {
    #[serde(skip_serializing_if="Option::is_none")]
    pub action: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub organization: Option<OrganizationSimpleWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub projects_v2: Option<ProjectsV2>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub sender: Option<SimpleUser>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhookProjectsV2ProjectEdited {
    #[serde(skip_serializing_if="Option::is_none")]
    pub action: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub changes: Option<Webhookprojectsv2projecteditedChanges>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub organization: Option<OrganizationSimpleWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub projects_v2: Option<ProjectsV2>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub sender: Option<SimpleUser>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhookProjectsV2ProjectReopened {
    #[serde(skip_serializing_if="Option::is_none")]
    pub action: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub organization: Option<OrganizationSimpleWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub projects_v2: Option<ProjectsV2>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub sender: Option<SimpleUser>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhookProjectsV2StatusUpdateCreated {
    #[serde(skip_serializing_if="Option::is_none")]
    pub action: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub organization: Option<OrganizationSimpleWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub projects_v2_status_update: Option<ProjectsV2StatusUpdate>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub sender: Option<SimpleUser>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhookProjectsV2StatusUpdateDeleted {
    #[serde(skip_serializing_if="Option::is_none")]
    pub action: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub organization: Option<OrganizationSimpleWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub projects_v2_status_update: Option<ProjectsV2StatusUpdate>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub sender: Option<SimpleUser>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhookProjectsV2StatusUpdateEdited {
    #[serde(skip_serializing_if="Option::is_none")]
    pub action: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub changes: Option<Webhookprojectsv2statusupdateeditedChanges>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub organization: Option<OrganizationSimpleWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub projects_v2_status_update: Option<ProjectsV2StatusUpdate>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub sender: Option<SimpleUser>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhookPublic {
    #[serde(skip_serializing_if="Option::is_none")]
    pub enterprise: Option<EnterpriseWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub organization: Option<OrganizationSimpleWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub repository: Option<RepositoryWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub sender: Option<SimpleUser>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhookPullRequestAssigned {
    #[serde(skip_serializing_if="Option::is_none")]
    pub action: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub assignee: Option<WebhooksUser>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub enterprise: Option<EnterpriseWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub number: Option<WebhooksNumber>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub organization: Option<OrganizationSimpleWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub pull_request: Option<PullRequest>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub repository: Option<RepositoryWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub sender: Option<SimpleUser>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhookPullRequestAutoMergeDisabled {
    #[serde(skip_serializing_if="Option::is_none")]
    pub action: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub enterprise: Option<EnterpriseWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub number: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub organization: Option<OrganizationSimpleWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub pull_request: Option<PullRequest1>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub reason: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub repository: Option<RepositoryWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub sender: Option<SimpleUser>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhookPullRequestAutoMergeEnabled {
    #[serde(skip_serializing_if="Option::is_none")]
    pub action: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub enterprise: Option<EnterpriseWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub number: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub organization: Option<OrganizationSimpleWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub pull_request: Option<PullRequest2>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub reason: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub repository: Option<RepositoryWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub sender: Option<SimpleUser>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhookPullRequestClosed {
    #[serde(skip_serializing_if="Option::is_none")]
    pub action: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub enterprise: Option<EnterpriseWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub number: Option<WebhooksNumber>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub organization: Option<OrganizationSimpleWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub pull_request: Option<PullRequestWebhook>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub repository: Option<RepositoryWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub sender: Option<SimpleUser>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhookPullRequestConvertedToDraft {
    #[serde(skip_serializing_if="Option::is_none")]
    pub action: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub enterprise: Option<EnterpriseWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub number: Option<WebhooksNumber>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub organization: Option<OrganizationSimpleWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub pull_request: Option<PullRequestWebhook>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub repository: Option<RepositoryWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub sender: Option<SimpleUser>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhookPullRequestDemilestoned {
    #[serde(skip_serializing_if="Option::is_none")]
    pub action: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub enterprise: Option<EnterpriseWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub milestone: Option<Milestone>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub number: Option<WebhooksNumber>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub organization: Option<OrganizationSimpleWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub pull_request: Option<WebhooksPullRequest5>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub repository: Option<RepositoryWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub sender: Option<SimpleUser>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhookPullRequestDequeued {
    #[serde(skip_serializing_if="Option::is_none")]
    pub action: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub enterprise: Option<EnterpriseWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub number: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub organization: Option<OrganizationSimpleWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub pull_request: Option<PullRequest3>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub reason: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub repository: Option<RepositoryWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub sender: Option<SimpleUser>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhookPullRequestEdited {
    #[serde(skip_serializing_if="Option::is_none")]
    pub action: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub changes: Option<WebhookpullrequesteditedChanges>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub enterprise: Option<EnterpriseWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub number: Option<WebhooksNumber>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub organization: Option<OrganizationSimpleWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub pull_request: Option<PullRequestWebhook>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub repository: Option<RepositoryWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub sender: Option<SimpleUser>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhookPullRequestEnqueued {
    #[serde(skip_serializing_if="Option::is_none")]
    pub action: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub enterprise: Option<EnterpriseWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub number: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub organization: Option<OrganizationSimpleWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub pull_request: Option<PullRequest3>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub repository: Option<RepositoryWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub sender: Option<SimpleUser>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhookPullRequestLabeled {
    #[serde(skip_serializing_if="Option::is_none")]
    pub action: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub enterprise: Option<EnterpriseWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub label: Option<WebhooksLabel>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub number: Option<WebhooksNumber>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub organization: Option<OrganizationSimpleWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub pull_request: Option<PullRequest4>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub repository: Option<RepositoryWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub sender: Option<SimpleUser>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhookPullRequestLocked {
    #[serde(skip_serializing_if="Option::is_none")]
    pub action: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub enterprise: Option<EnterpriseWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub number: Option<WebhooksNumber>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub organization: Option<OrganizationSimpleWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub pull_request: Option<PullRequest5>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub repository: Option<RepositoryWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub sender: Option<SimpleUser>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhookPullRequestMilestoned {
    #[serde(skip_serializing_if="Option::is_none")]
    pub action: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub enterprise: Option<EnterpriseWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub milestone: Option<Milestone>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub number: Option<WebhooksNumber>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub organization: Option<OrganizationSimpleWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub pull_request: Option<WebhooksPullRequest5>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub repository: Option<RepositoryWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub sender: Option<SimpleUser>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhookPullRequestOpened {
    #[serde(skip_serializing_if="Option::is_none")]
    pub action: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub enterprise: Option<EnterpriseWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub number: Option<WebhooksNumber>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub organization: Option<OrganizationSimpleWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub pull_request: Option<PullRequestWebhook>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub repository: Option<RepositoryWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub sender: Option<SimpleUser>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhookPullRequestReadyForReview {
    #[serde(skip_serializing_if="Option::is_none")]
    pub action: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub enterprise: Option<EnterpriseWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub number: Option<WebhooksNumber>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub organization: Option<OrganizationSimpleWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub pull_request: Option<PullRequestWebhook>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub repository: Option<RepositoryWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub sender: Option<SimpleUser>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhookPullRequestReopened {
    #[serde(skip_serializing_if="Option::is_none")]
    pub action: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub enterprise: Option<EnterpriseWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub number: Option<WebhooksNumber>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub organization: Option<OrganizationSimpleWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub pull_request: Option<PullRequestWebhook>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub repository: Option<RepositoryWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub sender: Option<SimpleUser>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhookPullRequestReviewCommentCreated {
    #[serde(skip_serializing_if="Option::is_none")]
    pub action: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub comment: Option<PullRequestReviewComment>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub enterprise: Option<EnterpriseWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub organization: Option<OrganizationSimpleWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub pull_request: Option<WebhookpullrequestreviewcommentcreatedPullRequest>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub repository: Option<RepositoryWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub sender: Option<SimpleUser>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhookPullRequestReviewCommentDeleted {
    #[serde(skip_serializing_if="Option::is_none")]
    pub action: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub comment: Option<WebhooksReviewComment>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub enterprise: Option<EnterpriseWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub organization: Option<OrganizationSimpleWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub pull_request: Option<WebhookpullrequestreviewcommentdeletedPullRequest>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub repository: Option<RepositoryWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub sender: Option<SimpleUser>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhookPullRequestReviewCommentEdited {
    #[serde(skip_serializing_if="Option::is_none")]
    pub action: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub changes: Option<WebhooksChanges>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub comment: Option<WebhooksReviewComment>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub enterprise: Option<EnterpriseWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub organization: Option<OrganizationSimpleWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub pull_request: Option<WebhookpullrequestreviewcommenteditedPullRequest>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub repository: Option<RepositoryWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub sender: Option<SimpleUser>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhookPullRequestReviewDismissed {
    #[serde(skip_serializing_if="Option::is_none")]
    pub action: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub enterprise: Option<EnterpriseWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub organization: Option<OrganizationSimpleWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub pull_request: Option<SimplePullRequest>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub repository: Option<RepositoryWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub review: Option<WebhookpullrequestreviewdismissedReview>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub sender: Option<SimpleUser>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhookPullRequestReviewEdited {
    #[serde(skip_serializing_if="Option::is_none")]
    pub action: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub changes: Option<WebhookpullrequestrevieweditedChanges>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub enterprise: Option<EnterpriseWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub organization: Option<OrganizationSimpleWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub pull_request: Option<SimplePullRequest1>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub repository: Option<RepositoryWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub review: Option<WebhooksReview>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub sender: Option<SimpleUser>,
}

#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
#[serde(untagged)]
pub enum WebhookPullRequestReviewRequestRemoved { 
    WebhookPullRequestReviewRequestRemovedVariant0(HashMap<String, String>),
}

impl From<HashMap<String, String>> for WebhookPullRequestReviewRequestRemoved {
    fn from(value: HashMap<String, String>) -> Self {
        WebhookPullRequestReviewRequestRemoved::WebhookPullRequestReviewRequestRemovedVariant0(value)
    }
}

#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
#[serde(untagged)]
pub enum WebhookPullRequestReviewRequested { 
    WebhookPullRequestReviewRequestedVariant0(HashMap<String, String>),
}

impl From<HashMap<String, String>> for WebhookPullRequestReviewRequested {
    fn from(value: HashMap<String, String>) -> Self {
        WebhookPullRequestReviewRequested::WebhookPullRequestReviewRequestedVariant0(value)
    }
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhookPullRequestReviewSubmitted {
    #[serde(skip_serializing_if="Option::is_none")]
    pub action: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub enterprise: Option<EnterpriseWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub organization: Option<OrganizationSimpleWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub pull_request: Option<SimplePullRequest2>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub repository: Option<RepositoryWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub review: Option<WebhooksReview>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub sender: Option<SimpleUser>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhookPullRequestReviewThreadResolved {
    #[serde(skip_serializing_if="Option::is_none")]
    pub action: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub enterprise: Option<EnterpriseWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub organization: Option<OrganizationSimpleWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub pull_request: Option<SimplePullRequest3>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub repository: Option<RepositoryWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub sender: Option<SimpleUser>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub thread: Option<WebhookpullrequestreviewthreadresolvedThread>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhookPullRequestReviewThreadUnresolved {
    #[serde(skip_serializing_if="Option::is_none")]
    pub action: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub enterprise: Option<EnterpriseWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub organization: Option<OrganizationSimpleWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub pull_request: Option<SimplePullRequest4>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub repository: Option<RepositoryWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub sender: Option<SimpleUser>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub thread: Option<WebhookpullrequestreviewthreadunresolvedThread>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhookPullRequestSynchronize {
    #[serde(skip_serializing_if="Option::is_none")]
    pub action: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub after: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub before: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub enterprise: Option<EnterpriseWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub number: Option<WebhooksNumber>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub organization: Option<OrganizationSimpleWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub pull_request: Option<PullRequest10>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub repository: Option<RepositoryWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub sender: Option<SimpleUser>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhookPullRequestUnassigned {
    #[serde(skip_serializing_if="Option::is_none")]
    pub action: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub assignee: Option<WebhooksUserMannequin>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub enterprise: Option<EnterpriseWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub number: Option<WebhooksNumber>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub organization: Option<OrganizationSimpleWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub pull_request: Option<PullRequest11>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub repository: Option<RepositoryWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub sender: Option<SimpleUser>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhookPullRequestUnlabeled {
    #[serde(skip_serializing_if="Option::is_none")]
    pub action: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub enterprise: Option<EnterpriseWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub label: Option<WebhooksLabel>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub number: Option<WebhooksNumber>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub organization: Option<OrganizationSimpleWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub pull_request: Option<PullRequest12>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub repository: Option<RepositoryWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub sender: Option<SimpleUser>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhookPullRequestUnlocked {
    #[serde(skip_serializing_if="Option::is_none")]
    pub action: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub enterprise: Option<EnterpriseWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub number: Option<WebhooksNumber>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub organization: Option<OrganizationSimpleWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub pull_request: Option<PullRequest13>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub repository: Option<RepositoryWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub sender: Option<SimpleUser>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhookPush {
    /// The SHA of the most recent commit on `ref` after the push.
    #[serde(skip_serializing_if="Option::is_none")]
    pub after: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub base_ref: Option<WebhooksNullableString>,
    /// The SHA of the most recent commit on `ref` before the push.
    #[serde(skip_serializing_if="Option::is_none")]
    pub before: Option<String>,
    /// An array of commit objects describing the pushed commits. (Pushed commits are all commits that are included in the `compare` between the `before` commit and the `after` commit.) The array includes a maximum of 2048 commits. If necessary, you can use the [Commits API](https://docs.github.com/rest/commits) to fetch additional commits.
    #[serde(skip_serializing_if="Option::is_none")]
    pub commits: Option<Vec<Commit>>,
    /// URL that shows the changes in this `ref` update, from the `before` commit to the `after` commit. For a newly created `ref` that is directly based on the default branch, this is the comparison between the head of the default branch and the `after` commit. Otherwise, this shows all commits until the `after` commit.
    #[serde(skip_serializing_if="Option::is_none")]
    pub compare: Option<String>,
    /// Whether this push created the `ref`.
    #[serde(skip_serializing_if="Option::is_none")]
    pub created: Option<bool>,
    /// Whether this push deleted the `ref`.
    #[serde(skip_serializing_if="Option::is_none")]
    pub deleted: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub enterprise: Option<EnterpriseWebhooks>,
    /// Whether this push was a force push of the `ref`.
    #[serde(skip_serializing_if="Option::is_none")]
    pub forced: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub head_commit: Option<Commit1>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub organization: Option<OrganizationSimpleWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub pusher: Option<Committer1>,
    /// The full git ref that was pushed. Example: `refs/heads/main` or `refs/tags/v3.14.1`.
    #[serde(rename = "ref")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub git_ref: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub repository: Option<Repository2>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub sender: Option<SimpleUser>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhookRegistryPackagePublished {
    #[serde(skip_serializing_if="Option::is_none")]
    pub action: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub enterprise: Option<EnterpriseWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub organization: Option<OrganizationSimpleWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub registry_package: Option<WebhookregistrypackagepublishedRegistryPackage>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub repository: Option<RepositoryWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub sender: Option<SimpleUser>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhookRegistryPackageUpdated {
    #[serde(skip_serializing_if="Option::is_none")]
    pub action: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub enterprise: Option<EnterpriseWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub organization: Option<OrganizationSimpleWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub registry_package: Option<WebhookregistrypackageupdatedRegistryPackage>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub repository: Option<RepositoryWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub sender: Option<SimpleUser>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhookReleaseCreated {
    #[serde(skip_serializing_if="Option::is_none")]
    pub action: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub enterprise: Option<EnterpriseWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub organization: Option<OrganizationSimpleWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub release: Option<WebhooksRelease>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub repository: Option<RepositoryWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub sender: Option<SimpleUser>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhookReleaseDeleted {
    #[serde(skip_serializing_if="Option::is_none")]
    pub action: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub enterprise: Option<EnterpriseWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub organization: Option<OrganizationSimpleWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub release: Option<WebhooksRelease>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub repository: Option<RepositoryWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub sender: Option<SimpleUser>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhookReleaseEdited {
    #[serde(skip_serializing_if="Option::is_none")]
    pub action: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub changes: Option<WebhookreleaseeditedChanges>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub enterprise: Option<EnterpriseWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub organization: Option<OrganizationSimpleWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub release: Option<WebhooksRelease>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub repository: Option<RepositoryWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub sender: Option<SimpleUser>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhookReleasePrereleased {
    #[serde(skip_serializing_if="Option::is_none")]
    pub action: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub enterprise: Option<EnterpriseWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub organization: Option<OrganizationSimpleWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub release: Option<Release>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub repository: Option<RepositoryWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub sender: Option<SimpleUser>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhookReleasePublished {
    #[serde(skip_serializing_if="Option::is_none")]
    pub action: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub enterprise: Option<EnterpriseWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub organization: Option<OrganizationSimpleWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub release: Option<WebhooksRelease1>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub repository: Option<RepositoryWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub sender: Option<SimpleUser>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhookReleaseReleased {
    #[serde(skip_serializing_if="Option::is_none")]
    pub action: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub enterprise: Option<EnterpriseWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub organization: Option<OrganizationSimpleWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub release: Option<WebhooksRelease>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub repository: Option<RepositoryWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub sender: Option<SimpleUser>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhookReleaseUnpublished {
    #[serde(skip_serializing_if="Option::is_none")]
    pub action: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub enterprise: Option<EnterpriseWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub organization: Option<OrganizationSimpleWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub release: Option<WebhooksRelease1>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub repository: Option<RepositoryWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub sender: Option<SimpleUser>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhookRepositoryAdvisoryPublished {
    #[serde(skip_serializing_if="Option::is_none")]
    pub action: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub enterprise: Option<EnterpriseWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub organization: Option<OrganizationSimpleWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub repository: Option<RepositoryWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub repository_advisory: Option<RepositoryAdvisory>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub sender: Option<SimpleUser>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhookRepositoryAdvisoryReported {
    #[serde(skip_serializing_if="Option::is_none")]
    pub action: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub enterprise: Option<EnterpriseWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub organization: Option<OrganizationSimpleWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub repository: Option<RepositoryWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub repository_advisory: Option<RepositoryAdvisory>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub sender: Option<SimpleUser>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhookRepositoryArchived {
    #[serde(skip_serializing_if="Option::is_none")]
    pub action: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub enterprise: Option<EnterpriseWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub organization: Option<OrganizationSimpleWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub repository: Option<RepositoryWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub sender: Option<SimpleUser>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhookRepositoryCreated {
    #[serde(skip_serializing_if="Option::is_none")]
    pub action: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub enterprise: Option<EnterpriseWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub organization: Option<OrganizationSimpleWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub repository: Option<RepositoryWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub sender: Option<SimpleUser>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhookRepositoryDeleted {
    #[serde(skip_serializing_if="Option::is_none")]
    pub action: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub enterprise: Option<EnterpriseWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub organization: Option<OrganizationSimpleWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub repository: Option<RepositoryWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub sender: Option<SimpleUser>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhookRepositoryDispatchSample {
    /// The `event_type` that was specified in the `POST /repos/{owner}/{repo}/dispatches` request body.
    #[serde(skip_serializing_if="Option::is_none")]
    pub action: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub branch: Option<String>,
    /// The `client_payload` that was specified in the `POST /repos/{owner}/{repo}/dispatches` request body.
    #[serde(skip_serializing_if="Option::is_none")]
    pub client_payload: Option<HashMap<String, HashMap<String, Value>>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub enterprise: Option<EnterpriseWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub organization: Option<OrganizationSimpleWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub repository: Option<RepositoryWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub sender: Option<SimpleUser>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhookRepositoryEdited {
    #[serde(skip_serializing_if="Option::is_none")]
    pub action: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub changes: Option<WebhookrepositoryeditedChanges>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub enterprise: Option<EnterpriseWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub organization: Option<OrganizationSimpleWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub repository: Option<RepositoryWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub sender: Option<SimpleUser>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhookRepositoryImport {
    #[serde(skip_serializing_if="Option::is_none")]
    pub enterprise: Option<EnterpriseWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub organization: Option<OrganizationSimpleWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub repository: Option<RepositoryWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub sender: Option<SimpleUser>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub status: Option<String>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhookRepositoryPrivatized {
    #[serde(skip_serializing_if="Option::is_none")]
    pub action: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub enterprise: Option<EnterpriseWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub organization: Option<OrganizationSimpleWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub repository: Option<RepositoryWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub sender: Option<SimpleUser>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhookRepositoryPublicized {
    #[serde(skip_serializing_if="Option::is_none")]
    pub action: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub enterprise: Option<EnterpriseWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub organization: Option<OrganizationSimpleWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub repository: Option<RepositoryWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub sender: Option<SimpleUser>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhookRepositoryRenamed {
    #[serde(skip_serializing_if="Option::is_none")]
    pub action: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub changes: Option<WebhookrepositoryrenamedChanges>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub enterprise: Option<EnterpriseWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub organization: Option<OrganizationSimpleWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub repository: Option<RepositoryWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub sender: Option<SimpleUser>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhookRepositoryRulesetCreated {
    #[serde(skip_serializing_if="Option::is_none")]
    pub action: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub enterprise: Option<EnterpriseWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub organization: Option<OrganizationSimpleWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub repository: Option<RepositoryWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub repository_ruleset: Option<RepositoryRuleset>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub sender: Option<SimpleUser>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhookRepositoryRulesetDeleted {
    #[serde(skip_serializing_if="Option::is_none")]
    pub action: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub enterprise: Option<EnterpriseWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub organization: Option<OrganizationSimpleWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub repository: Option<RepositoryWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub repository_ruleset: Option<RepositoryRuleset>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub sender: Option<SimpleUser>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhookRepositoryRulesetEdited {
    #[serde(skip_serializing_if="Option::is_none")]
    pub action: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub enterprise: Option<EnterpriseWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub organization: Option<OrganizationSimpleWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub repository: Option<RepositoryWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub repository_ruleset: Option<RepositoryRuleset>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub changes: Option<WebhookrepositoryruleseteditedChanges>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub sender: Option<SimpleUser>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhookRepositoryTransferred {
    #[serde(skip_serializing_if="Option::is_none")]
    pub action: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub changes: Option<WebhookrepositorytransferredChanges>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub enterprise: Option<EnterpriseWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub organization: Option<OrganizationSimpleWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub repository: Option<RepositoryWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub sender: Option<SimpleUser>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhookRepositoryUnarchived {
    #[serde(skip_serializing_if="Option::is_none")]
    pub action: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub enterprise: Option<EnterpriseWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub organization: Option<OrganizationSimpleWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub repository: Option<RepositoryWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub sender: Option<SimpleUser>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhookRepositoryVulnerabilityAlertCreate {
    #[serde(skip_serializing_if="Option::is_none")]
    pub action: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub alert: Option<WebhooksAlert>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub enterprise: Option<EnterpriseWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub organization: Option<OrganizationSimpleWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub repository: Option<RepositoryWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub sender: Option<SimpleUser>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhookRepositoryVulnerabilityAlertDismiss {
    #[serde(skip_serializing_if="Option::is_none")]
    pub action: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub alert: Option<RepositoryVulnerabilityAlertAlert>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub enterprise: Option<EnterpriseWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub organization: Option<OrganizationSimpleWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub repository: Option<RepositoryWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub sender: Option<SimpleUser>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhookRepositoryVulnerabilityAlertReopen {
    #[serde(skip_serializing_if="Option::is_none")]
    pub action: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub alert: Option<WebhooksAlert>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub enterprise: Option<EnterpriseWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub organization: Option<OrganizationSimpleWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub repository: Option<RepositoryWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub sender: Option<SimpleUser>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhookRepositoryVulnerabilityAlertResolve {
    #[serde(skip_serializing_if="Option::is_none")]
    pub action: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub alert: Option<RepositoryVulnerabilityAlertAlert1>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub enterprise: Option<EnterpriseWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub organization: Option<OrganizationSimpleWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub repository: Option<RepositoryWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub sender: Option<SimpleUser>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhookRubygemsMetadata {
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub description: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub readme: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub homepage: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub version_info: Option<WebhookrubygemsmetadataVersionInfo>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub platform: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub metadata: Option<HashMap<String, String>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub repo: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub dependencies: Option<Vec<HashMap<String, String>>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub commit_oid: Option<String>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhookSecretScanningAlertCreated {
    #[serde(skip_serializing_if="Option::is_none")]
    pub action: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub alert: Option<SecretScanningAlertWebhook>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub enterprise: Option<EnterpriseWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub organization: Option<OrganizationSimpleWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub repository: Option<RepositoryWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub sender: Option<SimpleUser>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhookSecretScanningAlertLocationCreated {
    #[serde(skip_serializing_if="Option::is_none")]
    pub action: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub alert: Option<SecretScanningAlertWebhook>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub location: Option<SecretScanningLocation>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub organization: Option<OrganizationSimpleWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub repository: Option<RepositoryWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub sender: Option<SimpleUser>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhookSecretScanningAlertLocationCreatedFormEncoded {
    /// A URL-encoded string of the secret_scanning_alert_location.created JSON payload. The decoded payload is a JSON object.
    #[serde(skip_serializing_if="Option::is_none")]
    pub payload: Option<String>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhookSecretScanningAlertPubliclyLeaked {
    #[serde(skip_serializing_if="Option::is_none")]
    pub action: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub alert: Option<SecretScanningAlertWebhook>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub enterprise: Option<EnterpriseWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub organization: Option<OrganizationSimpleWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub repository: Option<RepositoryWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub sender: Option<SimpleUser>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhookSecretScanningAlertReopened {
    #[serde(skip_serializing_if="Option::is_none")]
    pub action: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub alert: Option<SecretScanningAlertWebhook>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub enterprise: Option<EnterpriseWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub organization: Option<OrganizationSimpleWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub repository: Option<RepositoryWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub sender: Option<SimpleUser>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhookSecretScanningAlertResolved {
    #[serde(skip_serializing_if="Option::is_none")]
    pub action: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub alert: Option<SecretScanningAlertWebhook>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub enterprise: Option<EnterpriseWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub organization: Option<OrganizationSimpleWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub repository: Option<RepositoryWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub sender: Option<SimpleUser>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhookSecretScanningAlertValidated {
    #[serde(skip_serializing_if="Option::is_none")]
    pub action: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub alert: Option<SecretScanningAlertWebhook>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub enterprise: Option<EnterpriseWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub organization: Option<OrganizationSimpleWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub repository: Option<RepositoryWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub sender: Option<SimpleUser>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhookSecretScanningScanCompleted {
    #[serde(skip_serializing_if="Option::is_none")]
    pub action: Option<String>,
    /// What type of scan was completed
    #[serde(rename = "type")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub _type: Option<String>,
    /// What type of content was scanned
    #[serde(skip_serializing_if="Option::is_none")]
    pub source: Option<String>,
    /// The time that the alert was resolved in ISO 8601 format: `YYYY-MM-DDTHH:MM:SSZ`.
    #[serde(skip_serializing_if="Option::is_none")]
    pub started_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The time that the alert was resolved in ISO 8601 format: `YYYY-MM-DDTHH:MM:SSZ`.
    #[serde(skip_serializing_if="Option::is_none")]
    pub completed_at: Option<chrono::DateTime<chrono::Utc>>,
    /// List of patterns that were updated. This will be empty for normal backfill scans or custom pattern updates
    #[serde(skip_serializing_if="Option::is_none")]
    pub secret_types: Option<Vec<String>>,
    /// If the scan was triggered by a custom pattern update, this will be the name of the pattern that was updated
    #[serde(skip_serializing_if="Option::is_none")]
    pub custom_pattern_name: Option<String>,
    /// If the scan was triggered by a custom pattern update, this will be the scope of the pattern that was updated
    #[serde(skip_serializing_if="Option::is_none")]
    pub custom_pattern_scope: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub repository: Option<RepositoryWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub enterprise: Option<EnterpriseWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub organization: Option<OrganizationSimpleWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub sender: Option<SimpleUser>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhookSecurityAdvisoryPublished {
    #[serde(skip_serializing_if="Option::is_none")]
    pub action: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub enterprise: Option<EnterpriseWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub organization: Option<OrganizationSimpleWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub repository: Option<RepositoryWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub security_advisory: Option<WebhooksSecurityAdvisory>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub sender: Option<SimpleUser>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhookSecurityAdvisoryUpdated {
    #[serde(skip_serializing_if="Option::is_none")]
    pub action: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub enterprise: Option<EnterpriseWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub organization: Option<OrganizationSimpleWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub repository: Option<RepositoryWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub security_advisory: Option<WebhooksSecurityAdvisory>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub sender: Option<SimpleUser>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhookSecurityAdvisoryWithdrawn {
    #[serde(skip_serializing_if="Option::is_none")]
    pub action: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub enterprise: Option<EnterpriseWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub organization: Option<OrganizationSimpleWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub repository: Option<RepositoryWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub security_advisory: Option<WebhooksecurityadvisorywithdrawnSecurityAdvisory>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub sender: Option<SimpleUser>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhookSecurityAndAnalysis {
    #[serde(skip_serializing_if="Option::is_none")]
    pub changes: Option<WebhooksecurityandanalysisChanges>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub enterprise: Option<EnterpriseWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub organization: Option<OrganizationSimpleWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub repository: Option<FullRepository>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub sender: Option<SimpleUser>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhookSponsorshipCancelled {
    #[serde(skip_serializing_if="Option::is_none")]
    pub action: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub enterprise: Option<EnterpriseWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub organization: Option<OrganizationSimpleWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub repository: Option<RepositoryWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub sender: Option<SimpleUser>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub sponsorship: Option<WebhooksSponsorship>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhookSponsorshipCreated {
    #[serde(skip_serializing_if="Option::is_none")]
    pub action: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub enterprise: Option<EnterpriseWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub organization: Option<OrganizationSimpleWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub repository: Option<RepositoryWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub sender: Option<SimpleUser>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub sponsorship: Option<WebhooksSponsorship>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhookSponsorshipEdited {
    #[serde(skip_serializing_if="Option::is_none")]
    pub action: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub changes: Option<WebhooksponsorshipeditedChanges>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub enterprise: Option<EnterpriseWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub organization: Option<OrganizationSimpleWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub repository: Option<RepositoryWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub sender: Option<SimpleUser>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub sponsorship: Option<WebhooksSponsorship>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhookSponsorshipPendingCancellation {
    #[serde(skip_serializing_if="Option::is_none")]
    pub action: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub effective_date: Option<WebhooksEffectiveDate>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub enterprise: Option<EnterpriseWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub organization: Option<OrganizationSimpleWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub repository: Option<RepositoryWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub sender: Option<SimpleUser>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub sponsorship: Option<WebhooksSponsorship>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhookSponsorshipPendingTierChange {
    #[serde(skip_serializing_if="Option::is_none")]
    pub action: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub changes: Option<WebhooksChanges8>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub effective_date: Option<WebhooksEffectiveDate>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub enterprise: Option<EnterpriseWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub organization: Option<OrganizationSimpleWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub repository: Option<RepositoryWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub sender: Option<SimpleUser>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub sponsorship: Option<WebhooksSponsorship>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhookSponsorshipTierChanged {
    #[serde(skip_serializing_if="Option::is_none")]
    pub action: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub changes: Option<WebhooksChanges8>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub enterprise: Option<EnterpriseWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub organization: Option<OrganizationSimpleWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub repository: Option<RepositoryWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub sender: Option<SimpleUser>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub sponsorship: Option<WebhooksSponsorship>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhookStarCreated {
    #[serde(skip_serializing_if="Option::is_none")]
    pub action: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub enterprise: Option<EnterpriseWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub organization: Option<OrganizationSimpleWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub repository: Option<RepositoryWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub sender: Option<SimpleUser>,
    /// The time the star was created. This is a timestamp in ISO 8601 format: `YYYY-MM-DDTHH:MM:SSZ`. Will be `null` for the `deleted` action.
    #[serde(skip_serializing_if="Option::is_none")]
    pub starred_at: Option<String>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhookStarDeleted {
    #[serde(skip_serializing_if="Option::is_none")]
    pub action: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub enterprise: Option<EnterpriseWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub organization: Option<OrganizationSimpleWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub repository: Option<RepositoryWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub sender: Option<SimpleUser>,
    /// The time the star was created. This is a timestamp in ISO 8601 format: `YYYY-MM-DDTHH:MM:SSZ`. Will be `null` for the `deleted` action.
    #[serde(skip_serializing_if="Option::is_none")]
    pub starred_at: Option<Value>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhookStatus {
    #[serde(skip_serializing_if="Option::is_none")]
    pub avatar_url: Option<String>,
    /// An array of branch objects containing the status' SHA. Each branch contains the given SHA, but the SHA may or may not be the head of the branch. The array includes a maximum of 10 branches.
    #[serde(skip_serializing_if="Option::is_none")]
    pub branches: Option<Vec<WebhookstatusBranches>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub commit: Option<WebhookstatusCommit1>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub context: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub created_at: Option<String>,
    /// The optional human-readable description added to the status.
    #[serde(skip_serializing_if="Option::is_none")]
    pub description: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub enterprise: Option<EnterpriseWebhooks>,
    /// The unique identifier of the status.
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub organization: Option<OrganizationSimpleWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub repository: Option<RepositoryWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub sender: Option<SimpleUser>,
    /// The Commit SHA.
    #[serde(skip_serializing_if="Option::is_none")]
    pub sha: Option<String>,
    /// The new state. Can be `pending`, `success`, `failure`, or `error`.
    #[serde(skip_serializing_if="Option::is_none")]
    pub state: Option<String>,
    /// The optional link added to the status.
    #[serde(skip_serializing_if="Option::is_none")]
    pub target_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub updated_at: Option<String>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhookSubIssuesParentIssueAdded {
    #[serde(skip_serializing_if="Option::is_none")]
    pub action: Option<String>,
    /// The ID of the parent issue.
    #[serde(skip_serializing_if="Option::is_none")]
    pub parent_issue_id: Option<f64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub parent_issue: Option<Issue>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub parent_issue_repo: Option<Repository>,
    /// The ID of the sub-issue.
    #[serde(skip_serializing_if="Option::is_none")]
    pub sub_issue_id: Option<f64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub sub_issue: Option<Issue>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub organization: Option<OrganizationSimpleWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub repository: Option<RepositoryWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub sender: Option<SimpleUser>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhookSubIssuesParentIssueRemoved {
    #[serde(skip_serializing_if="Option::is_none")]
    pub action: Option<String>,
    /// The ID of the parent issue.
    #[serde(skip_serializing_if="Option::is_none")]
    pub parent_issue_id: Option<f64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub parent_issue: Option<Issue>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub parent_issue_repo: Option<Repository>,
    /// The ID of the sub-issue.
    #[serde(skip_serializing_if="Option::is_none")]
    pub sub_issue_id: Option<f64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub sub_issue: Option<Issue>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub organization: Option<OrganizationSimpleWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub repository: Option<RepositoryWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub sender: Option<SimpleUser>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhookSubIssuesSubIssueAdded {
    #[serde(skip_serializing_if="Option::is_none")]
    pub action: Option<String>,
    /// The ID of the sub-issue.
    #[serde(skip_serializing_if="Option::is_none")]
    pub sub_issue_id: Option<f64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub sub_issue: Option<Issue>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub sub_issue_repo: Option<Repository>,
    /// The ID of the parent issue.
    #[serde(skip_serializing_if="Option::is_none")]
    pub parent_issue_id: Option<f64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub parent_issue: Option<Issue>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub organization: Option<OrganizationSimpleWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub repository: Option<RepositoryWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub sender: Option<SimpleUser>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhookSubIssuesSubIssueRemoved {
    #[serde(skip_serializing_if="Option::is_none")]
    pub action: Option<String>,
    /// The ID of the sub-issue.
    #[serde(skip_serializing_if="Option::is_none")]
    pub sub_issue_id: Option<f64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub sub_issue: Option<Issue>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub sub_issue_repo: Option<Repository>,
    /// The ID of the parent issue.
    #[serde(skip_serializing_if="Option::is_none")]
    pub parent_issue_id: Option<f64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub parent_issue: Option<Issue>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub organization: Option<OrganizationSimpleWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub repository: Option<RepositoryWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub sender: Option<SimpleUser>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhookTeamAdd {
    #[serde(skip_serializing_if="Option::is_none")]
    pub enterprise: Option<EnterpriseWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub organization: Option<OrganizationSimpleWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub repository: Option<RepositoryWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub sender: Option<SimpleUser>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub team: Option<WebhooksTeam1>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhookTeamAddedToRepository {
    #[serde(skip_serializing_if="Option::is_none")]
    pub action: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub enterprise: Option<EnterpriseWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub organization: Option<OrganizationSimpleWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub repository: Option<Repository11>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub sender: Option<SimpleUser>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub team: Option<WebhooksTeam1>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhookTeamCreated {
    #[serde(skip_serializing_if="Option::is_none")]
    pub action: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub enterprise: Option<EnterpriseWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub organization: Option<OrganizationSimpleWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub repository: Option<Repository11>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub sender: Option<SimpleUser>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub team: Option<WebhooksTeam1>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhookTeamDeleted {
    #[serde(skip_serializing_if="Option::is_none")]
    pub action: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub enterprise: Option<EnterpriseWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub organization: Option<OrganizationSimpleWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub repository: Option<Repository11>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub sender: Option<SimpleUser>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub team: Option<WebhooksTeam1>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhookTeamEdited {
    #[serde(skip_serializing_if="Option::is_none")]
    pub action: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub changes: Option<WebhookteameditedChanges>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub enterprise: Option<EnterpriseWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub organization: Option<OrganizationSimpleWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub repository: Option<Repository11>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub sender: Option<SimpleUser>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub team: Option<WebhooksTeam1>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhookTeamRemovedFromRepository {
    #[serde(skip_serializing_if="Option::is_none")]
    pub action: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub enterprise: Option<EnterpriseWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub organization: Option<OrganizationSimpleWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub repository: Option<Repository11>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub sender: Option<SimpleUser>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub team: Option<WebhooksTeam1>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhookWatchStarted {
    #[serde(skip_serializing_if="Option::is_none")]
    pub action: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub enterprise: Option<EnterpriseWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub organization: Option<OrganizationSimpleWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub repository: Option<RepositoryWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub sender: Option<SimpleUser>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhookWorkflowDispatch {
    #[serde(skip_serializing_if="Option::is_none")]
    pub enterprise: Option<EnterpriseWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub inputs: Option<HashMap<String, HashMap<String, Value>>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub organization: Option<OrganizationSimpleWebhooks>,
    #[serde(rename = "ref")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub git_ref: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub repository: Option<RepositoryWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub sender: Option<SimpleUser>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub workflow: Option<String>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhookWorkflowJobCompleted {
    #[serde(skip_serializing_if="Option::is_none")]
    pub action: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub enterprise: Option<EnterpriseWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub organization: Option<OrganizationSimpleWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub repository: Option<RepositoryWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub sender: Option<SimpleUser>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub workflow_job: Option<AllOfwebhookWorkflowJobCompletedWorkflowJob>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub deployment: Option<Deployment>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhookWorkflowJobInProgress {
    #[serde(skip_serializing_if="Option::is_none")]
    pub action: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub enterprise: Option<EnterpriseWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub organization: Option<OrganizationSimpleWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub repository: Option<RepositoryWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub sender: Option<SimpleUser>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub workflow_job: Option<AllOfwebhookWorkflowJobInProgressWorkflowJob>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub deployment: Option<Deployment>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhookWorkflowJobQueued {
    #[serde(skip_serializing_if="Option::is_none")]
    pub action: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub enterprise: Option<EnterpriseWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub organization: Option<OrganizationSimpleWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub repository: Option<RepositoryWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub sender: Option<SimpleUser>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub workflow_job: Option<WebhookworkflowjobqueuedWorkflowJob>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub deployment: Option<Deployment>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhookWorkflowJobWaiting {
    #[serde(skip_serializing_if="Option::is_none")]
    pub action: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub enterprise: Option<EnterpriseWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub organization: Option<OrganizationSimpleWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub repository: Option<RepositoryWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub sender: Option<SimpleUser>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub workflow_job: Option<WebhookworkflowjobwaitingWorkflowJob>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub deployment: Option<Deployment>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhookWorkflowRunCompleted {
    #[serde(skip_serializing_if="Option::is_none")]
    pub action: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub enterprise: Option<EnterpriseWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub organization: Option<OrganizationSimpleWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub repository: Option<RepositoryWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub sender: Option<SimpleUser>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub workflow: Option<WebhooksWorkflow>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub workflow_run: Option<WorkflowRun>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhookWorkflowRunInProgress {
    #[serde(skip_serializing_if="Option::is_none")]
    pub action: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub enterprise: Option<EnterpriseWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub organization: Option<OrganizationSimpleWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub repository: Option<RepositoryWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub sender: Option<SimpleUser>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub workflow: Option<WebhooksWorkflow>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub workflow_run: Option<WorkflowRun1>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhookWorkflowRunRequested {
    #[serde(skip_serializing_if="Option::is_none")]
    pub action: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub enterprise: Option<EnterpriseWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub installation: Option<SimpleInstallation>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub organization: Option<OrganizationSimpleWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub repository: Option<RepositoryWebhooks>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub sender: Option<SimpleUser>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub workflow: Option<WebhooksWorkflow>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub workflow_run: Option<WorkflowRun2>,
}

/// If the action was `edited`, the changes to the rule.
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhookbranchprotectionruleeditedChanges {
    #[serde(skip_serializing_if="Option::is_none")]
    pub admin_enforced: Option<WebhookbranchprotectionruleeditedChangesAdminEnforced>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub authorized_actor_names: Option<WebhookbranchprotectionruleeditedChangesAuthorizedActorNames>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub authorized_actors_only: Option<WebhookbranchprotectionruleeditedChangesAdminEnforced>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub authorized_dismissal_actors_only: Option<WebhookbranchprotectionruleeditedChangesAdminEnforced>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub linear_history_requirement_enforcement_level: Option<WebhookbranchprotectionruleeditedChangesLinearHistoryRequirementEnforcementLevel>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub lock_branch_enforcement_level: Option<WebhookbranchprotectionruleeditedChangesLinearHistoryRequirementEnforcementLevel>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub lock_allows_fork_sync: Option<WebhookbranchprotectionruleeditedChangesAdminEnforced>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub pull_request_reviews_enforcement_level: Option<WebhookbranchprotectionruleeditedChangesLinearHistoryRequirementEnforcementLevel>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub require_last_push_approval: Option<WebhookbranchprotectionruleeditedChangesAdminEnforced>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub required_status_checks: Option<WebhookbranchprotectionruleeditedChangesAuthorizedActorNames>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub required_status_checks_enforcement_level: Option<WebhookbranchprotectionruleeditedChangesLinearHistoryRequirementEnforcementLevel>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhookbranchprotectionruleeditedChangesAdminEnforced {
    #[serde(skip_serializing_if="Option::is_none")]
    pub from: Option<bool>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhookbranchprotectionruleeditedChangesAuthorizedActorNames {
    #[serde(skip_serializing_if="Option::is_none")]
    pub from: Option<Vec<String>>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhookbranchprotectionruleeditedChangesLinearHistoryRequirementEnforcementLevel {
    #[serde(skip_serializing_if="Option::is_none")]
    pub from: Option<String>,
}

/// The action requested by the user.
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhookcheckrunrequestedactionRequestedAction {
    /// The integrator reference of the action requested by the user.
    #[serde(skip_serializing_if="Option::is_none")]
    pub identifier: Option<String>,
}

/// The [check_suite](https://docs.github.com/rest/checks/suites#get-a-check-suite).
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhookchecksuitecompletedCheckSuite {
    #[serde(skip_serializing_if="Option::is_none")]
    pub after: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub app: Option<App2>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub before: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub check_runs_url: Option<String>,
    /// The summary conclusion for all check runs that are part of the check suite. This value will be `null` until the check run has `completed`.
    #[serde(skip_serializing_if="Option::is_none")]
    pub conclusion: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The head branch name the changes are on.
    #[serde(skip_serializing_if="Option::is_none")]
    pub head_branch: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub head_commit: Option<SimpleCommit>,
    /// The SHA of the head commit that is being checked.
    #[serde(skip_serializing_if="Option::is_none")]
    pub head_sha: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub latest_check_runs_count: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub node_id: Option<String>,
    /// An array of pull requests that match this check suite. A pull request matches a check suite if they have the same `head_sha` and `head_branch`. When the check suite's `head_branch` is in a forked repository it will be `null` and the `pull_requests` array will be empty.
    #[serde(skip_serializing_if="Option::is_none")]
    pub pull_requests: Option<Vec<CheckRunPullRequest>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub rerequestable: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub runs_rerequestable: Option<bool>,
    /// The summary status for all check runs that are part of the check suite. Can be `requested`, `in_progress`, or `completed`.
    #[serde(skip_serializing_if="Option::is_none")]
    pub status: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub updated_at: Option<chrono::DateTime<chrono::Utc>>,
    /// URL that points to the check suite API resource.
    #[serde(skip_serializing_if="Option::is_none")]
    pub url: Option<String>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhookchecksuitecompletedCheckSuiteBase {
    #[serde(rename = "ref")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub git_ref: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub repo: Option<EventRepo>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub sha: Option<String>,
}

/// The [check_suite](https://docs.github.com/rest/checks/suites#get-a-check-suite).
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhookchecksuiterequestedCheckSuite {
    #[serde(skip_serializing_if="Option::is_none")]
    pub after: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub app: Option<App3>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub before: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub check_runs_url: Option<String>,
    /// The summary conclusion for all check runs that are part of the check suite. This value will be `null` until the check run has completed.
    #[serde(skip_serializing_if="Option::is_none")]
    pub conclusion: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The head branch name the changes are on.
    #[serde(skip_serializing_if="Option::is_none")]
    pub head_branch: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub head_commit: Option<SimpleCommit>,
    /// The SHA of the head commit that is being checked.
    #[serde(skip_serializing_if="Option::is_none")]
    pub head_sha: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub latest_check_runs_count: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub node_id: Option<String>,
    /// An array of pull requests that match this check suite. A pull request matches a check suite if they have the same `head_sha` and `head_branch`. When the check suite's `head_branch` is in a forked repository it will be `null` and the `pull_requests` array will be empty.
    #[serde(skip_serializing_if="Option::is_none")]
    pub pull_requests: Option<Vec<CheckRunPullRequest>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub rerequestable: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub runs_rerequestable: Option<bool>,
    /// The summary status for all check runs that are part of the check suite. Can be `requested`, `in_progress`, or `completed`.
    #[serde(skip_serializing_if="Option::is_none")]
    pub status: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub updated_at: Option<chrono::DateTime<chrono::Utc>>,
    /// URL that points to the check suite API resource.
    #[serde(skip_serializing_if="Option::is_none")]
    pub url: Option<String>,
}

/// The [check_suite](https://docs.github.com/rest/checks/suites#get-a-check-suite).
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhookchecksuitererequestedCheckSuite {
    #[serde(skip_serializing_if="Option::is_none")]
    pub after: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub app: Option<App4>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub before: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub check_runs_url: Option<String>,
    /// The summary conclusion for all check runs that are part of the check suite. This value will be `null` until the check run has completed.
    #[serde(skip_serializing_if="Option::is_none")]
    pub conclusion: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The head branch name the changes are on.
    #[serde(skip_serializing_if="Option::is_none")]
    pub head_branch: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub head_commit: Option<SimpleCommit>,
    /// The SHA of the head commit that is being checked.
    #[serde(skip_serializing_if="Option::is_none")]
    pub head_sha: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub latest_check_runs_count: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub node_id: Option<String>,
    /// An array of pull requests that match this check suite. A pull request matches a check suite if they have the same `head_sha` and `head_branch`. When the check suite's `head_branch` is in a forked repository it will be `null` and the `pull_requests` array will be empty.
    #[serde(skip_serializing_if="Option::is_none")]
    pub pull_requests: Option<Vec<CheckRunPullRequest>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub rerequestable: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub runs_rerequestable: Option<bool>,
    /// The summary status for all check runs that are part of the check suite. Can be `requested`, `in_progress`, or `completed`.
    #[serde(skip_serializing_if="Option::is_none")]
    pub status: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub updated_at: Option<chrono::DateTime<chrono::Utc>>,
    /// URL that points to the check suite API resource.
    #[serde(skip_serializing_if="Option::is_none")]
    pub url: Option<String>,
}

/// The code scanning alert involved in the event.
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhookcodescanningalertappearedinbranchAlert {
    /// The time that the alert was created in ISO 8601 format: `YYYY-MM-DDTHH:MM:SSZ.`
    #[serde(skip_serializing_if="Option::is_none")]
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The time that the alert was dismissed in ISO 8601 format: `YYYY-MM-DDTHH:MM:SSZ`.
    #[serde(skip_serializing_if="Option::is_none")]
    pub dismissed_at: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub dismissed_by: Option<User1>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub dismissed_comment: Option<CodeScanningAlertDismissedComment>,
    /// The reason for dismissing or closing the alert.
    #[serde(skip_serializing_if="Option::is_none")]
    pub dismissed_reason: Option<String>,
    /// The time that the alert was fixed in ISO 8601 format: `YYYY-MM-DDTHH:MM:SSZ`.
    #[serde(skip_serializing_if="Option::is_none")]
    pub fixed_at: Option<Value>,
    /// The GitHub URL of the alert resource.
    #[serde(skip_serializing_if="Option::is_none")]
    pub html_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub most_recent_instance: Option<AlertInstance>,
    /// The code scanning alert number.
    #[serde(skip_serializing_if="Option::is_none")]
    pub number: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub rule: Option<WebhookcodescanningalertappearedinbranchAlertRule>,
    /// State of a code scanning alert. Events for alerts found outside the default branch will return a `null` value until they are dismissed or fixed.
    #[serde(skip_serializing_if="Option::is_none")]
    pub state: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub tool: Option<WebhookcodescanningalertappearedinbranchAlertTool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub url: Option<String>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhookcodescanningalertappearedinbranchAlertRule {
    /// A short description of the rule used to detect the alert.
    #[serde(skip_serializing_if="Option::is_none")]
    pub description: Option<String>,
    /// A unique identifier for the rule used to detect the alert.
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<String>,
    /// The severity of the alert.
    #[serde(skip_serializing_if="Option::is_none")]
    pub severity: Option<String>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhookcodescanningalertappearedinbranchAlertTool {
    /// The name of the tool used to generate the code scanning analysis alert.
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,
    /// The version of the tool used to detect the alert.
    #[serde(skip_serializing_if="Option::is_none")]
    pub version: Option<String>,
}

/// The code scanning alert involved in the event.
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhookcodescanningalertclosedbyuserAlert {
    /// The time that the alert was created in ISO 8601 format: `YYYY-MM-DDTHH:MM:SSZ.`
    #[serde(skip_serializing_if="Option::is_none")]
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The time that the alert was dismissed in ISO 8601 format: `YYYY-MM-DDTHH:MM:SSZ`.
    #[serde(skip_serializing_if="Option::is_none")]
    pub dismissed_at: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub dismissed_by: Option<User1>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub dismissed_comment: Option<CodeScanningAlertDismissedComment>,
    /// The reason for dismissing or closing the alert.
    #[serde(skip_serializing_if="Option::is_none")]
    pub dismissed_reason: Option<String>,
    /// The time that the alert was fixed in ISO 8601 format: `YYYY-MM-DDTHH:MM:SSZ`.
    #[serde(skip_serializing_if="Option::is_none")]
    pub fixed_at: Option<Value>,
    /// The GitHub URL of the alert resource.
    #[serde(skip_serializing_if="Option::is_none")]
    pub html_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub most_recent_instance: Option<AlertInstance>,
    /// The code scanning alert number.
    #[serde(skip_serializing_if="Option::is_none")]
    pub number: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub rule: Option<WebhookcodescanningalertclosedbyuserAlertRule>,
    /// State of a code scanning alert.
    #[serde(skip_serializing_if="Option::is_none")]
    pub state: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub tool: Option<WebhookcodescanningalertclosedbyuserAlertTool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub url: Option<String>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhookcodescanningalertclosedbyuserAlertRule {
    /// A short description of the rule used to detect the alert.
    #[serde(skip_serializing_if="Option::is_none")]
    pub description: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub full_description: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub help: Option<String>,
    /// A link to the documentation for the rule used to detect the alert.
    #[serde(skip_serializing_if="Option::is_none")]
    pub help_uri: Option<String>,
    /// A unique identifier for the rule used to detect the alert.
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,
    /// The severity of the alert.
    #[serde(skip_serializing_if="Option::is_none")]
    pub severity: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub tags: Option<Vec<String>>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhookcodescanningalertclosedbyuserAlertTool {
    #[serde(skip_serializing_if="Option::is_none")]
    pub guid: Option<String>,
    /// The name of the tool used to generate the code scanning analysis alert.
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,
    /// The version of the tool used to detect the alert.
    #[serde(skip_serializing_if="Option::is_none")]
    pub version: Option<String>,
}

/// The code scanning alert involved in the event.
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhookcodescanningalertcreatedAlert {
    /// The time that the alert was created in ISO 8601 format: `YYYY-MM-DDTHH:MM:SSZ.`
    #[serde(skip_serializing_if="Option::is_none")]
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The time that the alert was dismissed in ISO 8601 format: `YYYY-MM-DDTHH:MM:SSZ`.
    #[serde(skip_serializing_if="Option::is_none")]
    pub dismissed_at: Option<Value>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub dismissed_by: Option<Value>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub dismissed_comment: Option<CodeScanningAlertDismissedComment>,
    /// The reason for dismissing or closing the alert. Can be one of: `false positive`, `won't fix`, and `used in tests`.
    #[serde(skip_serializing_if="Option::is_none")]
    pub dismissed_reason: Option<Value>,
    /// The time that the alert was fixed in ISO 8601 format: `YYYY-MM-DDTHH:MM:SSZ`.
    #[serde(skip_serializing_if="Option::is_none")]
    pub fixed_at: Option<Value>,
    /// The GitHub URL of the alert resource.
    #[serde(skip_serializing_if="Option::is_none")]
    pub html_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub instances_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub most_recent_instance: Option<AlertInstance>,
    /// The code scanning alert number.
    #[serde(skip_serializing_if="Option::is_none")]
    pub number: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub rule: Option<WebhookcodescanningalertclosedbyuserAlertRule>,
    /// State of a code scanning alert. Events for alerts found outside the default branch will return a `null` value until they are dismissed or fixed.
    #[serde(skip_serializing_if="Option::is_none")]
    pub state: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub tool: Option<WebhookcodescanningalertclosedbyuserAlertTool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub updated_at: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub url: Option<String>,
}

/// The code scanning alert involved in the event.
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhookcodescanningalertfixedAlert {
    /// The time that the alert was created in ISO 8601 format: `YYYY-MM-DDTHH:MM:SSZ.`
    #[serde(skip_serializing_if="Option::is_none")]
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The time that the alert was dismissed in ISO 8601 format: `YYYY-MM-DDTHH:MM:SSZ`.
    #[serde(skip_serializing_if="Option::is_none")]
    pub dismissed_at: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub dismissed_by: Option<User1>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub dismissed_comment: Option<CodeScanningAlertDismissedComment>,
    /// The reason for dismissing or closing the alert.
    #[serde(skip_serializing_if="Option::is_none")]
    pub dismissed_reason: Option<String>,
    /// The time that the alert was fixed in ISO 8601 format: `YYYY-MM-DDTHH:MM:SSZ`.
    #[serde(skip_serializing_if="Option::is_none")]
    pub fixed_at: Option<Value>,
    /// The GitHub URL of the alert resource.
    #[serde(skip_serializing_if="Option::is_none")]
    pub html_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub instances_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub most_recent_instance: Option<AlertInstance>,
    /// The code scanning alert number.
    #[serde(skip_serializing_if="Option::is_none")]
    pub number: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub rule: Option<WebhookcodescanningalertclosedbyuserAlertRule>,
    /// State of a code scanning alert. Events for alerts found outside the default branch will return a `null` value until they are dismissed or fixed.
    #[serde(skip_serializing_if="Option::is_none")]
    pub state: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub tool: Option<WebhookcodescanningalertclosedbyuserAlertTool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub url: Option<String>,
}

/// The code scanning alert involved in the event.
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhookcodescanningalertreopenedAlert {
    /// The time that the alert was created in ISO 8601 format: `YYYY-MM-DDTHH:MM:SSZ.`
    #[serde(skip_serializing_if="Option::is_none")]
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The time that the alert was dismissed in ISO 8601 format: `YYYY-MM-DDTHH:MM:SSZ`.
    #[serde(skip_serializing_if="Option::is_none")]
    pub dismissed_at: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub dismissed_by: Option<HashMap<String, Value>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub dismissed_comment: Option<CodeScanningAlertDismissedComment>,
    /// The reason for dismissing or closing the alert. Can be one of: `false positive`, `won't fix`, and `used in tests`.
    #[serde(skip_serializing_if="Option::is_none")]
    pub dismissed_reason: Option<String>,
    /// The time that the alert was fixed in ISO 8601 format: `YYYY-MM-DDTHH:MM:SSZ`.
    #[serde(skip_serializing_if="Option::is_none")]
    pub fixed_at: Option<Value>,
    /// The GitHub URL of the alert resource.
    #[serde(skip_serializing_if="Option::is_none")]
    pub html_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub most_recent_instance: Option<AlertInstance>,
    /// The code scanning alert number.
    #[serde(skip_serializing_if="Option::is_none")]
    pub number: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub rule: Option<WebhookcodescanningalertclosedbyuserAlertRule>,
    /// State of a code scanning alert. Events for alerts found outside the default branch will return a `null` value until they are dismissed or fixed.
    #[serde(skip_serializing_if="Option::is_none")]
    pub state: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub tool: Option<WebhookcodescanningalertclosedbyuserAlertTool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub url: Option<String>,
}

/// The code scanning alert involved in the event.
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhookcodescanningalertreopenedbyuserAlert {
    /// The time that the alert was created in ISO 8601 format: `YYYY-MM-DDTHH:MM:SSZ.`
    #[serde(skip_serializing_if="Option::is_none")]
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The time that the alert was dismissed in ISO 8601 format: `YYYY-MM-DDTHH:MM:SSZ`.
    #[serde(skip_serializing_if="Option::is_none")]
    pub dismissed_at: Option<Value>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub dismissed_by: Option<Value>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub dismissed_comment: Option<CodeScanningAlertDismissedComment>,
    /// The reason for dismissing or closing the alert. Can be one of: `false positive`, `won't fix`, and `used in tests`.
    #[serde(skip_serializing_if="Option::is_none")]
    pub dismissed_reason: Option<Value>,
    /// The time that the alert was fixed in ISO 8601 format: `YYYY-MM-DDTHH:MM:SSZ`.
    #[serde(skip_serializing_if="Option::is_none")]
    pub fixed_at: Option<Value>,
    /// The GitHub URL of the alert resource.
    #[serde(skip_serializing_if="Option::is_none")]
    pub html_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub most_recent_instance: Option<AlertInstance>,
    /// The code scanning alert number.
    #[serde(skip_serializing_if="Option::is_none")]
    pub number: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub rule: Option<WebhookcodescanningalertappearedinbranchAlertRule>,
    /// State of a code scanning alert. Events for alerts found outside the default branch will return a `null` value until they are dismissed or fixed.
    #[serde(skip_serializing_if="Option::is_none")]
    pub state: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub tool: Option<WebhookcodescanningalertappearedinbranchAlertTool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub url: Option<String>,
}

/// The [commit comment](${externalDocsUpapp/api/description/components/schemas/webhooks/issue-comment-created.yamlrl}/rest/commits/comments#get-a-commit-comment) resource.
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhookcommitcommentcreatedComment {
    /// How the author is associated with the repository.
    #[serde(skip_serializing_if="Option::is_none")]
    pub author_association: Option<String>,
    /// The text of the comment.
    #[serde(skip_serializing_if="Option::is_none")]
    pub body: Option<String>,
    /// The SHA of the commit to which the comment applies.
    #[serde(skip_serializing_if="Option::is_none")]
    pub commit_id: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub created_at: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub html_url: Option<String>,
    /// The ID of the commit comment.
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<i64>,
    /// The line of the blob to which the comment applies. The last line of the range for a multi-line comment
    #[serde(skip_serializing_if="Option::is_none")]
    pub line: Option<i64>,
    /// The node ID of the commit comment.
    #[serde(skip_serializing_if="Option::is_none")]
    pub node_id: Option<String>,
    /// The relative path of the file to which the comment applies.
    #[serde(skip_serializing_if="Option::is_none")]
    pub path: Option<String>,
    /// The line index in the diff to which the comment applies.
    #[serde(skip_serializing_if="Option::is_none")]
    pub position: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub reactions: Option<Reactions>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub updated_at: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub user: Option<User>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhookcustompropertydeletedDefinition {
    /// The name of the property that was deleted.
    #[serde(skip_serializing_if="Option::is_none")]
    pub property_name: Option<String>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhookdeploymentreviewapprovedWorkflowJobRuns {
    #[serde(skip_serializing_if="Option::is_none")]
    pub conclusion: Option<Value>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub created_at: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub environment: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub html_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub status: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub updated_at: Option<String>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhookdeploymentreviewrejectedWorkflowJobRuns {
    #[serde(skip_serializing_if="Option::is_none")]
    pub conclusion: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub created_at: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub environment: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub html_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub status: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub updated_at: Option<String>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhookdeploymentreviewrequestedReviewers {
    #[serde(skip_serializing_if="Option::is_none")]
    pub reviewer: Option<User6>,
    #[serde(rename = "type")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub _type: Option<String>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhookdeploymentreviewrequestedWorkflowJobRun {
    #[serde(skip_serializing_if="Option::is_none")]
    pub conclusion: Option<Value>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub created_at: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub environment: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub html_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub status: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub updated_at: Option<String>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhookdeploymentstatuscreatedCheckRun {
    #[serde(skip_serializing_if="Option::is_none")]
    pub completed_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The result of the completed check run. This value will be `null` until the check run has completed.
    #[serde(skip_serializing_if="Option::is_none")]
    pub conclusion: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub details_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub external_id: Option<String>,
    /// The SHA of the commit that is being checked.
    #[serde(skip_serializing_if="Option::is_none")]
    pub head_sha: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub html_url: Option<String>,
    /// The id of the check.
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<i64>,
    /// The name of the check run.
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub node_id: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub started_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The current status of the check run. Can be `queued`, `in_progress`, or `completed`.
    #[serde(skip_serializing_if="Option::is_none")]
    pub status: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub url: Option<String>,
}

/// The [deployment status](https://docs.github.com/rest/deployments/statuses#list-deployment-statuses).
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhookdeploymentstatuscreatedDeploymentStatus {
    #[serde(skip_serializing_if="Option::is_none")]
    pub created_at: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub creator: Option<User1>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub deployment_url: Option<String>,
    /// The optional human-readable description added to the status.
    #[serde(skip_serializing_if="Option::is_none")]
    pub description: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub environment: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub environment_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub log_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub node_id: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub performed_via_github_app: Option<App7>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub repository_url: Option<String>,
    /// The new state. Can be `pending`, `success`, `failure`, or `error`.
    #[serde(skip_serializing_if="Option::is_none")]
    pub state: Option<String>,
    /// The optional link added to the status.
    #[serde(skip_serializing_if="Option::is_none")]
    pub target_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub updated_at: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub url: Option<String>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhookdiscussioncategorychangedChanges {
    #[serde(skip_serializing_if="Option::is_none")]
    pub category: Option<WebhookdiscussioncategorychangedChangesCategory>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhookdiscussioncategorychangedChangesCategory {
    #[serde(skip_serializing_if="Option::is_none")]
    pub from: Option<DiscussionCategory>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhookdiscussioncommenteditedChanges {
    #[serde(skip_serializing_if="Option::is_none")]
    pub body: Option<WebhookdiscussioncommenteditedChangesBody>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhookdiscussioncommenteditedChangesBody {
    #[serde(skip_serializing_if="Option::is_none")]
    pub from: Option<String>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhookdiscussioneditedChanges {
    #[serde(skip_serializing_if="Option::is_none")]
    pub body: Option<WebhookdiscussioncommenteditedChangesBody>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub title: Option<WebhookdiscussioncommenteditedChangesBody>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhookdiscussiontransferredChanges {
    #[serde(skip_serializing_if="Option::is_none")]
    pub new_discussion: Option<Discussion>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub new_repository: Option<RepositoryWebhooks>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhookgollumPages {
    /// The action that was performed on the page. Can be `created` or `edited`.
    #[serde(skip_serializing_if="Option::is_none")]
    pub action: Option<String>,
    /// Points to the HTML wiki page.
    #[serde(skip_serializing_if="Option::is_none")]
    pub html_url: Option<String>,
    /// The name of the page.
    #[serde(skip_serializing_if="Option::is_none")]
    pub page_name: Option<String>,
    /// The latest commit SHA of the page.
    #[serde(skip_serializing_if="Option::is_none")]
    pub sha: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub summary: Option<String>,
    /// The current page title.
    #[serde(skip_serializing_if="Option::is_none")]
    pub title: Option<String>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhookinstallationrepositoriesaddedRepositoriesRemoved {
    #[serde(skip_serializing_if="Option::is_none")]
    pub full_name: Option<String>,
    /// Unique identifier of the repository
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<i64>,
    /// The name of the repository.
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub node_id: Option<String>,
    /// Whether the repository is private or public.
    #[serde(skip_serializing_if="Option::is_none")]
    pub private: Option<bool>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhookinstallationtargetrenamedAccount {
    #[serde(skip_serializing_if="Option::is_none")]
    pub archived_at: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub avatar_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub created_at: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub description: Option<Value>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub events_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub followers: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub followers_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub following: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub following_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub gists_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub gravatar_id: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub has_organization_projects: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub has_repository_projects: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub hooks_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub html_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub is_verified: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub issues_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub login: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub members_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub node_id: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub organizations_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub public_gists: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub public_members_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub public_repos: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub received_events_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub repos_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub site_admin: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub slug: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub starred_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub subscriptions_url: Option<String>,
    #[serde(rename = "type")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub _type: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub updated_at: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub website_url: Option<Value>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub user_view_type: Option<String>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhookinstallationtargetrenamedChanges {
    #[serde(skip_serializing_if="Option::is_none")]
    pub login: Option<WebhookdiscussioncommenteditedChangesBody>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub slug: Option<WebhookdiscussioncommenteditedChangesBody>,
}

/// The changes to the issue.
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhookissueseditedChanges {
    #[serde(skip_serializing_if="Option::is_none")]
    pub body: Option<WebhooksChangesBody>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub title: Option<WebhookissueseditedChangesTitle>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhookissueseditedChangesTitle {
    /// The previous version of the title.
    #[serde(skip_serializing_if="Option::is_none")]
    pub from: Option<String>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhookissuesopenedChanges {
    #[serde(skip_serializing_if="Option::is_none")]
    pub old_issue: Option<Issue6>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub old_repository: Option<Repository1>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhookissuestransferredChanges {
    #[serde(skip_serializing_if="Option::is_none")]
    pub new_issue: Option<Issue6>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub new_repository: Option<Repository2>,
}

/// The changes to the label if the action was `edited`.
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhooklabeleditedChanges {
    #[serde(skip_serializing_if="Option::is_none")]
    pub color: Option<WebhooklabeleditedChangesColor>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub description: Option<WebhooklabeleditedChangesDescription>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<WebhooklabeleditedChangesName>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhooklabeleditedChangesColor {
    /// The previous version of the color if the action was `edited`.
    #[serde(skip_serializing_if="Option::is_none")]
    pub from: Option<String>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhooklabeleditedChangesDescription {
    /// The previous version of the description if the action was `edited`.
    #[serde(skip_serializing_if="Option::is_none")]
    pub from: Option<String>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhooklabeleditedChangesName {
    /// The previous version of the name if the action was `edited`.
    #[serde(skip_serializing_if="Option::is_none")]
    pub from: Option<String>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhookmemberaddedChanges {
    #[serde(skip_serializing_if="Option::is_none")]
    pub permission: Option<WebhookmemberaddedChangesPermission>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub role_name: Option<WebhookmemberaddedChangesRoleName>,
}

/// This field is included for legacy purposes; use the `role_name` field instead. The `maintain` role is mapped to `write` and the `triage` role is mapped to `read`. To determine the role assigned to the collaborator, use the `role_name` field instead, which will provide the full role name, including custom roles.
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhookmemberaddedChangesPermission {
    #[serde(skip_serializing_if="Option::is_none")]
    pub to: Option<String>,
}

/// The role assigned to the collaborator.
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhookmemberaddedChangesRoleName {
    #[serde(skip_serializing_if="Option::is_none")]
    pub to: Option<String>,
}

/// The changes to the collaborator permissions
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhookmembereditedChanges {
    #[serde(skip_serializing_if="Option::is_none")]
    pub old_permission: Option<WebhookmembereditedChangesOldPermission>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub permission: Option<WebhookmembereditedChangesPermission>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhookmembereditedChangesOldPermission {
    /// The previous permissions of the collaborator if the action was edited.
    #[serde(skip_serializing_if="Option::is_none")]
    pub from: Option<String>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhookmembereditedChangesPermission {
    #[serde(skip_serializing_if="Option::is_none")]
    pub from: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub to: Option<String>,
}

/// The modified webhook. This will contain different keys based on the type of webhook it is: repository, organization, business, app, or GitHub Marketplace.
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhookmetadeletedHook {
    #[serde(skip_serializing_if="Option::is_none")]
    pub active: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub config: Option<WebhookmetadeletedHookConfig>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub created_at: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub events: Option<Vec<String>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,
    #[serde(rename = "type")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub _type: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub updated_at: Option<String>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhookmetadeletedHookConfig {
    #[serde(skip_serializing_if="Option::is_none")]
    pub content_type: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub insecure_ssl: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub secret: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub url: Option<String>,
}

/// The changes to the milestone if the action was `edited`.
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhookmilestoneeditedChanges {
    #[serde(skip_serializing_if="Option::is_none")]
    pub description: Option<WebhooklabeleditedChangesDescription>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub due_on: Option<WebhookmilestoneeditedChangesDueOn>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub title: Option<WebhookmilestoneeditedChangesTitle>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhookmilestoneeditedChangesDueOn {
    /// The previous version of the due date if the action was `edited`.
    #[serde(skip_serializing_if="Option::is_none")]
    pub from: Option<String>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhookmilestoneeditedChangesTitle {
    /// The previous version of the title if the action was `edited`.
    #[serde(skip_serializing_if="Option::is_none")]
    pub from: Option<String>,
}

/// The invitation for the user or email if the action is `member_invited`.
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhookorganizationmemberinvitedInvitation {
    #[serde(skip_serializing_if="Option::is_none")]
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub email: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub failed_at: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub failed_reason: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<f64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub invitation_teams_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub inviter: Option<User1>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub login: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub node_id: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub role: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub team_count: Option<f64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub invitation_source: Option<String>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhookorganizationrenamedChanges {
    #[serde(skip_serializing_if="Option::is_none")]
    pub login: Option<WebhookorganizationrenamedChangesLogin>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhookorganizationrenamedChangesLogin {
    #[serde(skip_serializing_if="Option::is_none")]
    pub from: Option<String>,
}

/// Information about the package.
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhookpackagepublishedPackage {
    #[serde(skip_serializing_if="Option::is_none")]
    pub created_at: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub description: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub ecosystem: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub html_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub namespace: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub owner: Option<User1>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub package_type: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub package_version: Option<WebhookpackagepublishedPackagePackageVersion>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub registry: Option<WebhookpackagepublishedPackageRegistry>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub updated_at: Option<String>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhookpackagepublishedPackagePackageVersion {
    #[serde(skip_serializing_if="Option::is_none")]
    pub author: Option<User1>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub body: Option<OneOfwebhookpackagepublishedPackagePackageVersionBody>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub body_html: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub container_metadata: Option<WebhookpackagepublishedPackagePackageVersionContainerMetadata>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub created_at: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub description: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub docker_metadata: Option<Vec<WebhookpackagepublishedPackagePackageVersionDockerMetadata>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub draft: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub html_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub installation_command: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub manifest: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub metadata: Option<Vec<HashMap<String, HashMap<String, Value>>>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub npm_metadata: Option<WebhookpackagepublishedPackagePackageVersionNpmMetadata>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub nuget_metadata: Option<Vec<WebhookpackagepublishedPackagePackageVersionNugetMetadata>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub package_files: Option<Vec<WebhookpackagepublishedPackagePackageVersionPackageFiles>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub package_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub prerelease: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub release: Option<WebhookpackagepublishedPackagePackageVersionRelease>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub rubygems_metadata: Option<Vec<WebhookRubygemsMetadata>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub source_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub summary: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub tag_name: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub target_commitish: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub target_oid: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub updated_at: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub version: Option<String>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhookpackagepublishedPackagePackageVersionContainerMetadata {
    #[serde(skip_serializing_if="Option::is_none")]
    pub labels: Option<HashMap<String, Value>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub manifest: Option<HashMap<String, Value>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub tag: Option<WebhookpackagepublishedPackagePackageVersionContainerMetadataTag>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhookpackagepublishedPackagePackageVersionContainerMetadataTag {
    #[serde(skip_serializing_if="Option::is_none")]
    pub digest: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhookpackagepublishedPackagePackageVersionDockerMetadata {
    #[serde(skip_serializing_if="Option::is_none")]
    pub tags: Option<Vec<String>>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhookpackagepublishedPackagePackageVersionNpmMetadata {
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub version: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub npm_user: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub author: Option<HashMap<String, Value>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub bugs: Option<HashMap<String, Value>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub dependencies: Option<HashMap<String, Value>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub dev_dependencies: Option<HashMap<String, Value>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub peer_dependencies: Option<HashMap<String, Value>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub optional_dependencies: Option<HashMap<String, Value>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub description: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub dist: Option<HashMap<String, Value>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub git_head: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub homepage: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub license: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub main: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub repository: Option<HashMap<String, Value>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub scripts: Option<HashMap<String, Value>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub node_version: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub npm_version: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub has_shrinkwrap: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub maintainers: Option<Vec<Value>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub contributors: Option<Vec<Value>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub engines: Option<HashMap<String, Value>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub keywords: Option<Vec<String>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub files: Option<Vec<String>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub bin: Option<HashMap<String, Value>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub man: Option<HashMap<String, Value>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub directories: Option<HashMap<String, Value>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub os: Option<Vec<String>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub cpu: Option<Vec<String>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub readme: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub installation_command: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub release_id: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub commit_oid: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub published_via_actions: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub deleted_by_id: Option<i64>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhookpackagepublishedPackagePackageVersionNugetMetadata {
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<OneOfwebhookpackagepublishedPackagePackageVersionNugetMetadataId>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub value: Option<OneOfwebhookpackagepublishedPackagePackageVersionNugetMetadataValue>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhookpackagepublishedPackagePackageVersionPackageFiles {
    #[serde(skip_serializing_if="Option::is_none")]
    pub content_type: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub created_at: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub download_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub md5: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub sha1: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub sha256: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub size: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub state: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub updated_at: Option<String>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhookpackagepublishedPackagePackageVersionRelease {
    #[serde(skip_serializing_if="Option::is_none")]
    pub author: Option<User1>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub created_at: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub draft: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub html_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub prerelease: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub published_at: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub tag_name: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub target_commitish: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub url: Option<String>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhookpackagepublishedPackageRegistry {
    #[serde(skip_serializing_if="Option::is_none")]
    pub about_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,
    #[serde(rename = "type")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub _type: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub vendor: Option<String>,
}

/// Information about the package.
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhookpackageupdatedPackage {
    #[serde(skip_serializing_if="Option::is_none")]
    pub created_at: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub description: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub ecosystem: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub html_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub namespace: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub owner: Option<User1>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub package_type: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub package_version: Option<WebhookpackageupdatedPackagePackageVersion>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub registry: Option<WebhookpackagepublishedPackageRegistry>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub updated_at: Option<String>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhookpackageupdatedPackagePackageVersion {
    #[serde(skip_serializing_if="Option::is_none")]
    pub author: Option<User1>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub body: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub body_html: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub created_at: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub description: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub docker_metadata: Option<Vec<WebhookpackagepublishedPackagePackageVersionDockerMetadata>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub draft: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub html_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub installation_command: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub manifest: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub metadata: Option<Vec<HashMap<String, HashMap<String, Value>>>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub package_files: Option<Vec<WebhookpackageupdatedPackagePackageVersionPackageFiles>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub package_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub prerelease: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub release: Option<WebhookpackageupdatedPackagePackageVersionRelease>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub rubygems_metadata: Option<Vec<WebhookRubygemsMetadata>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub source_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub summary: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub tag_name: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub target_commitish: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub target_oid: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub updated_at: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub version: Option<String>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhookpackageupdatedPackagePackageVersionPackageFiles {
    #[serde(skip_serializing_if="Option::is_none")]
    pub content_type: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub created_at: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub download_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub md5: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub sha1: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub sha256: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub size: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub state: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub updated_at: Option<String>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhookpackageupdatedPackagePackageVersionRelease {
    #[serde(skip_serializing_if="Option::is_none")]
    pub author: Option<User1>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub created_at: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub draft: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub html_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub prerelease: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub published_at: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub tag_name: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub target_commitish: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub url: Option<String>,
}

/// The [List GitHub Pages builds](https://docs.github.com/rest/pages/pages#list-github-pages-builds) itself.
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhookpagebuildBuild {
    #[serde(skip_serializing_if="Option::is_none")]
    pub commit: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub created_at: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub duration: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub error: Option<PagebuildError>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub pusher: Option<User1>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub status: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub updated_at: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub url: Option<String>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhookprojectcardconvertedChanges {
    #[serde(skip_serializing_if="Option::is_none")]
    pub note: Option<WebhookdiscussioncommenteditedChangesBody>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhookprojectcardeditedChanges {
    #[serde(skip_serializing_if="Option::is_none")]
    pub note: Option<WebhookprojectcardeditedChangesNote>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhookprojectcardeditedChangesNote {
    #[serde(skip_serializing_if="Option::is_none")]
    pub from: Option<String>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhookprojectcardmovedChanges {
    #[serde(skip_serializing_if="Option::is_none")]
    pub column_id: Option<WebhookprojectcardmovedChangesColumnId>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhookprojectcardmovedChangesColumnId {
    #[serde(skip_serializing_if="Option::is_none")]
    pub from: Option<i64>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhookprojectcolumneditedChanges {
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<WebhookdiscussioncommenteditedChangesBody>,
}

/// The changes to the project if the action was `edited`.
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhookprojecteditedChanges {
    #[serde(skip_serializing_if="Option::is_none")]
    pub body: Option<WebhookprojecteditedChangesBody>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<WebhookprojecteditedChangesName>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhookprojecteditedChangesBody {
    /// The previous version of the body if the action was `edited`.
    #[serde(skip_serializing_if="Option::is_none")]
    pub from: Option<String>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhookprojecteditedChangesName {
    /// The changes to the project if the action was `edited`.
    #[serde(skip_serializing_if="Option::is_none")]
    pub from: Option<String>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct Webhookprojectsv2itemconvertedChanges {
    #[serde(skip_serializing_if="Option::is_none")]
    pub content_type: Option<Webhookprojectsv2itemconvertedChangesContentType>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct Webhookprojectsv2itemconvertedChangesContentType {
    #[serde(skip_serializing_if="Option::is_none")]
    pub from: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub to: Option<String>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct Webhookprojectsv2itemreorderedChanges {
    #[serde(skip_serializing_if="Option::is_none")]
    pub previous_projects_v2_item_node_id: Option<WebhookmembereditedChangesPermission>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct Webhookprojectsv2projecteditedChanges {
    #[serde(skip_serializing_if="Option::is_none")]
    pub description: Option<WebhookmembereditedChangesPermission>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub public: Option<Webhookprojectsv2projecteditedChangesPublic>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub short_description: Option<WebhookmembereditedChangesPermission>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub title: Option<Webhookprojectsv2projecteditedChangesTitle>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct Webhookprojectsv2projecteditedChangesPublic {
    #[serde(skip_serializing_if="Option::is_none")]
    pub from: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub to: Option<bool>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct Webhookprojectsv2projecteditedChangesTitle {
    #[serde(skip_serializing_if="Option::is_none")]
    pub from: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub to: Option<String>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct Webhookprojectsv2statusupdateeditedChanges {
    #[serde(skip_serializing_if="Option::is_none")]
    pub body: Option<WebhookmembereditedChangesPermission>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub status: Option<Webhookprojectsv2statusupdateeditedChangesStatus>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub start_date: Option<Webhookprojectsv2statusupdateeditedChangesStartDate>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub target_date: Option<Webhookprojectsv2statusupdateeditedChangesStartDate>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct Webhookprojectsv2statusupdateeditedChangesStartDate {
    #[serde(skip_serializing_if="Option::is_none")]
    pub from: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub to: Option<chrono::DateTime<chrono::Utc>>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct Webhookprojectsv2statusupdateeditedChangesStatus {
    #[serde(skip_serializing_if="Option::is_none")]
    pub from: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub to: Option<String>,
}

/// The changes to the comment if the action was `edited`.
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhookpullrequesteditedChanges {
    #[serde(skip_serializing_if="Option::is_none")]
    pub base: Option<WebhookpullrequesteditedChangesBase>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub body: Option<WebhookprojecteditedChangesBody>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub title: Option<WebhookmilestoneeditedChangesTitle>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhookpullrequesteditedChangesBase {
    #[serde(rename = "ref")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub git_ref: Option<WebhookdiscussioncommenteditedChangesBody>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub sha: Option<WebhookdiscussioncommenteditedChangesBody>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhookpullrequestreviewcommentcreatedPullRequest {
    #[serde(skip_serializing_if="Option::is_none")]
    pub _links: Option<WebhooksPullRequest5Links>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub active_lock_reason: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub assignee: Option<User3>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub assignees: Option<Vec<User4>>,
    /// How the author is associated with the repository.
    #[serde(skip_serializing_if="Option::is_none")]
    pub author_association: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub auto_merge: Option<PullRequestAutoMerge>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub base: Option<PullRequestBase>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub body: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub closed_at: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub comments_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub commits_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub created_at: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub diff_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub draft: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub head: Option<WebhookpullrequestreviewcommentcreatedPullRequestHead>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub html_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub issue_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub labels: Option<Vec<Label>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub locked: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub merge_commit_sha: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub merged_at: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub milestone: Option<Milestone>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub node_id: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub number: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub patch_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub requested_reviewers: Option<Vec<OneOfwebhookpullrequestreviewcommentcreatedPullRequestRequestedReviewersItems>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub requested_teams: Option<Vec<Team>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub review_comment_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub review_comments_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub state: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub statuses_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub title: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub updated_at: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub user: Option<User2>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhookpullrequestreviewcommentcreatedPullRequestHead {
    #[serde(skip_serializing_if="Option::is_none")]
    pub label: Option<String>,
    #[serde(rename = "ref")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub git_ref: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub repo: Option<Repository6>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub sha: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub user: Option<User>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhookpullrequestreviewcommentdeletedPullRequest {
    #[serde(skip_serializing_if="Option::is_none")]
    pub _links: Option<WebhooksPullRequest5Links>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub active_lock_reason: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub assignee: Option<User1>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub assignees: Option<Vec<User5>>,
    /// How the author is associated with the repository.
    #[serde(skip_serializing_if="Option::is_none")]
    pub author_association: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub auto_merge: Option<PullRequestAutoMerge>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub base: Option<PullRequestBase>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub body: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub closed_at: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub comments_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub commits_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub created_at: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub diff_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub draft: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub head: Option<PullRequestBase>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub html_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub issue_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub labels: Option<Vec<Label>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub locked: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub merge_commit_sha: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub merged_at: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub milestone: Option<Milestone1>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub node_id: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub number: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub patch_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub requested_reviewers: Option<Vec<OneOfwebhookpullrequestreviewcommentdeletedPullRequestRequestedReviewersItems>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub requested_teams: Option<Vec<Team>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub review_comment_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub review_comments_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub state: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub statuses_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub title: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub updated_at: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub user: Option<User2>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhookpullrequestreviewcommenteditedPullRequest {
    #[serde(skip_serializing_if="Option::is_none")]
    pub _links: Option<WebhooksPullRequest5Links>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub active_lock_reason: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub assignee: Option<User1>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub assignees: Option<Vec<User1>>,
    /// How the author is associated with the repository.
    #[serde(skip_serializing_if="Option::is_none")]
    pub author_association: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub auto_merge: Option<PullRequestAutoMerge>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub base: Option<PullRequestBase>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub body: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub closed_at: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub comments_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub commits_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub created_at: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub diff_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub draft: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub head: Option<PullRequestBase>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub html_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub issue_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub labels: Option<Vec<Label>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub locked: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub merge_commit_sha: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub merged_at: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub milestone: Option<Milestone>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub node_id: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub number: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub patch_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub requested_reviewers: Option<Vec<OneOfwebhookpullrequestreviewcommenteditedPullRequestRequestedReviewersItems>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub requested_teams: Option<Vec<Team>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub review_comment_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub review_comments_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub state: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub statuses_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub title: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub updated_at: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub user: Option<User7>,
}

/// The review that was affected.
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhookpullrequestreviewdismissedReview {
    #[serde(skip_serializing_if="Option::is_none")]
    pub _links: Option<WebhooksReviewLinks>,
    /// How the author is associated with the repository.
    #[serde(skip_serializing_if="Option::is_none")]
    pub author_association: Option<String>,
    /// The text of the review.
    #[serde(skip_serializing_if="Option::is_none")]
    pub body: Option<String>,
    /// A commit SHA for the review.
    #[serde(skip_serializing_if="Option::is_none")]
    pub commit_id: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub html_url: Option<String>,
    /// Unique identifier of the review
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub node_id: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub pull_request_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub state: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub submitted_at: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub user: Option<User2>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhookpullrequestrevieweditedChanges {
    #[serde(skip_serializing_if="Option::is_none")]
    pub body: Option<WebhookprojecteditedChangesBody>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhookpullrequestreviewthreadresolvedThread {
    #[serde(skip_serializing_if="Option::is_none")]
    pub comments: Option<Vec<PullRequestReviewComment1>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub node_id: Option<String>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhookpullrequestreviewthreadunresolvedThread {
    #[serde(skip_serializing_if="Option::is_none")]
    pub comments: Option<Vec<PullRequestReviewComment2>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub node_id: Option<String>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhookregistrypackagepublishedRegistryPackage {
    #[serde(skip_serializing_if="Option::is_none")]
    pub created_at: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub description: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub ecosystem: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub html_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub namespace: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub owner: Option<WebhookregistrypackagepublishedRegistryPackageOwner>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub package_type: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub package_version: Option<WebhookregistrypackagepublishedRegistryPackagePackageVersion>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub registry: Option<WebhookregistrypackagepublishedRegistryPackageRegistry>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub updated_at: Option<String>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhookregistrypackagepublishedRegistryPackageOwner {
    #[serde(skip_serializing_if="Option::is_none")]
    pub avatar_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub events_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub followers_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub following_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub gists_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub gravatar_id: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub html_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub login: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub node_id: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub organizations_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub received_events_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub repos_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub site_admin: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub starred_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub subscriptions_url: Option<String>,
    #[serde(rename = "type")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub _type: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub user_view_type: Option<String>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhookregistrypackagepublishedRegistryPackagePackageVersion {
    #[serde(skip_serializing_if="Option::is_none")]
    pub author: Option<WebhookregistrypackagepublishedRegistryPackageOwner>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub body: Option<OneOfwebhookregistrypackagepublishedRegistryPackagePackageVersionBody>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub body_html: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub container_metadata: Option<WebhookpackagepublishedPackagePackageVersionContainerMetadata>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub created_at: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub description: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub docker_metadata: Option<Vec<WebhookpackagepublishedPackagePackageVersionDockerMetadata>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub draft: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub html_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub installation_command: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub manifest: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub metadata: Option<Vec<HashMap<String, HashMap<String, Value>>>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub npm_metadata: Option<WebhookregistrypackagepublishedRegistryPackagePackageVersionNpmMetadata>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub nuget_metadata: Option<Vec<WebhookregistrypackagepublishedRegistryPackagePackageVersionNugetMetadata>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub package_files: Option<Vec<WebhookregistrypackagepublishedRegistryPackagePackageVersionPackageFiles>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub package_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub prerelease: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub release: Option<WebhookregistrypackagepublishedRegistryPackagePackageVersionRelease>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub rubygems_metadata: Option<Vec<WebhookRubygemsMetadata>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub summary: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub tag_name: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub target_commitish: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub target_oid: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub updated_at: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub version: Option<String>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhookregistrypackagepublishedRegistryPackagePackageVersionNpmMetadata {
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub version: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub npm_user: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub author: Option<OneOfwebhookregistrypackagepublishedRegistryPackagePackageVersionNpmMetadataAuthor>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub bugs: Option<OneOfwebhookregistrypackagepublishedRegistryPackagePackageVersionNpmMetadataBugs>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub dependencies: Option<HashMap<String, Value>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub dev_dependencies: Option<HashMap<String, Value>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub peer_dependencies: Option<HashMap<String, Value>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub optional_dependencies: Option<HashMap<String, Value>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub description: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub dist: Option<OneOfwebhookregistrypackagepublishedRegistryPackagePackageVersionNpmMetadataDist>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub git_head: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub homepage: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub license: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub main: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub repository: Option<OneOfwebhookregistrypackagepublishedRegistryPackagePackageVersionNpmMetadataRepository>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub scripts: Option<HashMap<String, Value>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub node_version: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub npm_version: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub has_shrinkwrap: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub maintainers: Option<Vec<String>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub contributors: Option<Vec<String>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub engines: Option<HashMap<String, Value>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub keywords: Option<Vec<String>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub files: Option<Vec<String>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub bin: Option<HashMap<String, Value>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub man: Option<HashMap<String, Value>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub directories: Option<OneOfwebhookregistrypackagepublishedRegistryPackagePackageVersionNpmMetadataDirectories>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub os: Option<Vec<String>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub cpu: Option<Vec<String>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub readme: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub installation_command: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub release_id: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub commit_oid: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub published_via_actions: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub deleted_by_id: Option<i64>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhookregistrypackagepublishedRegistryPackagePackageVersionNugetMetadata {
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<OneOfwebhookregistrypackagepublishedRegistryPackagePackageVersionNugetMetadataId>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub value: Option<OneOfwebhookregistrypackagepublishedRegistryPackagePackageVersionNugetMetadataValue>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhookregistrypackagepublishedRegistryPackagePackageVersionPackageFiles {
    #[serde(skip_serializing_if="Option::is_none")]
    pub content_type: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub created_at: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub download_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub md5: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub sha1: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub sha256: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub size: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub state: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub updated_at: Option<String>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhookregistrypackagepublishedRegistryPackagePackageVersionRelease {
    #[serde(skip_serializing_if="Option::is_none")]
    pub author: Option<WebhooksSponsorshipMaintainer>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub created_at: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub draft: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub html_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub prerelease: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub published_at: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub tag_name: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub target_commitish: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub url: Option<String>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhookregistrypackagepublishedRegistryPackageRegistry {
    #[serde(skip_serializing_if="Option::is_none")]
    pub about_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,
    #[serde(rename = "type")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub _type: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub vendor: Option<String>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhookregistrypackageupdatedRegistryPackage {
    #[serde(skip_serializing_if="Option::is_none")]
    pub created_at: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub description: Option<Value>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub ecosystem: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub html_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub namespace: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub owner: Option<WebhookregistrypackagepublishedRegistryPackageOwner>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub package_type: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub package_version: Option<WebhookregistrypackageupdatedRegistryPackagePackageVersion>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub registry: Option<HashMap<String, Value>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub updated_at: Option<String>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhookregistrypackageupdatedRegistryPackagePackageVersion {
    #[serde(skip_serializing_if="Option::is_none")]
    pub author: Option<WebhookregistrypackagepublishedRegistryPackageOwner>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub body: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub body_html: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub created_at: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub description: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub docker_metadata: Option<Vec<WebhookpackagepublishedPackagePackageVersionDockerMetadata>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub draft: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub html_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub installation_command: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub manifest: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub metadata: Option<Vec<HashMap<String, HashMap<String, Value>>>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub package_files: Option<Vec<WebhookregistrypackageupdatedRegistryPackagePackageVersionPackageFiles>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub package_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub prerelease: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub release: Option<WebhookregistrypackageupdatedRegistryPackagePackageVersionRelease>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub rubygems_metadata: Option<Vec<WebhookRubygemsMetadata>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub summary: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub tag_name: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub target_commitish: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub target_oid: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub updated_at: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub version: Option<String>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhookregistrypackageupdatedRegistryPackagePackageVersionPackageFiles {
    #[serde(skip_serializing_if="Option::is_none")]
    pub content_type: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub created_at: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub download_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub md5: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub sha1: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub sha256: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub size: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub state: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub updated_at: Option<String>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhookregistrypackageupdatedRegistryPackagePackageVersionRelease {
    #[serde(skip_serializing_if="Option::is_none")]
    pub author: Option<WebhookregistrypackagepublishedRegistryPackageOwner>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub created_at: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub draft: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub html_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub prerelease: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub published_at: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub tag_name: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub target_commitish: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub url: Option<String>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhookreleaseeditedChanges {
    #[serde(skip_serializing_if="Option::is_none")]
    pub body: Option<WebhookprojecteditedChangesBody>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<WebhooklabeleditedChangesName>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub make_latest: Option<WebhookreleaseeditedChangesMakeLatest>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhookreleaseeditedChangesMakeLatest {
    /// Whether this release was explicitly `edited` to be the latest.
    #[serde(skip_serializing_if="Option::is_none")]
    pub to: Option<bool>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhookrepositoryeditedChanges {
    #[serde(skip_serializing_if="Option::is_none")]
    pub default_branch: Option<WebhookdiscussioncommenteditedChangesBody>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub description: Option<WebhookprojectcardeditedChangesNote>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub homepage: Option<WebhookprojectcardeditedChangesNote>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub topics: Option<WebhookrepositoryeditedChangesTopics>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhookrepositoryeditedChangesTopics {
    #[serde(skip_serializing_if="Option::is_none")]
    pub from: Option<Vec<String>>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhookrepositoryrenamedChanges {
    #[serde(skip_serializing_if="Option::is_none")]
    pub repository: Option<WebhookrepositoryrenamedChangesRepository>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhookrepositoryrenamedChangesRepository {
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<WebhookdiscussioncommenteditedChangesBody>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhookrepositoryruleseteditedChanges {
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<WebhookorganizationrenamedChangesLogin>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub enforcement: Option<WebhookorganizationrenamedChangesLogin>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub conditions: Option<WebhookrepositoryruleseteditedChangesConditions>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub rules: Option<WebhookrepositoryruleseteditedChangesRules>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhookrepositoryruleseteditedChangesConditions {
    #[serde(skip_serializing_if="Option::is_none")]
    pub added: Option<Vec<RepositoryRulesetConditions>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub deleted: Option<Vec<RepositoryRulesetConditions>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub updated: Option<Vec<WebhookrepositoryruleseteditedChangesConditionsUpdated>>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhookrepositoryruleseteditedChangesConditionsChanges {
    #[serde(skip_serializing_if="Option::is_none")]
    pub condition_type: Option<WebhookorganizationrenamedChangesLogin>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub target: Option<WebhookorganizationrenamedChangesLogin>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub include: Option<WebhookrepositoryruleseteditedChangesConditionsChangesInclude>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub exclude: Option<WebhookrepositoryruleseteditedChangesConditionsChangesInclude>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhookrepositoryruleseteditedChangesConditionsChangesInclude {
    #[serde(skip_serializing_if="Option::is_none")]
    pub from: Option<Vec<String>>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhookrepositoryruleseteditedChangesConditionsUpdated {
    #[serde(skip_serializing_if="Option::is_none")]
    pub condition: Option<RepositoryRulesetConditions>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub changes: Option<WebhookrepositoryruleseteditedChangesConditionsChanges>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhookrepositoryruleseteditedChangesRules {
    #[serde(skip_serializing_if="Option::is_none")]
    pub added: Option<Vec<RepositoryRule>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub deleted: Option<Vec<RepositoryRule>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub updated: Option<Vec<WebhookrepositoryruleseteditedChangesRulesUpdated>>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhookrepositoryruleseteditedChangesRulesChanges {
    #[serde(skip_serializing_if="Option::is_none")]
    pub configuration: Option<WebhookorganizationrenamedChangesLogin>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub rule_type: Option<WebhookorganizationrenamedChangesLogin>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub pattern: Option<WebhookorganizationrenamedChangesLogin>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhookrepositoryruleseteditedChangesRulesUpdated {
    #[serde(skip_serializing_if="Option::is_none")]
    pub rule: Option<RepositoryRule>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub changes: Option<WebhookrepositoryruleseteditedChangesRulesChanges>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhookrepositorytransferredChanges {
    #[serde(skip_serializing_if="Option::is_none")]
    pub owner: Option<WebhookrepositorytransferredChangesOwner>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhookrepositorytransferredChangesOwner {
    #[serde(skip_serializing_if="Option::is_none")]
    pub from: Option<WebhookrepositorytransferredChangesOwnerFrom>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhookrepositorytransferredChangesOwnerFrom {
    #[serde(skip_serializing_if="Option::is_none")]
    pub organization: Option<Organization>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub user: Option<User>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhookrubygemsmetadataVersionInfo {
    #[serde(skip_serializing_if="Option::is_none")]
    pub version: Option<String>,
}

/// The security alert of the vulnerable dependency.
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhooksAlert {
    #[serde(skip_serializing_if="Option::is_none")]
    pub affected_package_name: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub affected_range: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub created_at: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub dismiss_reason: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub dismissed_at: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub dismisser: Option<User5>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub external_identifier: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub external_reference: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub fix_reason: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub fixed_at: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub fixed_in: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub ghsa_id: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub node_id: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub number: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub severity: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub state: Option<String>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhooksAnswer {
    /// How the author is associated with the repository.
    #[serde(skip_serializing_if="Option::is_none")]
    pub author_association: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub body: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub child_comment_count: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub discussion_id: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub html_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub node_id: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub parent_id: Option<Value>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub reactions: Option<Reactions>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub repository_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub updated_at: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub user: Option<User>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhooksApprover {
    #[serde(skip_serializing_if="Option::is_none")]
    pub avatar_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub events_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub followers_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub following_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub gists_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub gravatar_id: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub html_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub login: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub node_id: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub organizations_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub received_events_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub repos_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub site_admin: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub starred_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub subscriptions_url: Option<String>,
    #[serde(rename = "type")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub _type: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub user_view_type: Option<String>,
}

/// The changes to the comment.
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhooksChanges {
    #[serde(skip_serializing_if="Option::is_none")]
    pub body: Option<WebhooksChangesBody>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhooksChanges8 {
    #[serde(skip_serializing_if="Option::is_none")]
    pub tier: Option<WebhooksChanges8Tier>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhooksChanges8Tier {
    #[serde(skip_serializing_if="Option::is_none")]
    pub from: Option<SponsorshipTier>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhooksChangesBody {
    /// The previous version of the body.
    #[serde(skip_serializing_if="Option::is_none")]
    pub from: Option<String>,
}

/// The commit SHA of the code scanning alert. When the action is `reopened_by_user` or `closed_by_user`, the event was triggered by the `sender` and this value will be empty.
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhooksCodeScanningCommitOid {
}

/// The Git reference of the code scanning alert. When the action is `reopened_by_user` or `closed_by_user`, the event was triggered by the `sender` and this value will be empty.
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhooksCodeScanningRef {
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhooksComment {
    /// How the author is associated with the repository.
    #[serde(skip_serializing_if="Option::is_none")]
    pub author_association: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub body: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub child_comment_count: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub created_at: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub discussion_id: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub html_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub node_id: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub parent_id: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub reactions: Option<Reactions>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub repository_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub updated_at: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub user: Option<User>,
}

/// The [`deploy key`](https://docs.github.com/rest/deploy-keys/deploy-keys#get-a-deploy-key) resource.
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhooksDeployKey {
    #[serde(skip_serializing_if="Option::is_none")]
    pub added_by: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub created_at: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub key: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub last_used: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub read_only: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub title: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub verified: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub enabled: Option<bool>,
}

/// The pusher type for the event. Can be either `user` or a deploy key.
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhooksDeployPusherType {
}

/// The `pending_cancellation` and `pending_tier_change` event types will include the date the cancellation or tier change will take effect.
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhooksEffectiveDate {
}

/// The [issue](https://docs.github.com/rest/issues/issues#get-an-issue) itself.
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhooksIssue {
    #[serde(skip_serializing_if="Option::is_none")]
    pub active_lock_reason: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub assignee: Option<User3>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub assignees: Option<Vec<User3>>,
    /// How the author is associated with the repository.
    #[serde(skip_serializing_if="Option::is_none")]
    pub author_association: Option<String>,
    /// Contents of the issue
    #[serde(skip_serializing_if="Option::is_none")]
    pub body: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub closed_at: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub comments: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub comments_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub draft: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub events_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub html_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub labels: Option<Vec<Label>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub labels_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub locked: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub milestone: Option<Milestone>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub node_id: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub number: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub performed_via_github_app: Option<App>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub pull_request: Option<WebhooksIssuePullRequest>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub reactions: Option<Reactions>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub repository_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub sub_issues_summary: Option<SubissuesSummary>,
    /// State of the issue; either 'open' or 'closed'
    #[serde(skip_serializing_if="Option::is_none")]
    pub state: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub state_reason: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub timeline_url: Option<String>,
    /// Title of the issue
    #[serde(skip_serializing_if="Option::is_none")]
    pub title: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub updated_at: Option<chrono::DateTime<chrono::Utc>>,
    /// URL for the issue
    #[serde(skip_serializing_if="Option::is_none")]
    pub url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub user: Option<User2>,
}

/// The [issue](https://docs.github.com/rest/issues/issues#get-an-issue) itself.
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhooksIssue2 {
    #[serde(skip_serializing_if="Option::is_none")]
    pub active_lock_reason: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub assignee: Option<User1>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub assignees: Option<Vec<User1>>,
    /// How the author is associated with the repository.
    #[serde(skip_serializing_if="Option::is_none")]
    pub author_association: Option<String>,
    /// Contents of the issue
    #[serde(skip_serializing_if="Option::is_none")]
    pub body: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub closed_at: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub comments: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub comments_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub draft: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub events_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub html_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub labels: Option<Vec<Label>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub labels_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub locked: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub milestone: Option<Milestone1>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub node_id: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub number: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub performed_via_github_app: Option<App1>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub pull_request: Option<WebhooksIssuePullRequest>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub reactions: Option<Reactions>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub repository_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub sub_issues_summary: Option<SubissuesSummary>,
    /// State of the issue; either 'open' or 'closed'
    #[serde(skip_serializing_if="Option::is_none")]
    pub state: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub state_reason: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub timeline_url: Option<String>,
    /// Title of the issue
    #[serde(skip_serializing_if="Option::is_none")]
    pub title: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub updated_at: Option<chrono::DateTime<chrono::Utc>>,
    /// URL for the issue
    #[serde(skip_serializing_if="Option::is_none")]
    pub url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub user: Option<User>,
}

/// The [comment](https://docs.github.com/rest/issues/comments#get-an-issue-comment) itself.
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhooksIssueComment {
    /// How the author is associated with the repository.
    #[serde(skip_serializing_if="Option::is_none")]
    pub author_association: Option<String>,
    /// Contents of the issue comment
    #[serde(skip_serializing_if="Option::is_none")]
    pub body: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub html_url: Option<String>,
    /// Unique identifier of the issue comment
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub issue_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub node_id: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub performed_via_github_app: Option<Integration>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub reactions: Option<Reactions>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub updated_at: Option<chrono::DateTime<chrono::Utc>>,
    /// URL for the issue comment
    #[serde(skip_serializing_if="Option::is_none")]
    pub url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub user: Option<User2>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhooksIssuePullRequest {
    #[serde(skip_serializing_if="Option::is_none")]
    pub diff_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub html_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub merged_at: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub patch_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub url: Option<String>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhooksLabel {
    /// 6-character hex code, without the leading #, identifying the color
    #[serde(skip_serializing_if="Option::is_none")]
    pub color: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub default: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub description: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<i64>,
    /// The name of the label.
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub node_id: Option<String>,
    /// URL for the label
    #[serde(skip_serializing_if="Option::is_none")]
    pub url: Option<String>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhooksMarketplacePurchase {
    #[serde(skip_serializing_if="Option::is_none")]
    pub account: Option<WebhooksMarketplacePurchaseAccount>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub billing_cycle: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub free_trial_ends_on: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub next_billing_date: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub on_free_trial: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub plan: Option<WebhooksMarketplacePurchasePlan>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub unit_count: Option<i64>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhooksMarketplacePurchaseAccount {
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub login: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub node_id: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub organization_billing_email: Option<String>,
    #[serde(rename = "type")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub _type: Option<String>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhooksMarketplacePurchasePlan {
    #[serde(skip_serializing_if="Option::is_none")]
    pub bullets: Option<Vec<String>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub description: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub has_free_trial: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub monthly_price_in_cents: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub price_model: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub unit_name: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub yearly_price_in_cents: Option<i64>,
}

/// The membership between the user and the organization. Not present when the action is `member_invited`.
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhooksMembership {
    #[serde(skip_serializing_if="Option::is_none")]
    pub organization_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub role: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub state: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub user: Option<User>,
}

/// A collection of related issues and pull requests.
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhooksMilestone {
    #[serde(skip_serializing_if="Option::is_none")]
    pub closed_at: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub closed_issues: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub creator: Option<User3>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub description: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub due_on: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub html_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub labels_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub node_id: Option<String>,
    /// The number of the milestone.
    #[serde(skip_serializing_if="Option::is_none")]
    pub number: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub open_issues: Option<i64>,
    /// The state of the milestone.
    #[serde(skip_serializing_if="Option::is_none")]
    pub state: Option<String>,
    /// The title of the milestone.
    #[serde(skip_serializing_if="Option::is_none")]
    pub title: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub updated_at: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub url: Option<String>,
}

/// A collection of related issues and pull requests.
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhooksMilestone3 {
    #[serde(skip_serializing_if="Option::is_none")]
    pub closed_at: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub closed_issues: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub creator: Option<User1>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub description: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub due_on: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub html_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub labels_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub node_id: Option<String>,
    /// The number of the milestone.
    #[serde(skip_serializing_if="Option::is_none")]
    pub number: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub open_issues: Option<i64>,
    /// The state of the milestone.
    #[serde(skip_serializing_if="Option::is_none")]
    pub state: Option<String>,
    /// The title of the milestone.
    #[serde(skip_serializing_if="Option::is_none")]
    pub title: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub updated_at: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub url: Option<String>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhooksNullableString {
}

/// The pull request number.
pub type WebhooksNumber = i32;

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhooksPreviousMarketplacePurchase {
    #[serde(skip_serializing_if="Option::is_none")]
    pub account: Option<WebhooksMarketplacePurchaseAccount>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub billing_cycle: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub free_trial_ends_on: Option<Value>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub next_billing_date: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub on_free_trial: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub plan: Option<WebhooksPreviousMarketplacePurchasePlan>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub unit_count: Option<i64>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhooksPreviousMarketplacePurchasePlan {
    #[serde(skip_serializing_if="Option::is_none")]
    pub bullets: Option<Vec<String>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub description: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub has_free_trial: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub monthly_price_in_cents: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub price_model: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub unit_name: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub yearly_price_in_cents: Option<i64>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhooksProject {
    /// Body of the project
    #[serde(skip_serializing_if="Option::is_none")]
    pub body: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub columns_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub creator: Option<User1>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub html_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<i64>,
    /// Name of the project
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub node_id: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub number: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub owner_url: Option<String>,
    /// State of the project; either 'open' or 'closed'
    #[serde(skip_serializing_if="Option::is_none")]
    pub state: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub updated_at: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub url: Option<String>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhooksProjectCard {
    #[serde(skip_serializing_if="Option::is_none")]
    pub after_id: Option<i64>,
    /// Whether or not the card is archived
    #[serde(skip_serializing_if="Option::is_none")]
    pub archived: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub column_id: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub column_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub content_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub creator: Option<User1>,
    /// The project card's ID
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub node_id: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub note: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub project_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub updated_at: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub url: Option<String>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhooksProjectChanges {
    #[serde(skip_serializing_if="Option::is_none")]
    pub archived_at: Option<WebhooksProjectChangesArchivedAt>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhooksProjectChangesArchivedAt {
    #[serde(skip_serializing_if="Option::is_none")]
    pub from: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub to: Option<chrono::DateTime<chrono::Utc>>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhooksProjectColumn {
    #[serde(skip_serializing_if="Option::is_none")]
    pub after_id: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub cards_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The unique identifier of the project column
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<i64>,
    /// Name of the project column
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub node_id: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub project_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub updated_at: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub url: Option<String>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhooksPullRequest5 {
    #[serde(skip_serializing_if="Option::is_none")]
    pub _links: Option<WebhooksPullRequest5Links>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub active_lock_reason: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub additions: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub assignee: Option<User3>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub assignees: Option<Vec<User4>>,
    /// How the author is associated with the repository.
    #[serde(skip_serializing_if="Option::is_none")]
    pub author_association: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub auto_merge: Option<PullRequestAutoMerge>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub base: Option<WebhooksPullRequest5Base>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub body: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub changed_files: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub closed_at: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub comments: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub comments_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub commits: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub commits_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub deletions: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub diff_url: Option<String>,
    /// Indicates whether or not the pull request is a draft.
    #[serde(skip_serializing_if="Option::is_none")]
    pub draft: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub head: Option<WebhooksPullRequest5Base>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub html_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub issue_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub labels: Option<Vec<Label>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub locked: Option<bool>,
    /// Indicates whether maintainers can modify the pull request.
    #[serde(skip_serializing_if="Option::is_none")]
    pub maintainer_can_modify: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub merge_commit_sha: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub mergeable: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub mergeable_state: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub merged: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub merged_at: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub merged_by: Option<User3>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub milestone: Option<Milestone>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub node_id: Option<String>,
    /// Number uniquely identifying the pull request within its repository.
    #[serde(skip_serializing_if="Option::is_none")]
    pub number: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub patch_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub rebaseable: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub requested_reviewers: Option<Vec<OneOfwebhooksPullRequest5RequestedReviewersItems>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub requested_teams: Option<Vec<Team>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub review_comment_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub review_comments: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub review_comments_url: Option<String>,
    /// State of this Pull Request. Either `open` or `closed`.
    #[serde(skip_serializing_if="Option::is_none")]
    pub state: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub statuses_url: Option<String>,
    /// The title of the pull request.
    #[serde(skip_serializing_if="Option::is_none")]
    pub title: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub updated_at: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub user: Option<User2>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhooksPullRequest5Base {
    #[serde(skip_serializing_if="Option::is_none")]
    pub label: Option<String>,
    #[serde(rename = "ref")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub git_ref: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub repo: Option<Repository>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub sha: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub user: Option<User>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhooksPullRequest5Links {
    #[serde(skip_serializing_if="Option::is_none")]
    pub comments: Option<Link>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub commits: Option<Link>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub html: Option<Link>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub issue: Option<Link>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub review_comment: Option<Link>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub review_comments: Option<Link>,
    #[serde(rename = "self")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub _self: Option<Link>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub statuses: Option<Link>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhooksPullRequest5Parent {
    /// Description of the team
    #[serde(skip_serializing_if="Option::is_none")]
    pub description: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub html_url: Option<String>,
    /// Unique identifier of the team
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub members_url: Option<String>,
    /// Name of the team
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub node_id: Option<String>,
    /// Permission that the team will have for its repositories
    #[serde(skip_serializing_if="Option::is_none")]
    pub permission: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub privacy: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub repositories_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub slug: Option<String>,
    /// URL for the team
    #[serde(skip_serializing_if="Option::is_none")]
    pub url: Option<String>,
}

/// The [`git ref`](https://docs.github.com/rest/git/refs#get-a-reference) resource.
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhooksRef0 {
}

/// The [release](https://docs.github.com/rest/releases/releases/#get-a-release) object.
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhooksRelease {
    #[serde(skip_serializing_if="Option::is_none")]
    pub assets: Option<Vec<ReleaseAsset>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub assets_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub author: Option<User1>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub body: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub discussion_url: Option<String>,
    /// Whether the release is a draft or published
    #[serde(skip_serializing_if="Option::is_none")]
    pub draft: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub html_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub node_id: Option<String>,
    /// Whether the release is identified as a prerelease or a full release.
    #[serde(skip_serializing_if="Option::is_none")]
    pub prerelease: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub published_at: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub reactions: Option<Reactions>,
    /// The name of the tag.
    #[serde(skip_serializing_if="Option::is_none")]
    pub tag_name: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub tarball_url: Option<String>,
    /// Specifies the commitish value that determines where the Git tag is created from.
    #[serde(skip_serializing_if="Option::is_none")]
    pub target_commitish: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub upload_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub zipball_url: Option<String>,
}

/// The [release](https://docs.github.com/rest/releases/releases/#get-a-release) object.
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhooksRelease1 {
    #[serde(skip_serializing_if="Option::is_none")]
    pub assets: Option<Vec<ReleaseAsset>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub assets_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub author: Option<User1>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub body: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub discussion_url: Option<String>,
    /// Whether the release is a draft or published
    #[serde(skip_serializing_if="Option::is_none")]
    pub draft: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub html_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub node_id: Option<String>,
    /// Whether the release is identified as a prerelease or a full release.
    #[serde(skip_serializing_if="Option::is_none")]
    pub prerelease: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub published_at: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub reactions: Option<Reactions>,
    /// The name of the tag.
    #[serde(skip_serializing_if="Option::is_none")]
    pub tag_name: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub tarball_url: Option<String>,
    /// Specifies the commitish value that determines where the Git tag is created from.
    #[serde(skip_serializing_if="Option::is_none")]
    pub target_commitish: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub upload_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub zipball_url: Option<String>,
}

/// An array of repository objects that the installation can access.
pub type WebhooksRepositories = Vec<WebhooksRepositoriesInner>;

/// An array of repository objects, which were added to the installation.
pub type WebhooksRepositoriesAdded = Vec<WebhooksRepositoriesInner>;

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhooksRepositoriesInner {
    #[serde(skip_serializing_if="Option::is_none")]
    pub full_name: Option<String>,
    /// Unique identifier of the repository
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<i64>,
    /// The name of the repository.
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub node_id: Option<String>,
    /// Whether the repository is private or public.
    #[serde(skip_serializing_if="Option::is_none")]
    pub private: Option<bool>,
}

/// Describe whether all repositories have been selected or there's a selection involved
/// Enumeration of values.
/// Since this enum's variants do not hold data, we can easily define them them as `#[repr(C)]`
/// which helps with FFI.
#[allow(non_camel_case_types)]
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq, PartialOrd, Serialize, Deserialize, Eq, Ord)]
pub enum WebhooksRepositorySelection { 
    #[serde(rename = "all")]
    ALL,
    #[serde(rename = "selected")]
    SELECTED,
}

impl Display for WebhooksRepositorySelection {
    fn fmt(&self, f: &mut Formatter) -> fmt::Result {
        match *self { 
            WebhooksRepositorySelection::ALL => write!(f, "{}", "all"),
            WebhooksRepositorySelection::SELECTED => write!(f, "{}", "selected"),
        }
    }
}

impl std::str::FromStr for WebhooksRepositorySelection {
    type Err = ();
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s {
            "all" => Ok(WebhooksRepositorySelection::ALL),
            "selected" => Ok(WebhooksRepositorySelection::SELECTED),
            _ => Err(()),
        }
    }
}

/// The review that was affected.
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhooksReview {
    #[serde(skip_serializing_if="Option::is_none")]
    pub _links: Option<WebhooksReviewLinks>,
    /// How the author is associated with the repository.
    #[serde(skip_serializing_if="Option::is_none")]
    pub author_association: Option<String>,
    /// The text of the review.
    #[serde(skip_serializing_if="Option::is_none")]
    pub body: Option<String>,
    /// A commit SHA for the review.
    #[serde(skip_serializing_if="Option::is_none")]
    pub commit_id: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub html_url: Option<String>,
    /// Unique identifier of the review
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub node_id: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub pull_request_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub state: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub submitted_at: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub user: Option<User>,
}

/// The [comment](https://docs.github.com/rest/pulls/comments#get-a-review-comment-for-a-pull-request) itself.
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhooksReviewComment {
    #[serde(skip_serializing_if="Option::is_none")]
    pub _links: Option<WebhooksReviewCommentLinks>,
    /// How the author is associated with the repository.
    #[serde(skip_serializing_if="Option::is_none")]
    pub author_association: Option<String>,
    /// The text of the comment.
    #[serde(skip_serializing_if="Option::is_none")]
    pub body: Option<String>,
    /// The SHA of the commit to which the comment applies.
    #[serde(skip_serializing_if="Option::is_none")]
    pub commit_id: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The diff of the line that the comment refers to.
    #[serde(skip_serializing_if="Option::is_none")]
    pub diff_hunk: Option<String>,
    /// HTML URL for the pull request review comment.
    #[serde(skip_serializing_if="Option::is_none")]
    pub html_url: Option<String>,
    /// The ID of the pull request review comment.
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<i64>,
    /// The comment ID to reply to.
    #[serde(skip_serializing_if="Option::is_none")]
    pub in_reply_to_id: Option<i64>,
    /// The line of the blob to which the comment applies. The last line of the range for a multi-line comment
    #[serde(skip_serializing_if="Option::is_none")]
    pub line: Option<i64>,
    /// The node ID of the pull request review comment.
    #[serde(skip_serializing_if="Option::is_none")]
    pub node_id: Option<String>,
    /// The SHA of the original commit to which the comment applies.
    #[serde(skip_serializing_if="Option::is_none")]
    pub original_commit_id: Option<String>,
    /// The line of the blob to which the comment applies. The last line of the range for a multi-line comment
    #[serde(skip_serializing_if="Option::is_none")]
    pub original_line: Option<i64>,
    /// The index of the original line in the diff to which the comment applies.
    #[serde(skip_serializing_if="Option::is_none")]
    pub original_position: Option<i64>,
    /// The first line of the range for a multi-line comment.
    #[serde(skip_serializing_if="Option::is_none")]
    pub original_start_line: Option<i64>,
    /// The relative path of the file to which the comment applies.
    #[serde(skip_serializing_if="Option::is_none")]
    pub path: Option<String>,
    /// The line index in the diff to which the comment applies.
    #[serde(skip_serializing_if="Option::is_none")]
    pub position: Option<i64>,
    /// The ID of the pull request review to which the comment belongs.
    #[serde(skip_serializing_if="Option::is_none")]
    pub pull_request_review_id: Option<i64>,
    /// URL for the pull request that the review comment belongs to.
    #[serde(skip_serializing_if="Option::is_none")]
    pub pull_request_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub reactions: Option<Reactions>,
    /// The side of the first line of the range for a multi-line comment.
    #[serde(skip_serializing_if="Option::is_none")]
    pub side: Option<String>,
    /// The first line of the range for a multi-line comment.
    #[serde(skip_serializing_if="Option::is_none")]
    pub start_line: Option<i64>,
    /// The side of the first line of the range for a multi-line comment.
    #[serde(skip_serializing_if="Option::is_none")]
    pub start_side: Option<String>,
    /// The level at which the comment is targeted, can be a diff line or a file.
    #[serde(skip_serializing_if="Option::is_none")]
    pub subject_type: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub updated_at: Option<chrono::DateTime<chrono::Utc>>,
    /// URL for the pull request review comment
    #[serde(skip_serializing_if="Option::is_none")]
    pub url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub user: Option<User>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhooksReviewCommentLinks {
    #[serde(skip_serializing_if="Option::is_none")]
    pub html: Option<Link>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub pull_request: Option<Link>,
    #[serde(rename = "self")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub _self: Option<Link>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhooksReviewLinks {
    #[serde(skip_serializing_if="Option::is_none")]
    pub html: Option<Link>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub pull_request: Option<Link>,
}

pub type WebhooksReviewers = Vec<WebhooksReviewersInner>;

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhooksReviewersInner {
    #[serde(skip_serializing_if="Option::is_none")]
    pub reviewer: Option<HashMap<String, Value>>,
    #[serde(rename = "type")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub _type: Option<String>,
}

/// The branch protection rule. Includes a `name` and all the [branch protection settings](https://docs.github.com/github/administering-a-repository/defining-the-mergeability-of-pull-requests/about-protected-branches#about-branch-protection-settings) applied to branches that match the name. Binary settings are boolean. Multi-level configurations are one of `off`, `non_admins`, or `everyone`. Actor and build lists are arrays of strings.
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhooksRule {
    #[serde(skip_serializing_if="Option::is_none")]
    pub admin_enforced: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub allow_deletions_enforcement_level: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub allow_force_pushes_enforcement_level: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub authorized_actor_names: Option<Vec<String>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub authorized_actors_only: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub authorized_dismissal_actors_only: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub create_protected: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub dismiss_stale_reviews_on_push: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub ignore_approvals_from_contributors: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub linear_history_requirement_enforcement_level: Option<String>,
    /// The enforcement level of the branch lock setting. `off` means the branch is not locked, `non_admins` means the branch is read-only for non_admins, and `everyone` means the branch is read-only for everyone.
    #[serde(skip_serializing_if="Option::is_none")]
    pub lock_branch_enforcement_level: Option<String>,
    /// Whether users can pull changes from upstream when the branch is locked. Set to `true` to allow users to pull changes from upstream when the branch is locked. This setting is only applicable for forks.
    #[serde(skip_serializing_if="Option::is_none")]
    pub lock_allows_fork_sync: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub merge_queue_enforcement_level: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub pull_request_reviews_enforcement_level: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub repository_id: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub require_code_owner_review: Option<bool>,
    /// Whether the most recent push must be approved by someone other than the person who pushed it
    #[serde(skip_serializing_if="Option::is_none")]
    pub require_last_push_approval: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub required_approving_review_count: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub required_conversation_resolution_level: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub required_deployments_enforcement_level: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub required_status_checks: Option<Vec<String>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub required_status_checks_enforcement_level: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub signature_requirement_enforcement_level: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub strict_required_status_checks_policy: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub updated_at: Option<chrono::DateTime<chrono::Utc>>,
}

/// The details of the security advisory, including summary, description, and severity.
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhooksSecurityAdvisory {
    #[serde(skip_serializing_if="Option::is_none")]
    pub cvss: Option<WebhooksSecurityAdvisoryCvss>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub cvss_severities: Option<CvssSeverities>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub cwes: Option<Vec<WebhooksSecurityAdvisoryCwes>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub description: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub ghsa_id: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub identifiers: Option<Vec<WebhooksSecurityAdvisoryIdentifiers>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub published_at: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub references: Option<Vec<WebhooksSecurityAdvisoryReferences>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub severity: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub summary: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub updated_at: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub vulnerabilities: Option<Vec<WebhooksSecurityAdvisoryVulnerabilities>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub withdrawn_at: Option<String>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhooksSecurityAdvisoryCvss {
    #[serde(skip_serializing_if="Option::is_none")]
    pub score: Option<f64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub vector_string: Option<String>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhooksSecurityAdvisoryCwes {
    #[serde(skip_serializing_if="Option::is_none")]
    pub cwe_id: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhooksSecurityAdvisoryFirstPatchedVersion {
    #[serde(skip_serializing_if="Option::is_none")]
    pub identifier: Option<String>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhooksSecurityAdvisoryIdentifiers {
    #[serde(rename = "type")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub _type: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub value: Option<String>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhooksSecurityAdvisoryPackage {
    #[serde(skip_serializing_if="Option::is_none")]
    pub ecosystem: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhooksSecurityAdvisoryReferences {
    #[serde(skip_serializing_if="Option::is_none")]
    pub url: Option<String>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhooksSecurityAdvisoryVulnerabilities {
    #[serde(skip_serializing_if="Option::is_none")]
    pub first_patched_version: Option<WebhooksSecurityAdvisoryFirstPatchedVersion>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub package: Option<WebhooksSecurityAdvisoryPackage>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub severity: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub vulnerable_version_range: Option<String>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhooksSponsorship {
    #[serde(skip_serializing_if="Option::is_none")]
    pub created_at: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub maintainer: Option<WebhooksSponsorshipMaintainer>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub node_id: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub privacy_level: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub sponsor: Option<User1>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub sponsorable: Option<User1>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub tier: Option<SponsorshipTier>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhooksSponsorshipMaintainer {
    #[serde(skip_serializing_if="Option::is_none")]
    pub avatar_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub events_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub followers_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub following_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub gists_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub gravatar_id: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub html_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub login: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub node_id: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub organizations_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub received_events_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub repos_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub site_admin: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub starred_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub subscriptions_url: Option<String>,
    #[serde(rename = "type")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub _type: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub user_view_type: Option<String>,
}

/// Groups of organization members that gives permissions on specified repositories.
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhooksTeam {
    #[serde(skip_serializing_if="Option::is_none")]
    pub deleted: Option<bool>,
    /// Description of the team
    #[serde(skip_serializing_if="Option::is_none")]
    pub description: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub html_url: Option<String>,
    /// Unique identifier of the team
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub members_url: Option<String>,
    /// Name of the team
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub node_id: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub parent: Option<WebhooksTeamParent>,
    /// Permission that the team will have for its repositories
    #[serde(skip_serializing_if="Option::is_none")]
    pub permission: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub privacy: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub notification_setting: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub repositories_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub slug: Option<String>,
    /// URL for the team
    #[serde(skip_serializing_if="Option::is_none")]
    pub url: Option<String>,
}

/// Groups of organization members that gives permissions on specified repositories.
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhooksTeam1 {
    #[serde(skip_serializing_if="Option::is_none")]
    pub deleted: Option<bool>,
    /// Description of the team
    #[serde(skip_serializing_if="Option::is_none")]
    pub description: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub html_url: Option<String>,
    /// Unique identifier of the team
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub members_url: Option<String>,
    /// Name of the team
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub node_id: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub parent: Option<WebhooksTeamParent>,
    /// Permission that the team will have for its repositories
    #[serde(skip_serializing_if="Option::is_none")]
    pub permission: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub privacy: Option<String>,
    /// Whether team members will receive notifications when their team is @mentioned
    #[serde(skip_serializing_if="Option::is_none")]
    pub notification_setting: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub repositories_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub slug: Option<String>,
    /// URL for the team
    #[serde(skip_serializing_if="Option::is_none")]
    pub url: Option<String>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhooksTeamParent {
    /// Description of the team
    #[serde(skip_serializing_if="Option::is_none")]
    pub description: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub html_url: Option<String>,
    /// Unique identifier of the team
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub members_url: Option<String>,
    /// Name of the team
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub node_id: Option<String>,
    /// Permission that the team will have for its repositories
    #[serde(skip_serializing_if="Option::is_none")]
    pub permission: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub privacy: Option<String>,
    /// Whether team members will receive notifications when their team is @mentioned
    #[serde(skip_serializing_if="Option::is_none")]
    pub notification_setting: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub repositories_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub slug: Option<String>,
    /// URL for the team
    #[serde(skip_serializing_if="Option::is_none")]
    pub url: Option<String>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhooksUser {
    #[serde(skip_serializing_if="Option::is_none")]
    pub avatar_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub deleted: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub email: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub events_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub followers_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub following_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub gists_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub gravatar_id: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub html_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub login: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub node_id: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub organizations_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub received_events_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub repos_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub site_admin: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub starred_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub subscriptions_url: Option<String>,
    #[serde(rename = "type")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub _type: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub user_view_type: Option<String>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhooksUserMannequin {
    #[serde(skip_serializing_if="Option::is_none")]
    pub avatar_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub deleted: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub email: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub events_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub followers_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub following_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub gists_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub gravatar_id: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub html_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub login: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub node_id: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub organizations_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub received_events_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub repos_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub site_admin: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub starred_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub subscriptions_url: Option<String>,
    #[serde(rename = "type")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub _type: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub user_view_type: Option<String>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhooksWorkflow {
    #[serde(skip_serializing_if="Option::is_none")]
    pub badge_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub html_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub node_id: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub path: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub state: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub updated_at: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub url: Option<String>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhooksWorkflowJobRun {
    #[serde(skip_serializing_if="Option::is_none")]
    pub conclusion: Option<Value>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub created_at: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub environment: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub html_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<Value>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub status: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub updated_at: Option<String>,
}

/// The details of the security advisory, including summary, description, and severity.
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhooksecurityadvisorywithdrawnSecurityAdvisory {
    #[serde(skip_serializing_if="Option::is_none")]
    pub cvss: Option<WebhooksSecurityAdvisoryCvss>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub cvss_severities: Option<CvssSeverities>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub cwes: Option<Vec<WebhooksSecurityAdvisoryCwes>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub description: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub ghsa_id: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub identifiers: Option<Vec<WebhooksSecurityAdvisoryIdentifiers>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub published_at: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub references: Option<Vec<WebhooksSecurityAdvisoryReferences>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub severity: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub summary: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub updated_at: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub vulnerabilities: Option<Vec<WebhooksSecurityAdvisoryVulnerabilities>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub withdrawn_at: Option<String>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhooksecurityandanalysisChanges {
    #[serde(skip_serializing_if="Option::is_none")]
    pub from: Option<WebhooksecurityandanalysisChangesFrom>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhooksecurityandanalysisChangesFrom {
    #[serde(skip_serializing_if="Option::is_none")]
    pub security_and_analysis: Option<SecurityAndAnalysis>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhooksponsorshipeditedChanges {
    #[serde(skip_serializing_if="Option::is_none")]
    pub privacy_level: Option<WebhooksponsorshipeditedChangesPrivacyLevel>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhooksponsorshipeditedChangesPrivacyLevel {
    /// The `edited` event types include the details about the change when someone edits a sponsorship to change the privacy.
    #[serde(skip_serializing_if="Option::is_none")]
    pub from: Option<String>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhookstatusBranches {
    #[serde(skip_serializing_if="Option::is_none")]
    pub commit: Option<WebhookstatusCommit>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub protected: Option<bool>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhookstatusCommit {
    #[serde(skip_serializing_if="Option::is_none")]
    pub sha: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub url: Option<String>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhookstatusCommit1 {
    #[serde(skip_serializing_if="Option::is_none")]
    pub author: Option<User8>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub comments_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub commit: Option<WebhookstatusCommit1Commit>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub committer: Option<User8>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub html_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub node_id: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub parents: Option<Vec<WebhookstatusCommit1Parents>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub sha: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub url: Option<String>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhookstatusCommit1Commit {
    #[serde(skip_serializing_if="Option::is_none")]
    pub author: Option<AllOfwebhookstatusCommit1CommitAuthor>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub comment_count: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub committer: Option<AllOfwebhookstatusCommit1CommitCommitter>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub message: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub tree: Option<ShortbranchCommit>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub verification: Option<WebhookstatusCommit1CommitVerification>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhookstatusCommit1CommitVerification {
    #[serde(skip_serializing_if="Option::is_none")]
    pub payload: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub reason: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub signature: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub verified: Option<bool>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub verified_at: Option<String>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhookstatusCommit1Parents {
    #[serde(skip_serializing_if="Option::is_none")]
    pub html_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub sha: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub url: Option<String>,
}

/// The changes to the team if the action was `edited`.
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhookteameditedChanges {
    #[serde(skip_serializing_if="Option::is_none")]
    pub description: Option<WebhooklabeleditedChangesDescription>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<WebhooklabeleditedChangesName>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub privacy: Option<WebhookteameditedChangesPrivacy>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub notification_setting: Option<WebhookteameditedChangesNotificationSetting>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub repository: Option<WebhookteameditedChangesRepository>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhookteameditedChangesNotificationSetting {
    /// The previous version of the team's notification setting if the action was `edited`.
    #[serde(skip_serializing_if="Option::is_none")]
    pub from: Option<String>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhookteameditedChangesPrivacy {
    /// The previous version of the team's privacy if the action was `edited`.
    #[serde(skip_serializing_if="Option::is_none")]
    pub from: Option<String>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhookteameditedChangesRepository {
    #[serde(skip_serializing_if="Option::is_none")]
    pub permissions: Option<WebhookteameditedChangesRepositoryPermissions>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhookteameditedChangesRepositoryPermissions {
    #[serde(skip_serializing_if="Option::is_none")]
    pub from: Option<WebhookteameditedChangesRepositoryPermissionsFrom>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhookteameditedChangesRepositoryPermissionsFrom {
    /// The previous version of the team member's `admin` permission on a repository, if the action was `edited`.
    #[serde(skip_serializing_if="Option::is_none")]
    pub admin: Option<bool>,
    /// The previous version of the team member's `pull` permission on a repository, if the action was `edited`.
    #[serde(skip_serializing_if="Option::is_none")]
    pub pull: Option<bool>,
    /// The previous version of the team member's `push` permission on a repository, if the action was `edited`.
    #[serde(skip_serializing_if="Option::is_none")]
    pub push: Option<bool>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhookworkflowjobqueuedWorkflowJob {
    #[serde(skip_serializing_if="Option::is_none")]
    pub check_run_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub completed_at: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub conclusion: Option<String>,
    /// The time that the job created.
    #[serde(skip_serializing_if="Option::is_none")]
    pub created_at: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub head_sha: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub html_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub labels: Option<Vec<String>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub node_id: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub run_attempt: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub run_id: Option<f64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub run_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub runner_group_id: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub runner_group_name: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub runner_id: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub runner_name: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub started_at: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub status: Option<String>,
    /// The name of the current branch.
    #[serde(skip_serializing_if="Option::is_none")]
    pub head_branch: Option<String>,
    /// The name of the workflow.
    #[serde(skip_serializing_if="Option::is_none")]
    pub workflow_name: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub steps: Option<Vec<WorkflowStep>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub url: Option<String>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WebhookworkflowjobwaitingWorkflowJob {
    #[serde(skip_serializing_if="Option::is_none")]
    pub check_run_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub completed_at: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub conclusion: Option<String>,
    /// The time that the job created.
    #[serde(skip_serializing_if="Option::is_none")]
    pub created_at: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub head_sha: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub html_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub labels: Option<Vec<String>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub node_id: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub run_attempt: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub run_id: Option<f64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub run_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub runner_group_id: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub runner_group_name: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub runner_id: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub runner_name: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub started_at: Option<chrono::DateTime<chrono::Utc>>,
    /// The name of the current branch.
    #[serde(skip_serializing_if="Option::is_none")]
    pub head_branch: Option<String>,
    /// The name of the workflow.
    #[serde(skip_serializing_if="Option::is_none")]
    pub workflow_name: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub status: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub steps: Option<Vec<WorkflowStep1>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub url: Option<String>,
}

/// A GitHub Actions workflow
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct Workflow {
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub node_id: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub path: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub state: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub updated_at: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub html_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub badge_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub deleted_at: Option<chrono::DateTime<chrono::Utc>>,
}

#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
#[serde(untagged)]
pub enum WorkflowId { 
    WorkflowIdVariant0(i32),
    WorkflowIdVariant1(String),
}

impl From<i32> for WorkflowId {
    fn from(value: i32) -> Self {
        WorkflowId::WorkflowIdVariant0(value)
    }
}

impl From<String> for WorkflowId {
    fn from(value: String) -> Self {
        WorkflowId::WorkflowIdVariant1(value)
    }
}

impl Display for WorkflowId {
    fn fmt(&self, f: &mut Formatter) -> fmt::Result {
        match self { 
            WorkflowId::WorkflowIdVariant0(value) => write!(f, "{}", value),
            WorkflowId::WorkflowIdVariant1(value) => write!(f, "{}", value),
        }
    }
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WorkflowRun {
    #[serde(skip_serializing_if="Option::is_none")]
    pub actor: Option<User1>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub artifacts_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub cancel_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub check_suite_id: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub check_suite_node_id: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub check_suite_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub conclusion: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub event: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub head_branch: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub head_commit: Option<SimpleCommit>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub head_repository: Option<RepositoryLite>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub head_sha: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub html_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub jobs_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub logs_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub node_id: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub path: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub previous_attempt_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub pull_requests: Option<Vec<WorkflowRunPullRequests>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub referenced_workflows: Option<Vec<DeploymentWorkflowRunReferencedWorkflows>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub repository: Option<RepositoryLite>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub rerun_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub run_attempt: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub run_number: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub run_started_at: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub status: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub triggering_actor: Option<User1>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub updated_at: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub workflow_id: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub workflow_url: Option<String>,
    /// The event-specific title associated with the run or the run-name if set, or the value of `run-name` if it is set in the workflow.
    #[serde(skip_serializing_if="Option::is_none")]
    pub display_title: Option<String>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WorkflowRun1 {
    #[serde(skip_serializing_if="Option::is_none")]
    pub actor: Option<User5>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub artifacts_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub cancel_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub check_suite_id: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub check_suite_node_id: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub check_suite_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub conclusion: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub event: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub head_branch: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub head_commit: Option<SimpleCommit>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub head_repository: Option<RepositoryLite1>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub head_sha: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub html_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub jobs_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub logs_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub node_id: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub path: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub previous_attempt_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub pull_requests: Option<Vec<WorkflowRunPullRequests>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub referenced_workflows: Option<Vec<DeploymentWorkflowRunReferencedWorkflows>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub repository: Option<RepositoryLite2>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub rerun_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub run_attempt: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub run_number: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub run_started_at: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub status: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub triggering_actor: Option<User5>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub updated_at: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub workflow_id: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub workflow_url: Option<String>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WorkflowRun2 {
    #[serde(skip_serializing_if="Option::is_none")]
    pub actor: Option<User1>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub artifacts_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub cancel_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub check_suite_id: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub check_suite_node_id: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub check_suite_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub conclusion: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub created_at: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub event: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub head_branch: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub head_commit: Option<SimpleCommit>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub head_repository: Option<RepositoryLite>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub head_sha: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub html_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub jobs_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub logs_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub node_id: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub path: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub previous_attempt_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub pull_requests: Option<Vec<WorkflowRunPullRequests>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub referenced_workflows: Option<Vec<DeploymentWorkflowRunReferencedWorkflows>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub repository: Option<RepositoryLite>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub rerun_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub run_attempt: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub run_number: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub run_started_at: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub status: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub triggering_actor: Option<User1>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub updated_at: Option<chrono::DateTime<chrono::Utc>>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub workflow_id: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub workflow_url: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub display_title: Option<String>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WorkflowRunPullRequests {
    #[serde(skip_serializing_if="Option::is_none")]
    pub base: Option<WebhookchecksuitecompletedCheckSuiteBase>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub head: Option<WebhookchecksuitecompletedCheckSuiteBase>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<f64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub number: Option<f64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub url: Option<String>,
}

/// Workflow Run Usage
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WorkflowRunUsage {
    #[serde(skip_serializing_if="Option::is_none")]
    pub billable: Option<WorkflowrunusageBillable>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub run_duration_ms: Option<i64>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WorkflowStep {
    #[serde(skip_serializing_if="Option::is_none")]
    pub completed_at: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub conclusion: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub number: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub started_at: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub status: Option<String>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WorkflowStep1 {
    #[serde(skip_serializing_if="Option::is_none")]
    pub completed_at: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub conclusion: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub number: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub started_at: Option<String>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub status: Option<String>,
}

/// Workflow Usage
#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WorkflowUsage {
    #[serde(skip_serializing_if="Option::is_none")]
    pub billable: Option<WorkflowusageBillable>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WorkflowrunusageBillable {
    #[serde(rename = "UBUNTU")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub ubuntu: Option<WorkflowrunusageBillableUbuntu>,
    #[serde(rename = "MACOS")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub macos: Option<WorkflowrunusageBillableUbuntu>,
    #[serde(rename = "WINDOWS")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub windows: Option<WorkflowrunusageBillableUbuntu>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WorkflowrunusageBillableUbuntu {
    #[serde(skip_serializing_if="Option::is_none")]
    pub total_ms: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub jobs: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub job_runs: Option<Vec<WorkflowrunusageBillableUbuntuJobRuns>>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WorkflowrunusageBillableUbuntuJobRuns {
    #[serde(skip_serializing_if="Option::is_none")]
    pub job_id: Option<i64>,
    #[serde(skip_serializing_if="Option::is_none")]
    pub duration_ms: Option<i64>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WorkflowusageBillable {
    #[serde(rename = "UBUNTU")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub ubuntu: Option<WorkflowusageBillableUbuntu>,
    #[serde(rename = "MACOS")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub macos: Option<WorkflowusageBillableUbuntu>,
    #[serde(rename = "WINDOWS")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub windows: Option<WorkflowusageBillableUbuntu>,
}

#[derive(Debug, Default, Clone, PartialEq, Serialize, Deserialize)]
pub struct WorkflowusageBillableUbuntu {
    #[serde(skip_serializing_if="Option::is_none")]
    pub total_ms: Option<i64>,
}
