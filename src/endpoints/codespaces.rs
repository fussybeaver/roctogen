//! Method, error and parameter types for the Codespaces endpoint.
#![allow(
    clippy::all
)]
/* 
 * GitHub v3 REST API
 *
 * GitHub's v3 REST API.
 *
 * OpenAPI spec version: 1.1.4
 * 
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 */

use serde::Deserialize;

use crate::adapters::{AdapterError, Client, GitHubRequest, GitHubResponseExt};
use crate::models::*;

use super::PerPage;

use std::collections::HashMap;
use serde_json::value::Value;

pub struct Codespaces<'api, C: Client> where AdapterError: From<<C as Client>::Err> {
    client: &'api C
}

pub fn new<C: Client>(client: &C) -> Codespaces<C> where AdapterError: From<<C as Client>::Err> {
    Codespaces { client }
}

/// Errors for the [Add a selected repository to a user secret](Codespaces::add_repository_for_secret_for_authenticated_user_async()) endpoint.
#[derive(Debug, thiserror::Error)]
pub enum CodespacesAddRepositoryForSecretForAuthenticatedUserError {
    #[error("Requires authentication")]
    Status401(BasicError),
    #[error("Forbidden")]
    Status403(BasicError),
    #[error("Resource not found")]
    Status404(BasicError),
    #[error("Internal Error")]
    Status500(BasicError),
    #[error("Status code: {}", code)]
    Generic { code: u16 },
}

impl From<CodespacesAddRepositoryForSecretForAuthenticatedUserError> for AdapterError {
    fn from(err: CodespacesAddRepositoryForSecretForAuthenticatedUserError) -> Self {
        let (description, status_code) = match err {
            CodespacesAddRepositoryForSecretForAuthenticatedUserError::Status401(_) => (String::from("Requires authentication"), 401),
            CodespacesAddRepositoryForSecretForAuthenticatedUserError::Status403(_) => (String::from("Forbidden"), 403),
            CodespacesAddRepositoryForSecretForAuthenticatedUserError::Status404(_) => (String::from("Resource not found"), 404),
            CodespacesAddRepositoryForSecretForAuthenticatedUserError::Status500(_) => (String::from("Internal Error"), 500),
            CodespacesAddRepositoryForSecretForAuthenticatedUserError::Generic { code } => (String::from("Generic"), code)
        };

        Self::Endpoint {
            description,
            status_code,
            source: Some(Box::new(err))
        }
    }
}

/// Errors for the [Add selected repository to an organization secret](Codespaces::add_selected_repo_to_org_secret_async()) endpoint.
#[derive(Debug, thiserror::Error)]
pub enum CodespacesAddSelectedRepoToOrgSecretError {
    #[error("Resource not found")]
    Status404(BasicError),
    #[error("Conflict when visibility type is not set to selected")]
    Status409,
    #[error("Validation failed, or the endpoint has been spammed.")]
    Status422(ValidationError),
    #[error("Status code: {}", code)]
    Generic { code: u16 },
}

impl From<CodespacesAddSelectedRepoToOrgSecretError> for AdapterError {
    fn from(err: CodespacesAddSelectedRepoToOrgSecretError) -> Self {
        let (description, status_code) = match err {
            CodespacesAddSelectedRepoToOrgSecretError::Status404(_) => (String::from("Resource not found"), 404),
            CodespacesAddSelectedRepoToOrgSecretError::Status409 => (String::from("Conflict when visibility type is not set to selected"), 409),
            CodespacesAddSelectedRepoToOrgSecretError::Status422(_) => (String::from("Validation failed, or the endpoint has been spammed."), 422),
            CodespacesAddSelectedRepoToOrgSecretError::Generic { code } => (String::from("Generic"), code)
        };

        Self::Endpoint {
            description,
            status_code,
            source: Some(Box::new(err))
        }
    }
}

/// Errors for the [Check if permissions defined by a devcontainer have been accepted by the authenticated user](Codespaces::check_permissions_for_devcontainer_async()) endpoint.
#[derive(Debug, thiserror::Error)]
pub enum CodespacesCheckPermissionsForDevcontainerError {
    #[error("Requires authentication")]
    Status401(BasicError),
    #[error("Forbidden")]
    Status403(BasicError),
    #[error("Resource not found")]
    Status404(BasicError),
    #[error("Validation failed, or the endpoint has been spammed.")]
    Status422(ValidationError),
    #[error("Service unavailable")]
    Status503(PostCodespacesCreateForAuthenticatedUserResponse503),
    #[error("Status code: {}", code)]
    Generic { code: u16 },
}

impl From<CodespacesCheckPermissionsForDevcontainerError> for AdapterError {
    fn from(err: CodespacesCheckPermissionsForDevcontainerError) -> Self {
        let (description, status_code) = match err {
            CodespacesCheckPermissionsForDevcontainerError::Status401(_) => (String::from("Requires authentication"), 401),
            CodespacesCheckPermissionsForDevcontainerError::Status403(_) => (String::from("Forbidden"), 403),
            CodespacesCheckPermissionsForDevcontainerError::Status404(_) => (String::from("Resource not found"), 404),
            CodespacesCheckPermissionsForDevcontainerError::Status422(_) => (String::from("Validation failed, or the endpoint has been spammed."), 422),
            CodespacesCheckPermissionsForDevcontainerError::Status503(_) => (String::from("Service unavailable"), 503),
            CodespacesCheckPermissionsForDevcontainerError::Generic { code } => (String::from("Generic"), code)
        };

        Self::Endpoint {
            description,
            status_code,
            source: Some(Box::new(err))
        }
    }
}

/// Errors for the [List machine types for a codespace](Codespaces::codespace_machines_for_authenticated_user_async()) endpoint.
#[derive(Debug, thiserror::Error)]
pub enum CodespacesCodespaceMachinesForAuthenticatedUserError {
    #[error("Not modified")]
    Status304,
    #[error("Internal Error")]
    Status500(BasicError),
    #[error("Requires authentication")]
    Status401(BasicError),
    #[error("Forbidden")]
    Status403(BasicError),
    #[error("Resource not found")]
    Status404(BasicError),
    #[error("Status code: {}", code)]
    Generic { code: u16 },
}

impl From<CodespacesCodespaceMachinesForAuthenticatedUserError> for AdapterError {
    fn from(err: CodespacesCodespaceMachinesForAuthenticatedUserError) -> Self {
        let (description, status_code) = match err {
            CodespacesCodespaceMachinesForAuthenticatedUserError::Status304 => (String::from("Not modified"), 304),
            CodespacesCodespaceMachinesForAuthenticatedUserError::Status500(_) => (String::from("Internal Error"), 500),
            CodespacesCodespaceMachinesForAuthenticatedUserError::Status401(_) => (String::from("Requires authentication"), 401),
            CodespacesCodespaceMachinesForAuthenticatedUserError::Status403(_) => (String::from("Forbidden"), 403),
            CodespacesCodespaceMachinesForAuthenticatedUserError::Status404(_) => (String::from("Resource not found"), 404),
            CodespacesCodespaceMachinesForAuthenticatedUserError::Generic { code } => (String::from("Generic"), code)
        };

        Self::Endpoint {
            description,
            status_code,
            source: Some(Box::new(err))
        }
    }
}

/// Errors for the [Create a codespace for the authenticated user](Codespaces::create_for_authenticated_user_async()) endpoint.
#[derive(Debug, thiserror::Error)]
pub enum CodespacesCreateForAuthenticatedUserError {
    #[error("Response when the codespace creation partially failed but is being retried in the background")]
    Status202(Codespace),
    #[error("Requires authentication")]
    Status401(BasicError),
    #[error("Forbidden")]
    Status403(BasicError),
    #[error("Resource not found")]
    Status404(BasicError),
    #[error("Service unavailable")]
    Status503(PostCodespacesCreateForAuthenticatedUserResponse503),
    #[error("Status code: {}", code)]
    Generic { code: u16 },
}

impl From<CodespacesCreateForAuthenticatedUserError> for AdapterError {
    fn from(err: CodespacesCreateForAuthenticatedUserError) -> Self {
        let (description, status_code) = match err {
            CodespacesCreateForAuthenticatedUserError::Status202(_) => (String::from("Response when the codespace creation partially failed but is being retried in the background"), 202),
            CodespacesCreateForAuthenticatedUserError::Status401(_) => (String::from("Requires authentication"), 401),
            CodespacesCreateForAuthenticatedUserError::Status403(_) => (String::from("Forbidden"), 403),
            CodespacesCreateForAuthenticatedUserError::Status404(_) => (String::from("Resource not found"), 404),
            CodespacesCreateForAuthenticatedUserError::Status503(_) => (String::from("Service unavailable"), 503),
            CodespacesCreateForAuthenticatedUserError::Generic { code } => (String::from("Generic"), code)
        };

        Self::Endpoint {
            description,
            status_code,
            source: Some(Box::new(err))
        }
    }
}

/// Errors for the [Create or update an organization secret](Codespaces::create_or_update_org_secret_async()) endpoint.
#[derive(Debug, thiserror::Error)]
pub enum CodespacesCreateOrUpdateOrgSecretError {
    #[error("Response when updating a secret")]
    Status204,
    #[error("Resource not found")]
    Status404(BasicError),
    #[error("Validation failed, or the endpoint has been spammed.")]
    Status422(ValidationError),
    #[error("Status code: {}", code)]
    Generic { code: u16 },
}

impl From<CodespacesCreateOrUpdateOrgSecretError> for AdapterError {
    fn from(err: CodespacesCreateOrUpdateOrgSecretError) -> Self {
        let (description, status_code) = match err {
            CodespacesCreateOrUpdateOrgSecretError::Status204 => (String::from("Response when updating a secret"), 204),
            CodespacesCreateOrUpdateOrgSecretError::Status404(_) => (String::from("Resource not found"), 404),
            CodespacesCreateOrUpdateOrgSecretError::Status422(_) => (String::from("Validation failed, or the endpoint has been spammed."), 422),
            CodespacesCreateOrUpdateOrgSecretError::Generic { code } => (String::from("Generic"), code)
        };

        Self::Endpoint {
            description,
            status_code,
            source: Some(Box::new(err))
        }
    }
}

/// Errors for the [Create or update a repository secret](Codespaces::create_or_update_repo_secret_async()) endpoint.
#[derive(Debug, thiserror::Error)]
pub enum CodespacesCreateOrUpdateRepoSecretError {
    #[error("Response when updating a secret")]
    Status204,
    #[error("Status code: {}", code)]
    Generic { code: u16 },
}

impl From<CodespacesCreateOrUpdateRepoSecretError> for AdapterError {
    fn from(err: CodespacesCreateOrUpdateRepoSecretError) -> Self {
        let (description, status_code) = match err {
            CodespacesCreateOrUpdateRepoSecretError::Status204 => (String::from("Response when updating a secret"), 204),
            CodespacesCreateOrUpdateRepoSecretError::Generic { code } => (String::from("Generic"), code)
        };

        Self::Endpoint {
            description,
            status_code,
            source: Some(Box::new(err))
        }
    }
}

/// Errors for the [Create or update a secret for the authenticated user](Codespaces::create_or_update_secret_for_authenticated_user_async()) endpoint.
#[derive(Debug, thiserror::Error)]
pub enum CodespacesCreateOrUpdateSecretForAuthenticatedUserError {
    #[error("Response after successfully updating a secret")]
    Status204,
    #[error("Validation failed, or the endpoint has been spammed.")]
    Status422(ValidationError),
    #[error("Resource not found")]
    Status404(BasicError),
    #[error("Status code: {}", code)]
    Generic { code: u16 },
}

impl From<CodespacesCreateOrUpdateSecretForAuthenticatedUserError> for AdapterError {
    fn from(err: CodespacesCreateOrUpdateSecretForAuthenticatedUserError) -> Self {
        let (description, status_code) = match err {
            CodespacesCreateOrUpdateSecretForAuthenticatedUserError::Status204 => (String::from("Response after successfully updating a secret"), 204),
            CodespacesCreateOrUpdateSecretForAuthenticatedUserError::Status422(_) => (String::from("Validation failed, or the endpoint has been spammed."), 422),
            CodespacesCreateOrUpdateSecretForAuthenticatedUserError::Status404(_) => (String::from("Resource not found"), 404),
            CodespacesCreateOrUpdateSecretForAuthenticatedUserError::Generic { code } => (String::from("Generic"), code)
        };

        Self::Endpoint {
            description,
            status_code,
            source: Some(Box::new(err))
        }
    }
}

/// Errors for the [Create a codespace from a pull request](Codespaces::create_with_pr_for_authenticated_user_async()) endpoint.
#[derive(Debug, thiserror::Error)]
pub enum CodespacesCreateWithPrForAuthenticatedUserError {
    #[error("Response when the codespace creation partially failed but is being retried in the background")]
    Status202(Codespace),
    #[error("Requires authentication")]
    Status401(BasicError),
    #[error("Forbidden")]
    Status403(BasicError),
    #[error("Resource not found")]
    Status404(BasicError),
    #[error("Service unavailable")]
    Status503(PostCodespacesCreateForAuthenticatedUserResponse503),
    #[error("Status code: {}", code)]
    Generic { code: u16 },
}

impl From<CodespacesCreateWithPrForAuthenticatedUserError> for AdapterError {
    fn from(err: CodespacesCreateWithPrForAuthenticatedUserError) -> Self {
        let (description, status_code) = match err {
            CodespacesCreateWithPrForAuthenticatedUserError::Status202(_) => (String::from("Response when the codespace creation partially failed but is being retried in the background"), 202),
            CodespacesCreateWithPrForAuthenticatedUserError::Status401(_) => (String::from("Requires authentication"), 401),
            CodespacesCreateWithPrForAuthenticatedUserError::Status403(_) => (String::from("Forbidden"), 403),
            CodespacesCreateWithPrForAuthenticatedUserError::Status404(_) => (String::from("Resource not found"), 404),
            CodespacesCreateWithPrForAuthenticatedUserError::Status503(_) => (String::from("Service unavailable"), 503),
            CodespacesCreateWithPrForAuthenticatedUserError::Generic { code } => (String::from("Generic"), code)
        };

        Self::Endpoint {
            description,
            status_code,
            source: Some(Box::new(err))
        }
    }
}

/// Errors for the [Create a codespace in a repository](Codespaces::create_with_repo_for_authenticated_user_async()) endpoint.
#[derive(Debug, thiserror::Error)]
pub enum CodespacesCreateWithRepoForAuthenticatedUserError {
    #[error("Response when the codespace creation partially failed but is being retried in the background")]
    Status202(Codespace),
    #[error("Bad Request")]
    Status400(BasicError),
    #[error("Requires authentication")]
    Status401(BasicError),
    #[error("Forbidden")]
    Status403(BasicError),
    #[error("Resource not found")]
    Status404(BasicError),
    #[error("Service unavailable")]
    Status503(PostCodespacesCreateForAuthenticatedUserResponse503),
    #[error("Status code: {}", code)]
    Generic { code: u16 },
}

impl From<CodespacesCreateWithRepoForAuthenticatedUserError> for AdapterError {
    fn from(err: CodespacesCreateWithRepoForAuthenticatedUserError) -> Self {
        let (description, status_code) = match err {
            CodespacesCreateWithRepoForAuthenticatedUserError::Status202(_) => (String::from("Response when the codespace creation partially failed but is being retried in the background"), 202),
            CodespacesCreateWithRepoForAuthenticatedUserError::Status400(_) => (String::from("Bad Request"), 400),
            CodespacesCreateWithRepoForAuthenticatedUserError::Status401(_) => (String::from("Requires authentication"), 401),
            CodespacesCreateWithRepoForAuthenticatedUserError::Status403(_) => (String::from("Forbidden"), 403),
            CodespacesCreateWithRepoForAuthenticatedUserError::Status404(_) => (String::from("Resource not found"), 404),
            CodespacesCreateWithRepoForAuthenticatedUserError::Status503(_) => (String::from("Service unavailable"), 503),
            CodespacesCreateWithRepoForAuthenticatedUserError::Generic { code } => (String::from("Generic"), code)
        };

        Self::Endpoint {
            description,
            status_code,
            source: Some(Box::new(err))
        }
    }
}

/// Errors for the [Remove users from Codespaces access for an organization](Codespaces::delete_codespaces_access_users_async()) endpoint.
#[derive(Debug, thiserror::Error)]
pub enum CodespacesDeleteCodespacesAccessUsersError {
    #[error("Not modified")]
    Status304,
    #[error("Users are neither members nor collaborators of this organization.")]
    Status400,
    #[error("Resource not found")]
    Status404(BasicError),
    #[error("Validation failed, or the endpoint has been spammed.")]
    Status422(ValidationError),
    #[error("Internal Error")]
    Status500(BasicError),
    #[error("Status code: {}", code)]
    Generic { code: u16 },
}

impl From<CodespacesDeleteCodespacesAccessUsersError> for AdapterError {
    fn from(err: CodespacesDeleteCodespacesAccessUsersError) -> Self {
        let (description, status_code) = match err {
            CodespacesDeleteCodespacesAccessUsersError::Status304 => (String::from("Not modified"), 304),
            CodespacesDeleteCodespacesAccessUsersError::Status400 => (String::from("Users are neither members nor collaborators of this organization."), 400),
            CodespacesDeleteCodespacesAccessUsersError::Status404(_) => (String::from("Resource not found"), 404),
            CodespacesDeleteCodespacesAccessUsersError::Status422(_) => (String::from("Validation failed, or the endpoint has been spammed."), 422),
            CodespacesDeleteCodespacesAccessUsersError::Status500(_) => (String::from("Internal Error"), 500),
            CodespacesDeleteCodespacesAccessUsersError::Generic { code } => (String::from("Generic"), code)
        };

        Self::Endpoint {
            description,
            status_code,
            source: Some(Box::new(err))
        }
    }
}

/// Errors for the [Delete a codespace for the authenticated user](Codespaces::delete_for_authenticated_user_async()) endpoint.
#[derive(Debug, thiserror::Error)]
pub enum CodespacesDeleteForAuthenticatedUserError {
    #[error("Not modified")]
    Status304,
    #[error("Internal Error")]
    Status500(BasicError),
    #[error("Requires authentication")]
    Status401(BasicError),
    #[error("Forbidden")]
    Status403(BasicError),
    #[error("Resource not found")]
    Status404(BasicError),
    #[error("Status code: {}", code)]
    Generic { code: u16 },
}

impl From<CodespacesDeleteForAuthenticatedUserError> for AdapterError {
    fn from(err: CodespacesDeleteForAuthenticatedUserError) -> Self {
        let (description, status_code) = match err {
            CodespacesDeleteForAuthenticatedUserError::Status304 => (String::from("Not modified"), 304),
            CodespacesDeleteForAuthenticatedUserError::Status500(_) => (String::from("Internal Error"), 500),
            CodespacesDeleteForAuthenticatedUserError::Status401(_) => (String::from("Requires authentication"), 401),
            CodespacesDeleteForAuthenticatedUserError::Status403(_) => (String::from("Forbidden"), 403),
            CodespacesDeleteForAuthenticatedUserError::Status404(_) => (String::from("Resource not found"), 404),
            CodespacesDeleteForAuthenticatedUserError::Generic { code } => (String::from("Generic"), code)
        };

        Self::Endpoint {
            description,
            status_code,
            source: Some(Box::new(err))
        }
    }
}

/// Errors for the [Delete a codespace from the organization](Codespaces::delete_from_organization_async()) endpoint.
#[derive(Debug, thiserror::Error)]
pub enum CodespacesDeleteFromOrganizationError {
    #[error("Not modified")]
    Status304,
    #[error("Internal Error")]
    Status500(BasicError),
    #[error("Requires authentication")]
    Status401(BasicError),
    #[error("Forbidden")]
    Status403(BasicError),
    #[error("Resource not found")]
    Status404(BasicError),
    #[error("Status code: {}", code)]
    Generic { code: u16 },
}

impl From<CodespacesDeleteFromOrganizationError> for AdapterError {
    fn from(err: CodespacesDeleteFromOrganizationError) -> Self {
        let (description, status_code) = match err {
            CodespacesDeleteFromOrganizationError::Status304 => (String::from("Not modified"), 304),
            CodespacesDeleteFromOrganizationError::Status500(_) => (String::from("Internal Error"), 500),
            CodespacesDeleteFromOrganizationError::Status401(_) => (String::from("Requires authentication"), 401),
            CodespacesDeleteFromOrganizationError::Status403(_) => (String::from("Forbidden"), 403),
            CodespacesDeleteFromOrganizationError::Status404(_) => (String::from("Resource not found"), 404),
            CodespacesDeleteFromOrganizationError::Generic { code } => (String::from("Generic"), code)
        };

        Self::Endpoint {
            description,
            status_code,
            source: Some(Box::new(err))
        }
    }
}

/// Errors for the [Delete an organization secret](Codespaces::delete_org_secret_async()) endpoint.
#[derive(Debug, thiserror::Error)]
pub enum CodespacesDeleteOrgSecretError {
    #[error("Resource not found")]
    Status404(BasicError),
    #[error("Status code: {}", code)]
    Generic { code: u16 },
}

impl From<CodespacesDeleteOrgSecretError> for AdapterError {
    fn from(err: CodespacesDeleteOrgSecretError) -> Self {
        let (description, status_code) = match err {
            CodespacesDeleteOrgSecretError::Status404(_) => (String::from("Resource not found"), 404),
            CodespacesDeleteOrgSecretError::Generic { code } => (String::from("Generic"), code)
        };

        Self::Endpoint {
            description,
            status_code,
            source: Some(Box::new(err))
        }
    }
}

/// Errors for the [Delete a repository secret](Codespaces::delete_repo_secret_async()) endpoint.
#[derive(Debug, thiserror::Error)]
pub enum CodespacesDeleteRepoSecretError {
    #[error("Status code: {}", code)]
    Generic { code: u16 },
}

impl From<CodespacesDeleteRepoSecretError> for AdapterError {
    fn from(err: CodespacesDeleteRepoSecretError) -> Self {
        let (description, status_code) = match err {
            CodespacesDeleteRepoSecretError::Generic { code } => (String::from("Generic"), code)
        };

        Self::Endpoint {
            description,
            status_code,
            source: Some(Box::new(err))
        }
    }
}

/// Errors for the [Delete a secret for the authenticated user](Codespaces::delete_secret_for_authenticated_user_async()) endpoint.
#[derive(Debug, thiserror::Error)]
pub enum CodespacesDeleteSecretForAuthenticatedUserError {
    #[error("Status code: {}", code)]
    Generic { code: u16 },
}

impl From<CodespacesDeleteSecretForAuthenticatedUserError> for AdapterError {
    fn from(err: CodespacesDeleteSecretForAuthenticatedUserError) -> Self {
        let (description, status_code) = match err {
            CodespacesDeleteSecretForAuthenticatedUserError::Generic { code } => (String::from("Generic"), code)
        };

        Self::Endpoint {
            description,
            status_code,
            source: Some(Box::new(err))
        }
    }
}

/// Errors for the [Export a codespace for the authenticated user](Codespaces::export_for_authenticated_user_async()) endpoint.
#[derive(Debug, thiserror::Error)]
pub enum CodespacesExportForAuthenticatedUserError {
    #[error("Internal Error")]
    Status500(BasicError),
    #[error("Requires authentication")]
    Status401(BasicError),
    #[error("Forbidden")]
    Status403(BasicError),
    #[error("Resource not found")]
    Status404(BasicError),
    #[error("Validation failed, or the endpoint has been spammed.")]
    Status422(ValidationError),
    #[error("Status code: {}", code)]
    Generic { code: u16 },
}

impl From<CodespacesExportForAuthenticatedUserError> for AdapterError {
    fn from(err: CodespacesExportForAuthenticatedUserError) -> Self {
        let (description, status_code) = match err {
            CodespacesExportForAuthenticatedUserError::Status500(_) => (String::from("Internal Error"), 500),
            CodespacesExportForAuthenticatedUserError::Status401(_) => (String::from("Requires authentication"), 401),
            CodespacesExportForAuthenticatedUserError::Status403(_) => (String::from("Forbidden"), 403),
            CodespacesExportForAuthenticatedUserError::Status404(_) => (String::from("Resource not found"), 404),
            CodespacesExportForAuthenticatedUserError::Status422(_) => (String::from("Validation failed, or the endpoint has been spammed."), 422),
            CodespacesExportForAuthenticatedUserError::Generic { code } => (String::from("Generic"), code)
        };

        Self::Endpoint {
            description,
            status_code,
            source: Some(Box::new(err))
        }
    }
}

/// Errors for the [List codespaces for a user in organization](Codespaces::get_codespaces_for_user_in_org_async()) endpoint.
#[derive(Debug, thiserror::Error)]
pub enum CodespacesGetCodespacesForUserInOrgError {
    #[error("Not modified")]
    Status304,
    #[error("Internal Error")]
    Status500(BasicError),
    #[error("Requires authentication")]
    Status401(BasicError),
    #[error("Forbidden")]
    Status403(BasicError),
    #[error("Resource not found")]
    Status404(BasicError),
    #[error("Status code: {}", code)]
    Generic { code: u16 },
}

impl From<CodespacesGetCodespacesForUserInOrgError> for AdapterError {
    fn from(err: CodespacesGetCodespacesForUserInOrgError) -> Self {
        let (description, status_code) = match err {
            CodespacesGetCodespacesForUserInOrgError::Status304 => (String::from("Not modified"), 304),
            CodespacesGetCodespacesForUserInOrgError::Status500(_) => (String::from("Internal Error"), 500),
            CodespacesGetCodespacesForUserInOrgError::Status401(_) => (String::from("Requires authentication"), 401),
            CodespacesGetCodespacesForUserInOrgError::Status403(_) => (String::from("Forbidden"), 403),
            CodespacesGetCodespacesForUserInOrgError::Status404(_) => (String::from("Resource not found"), 404),
            CodespacesGetCodespacesForUserInOrgError::Generic { code } => (String::from("Generic"), code)
        };

        Self::Endpoint {
            description,
            status_code,
            source: Some(Box::new(err))
        }
    }
}

/// Errors for the [Get details about a codespace export](Codespaces::get_export_details_for_authenticated_user_async()) endpoint.
#[derive(Debug, thiserror::Error)]
pub enum CodespacesGetExportDetailsForAuthenticatedUserError {
    #[error("Resource not found")]
    Status404(BasicError),
    #[error("Status code: {}", code)]
    Generic { code: u16 },
}

impl From<CodespacesGetExportDetailsForAuthenticatedUserError> for AdapterError {
    fn from(err: CodespacesGetExportDetailsForAuthenticatedUserError) -> Self {
        let (description, status_code) = match err {
            CodespacesGetExportDetailsForAuthenticatedUserError::Status404(_) => (String::from("Resource not found"), 404),
            CodespacesGetExportDetailsForAuthenticatedUserError::Generic { code } => (String::from("Generic"), code)
        };

        Self::Endpoint {
            description,
            status_code,
            source: Some(Box::new(err))
        }
    }
}

/// Errors for the [Get a codespace for the authenticated user](Codespaces::get_for_authenticated_user_async()) endpoint.
#[derive(Debug, thiserror::Error)]
pub enum CodespacesGetForAuthenticatedUserError {
    #[error("Not modified")]
    Status304,
    #[error("Internal Error")]
    Status500(BasicError),
    #[error("Requires authentication")]
    Status401(BasicError),
    #[error("Forbidden")]
    Status403(BasicError),
    #[error("Resource not found")]
    Status404(BasicError),
    #[error("Status code: {}", code)]
    Generic { code: u16 },
}

impl From<CodespacesGetForAuthenticatedUserError> for AdapterError {
    fn from(err: CodespacesGetForAuthenticatedUserError) -> Self {
        let (description, status_code) = match err {
            CodespacesGetForAuthenticatedUserError::Status304 => (String::from("Not modified"), 304),
            CodespacesGetForAuthenticatedUserError::Status500(_) => (String::from("Internal Error"), 500),
            CodespacesGetForAuthenticatedUserError::Status401(_) => (String::from("Requires authentication"), 401),
            CodespacesGetForAuthenticatedUserError::Status403(_) => (String::from("Forbidden"), 403),
            CodespacesGetForAuthenticatedUserError::Status404(_) => (String::from("Resource not found"), 404),
            CodespacesGetForAuthenticatedUserError::Generic { code } => (String::from("Generic"), code)
        };

        Self::Endpoint {
            description,
            status_code,
            source: Some(Box::new(err))
        }
    }
}

/// Errors for the [Get an organization public key](Codespaces::get_org_public_key_async()) endpoint.
#[derive(Debug, thiserror::Error)]
pub enum CodespacesGetOrgPublicKeyError {
    #[error("Status code: {}", code)]
    Generic { code: u16 },
}

impl From<CodespacesGetOrgPublicKeyError> for AdapterError {
    fn from(err: CodespacesGetOrgPublicKeyError) -> Self {
        let (description, status_code) = match err {
            CodespacesGetOrgPublicKeyError::Generic { code } => (String::from("Generic"), code)
        };

        Self::Endpoint {
            description,
            status_code,
            source: Some(Box::new(err))
        }
    }
}

/// Errors for the [Get an organization secret](Codespaces::get_org_secret_async()) endpoint.
#[derive(Debug, thiserror::Error)]
pub enum CodespacesGetOrgSecretError {
    #[error("Status code: {}", code)]
    Generic { code: u16 },
}

impl From<CodespacesGetOrgSecretError> for AdapterError {
    fn from(err: CodespacesGetOrgSecretError) -> Self {
        let (description, status_code) = match err {
            CodespacesGetOrgSecretError::Generic { code } => (String::from("Generic"), code)
        };

        Self::Endpoint {
            description,
            status_code,
            source: Some(Box::new(err))
        }
    }
}

/// Errors for the [Get public key for the authenticated user](Codespaces::get_public_key_for_authenticated_user_async()) endpoint.
#[derive(Debug, thiserror::Error)]
pub enum CodespacesGetPublicKeyForAuthenticatedUserError {
    #[error("Status code: {}", code)]
    Generic { code: u16 },
}

impl From<CodespacesGetPublicKeyForAuthenticatedUserError> for AdapterError {
    fn from(err: CodespacesGetPublicKeyForAuthenticatedUserError) -> Self {
        let (description, status_code) = match err {
            CodespacesGetPublicKeyForAuthenticatedUserError::Generic { code } => (String::from("Generic"), code)
        };

        Self::Endpoint {
            description,
            status_code,
            source: Some(Box::new(err))
        }
    }
}

/// Errors for the [Get a repository public key](Codespaces::get_repo_public_key_async()) endpoint.
#[derive(Debug, thiserror::Error)]
pub enum CodespacesGetRepoPublicKeyError {
    #[error("Status code: {}", code)]
    Generic { code: u16 },
}

impl From<CodespacesGetRepoPublicKeyError> for AdapterError {
    fn from(err: CodespacesGetRepoPublicKeyError) -> Self {
        let (description, status_code) = match err {
            CodespacesGetRepoPublicKeyError::Generic { code } => (String::from("Generic"), code)
        };

        Self::Endpoint {
            description,
            status_code,
            source: Some(Box::new(err))
        }
    }
}

/// Errors for the [Get a repository secret](Codespaces::get_repo_secret_async()) endpoint.
#[derive(Debug, thiserror::Error)]
pub enum CodespacesGetRepoSecretError {
    #[error("Status code: {}", code)]
    Generic { code: u16 },
}

impl From<CodespacesGetRepoSecretError> for AdapterError {
    fn from(err: CodespacesGetRepoSecretError) -> Self {
        let (description, status_code) = match err {
            CodespacesGetRepoSecretError::Generic { code } => (String::from("Generic"), code)
        };

        Self::Endpoint {
            description,
            status_code,
            source: Some(Box::new(err))
        }
    }
}

/// Errors for the [Get a secret for the authenticated user](Codespaces::get_secret_for_authenticated_user_async()) endpoint.
#[derive(Debug, thiserror::Error)]
pub enum CodespacesGetSecretForAuthenticatedUserError {
    #[error("Status code: {}", code)]
    Generic { code: u16 },
}

impl From<CodespacesGetSecretForAuthenticatedUserError> for AdapterError {
    fn from(err: CodespacesGetSecretForAuthenticatedUserError) -> Self {
        let (description, status_code) = match err {
            CodespacesGetSecretForAuthenticatedUserError::Generic { code } => (String::from("Generic"), code)
        };

        Self::Endpoint {
            description,
            status_code,
            source: Some(Box::new(err))
        }
    }
}

/// Errors for the [List devcontainer configurations in a repository for the authenticated user](Codespaces::list_devcontainers_in_repository_for_authenticated_user_async()) endpoint.
#[derive(Debug, thiserror::Error)]
pub enum CodespacesListDevcontainersInRepositoryForAuthenticatedUserError {
    #[error("Internal Error")]
    Status500(BasicError),
    #[error("Bad Request")]
    Status400(BasicError),
    #[error("Requires authentication")]
    Status401(BasicError),
    #[error("Forbidden")]
    Status403(BasicError),
    #[error("Resource not found")]
    Status404(BasicError),
    #[error("Status code: {}", code)]
    Generic { code: u16 },
}

impl From<CodespacesListDevcontainersInRepositoryForAuthenticatedUserError> for AdapterError {
    fn from(err: CodespacesListDevcontainersInRepositoryForAuthenticatedUserError) -> Self {
        let (description, status_code) = match err {
            CodespacesListDevcontainersInRepositoryForAuthenticatedUserError::Status500(_) => (String::from("Internal Error"), 500),
            CodespacesListDevcontainersInRepositoryForAuthenticatedUserError::Status400(_) => (String::from("Bad Request"), 400),
            CodespacesListDevcontainersInRepositoryForAuthenticatedUserError::Status401(_) => (String::from("Requires authentication"), 401),
            CodespacesListDevcontainersInRepositoryForAuthenticatedUserError::Status403(_) => (String::from("Forbidden"), 403),
            CodespacesListDevcontainersInRepositoryForAuthenticatedUserError::Status404(_) => (String::from("Resource not found"), 404),
            CodespacesListDevcontainersInRepositoryForAuthenticatedUserError::Generic { code } => (String::from("Generic"), code)
        };

        Self::Endpoint {
            description,
            status_code,
            source: Some(Box::new(err))
        }
    }
}

/// Errors for the [List codespaces for the authenticated user](Codespaces::list_for_authenticated_user_async()) endpoint.
#[derive(Debug, thiserror::Error)]
pub enum CodespacesListForAuthenticatedUserError {
    #[error("Not modified")]
    Status304,
    #[error("Internal Error")]
    Status500(BasicError),
    #[error("Requires authentication")]
    Status401(BasicError),
    #[error("Forbidden")]
    Status403(BasicError),
    #[error("Resource not found")]
    Status404(BasicError),
    #[error("Status code: {}", code)]
    Generic { code: u16 },
}

impl From<CodespacesListForAuthenticatedUserError> for AdapterError {
    fn from(err: CodespacesListForAuthenticatedUserError) -> Self {
        let (description, status_code) = match err {
            CodespacesListForAuthenticatedUserError::Status304 => (String::from("Not modified"), 304),
            CodespacesListForAuthenticatedUserError::Status500(_) => (String::from("Internal Error"), 500),
            CodespacesListForAuthenticatedUserError::Status401(_) => (String::from("Requires authentication"), 401),
            CodespacesListForAuthenticatedUserError::Status403(_) => (String::from("Forbidden"), 403),
            CodespacesListForAuthenticatedUserError::Status404(_) => (String::from("Resource not found"), 404),
            CodespacesListForAuthenticatedUserError::Generic { code } => (String::from("Generic"), code)
        };

        Self::Endpoint {
            description,
            status_code,
            source: Some(Box::new(err))
        }
    }
}

/// Errors for the [List codespaces for the organization](Codespaces::list_in_organization_async()) endpoint.
#[derive(Debug, thiserror::Error)]
pub enum CodespacesListInOrganizationError {
    #[error("Not modified")]
    Status304,
    #[error("Internal Error")]
    Status500(BasicError),
    #[error("Requires authentication")]
    Status401(BasicError),
    #[error("Forbidden")]
    Status403(BasicError),
    #[error("Resource not found")]
    Status404(BasicError),
    #[error("Status code: {}", code)]
    Generic { code: u16 },
}

impl From<CodespacesListInOrganizationError> for AdapterError {
    fn from(err: CodespacesListInOrganizationError) -> Self {
        let (description, status_code) = match err {
            CodespacesListInOrganizationError::Status304 => (String::from("Not modified"), 304),
            CodespacesListInOrganizationError::Status500(_) => (String::from("Internal Error"), 500),
            CodespacesListInOrganizationError::Status401(_) => (String::from("Requires authentication"), 401),
            CodespacesListInOrganizationError::Status403(_) => (String::from("Forbidden"), 403),
            CodespacesListInOrganizationError::Status404(_) => (String::from("Resource not found"), 404),
            CodespacesListInOrganizationError::Generic { code } => (String::from("Generic"), code)
        };

        Self::Endpoint {
            description,
            status_code,
            source: Some(Box::new(err))
        }
    }
}

/// Errors for the [List codespaces in a repository for the authenticated user](Codespaces::list_in_repository_for_authenticated_user_async()) endpoint.
#[derive(Debug, thiserror::Error)]
pub enum CodespacesListInRepositoryForAuthenticatedUserError {
    #[error("Internal Error")]
    Status500(BasicError),
    #[error("Requires authentication")]
    Status401(BasicError),
    #[error("Forbidden")]
    Status403(BasicError),
    #[error("Resource not found")]
    Status404(BasicError),
    #[error("Status code: {}", code)]
    Generic { code: u16 },
}

impl From<CodespacesListInRepositoryForAuthenticatedUserError> for AdapterError {
    fn from(err: CodespacesListInRepositoryForAuthenticatedUserError) -> Self {
        let (description, status_code) = match err {
            CodespacesListInRepositoryForAuthenticatedUserError::Status500(_) => (String::from("Internal Error"), 500),
            CodespacesListInRepositoryForAuthenticatedUserError::Status401(_) => (String::from("Requires authentication"), 401),
            CodespacesListInRepositoryForAuthenticatedUserError::Status403(_) => (String::from("Forbidden"), 403),
            CodespacesListInRepositoryForAuthenticatedUserError::Status404(_) => (String::from("Resource not found"), 404),
            CodespacesListInRepositoryForAuthenticatedUserError::Generic { code } => (String::from("Generic"), code)
        };

        Self::Endpoint {
            description,
            status_code,
            source: Some(Box::new(err))
        }
    }
}

/// Errors for the [List organization secrets](Codespaces::list_org_secrets_async()) endpoint.
#[derive(Debug, thiserror::Error)]
pub enum CodespacesListOrgSecretsError {
    #[error("Status code: {}", code)]
    Generic { code: u16 },
}

impl From<CodespacesListOrgSecretsError> for AdapterError {
    fn from(err: CodespacesListOrgSecretsError) -> Self {
        let (description, status_code) = match err {
            CodespacesListOrgSecretsError::Generic { code } => (String::from("Generic"), code)
        };

        Self::Endpoint {
            description,
            status_code,
            source: Some(Box::new(err))
        }
    }
}

/// Errors for the [List repository secrets](Codespaces::list_repo_secrets_async()) endpoint.
#[derive(Debug, thiserror::Error)]
pub enum CodespacesListRepoSecretsError {
    #[error("Status code: {}", code)]
    Generic { code: u16 },
}

impl From<CodespacesListRepoSecretsError> for AdapterError {
    fn from(err: CodespacesListRepoSecretsError) -> Self {
        let (description, status_code) = match err {
            CodespacesListRepoSecretsError::Generic { code } => (String::from("Generic"), code)
        };

        Self::Endpoint {
            description,
            status_code,
            source: Some(Box::new(err))
        }
    }
}

/// Errors for the [List selected repositories for a user secret](Codespaces::list_repositories_for_secret_for_authenticated_user_async()) endpoint.
#[derive(Debug, thiserror::Error)]
pub enum CodespacesListRepositoriesForSecretForAuthenticatedUserError {
    #[error("Requires authentication")]
    Status401(BasicError),
    #[error("Forbidden")]
    Status403(BasicError),
    #[error("Resource not found")]
    Status404(BasicError),
    #[error("Internal Error")]
    Status500(BasicError),
    #[error("Status code: {}", code)]
    Generic { code: u16 },
}

impl From<CodespacesListRepositoriesForSecretForAuthenticatedUserError> for AdapterError {
    fn from(err: CodespacesListRepositoriesForSecretForAuthenticatedUserError) -> Self {
        let (description, status_code) = match err {
            CodespacesListRepositoriesForSecretForAuthenticatedUserError::Status401(_) => (String::from("Requires authentication"), 401),
            CodespacesListRepositoriesForSecretForAuthenticatedUserError::Status403(_) => (String::from("Forbidden"), 403),
            CodespacesListRepositoriesForSecretForAuthenticatedUserError::Status404(_) => (String::from("Resource not found"), 404),
            CodespacesListRepositoriesForSecretForAuthenticatedUserError::Status500(_) => (String::from("Internal Error"), 500),
            CodespacesListRepositoriesForSecretForAuthenticatedUserError::Generic { code } => (String::from("Generic"), code)
        };

        Self::Endpoint {
            description,
            status_code,
            source: Some(Box::new(err))
        }
    }
}

/// Errors for the [List secrets for the authenticated user](Codespaces::list_secrets_for_authenticated_user_async()) endpoint.
#[derive(Debug, thiserror::Error)]
pub enum CodespacesListSecretsForAuthenticatedUserError {
    #[error("Status code: {}", code)]
    Generic { code: u16 },
}

impl From<CodespacesListSecretsForAuthenticatedUserError> for AdapterError {
    fn from(err: CodespacesListSecretsForAuthenticatedUserError) -> Self {
        let (description, status_code) = match err {
            CodespacesListSecretsForAuthenticatedUserError::Generic { code } => (String::from("Generic"), code)
        };

        Self::Endpoint {
            description,
            status_code,
            source: Some(Box::new(err))
        }
    }
}

/// Errors for the [List selected repositories for an organization secret](Codespaces::list_selected_repos_for_org_secret_async()) endpoint.
#[derive(Debug, thiserror::Error)]
pub enum CodespacesListSelectedReposForOrgSecretError {
    #[error("Resource not found")]
    Status404(BasicError),
    #[error("Status code: {}", code)]
    Generic { code: u16 },
}

impl From<CodespacesListSelectedReposForOrgSecretError> for AdapterError {
    fn from(err: CodespacesListSelectedReposForOrgSecretError) -> Self {
        let (description, status_code) = match err {
            CodespacesListSelectedReposForOrgSecretError::Status404(_) => (String::from("Resource not found"), 404),
            CodespacesListSelectedReposForOrgSecretError::Generic { code } => (String::from("Generic"), code)
        };

        Self::Endpoint {
            description,
            status_code,
            source: Some(Box::new(err))
        }
    }
}

/// Errors for the [Get default attributes for a codespace](Codespaces::pre_flight_with_repo_for_authenticated_user_async()) endpoint.
#[derive(Debug, thiserror::Error)]
pub enum CodespacesPreFlightWithRepoForAuthenticatedUserError {
    #[error("Requires authentication")]
    Status401(BasicError),
    #[error("Forbidden")]
    Status403(BasicError),
    #[error("Resource not found")]
    Status404(BasicError),
    #[error("Status code: {}", code)]
    Generic { code: u16 },
}

impl From<CodespacesPreFlightWithRepoForAuthenticatedUserError> for AdapterError {
    fn from(err: CodespacesPreFlightWithRepoForAuthenticatedUserError) -> Self {
        let (description, status_code) = match err {
            CodespacesPreFlightWithRepoForAuthenticatedUserError::Status401(_) => (String::from("Requires authentication"), 401),
            CodespacesPreFlightWithRepoForAuthenticatedUserError::Status403(_) => (String::from("Forbidden"), 403),
            CodespacesPreFlightWithRepoForAuthenticatedUserError::Status404(_) => (String::from("Resource not found"), 404),
            CodespacesPreFlightWithRepoForAuthenticatedUserError::Generic { code } => (String::from("Generic"), code)
        };

        Self::Endpoint {
            description,
            status_code,
            source: Some(Box::new(err))
        }
    }
}

/// Errors for the [Create a repository from an unpublished codespace](Codespaces::publish_for_authenticated_user_async()) endpoint.
#[derive(Debug, thiserror::Error)]
pub enum CodespacesPublishForAuthenticatedUserError {
    #[error("Requires authentication")]
    Status401(BasicError),
    #[error("Forbidden")]
    Status403(BasicError),
    #[error("Resource not found")]
    Status404(BasicError),
    #[error("Validation failed, or the endpoint has been spammed.")]
    Status422(ValidationError),
    #[error("Status code: {}", code)]
    Generic { code: u16 },
}

impl From<CodespacesPublishForAuthenticatedUserError> for AdapterError {
    fn from(err: CodespacesPublishForAuthenticatedUserError) -> Self {
        let (description, status_code) = match err {
            CodespacesPublishForAuthenticatedUserError::Status401(_) => (String::from("Requires authentication"), 401),
            CodespacesPublishForAuthenticatedUserError::Status403(_) => (String::from("Forbidden"), 403),
            CodespacesPublishForAuthenticatedUserError::Status404(_) => (String::from("Resource not found"), 404),
            CodespacesPublishForAuthenticatedUserError::Status422(_) => (String::from("Validation failed, or the endpoint has been spammed."), 422),
            CodespacesPublishForAuthenticatedUserError::Generic { code } => (String::from("Generic"), code)
        };

        Self::Endpoint {
            description,
            status_code,
            source: Some(Box::new(err))
        }
    }
}

/// Errors for the [Remove a selected repository from a user secret](Codespaces::remove_repository_for_secret_for_authenticated_user_async()) endpoint.
#[derive(Debug, thiserror::Error)]
pub enum CodespacesRemoveRepositoryForSecretForAuthenticatedUserError {
    #[error("Requires authentication")]
    Status401(BasicError),
    #[error("Forbidden")]
    Status403(BasicError),
    #[error("Resource not found")]
    Status404(BasicError),
    #[error("Internal Error")]
    Status500(BasicError),
    #[error("Status code: {}", code)]
    Generic { code: u16 },
}

impl From<CodespacesRemoveRepositoryForSecretForAuthenticatedUserError> for AdapterError {
    fn from(err: CodespacesRemoveRepositoryForSecretForAuthenticatedUserError) -> Self {
        let (description, status_code) = match err {
            CodespacesRemoveRepositoryForSecretForAuthenticatedUserError::Status401(_) => (String::from("Requires authentication"), 401),
            CodespacesRemoveRepositoryForSecretForAuthenticatedUserError::Status403(_) => (String::from("Forbidden"), 403),
            CodespacesRemoveRepositoryForSecretForAuthenticatedUserError::Status404(_) => (String::from("Resource not found"), 404),
            CodespacesRemoveRepositoryForSecretForAuthenticatedUserError::Status500(_) => (String::from("Internal Error"), 500),
            CodespacesRemoveRepositoryForSecretForAuthenticatedUserError::Generic { code } => (String::from("Generic"), code)
        };

        Self::Endpoint {
            description,
            status_code,
            source: Some(Box::new(err))
        }
    }
}

/// Errors for the [Remove selected repository from an organization secret](Codespaces::remove_selected_repo_from_org_secret_async()) endpoint.
#[derive(Debug, thiserror::Error)]
pub enum CodespacesRemoveSelectedRepoFromOrgSecretError {
    #[error("Resource not found")]
    Status404(BasicError),
    #[error("Conflict when visibility type not set to selected")]
    Status409,
    #[error("Validation failed, or the endpoint has been spammed.")]
    Status422(ValidationError),
    #[error("Status code: {}", code)]
    Generic { code: u16 },
}

impl From<CodespacesRemoveSelectedRepoFromOrgSecretError> for AdapterError {
    fn from(err: CodespacesRemoveSelectedRepoFromOrgSecretError) -> Self {
        let (description, status_code) = match err {
            CodespacesRemoveSelectedRepoFromOrgSecretError::Status404(_) => (String::from("Resource not found"), 404),
            CodespacesRemoveSelectedRepoFromOrgSecretError::Status409 => (String::from("Conflict when visibility type not set to selected"), 409),
            CodespacesRemoveSelectedRepoFromOrgSecretError::Status422(_) => (String::from("Validation failed, or the endpoint has been spammed."), 422),
            CodespacesRemoveSelectedRepoFromOrgSecretError::Generic { code } => (String::from("Generic"), code)
        };

        Self::Endpoint {
            description,
            status_code,
            source: Some(Box::new(err))
        }
    }
}

/// Errors for the [List available machine types for a repository](Codespaces::repo_machines_for_authenticated_user_async()) endpoint.
#[derive(Debug, thiserror::Error)]
pub enum CodespacesRepoMachinesForAuthenticatedUserError {
    #[error("Not modified")]
    Status304,
    #[error("Internal Error")]
    Status500(BasicError),
    #[error("Requires authentication")]
    Status401(BasicError),
    #[error("Forbidden")]
    Status403(BasicError),
    #[error("Resource not found")]
    Status404(BasicError),
    #[error("Status code: {}", code)]
    Generic { code: u16 },
}

impl From<CodespacesRepoMachinesForAuthenticatedUserError> for AdapterError {
    fn from(err: CodespacesRepoMachinesForAuthenticatedUserError) -> Self {
        let (description, status_code) = match err {
            CodespacesRepoMachinesForAuthenticatedUserError::Status304 => (String::from("Not modified"), 304),
            CodespacesRepoMachinesForAuthenticatedUserError::Status500(_) => (String::from("Internal Error"), 500),
            CodespacesRepoMachinesForAuthenticatedUserError::Status401(_) => (String::from("Requires authentication"), 401),
            CodespacesRepoMachinesForAuthenticatedUserError::Status403(_) => (String::from("Forbidden"), 403),
            CodespacesRepoMachinesForAuthenticatedUserError::Status404(_) => (String::from("Resource not found"), 404),
            CodespacesRepoMachinesForAuthenticatedUserError::Generic { code } => (String::from("Generic"), code)
        };

        Self::Endpoint {
            description,
            status_code,
            source: Some(Box::new(err))
        }
    }
}

/// Errors for the [Manage access control for organization codespaces](Codespaces::set_codespaces_access_async()) endpoint.
#[derive(Debug, thiserror::Error)]
pub enum CodespacesSetCodespacesAccessError {
    #[error("Not modified")]
    Status304,
    #[error("Users are neither members nor collaborators of this organization.")]
    Status400,
    #[error("Resource not found")]
    Status404(BasicError),
    #[error("Validation failed, or the endpoint has been spammed.")]
    Status422(ValidationError),
    #[error("Internal Error")]
    Status500(BasicError),
    #[error("Status code: {}", code)]
    Generic { code: u16 },
}

impl From<CodespacesSetCodespacesAccessError> for AdapterError {
    fn from(err: CodespacesSetCodespacesAccessError) -> Self {
        let (description, status_code) = match err {
            CodespacesSetCodespacesAccessError::Status304 => (String::from("Not modified"), 304),
            CodespacesSetCodespacesAccessError::Status400 => (String::from("Users are neither members nor collaborators of this organization."), 400),
            CodespacesSetCodespacesAccessError::Status404(_) => (String::from("Resource not found"), 404),
            CodespacesSetCodespacesAccessError::Status422(_) => (String::from("Validation failed, or the endpoint has been spammed."), 422),
            CodespacesSetCodespacesAccessError::Status500(_) => (String::from("Internal Error"), 500),
            CodespacesSetCodespacesAccessError::Generic { code } => (String::from("Generic"), code)
        };

        Self::Endpoint {
            description,
            status_code,
            source: Some(Box::new(err))
        }
    }
}

/// Errors for the [Add users to Codespaces access for an organization](Codespaces::set_codespaces_access_users_async()) endpoint.
#[derive(Debug, thiserror::Error)]
pub enum CodespacesSetCodespacesAccessUsersError {
    #[error("Not modified")]
    Status304,
    #[error("Users are neither members nor collaborators of this organization.")]
    Status400,
    #[error("Resource not found")]
    Status404(BasicError),
    #[error("Validation failed, or the endpoint has been spammed.")]
    Status422(ValidationError),
    #[error("Internal Error")]
    Status500(BasicError),
    #[error("Status code: {}", code)]
    Generic { code: u16 },
}

impl From<CodespacesSetCodespacesAccessUsersError> for AdapterError {
    fn from(err: CodespacesSetCodespacesAccessUsersError) -> Self {
        let (description, status_code) = match err {
            CodespacesSetCodespacesAccessUsersError::Status304 => (String::from("Not modified"), 304),
            CodespacesSetCodespacesAccessUsersError::Status400 => (String::from("Users are neither members nor collaborators of this organization."), 400),
            CodespacesSetCodespacesAccessUsersError::Status404(_) => (String::from("Resource not found"), 404),
            CodespacesSetCodespacesAccessUsersError::Status422(_) => (String::from("Validation failed, or the endpoint has been spammed."), 422),
            CodespacesSetCodespacesAccessUsersError::Status500(_) => (String::from("Internal Error"), 500),
            CodespacesSetCodespacesAccessUsersError::Generic { code } => (String::from("Generic"), code)
        };

        Self::Endpoint {
            description,
            status_code,
            source: Some(Box::new(err))
        }
    }
}

/// Errors for the [Set selected repositories for a user secret](Codespaces::set_repositories_for_secret_for_authenticated_user_async()) endpoint.
#[derive(Debug, thiserror::Error)]
pub enum CodespacesSetRepositoriesForSecretForAuthenticatedUserError {
    #[error("Requires authentication")]
    Status401(BasicError),
    #[error("Forbidden")]
    Status403(BasicError),
    #[error("Resource not found")]
    Status404(BasicError),
    #[error("Internal Error")]
    Status500(BasicError),
    #[error("Status code: {}", code)]
    Generic { code: u16 },
}

impl From<CodespacesSetRepositoriesForSecretForAuthenticatedUserError> for AdapterError {
    fn from(err: CodespacesSetRepositoriesForSecretForAuthenticatedUserError) -> Self {
        let (description, status_code) = match err {
            CodespacesSetRepositoriesForSecretForAuthenticatedUserError::Status401(_) => (String::from("Requires authentication"), 401),
            CodespacesSetRepositoriesForSecretForAuthenticatedUserError::Status403(_) => (String::from("Forbidden"), 403),
            CodespacesSetRepositoriesForSecretForAuthenticatedUserError::Status404(_) => (String::from("Resource not found"), 404),
            CodespacesSetRepositoriesForSecretForAuthenticatedUserError::Status500(_) => (String::from("Internal Error"), 500),
            CodespacesSetRepositoriesForSecretForAuthenticatedUserError::Generic { code } => (String::from("Generic"), code)
        };

        Self::Endpoint {
            description,
            status_code,
            source: Some(Box::new(err))
        }
    }
}

/// Errors for the [Set selected repositories for an organization secret](Codespaces::set_selected_repos_for_org_secret_async()) endpoint.
#[derive(Debug, thiserror::Error)]
pub enum CodespacesSetSelectedReposForOrgSecretError {
    #[error("Resource not found")]
    Status404(BasicError),
    #[error("Conflict when visibility type not set to selected")]
    Status409,
    #[error("Status code: {}", code)]
    Generic { code: u16 },
}

impl From<CodespacesSetSelectedReposForOrgSecretError> for AdapterError {
    fn from(err: CodespacesSetSelectedReposForOrgSecretError) -> Self {
        let (description, status_code) = match err {
            CodespacesSetSelectedReposForOrgSecretError::Status404(_) => (String::from("Resource not found"), 404),
            CodespacesSetSelectedReposForOrgSecretError::Status409 => (String::from("Conflict when visibility type not set to selected"), 409),
            CodespacesSetSelectedReposForOrgSecretError::Generic { code } => (String::from("Generic"), code)
        };

        Self::Endpoint {
            description,
            status_code,
            source: Some(Box::new(err))
        }
    }
}

/// Errors for the [Start a codespace for the authenticated user](Codespaces::start_for_authenticated_user_async()) endpoint.
#[derive(Debug, thiserror::Error)]
pub enum CodespacesStartForAuthenticatedUserError {
    #[error("Not modified")]
    Status304,
    #[error("Internal Error")]
    Status500(BasicError),
    #[error("Bad Request")]
    Status400(BasicError),
    #[error("Requires authentication")]
    Status401(BasicError),
    #[error("Payment required")]
    Status402(BasicError),
    #[error("Forbidden")]
    Status403(BasicError),
    #[error("Resource not found")]
    Status404(BasicError),
    #[error("Conflict")]
    Status409(BasicError),
    #[error("Status code: {}", code)]
    Generic { code: u16 },
}

impl From<CodespacesStartForAuthenticatedUserError> for AdapterError {
    fn from(err: CodespacesStartForAuthenticatedUserError) -> Self {
        let (description, status_code) = match err {
            CodespacesStartForAuthenticatedUserError::Status304 => (String::from("Not modified"), 304),
            CodespacesStartForAuthenticatedUserError::Status500(_) => (String::from("Internal Error"), 500),
            CodespacesStartForAuthenticatedUserError::Status400(_) => (String::from("Bad Request"), 400),
            CodespacesStartForAuthenticatedUserError::Status401(_) => (String::from("Requires authentication"), 401),
            CodespacesStartForAuthenticatedUserError::Status402(_) => (String::from("Payment required"), 402),
            CodespacesStartForAuthenticatedUserError::Status403(_) => (String::from("Forbidden"), 403),
            CodespacesStartForAuthenticatedUserError::Status404(_) => (String::from("Resource not found"), 404),
            CodespacesStartForAuthenticatedUserError::Status409(_) => (String::from("Conflict"), 409),
            CodespacesStartForAuthenticatedUserError::Generic { code } => (String::from("Generic"), code)
        };

        Self::Endpoint {
            description,
            status_code,
            source: Some(Box::new(err))
        }
    }
}

/// Errors for the [Stop a codespace for the authenticated user](Codespaces::stop_for_authenticated_user_async()) endpoint.
#[derive(Debug, thiserror::Error)]
pub enum CodespacesStopForAuthenticatedUserError {
    #[error("Internal Error")]
    Status500(BasicError),
    #[error("Requires authentication")]
    Status401(BasicError),
    #[error("Forbidden")]
    Status403(BasicError),
    #[error("Resource not found")]
    Status404(BasicError),
    #[error("Status code: {}", code)]
    Generic { code: u16 },
}

impl From<CodespacesStopForAuthenticatedUserError> for AdapterError {
    fn from(err: CodespacesStopForAuthenticatedUserError) -> Self {
        let (description, status_code) = match err {
            CodespacesStopForAuthenticatedUserError::Status500(_) => (String::from("Internal Error"), 500),
            CodespacesStopForAuthenticatedUserError::Status401(_) => (String::from("Requires authentication"), 401),
            CodespacesStopForAuthenticatedUserError::Status403(_) => (String::from("Forbidden"), 403),
            CodespacesStopForAuthenticatedUserError::Status404(_) => (String::from("Resource not found"), 404),
            CodespacesStopForAuthenticatedUserError::Generic { code } => (String::from("Generic"), code)
        };

        Self::Endpoint {
            description,
            status_code,
            source: Some(Box::new(err))
        }
    }
}

/// Errors for the [Stop a codespace for an organization user](Codespaces::stop_in_organization_async()) endpoint.
#[derive(Debug, thiserror::Error)]
pub enum CodespacesStopInOrganizationError {
    #[error("Not modified")]
    Status304,
    #[error("Internal Error")]
    Status500(BasicError),
    #[error("Requires authentication")]
    Status401(BasicError),
    #[error("Forbidden")]
    Status403(BasicError),
    #[error("Resource not found")]
    Status404(BasicError),
    #[error("Status code: {}", code)]
    Generic { code: u16 },
}

impl From<CodespacesStopInOrganizationError> for AdapterError {
    fn from(err: CodespacesStopInOrganizationError) -> Self {
        let (description, status_code) = match err {
            CodespacesStopInOrganizationError::Status304 => (String::from("Not modified"), 304),
            CodespacesStopInOrganizationError::Status500(_) => (String::from("Internal Error"), 500),
            CodespacesStopInOrganizationError::Status401(_) => (String::from("Requires authentication"), 401),
            CodespacesStopInOrganizationError::Status403(_) => (String::from("Forbidden"), 403),
            CodespacesStopInOrganizationError::Status404(_) => (String::from("Resource not found"), 404),
            CodespacesStopInOrganizationError::Generic { code } => (String::from("Generic"), code)
        };

        Self::Endpoint {
            description,
            status_code,
            source: Some(Box::new(err))
        }
    }
}

/// Errors for the [Update a codespace for the authenticated user](Codespaces::update_for_authenticated_user_async()) endpoint.
#[derive(Debug, thiserror::Error)]
pub enum CodespacesUpdateForAuthenticatedUserError {
    #[error("Requires authentication")]
    Status401(BasicError),
    #[error("Forbidden")]
    Status403(BasicError),
    #[error("Resource not found")]
    Status404(BasicError),
    #[error("Status code: {}", code)]
    Generic { code: u16 },
}

impl From<CodespacesUpdateForAuthenticatedUserError> for AdapterError {
    fn from(err: CodespacesUpdateForAuthenticatedUserError) -> Self {
        let (description, status_code) = match err {
            CodespacesUpdateForAuthenticatedUserError::Status401(_) => (String::from("Requires authentication"), 401),
            CodespacesUpdateForAuthenticatedUserError::Status403(_) => (String::from("Forbidden"), 403),
            CodespacesUpdateForAuthenticatedUserError::Status404(_) => (String::from("Resource not found"), 404),
            CodespacesUpdateForAuthenticatedUserError::Generic { code } => (String::from("Generic"), code)
        };

        Self::Endpoint {
            description,
            status_code,
            source: Some(Box::new(err))
        }
    }
}


/// Query parameters for the [Check if permissions defined by a devcontainer have been accepted by the authenticated user](Codespaces::check_permissions_for_devcontainer_async()) endpoint.
#[derive(Default, Serialize)]
pub struct CodespacesCheckPermissionsForDevcontainerParams<'req> {
    /// The git reference that points to the location of the devcontainer configuration to use for the permission check. The value of `ref` will typically be a branch name (`heads/BRANCH_NAME`). For more information, see \"[Git References](https://git-scm.com/book/en/v2/Git-Internals-Git-References)\" in the Git documentation.
    git_ref: &'req str, 
    /// Path to the devcontainer.json configuration to use for the permission check.
    devcontainer_path: &'req str
}

impl<'req> CodespacesCheckPermissionsForDevcontainerParams<'req> {
    pub fn new() -> Self {
        Self::default()
    }

    /// The git reference that points to the location of the devcontainer configuration to use for the permission check. The value of `ref` will typically be a branch name (`heads/BRANCH_NAME`). For more information, see \"[Git References](https://git-scm.com/book/en/v2/Git-Internals-Git-References)\" in the Git documentation.
    pub fn git_ref(self, git_ref: &'req str) -> Self {
        Self {
            git_ref: git_ref,
            devcontainer_path: self.devcontainer_path, 
        }
    }

    /// Path to the devcontainer.json configuration to use for the permission check.
    pub fn devcontainer_path(self, devcontainer_path: &'req str) -> Self {
        Self {
            git_ref: self.git_ref, 
            devcontainer_path: devcontainer_path,
        }
    }
}

/// Query parameters for the [List codespaces for a user in organization](Codespaces::get_codespaces_for_user_in_org_async()) endpoint.
#[derive(Default, Serialize)]
pub struct CodespacesGetCodespacesForUserInOrgParams {
    /// The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    per_page: Option<u16>, 
    /// The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    page: Option<u16>
}

impl CodespacesGetCodespacesForUserInOrgParams {
    pub fn new() -> Self {
        Self::default()
    }

    /// The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    pub fn per_page(self, per_page: u16) -> Self {
        Self {
            per_page: Some(per_page),
            page: self.page, 
        }
    }

    /// The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    pub fn page(self, page: u16) -> Self {
        Self {
            per_page: self.per_page, 
            page: Some(page),
        }
    }
}

impl<'enc> From<&'enc PerPage> for CodespacesGetCodespacesForUserInOrgParams {
    fn from(per_page: &'enc PerPage) -> Self {
        Self {
            per_page: Some(per_page.per_page),
            page: Some(per_page.page),
            ..Default::default()
        }
    }
}
/// Query parameters for the [List devcontainer configurations in a repository for the authenticated user](Codespaces::list_devcontainers_in_repository_for_authenticated_user_async()) endpoint.
#[derive(Default, Serialize)]
pub struct CodespacesListDevcontainersInRepositoryForAuthenticatedUserParams {
    /// The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    per_page: Option<u16>, 
    /// The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    page: Option<u16>
}

impl CodespacesListDevcontainersInRepositoryForAuthenticatedUserParams {
    pub fn new() -> Self {
        Self::default()
    }

    /// The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    pub fn per_page(self, per_page: u16) -> Self {
        Self {
            per_page: Some(per_page),
            page: self.page, 
        }
    }

    /// The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    pub fn page(self, page: u16) -> Self {
        Self {
            per_page: self.per_page, 
            page: Some(page),
        }
    }
}

impl<'enc> From<&'enc PerPage> for CodespacesListDevcontainersInRepositoryForAuthenticatedUserParams {
    fn from(per_page: &'enc PerPage) -> Self {
        Self {
            per_page: Some(per_page.per_page),
            page: Some(per_page.page),
            ..Default::default()
        }
    }
}
/// Query parameters for the [List codespaces for the authenticated user](Codespaces::list_for_authenticated_user_async()) endpoint.
#[derive(Default, Serialize)]
pub struct CodespacesListForAuthenticatedUserParams {
    /// The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    per_page: Option<u16>, 
    /// The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    page: Option<u16>, 
    /// ID of the Repository to filter on
    repository_id: Option<i32>
}

impl CodespacesListForAuthenticatedUserParams {
    pub fn new() -> Self {
        Self::default()
    }

    /// The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    pub fn per_page(self, per_page: u16) -> Self {
        Self {
            per_page: Some(per_page),
            page: self.page, 
            repository_id: self.repository_id, 
        }
    }

    /// The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    pub fn page(self, page: u16) -> Self {
        Self {
            per_page: self.per_page, 
            page: Some(page),
            repository_id: self.repository_id, 
        }
    }

    /// ID of the Repository to filter on
    pub fn repository_id(self, repository_id: i32) -> Self {
        Self {
            per_page: self.per_page, 
            page: self.page, 
            repository_id: Some(repository_id),
        }
    }
}

impl<'enc> From<&'enc PerPage> for CodespacesListForAuthenticatedUserParams {
    fn from(per_page: &'enc PerPage) -> Self {
        Self {
            per_page: Some(per_page.per_page),
            page: Some(per_page.page),
            ..Default::default()
        }
    }
}
/// Query parameters for the [List codespaces for the organization](Codespaces::list_in_organization_async()) endpoint.
#[derive(Default, Serialize)]
pub struct CodespacesListInOrganizationParams {
    /// The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    per_page: Option<u16>, 
    /// The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    page: Option<u16>
}

impl CodespacesListInOrganizationParams {
    pub fn new() -> Self {
        Self::default()
    }

    /// The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    pub fn per_page(self, per_page: u16) -> Self {
        Self {
            per_page: Some(per_page),
            page: self.page, 
        }
    }

    /// The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    pub fn page(self, page: u16) -> Self {
        Self {
            per_page: self.per_page, 
            page: Some(page),
        }
    }
}

impl<'enc> From<&'enc PerPage> for CodespacesListInOrganizationParams {
    fn from(per_page: &'enc PerPage) -> Self {
        Self {
            per_page: Some(per_page.per_page),
            page: Some(per_page.page),
            ..Default::default()
        }
    }
}
/// Query parameters for the [List codespaces in a repository for the authenticated user](Codespaces::list_in_repository_for_authenticated_user_async()) endpoint.
#[derive(Default, Serialize)]
pub struct CodespacesListInRepositoryForAuthenticatedUserParams {
    /// The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    per_page: Option<u16>, 
    /// The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    page: Option<u16>
}

impl CodespacesListInRepositoryForAuthenticatedUserParams {
    pub fn new() -> Self {
        Self::default()
    }

    /// The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    pub fn per_page(self, per_page: u16) -> Self {
        Self {
            per_page: Some(per_page),
            page: self.page, 
        }
    }

    /// The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    pub fn page(self, page: u16) -> Self {
        Self {
            per_page: self.per_page, 
            page: Some(page),
        }
    }
}

impl<'enc> From<&'enc PerPage> for CodespacesListInRepositoryForAuthenticatedUserParams {
    fn from(per_page: &'enc PerPage) -> Self {
        Self {
            per_page: Some(per_page.per_page),
            page: Some(per_page.page),
            ..Default::default()
        }
    }
}
/// Query parameters for the [List organization secrets](Codespaces::list_org_secrets_async()) endpoint.
#[derive(Default, Serialize)]
pub struct CodespacesListOrgSecretsParams {
    /// The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    per_page: Option<u16>, 
    /// The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    page: Option<u16>
}

impl CodespacesListOrgSecretsParams {
    pub fn new() -> Self {
        Self::default()
    }

    /// The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    pub fn per_page(self, per_page: u16) -> Self {
        Self {
            per_page: Some(per_page),
            page: self.page, 
        }
    }

    /// The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    pub fn page(self, page: u16) -> Self {
        Self {
            per_page: self.per_page, 
            page: Some(page),
        }
    }
}

impl<'enc> From<&'enc PerPage> for CodespacesListOrgSecretsParams {
    fn from(per_page: &'enc PerPage) -> Self {
        Self {
            per_page: Some(per_page.per_page),
            page: Some(per_page.page),
            ..Default::default()
        }
    }
}
/// Query parameters for the [List repository secrets](Codespaces::list_repo_secrets_async()) endpoint.
#[derive(Default, Serialize)]
pub struct CodespacesListRepoSecretsParams {
    /// The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    per_page: Option<u16>, 
    /// The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    page: Option<u16>
}

impl CodespacesListRepoSecretsParams {
    pub fn new() -> Self {
        Self::default()
    }

    /// The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    pub fn per_page(self, per_page: u16) -> Self {
        Self {
            per_page: Some(per_page),
            page: self.page, 
        }
    }

    /// The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    pub fn page(self, page: u16) -> Self {
        Self {
            per_page: self.per_page, 
            page: Some(page),
        }
    }
}

impl<'enc> From<&'enc PerPage> for CodespacesListRepoSecretsParams {
    fn from(per_page: &'enc PerPage) -> Self {
        Self {
            per_page: Some(per_page.per_page),
            page: Some(per_page.page),
            ..Default::default()
        }
    }
}
/// Query parameters for the [List secrets for the authenticated user](Codespaces::list_secrets_for_authenticated_user_async()) endpoint.
#[derive(Default, Serialize)]
pub struct CodespacesListSecretsForAuthenticatedUserParams {
    /// The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    per_page: Option<u16>, 
    /// The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    page: Option<u16>
}

impl CodespacesListSecretsForAuthenticatedUserParams {
    pub fn new() -> Self {
        Self::default()
    }

    /// The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    pub fn per_page(self, per_page: u16) -> Self {
        Self {
            per_page: Some(per_page),
            page: self.page, 
        }
    }

    /// The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    pub fn page(self, page: u16) -> Self {
        Self {
            per_page: self.per_page, 
            page: Some(page),
        }
    }
}

impl<'enc> From<&'enc PerPage> for CodespacesListSecretsForAuthenticatedUserParams {
    fn from(per_page: &'enc PerPage) -> Self {
        Self {
            per_page: Some(per_page.per_page),
            page: Some(per_page.page),
            ..Default::default()
        }
    }
}
/// Query parameters for the [List selected repositories for an organization secret](Codespaces::list_selected_repos_for_org_secret_async()) endpoint.
#[derive(Default, Serialize)]
pub struct CodespacesListSelectedReposForOrgSecretParams {
    /// The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    page: Option<u16>, 
    /// The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    per_page: Option<u16>
}

impl CodespacesListSelectedReposForOrgSecretParams {
    pub fn new() -> Self {
        Self::default()
    }

    /// The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    pub fn page(self, page: u16) -> Self {
        Self {
            page: Some(page),
            per_page: self.per_page, 
        }
    }

    /// The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    pub fn per_page(self, per_page: u16) -> Self {
        Self {
            page: self.page, 
            per_page: Some(per_page),
        }
    }
}

impl<'enc> From<&'enc PerPage> for CodespacesListSelectedReposForOrgSecretParams {
    fn from(per_page: &'enc PerPage) -> Self {
        Self {
            per_page: Some(per_page.per_page),
            page: Some(per_page.page),
            ..Default::default()
        }
    }
}
/// Query parameters for the [Get default attributes for a codespace](Codespaces::pre_flight_with_repo_for_authenticated_user_async()) endpoint.
#[derive(Default, Serialize)]
pub struct CodespacesPreFlightWithRepoForAuthenticatedUserParams<'req> {
    /// The branch or commit to check for a default devcontainer path. If not specified, the default branch will be checked.
    git_ref: Option<&'req str>, 
    /// An alternative IP for default location auto-detection, such as when proxying a request.
    client_ip: Option<&'req str>
}

impl<'req> CodespacesPreFlightWithRepoForAuthenticatedUserParams<'req> {
    pub fn new() -> Self {
        Self::default()
    }

    /// The branch or commit to check for a default devcontainer path. If not specified, the default branch will be checked.
    pub fn git_ref(self, git_ref: &'req str) -> Self {
        Self {
            git_ref: Some(git_ref),
            client_ip: self.client_ip, 
        }
    }

    /// An alternative IP for default location auto-detection, such as when proxying a request.
    pub fn client_ip(self, client_ip: &'req str) -> Self {
        Self {
            git_ref: self.git_ref, 
            client_ip: Some(client_ip),
        }
    }
}

/// Query parameters for the [List available machine types for a repository](Codespaces::repo_machines_for_authenticated_user_async()) endpoint.
#[derive(Default, Serialize)]
pub struct CodespacesRepoMachinesForAuthenticatedUserParams<'req> {
    /// The location to check for available machines. Assigned by IP if not provided.
    location: Option<&'req str>, 
    /// IP for location auto-detection when proxying a request
    client_ip: Option<&'req str>, 
    /// The branch or commit to check for prebuild availability and devcontainer restrictions.
    git_ref: Option<&'req str>
}

impl<'req> CodespacesRepoMachinesForAuthenticatedUserParams<'req> {
    pub fn new() -> Self {
        Self::default()
    }

    /// The location to check for available machines. Assigned by IP if not provided.
    pub fn location(self, location: &'req str) -> Self {
        Self {
            location: Some(location),
            client_ip: self.client_ip, 
            git_ref: self.git_ref, 
        }
    }

    /// IP for location auto-detection when proxying a request
    pub fn client_ip(self, client_ip: &'req str) -> Self {
        Self {
            location: self.location, 
            client_ip: Some(client_ip),
            git_ref: self.git_ref, 
        }
    }

    /// The branch or commit to check for prebuild availability and devcontainer restrictions.
    pub fn git_ref(self, git_ref: &'req str) -> Self {
        Self {
            location: self.location, 
            client_ip: self.client_ip, 
            git_ref: Some(git_ref),
        }
    }
}


impl<'api, C: Client> Codespaces<'api, C> where AdapterError: From<<C as Client>::Err> {
    /// ---
    ///
    /// # Add a selected repository to a user secret
    ///
    /// Adds a repository to the selected repositories for a user's development environment secret.
    /// 
    /// The authenticated user must have Codespaces access to use this endpoint.
    /// 
    /// OAuth app tokens and personal access tokens (classic) need the `codespace` or `codespace:secrets` scope to use this endpoint.
    ///
    /// [GitHub API docs for add_repository_for_secret_for_authenticated_user](https://docs.github.com/rest/codespaces/secrets#add-a-selected-repository-to-a-user-secret)
    ///
    /// ---
    pub async fn add_repository_for_secret_for_authenticated_user_async(&self, secret_name: &str, repository_id: i32) -> Result<(), AdapterError> {

        let request_uri = format!("{}/user/codespaces/secrets/{}/repositories/{}", super::GITHUB_BASE_API_URL, secret_name, repository_id);


        let req = GitHubRequest {
            uri: request_uri,
            body: None::<C::Body>,
            method: "PUT",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch_async(request).await?;

        // --

        if github_response.is_success() {
            Ok(github_response.to_json_async().await?)
        } else {
            match github_response.status_code() {
                401 => Err(CodespacesAddRepositoryForSecretForAuthenticatedUserError::Status401(github_response.to_json_async().await?).into()),
                403 => Err(CodespacesAddRepositoryForSecretForAuthenticatedUserError::Status403(github_response.to_json_async().await?).into()),
                404 => Err(CodespacesAddRepositoryForSecretForAuthenticatedUserError::Status404(github_response.to_json_async().await?).into()),
                500 => Err(CodespacesAddRepositoryForSecretForAuthenticatedUserError::Status500(github_response.to_json_async().await?).into()),
                code => Err(CodespacesAddRepositoryForSecretForAuthenticatedUserError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # Add a selected repository to a user secret
    ///
    /// Adds a repository to the selected repositories for a user's development environment secret.
    /// 
    /// The authenticated user must have Codespaces access to use this endpoint.
    /// 
    /// OAuth app tokens and personal access tokens (classic) need the `codespace` or `codespace:secrets` scope to use this endpoint.
    ///
    /// [GitHub API docs for add_repository_for_secret_for_authenticated_user](https://docs.github.com/rest/codespaces/secrets#add-a-selected-repository-to-a-user-secret)
    ///
    /// ---
    #[cfg(not(target_arch = "wasm32"))]
    pub fn add_repository_for_secret_for_authenticated_user(&self, secret_name: &str, repository_id: i32) -> Result<(), AdapterError> {

        let request_uri = format!("{}/user/codespaces/secrets/{}/repositories/{}", super::GITHUB_BASE_API_URL, secret_name, repository_id);


        let req = GitHubRequest {
            uri: request_uri,
            body: None,
            method: "PUT",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch(request)?;

        // --

        if github_response.is_success() {
            Ok(github_response.to_json()?)
        } else {
            match github_response.status_code() {
                401 => Err(CodespacesAddRepositoryForSecretForAuthenticatedUserError::Status401(github_response.to_json()?).into()),
                403 => Err(CodespacesAddRepositoryForSecretForAuthenticatedUserError::Status403(github_response.to_json()?).into()),
                404 => Err(CodespacesAddRepositoryForSecretForAuthenticatedUserError::Status404(github_response.to_json()?).into()),
                500 => Err(CodespacesAddRepositoryForSecretForAuthenticatedUserError::Status500(github_response.to_json()?).into()),
                code => Err(CodespacesAddRepositoryForSecretForAuthenticatedUserError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # Add selected repository to an organization secret
    ///
    /// Adds a repository to an organization development environment secret when the `visibility` for repository access is set to `selected`. The visibility is set when you [Create or update an organization secret](https://docs.github.com/rest/codespaces/organization-secrets#create-or-update-an-organization-secret).
    /// OAuth app tokens and personal access tokens (classic) need the `admin:org` scope to use this endpoint.
    ///
    /// [GitHub API docs for add_selected_repo_to_org_secret](https://docs.github.com/rest/codespaces/organization-secrets#add-selected-repository-to-an-organization-secret)
    ///
    /// ---
    pub async fn add_selected_repo_to_org_secret_async(&self, org: &str, secret_name: &str, repository_id: i32) -> Result<(), AdapterError> {

        let request_uri = format!("{}/orgs/{}/codespaces/secrets/{}/repositories/{}", super::GITHUB_BASE_API_URL, org, secret_name, repository_id);


        let req = GitHubRequest {
            uri: request_uri,
            body: None::<C::Body>,
            method: "PUT",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch_async(request).await?;

        // --

        if github_response.is_success() {
            Ok(github_response.to_json_async().await?)
        } else {
            match github_response.status_code() {
                404 => Err(CodespacesAddSelectedRepoToOrgSecretError::Status404(github_response.to_json_async().await?).into()),
                409 => Err(CodespacesAddSelectedRepoToOrgSecretError::Status409.into()),
                422 => Err(CodespacesAddSelectedRepoToOrgSecretError::Status422(github_response.to_json_async().await?).into()),
                code => Err(CodespacesAddSelectedRepoToOrgSecretError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # Add selected repository to an organization secret
    ///
    /// Adds a repository to an organization development environment secret when the `visibility` for repository access is set to `selected`. The visibility is set when you [Create or update an organization secret](https://docs.github.com/rest/codespaces/organization-secrets#create-or-update-an-organization-secret).
    /// OAuth app tokens and personal access tokens (classic) need the `admin:org` scope to use this endpoint.
    ///
    /// [GitHub API docs for add_selected_repo_to_org_secret](https://docs.github.com/rest/codespaces/organization-secrets#add-selected-repository-to-an-organization-secret)
    ///
    /// ---
    #[cfg(not(target_arch = "wasm32"))]
    pub fn add_selected_repo_to_org_secret(&self, org: &str, secret_name: &str, repository_id: i32) -> Result<(), AdapterError> {

        let request_uri = format!("{}/orgs/{}/codespaces/secrets/{}/repositories/{}", super::GITHUB_BASE_API_URL, org, secret_name, repository_id);


        let req = GitHubRequest {
            uri: request_uri,
            body: None,
            method: "PUT",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch(request)?;

        // --

        if github_response.is_success() {
            Ok(github_response.to_json()?)
        } else {
            match github_response.status_code() {
                404 => Err(CodespacesAddSelectedRepoToOrgSecretError::Status404(github_response.to_json()?).into()),
                409 => Err(CodespacesAddSelectedRepoToOrgSecretError::Status409.into()),
                422 => Err(CodespacesAddSelectedRepoToOrgSecretError::Status422(github_response.to_json()?).into()),
                code => Err(CodespacesAddSelectedRepoToOrgSecretError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # Check if permissions defined by a devcontainer have been accepted by the authenticated user
    ///
    /// Checks whether the permissions defined by a given devcontainer configuration have been accepted by the authenticated user.
    /// 
    /// OAuth app tokens and personal access tokens (classic) need the `codespace` scope to use this endpoint.
    ///
    /// [GitHub API docs for check_permissions_for_devcontainer](https://docs.github.com/rest/codespaces/codespaces#check-if-permissions-defined-by-a-devcontainer-have-been-accepted-by-the-authenticated-user)
    ///
    /// ---
    pub async fn check_permissions_for_devcontainer_async(&self, owner: &str, repo: &str, query_params: impl Into<CodespacesCheckPermissionsForDevcontainerParams<'api>>) -> Result<CodespacesPermissionsCheckForDevcontainer, AdapterError> {

        let mut request_uri = format!("{}/repos/{}/{}/codespaces/permissions_check", super::GITHUB_BASE_API_URL, owner, repo);

        request_uri.push_str("?");
        request_uri.push_str(&serde_urlencoded::to_string(query_params.into())?);

        let req = GitHubRequest {
            uri: request_uri,
            body: None::<C::Body>,
            method: "GET",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch_async(request).await?;

        // --

        if github_response.is_success() {
            Ok(github_response.to_json_async().await?)
        } else {
            match github_response.status_code() {
                401 => Err(CodespacesCheckPermissionsForDevcontainerError::Status401(github_response.to_json_async().await?).into()),
                403 => Err(CodespacesCheckPermissionsForDevcontainerError::Status403(github_response.to_json_async().await?).into()),
                404 => Err(CodespacesCheckPermissionsForDevcontainerError::Status404(github_response.to_json_async().await?).into()),
                422 => Err(CodespacesCheckPermissionsForDevcontainerError::Status422(github_response.to_json_async().await?).into()),
                503 => Err(CodespacesCheckPermissionsForDevcontainerError::Status503(github_response.to_json_async().await?).into()),
                code => Err(CodespacesCheckPermissionsForDevcontainerError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # Check if permissions defined by a devcontainer have been accepted by the authenticated user
    ///
    /// Checks whether the permissions defined by a given devcontainer configuration have been accepted by the authenticated user.
    /// 
    /// OAuth app tokens and personal access tokens (classic) need the `codespace` scope to use this endpoint.
    ///
    /// [GitHub API docs for check_permissions_for_devcontainer](https://docs.github.com/rest/codespaces/codespaces#check-if-permissions-defined-by-a-devcontainer-have-been-accepted-by-the-authenticated-user)
    ///
    /// ---
    #[cfg(not(target_arch = "wasm32"))]
    pub fn check_permissions_for_devcontainer(&self, owner: &str, repo: &str, query_params: impl Into<CodespacesCheckPermissionsForDevcontainerParams<'api>>) -> Result<CodespacesPermissionsCheckForDevcontainer, AdapterError> {

        let mut request_uri = format!("{}/repos/{}/{}/codespaces/permissions_check", super::GITHUB_BASE_API_URL, owner, repo);

        request_uri.push_str("?");
        let qp: CodespacesCheckPermissionsForDevcontainerParams = query_params.into();
        request_uri.push_str(&serde_urlencoded::to_string(qp)?);

        let req = GitHubRequest {
            uri: request_uri,
            body: None,
            method: "GET",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch(request)?;

        // --

        if github_response.is_success() {
            Ok(github_response.to_json()?)
        } else {
            match github_response.status_code() {
                401 => Err(CodespacesCheckPermissionsForDevcontainerError::Status401(github_response.to_json()?).into()),
                403 => Err(CodespacesCheckPermissionsForDevcontainerError::Status403(github_response.to_json()?).into()),
                404 => Err(CodespacesCheckPermissionsForDevcontainerError::Status404(github_response.to_json()?).into()),
                422 => Err(CodespacesCheckPermissionsForDevcontainerError::Status422(github_response.to_json()?).into()),
                503 => Err(CodespacesCheckPermissionsForDevcontainerError::Status503(github_response.to_json()?).into()),
                code => Err(CodespacesCheckPermissionsForDevcontainerError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # List machine types for a codespace
    ///
    /// List the machine types a codespace can transition to use.
    /// 
    /// OAuth app tokens and personal access tokens (classic) need the `codespace` scope to use this endpoint.
    ///
    /// [GitHub API docs for codespace_machines_for_authenticated_user](https://docs.github.com/rest/codespaces/machines#list-machine-types-for-a-codespace)
    ///
    /// ---
    pub async fn codespace_machines_for_authenticated_user_async(&self, codespace_name: &str) -> Result<GetCodespacesCodespaceMachinesForAuthenticatedUserResponse200, AdapterError> {

        let request_uri = format!("{}/user/codespaces/{}/machines", super::GITHUB_BASE_API_URL, codespace_name);


        let req = GitHubRequest {
            uri: request_uri,
            body: None::<C::Body>,
            method: "GET",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch_async(request).await?;

        // --

        if github_response.is_success() {
            Ok(github_response.to_json_async().await?)
        } else {
            match github_response.status_code() {
                304 => Err(CodespacesCodespaceMachinesForAuthenticatedUserError::Status304.into()),
                500 => Err(CodespacesCodespaceMachinesForAuthenticatedUserError::Status500(github_response.to_json_async().await?).into()),
                401 => Err(CodespacesCodespaceMachinesForAuthenticatedUserError::Status401(github_response.to_json_async().await?).into()),
                403 => Err(CodespacesCodespaceMachinesForAuthenticatedUserError::Status403(github_response.to_json_async().await?).into()),
                404 => Err(CodespacesCodespaceMachinesForAuthenticatedUserError::Status404(github_response.to_json_async().await?).into()),
                code => Err(CodespacesCodespaceMachinesForAuthenticatedUserError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # List machine types for a codespace
    ///
    /// List the machine types a codespace can transition to use.
    /// 
    /// OAuth app tokens and personal access tokens (classic) need the `codespace` scope to use this endpoint.
    ///
    /// [GitHub API docs for codespace_machines_for_authenticated_user](https://docs.github.com/rest/codespaces/machines#list-machine-types-for-a-codespace)
    ///
    /// ---
    #[cfg(not(target_arch = "wasm32"))]
    pub fn codespace_machines_for_authenticated_user(&self, codespace_name: &str) -> Result<GetCodespacesCodespaceMachinesForAuthenticatedUserResponse200, AdapterError> {

        let request_uri = format!("{}/user/codespaces/{}/machines", super::GITHUB_BASE_API_URL, codespace_name);


        let req = GitHubRequest {
            uri: request_uri,
            body: None,
            method: "GET",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch(request)?;

        // --

        if github_response.is_success() {
            Ok(github_response.to_json()?)
        } else {
            match github_response.status_code() {
                304 => Err(CodespacesCodespaceMachinesForAuthenticatedUserError::Status304.into()),
                500 => Err(CodespacesCodespaceMachinesForAuthenticatedUserError::Status500(github_response.to_json()?).into()),
                401 => Err(CodespacesCodespaceMachinesForAuthenticatedUserError::Status401(github_response.to_json()?).into()),
                403 => Err(CodespacesCodespaceMachinesForAuthenticatedUserError::Status403(github_response.to_json()?).into()),
                404 => Err(CodespacesCodespaceMachinesForAuthenticatedUserError::Status404(github_response.to_json()?).into()),
                code => Err(CodespacesCodespaceMachinesForAuthenticatedUserError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # Create a codespace for the authenticated user
    ///
    /// Creates a new codespace, owned by the authenticated user.
    /// 
    /// This endpoint requires either a `repository_id` OR a `pull_request` but not both.
    /// 
    /// OAuth app tokens and personal access tokens (classic) need the `codespace` scope to use this endpoint.
    ///
    /// [GitHub API docs for create_for_authenticated_user](https://docs.github.com/rest/codespaces/codespaces#create-a-codespace-for-the-authenticated-user)
    ///
    /// ---
    pub async fn create_for_authenticated_user_async(&self, body: PostCodespacesCreateForAuthenticatedUser) -> Result<Codespace, AdapterError> {

        let request_uri = format!("{}/user/codespaces", super::GITHUB_BASE_API_URL);


        let req = GitHubRequest {
            uri: request_uri,
            body: Some(C::from_json::<PostCodespacesCreateForAuthenticatedUser>(body)?),
            method: "POST",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch_async(request).await?;

        // --

        if github_response.is_success() {
            Ok(github_response.to_json_async().await?)
        } else {
            match github_response.status_code() {
                202 => Err(CodespacesCreateForAuthenticatedUserError::Status202(github_response.to_json_async().await?).into()),
                401 => Err(CodespacesCreateForAuthenticatedUserError::Status401(github_response.to_json_async().await?).into()),
                403 => Err(CodespacesCreateForAuthenticatedUserError::Status403(github_response.to_json_async().await?).into()),
                404 => Err(CodespacesCreateForAuthenticatedUserError::Status404(github_response.to_json_async().await?).into()),
                503 => Err(CodespacesCreateForAuthenticatedUserError::Status503(github_response.to_json_async().await?).into()),
                code => Err(CodespacesCreateForAuthenticatedUserError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # Create a codespace for the authenticated user
    ///
    /// Creates a new codespace, owned by the authenticated user.
    /// 
    /// This endpoint requires either a `repository_id` OR a `pull_request` but not both.
    /// 
    /// OAuth app tokens and personal access tokens (classic) need the `codespace` scope to use this endpoint.
    ///
    /// [GitHub API docs for create_for_authenticated_user](https://docs.github.com/rest/codespaces/codespaces#create-a-codespace-for-the-authenticated-user)
    ///
    /// ---
    #[cfg(not(target_arch = "wasm32"))]
    pub fn create_for_authenticated_user(&self, body: PostCodespacesCreateForAuthenticatedUser) -> Result<Codespace, AdapterError> {

        let request_uri = format!("{}/user/codespaces", super::GITHUB_BASE_API_URL);


        let req = GitHubRequest {
            uri: request_uri,
            body: Some(C::from_json::<PostCodespacesCreateForAuthenticatedUser>(body)?),
            method: "POST",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch(request)?;

        // --

        if github_response.is_success() {
            Ok(github_response.to_json()?)
        } else {
            match github_response.status_code() {
                202 => Err(CodespacesCreateForAuthenticatedUserError::Status202(github_response.to_json()?).into()),
                401 => Err(CodespacesCreateForAuthenticatedUserError::Status401(github_response.to_json()?).into()),
                403 => Err(CodespacesCreateForAuthenticatedUserError::Status403(github_response.to_json()?).into()),
                404 => Err(CodespacesCreateForAuthenticatedUserError::Status404(github_response.to_json()?).into()),
                503 => Err(CodespacesCreateForAuthenticatedUserError::Status503(github_response.to_json()?).into()),
                code => Err(CodespacesCreateForAuthenticatedUserError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # Create or update an organization secret
    ///
    /// Creates or updates an organization development environment secret with an encrypted value. Encrypt your secret using
    /// [LibSodium](https://libsodium.gitbook.io/doc/bindings_for_other_languages). For more information, see "[Encrypting secrets for the REST API](https://docs.github.com/rest/guides/encrypting-secrets-for-the-rest-api)."
    /// 
    /// OAuth app tokens and personal access tokens (classic) need the `admin:org` scope to use this endpoint.
    ///
    /// [GitHub API docs for create_or_update_org_secret](https://docs.github.com/rest/codespaces/organization-secrets#create-or-update-an-organization-secret)
    ///
    /// ---
    pub async fn create_or_update_org_secret_async(&self, org: &str, secret_name: &str, body: PutCodespacesCreateOrUpdateOrgSecret) -> Result<EmptyObject, AdapterError> {

        let request_uri = format!("{}/orgs/{}/codespaces/secrets/{}", super::GITHUB_BASE_API_URL, org, secret_name);


        let req = GitHubRequest {
            uri: request_uri,
            body: Some(C::from_json::<PutCodespacesCreateOrUpdateOrgSecret>(body)?),
            method: "PUT",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch_async(request).await?;

        // --

        if github_response.is_success() {
            Ok(github_response.to_json_async().await?)
        } else {
            match github_response.status_code() {
                204 => Err(CodespacesCreateOrUpdateOrgSecretError::Status204.into()),
                404 => Err(CodespacesCreateOrUpdateOrgSecretError::Status404(github_response.to_json_async().await?).into()),
                422 => Err(CodespacesCreateOrUpdateOrgSecretError::Status422(github_response.to_json_async().await?).into()),
                code => Err(CodespacesCreateOrUpdateOrgSecretError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # Create or update an organization secret
    ///
    /// Creates or updates an organization development environment secret with an encrypted value. Encrypt your secret using
    /// [LibSodium](https://libsodium.gitbook.io/doc/bindings_for_other_languages). For more information, see "[Encrypting secrets for the REST API](https://docs.github.com/rest/guides/encrypting-secrets-for-the-rest-api)."
    /// 
    /// OAuth app tokens and personal access tokens (classic) need the `admin:org` scope to use this endpoint.
    ///
    /// [GitHub API docs for create_or_update_org_secret](https://docs.github.com/rest/codespaces/organization-secrets#create-or-update-an-organization-secret)
    ///
    /// ---
    #[cfg(not(target_arch = "wasm32"))]
    pub fn create_or_update_org_secret(&self, org: &str, secret_name: &str, body: PutCodespacesCreateOrUpdateOrgSecret) -> Result<EmptyObject, AdapterError> {

        let request_uri = format!("{}/orgs/{}/codespaces/secrets/{}", super::GITHUB_BASE_API_URL, org, secret_name);


        let req = GitHubRequest {
            uri: request_uri,
            body: Some(C::from_json::<PutCodespacesCreateOrUpdateOrgSecret>(body)?),
            method: "PUT",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch(request)?;

        // --

        if github_response.is_success() {
            Ok(github_response.to_json()?)
        } else {
            match github_response.status_code() {
                204 => Err(CodespacesCreateOrUpdateOrgSecretError::Status204.into()),
                404 => Err(CodespacesCreateOrUpdateOrgSecretError::Status404(github_response.to_json()?).into()),
                422 => Err(CodespacesCreateOrUpdateOrgSecretError::Status422(github_response.to_json()?).into()),
                code => Err(CodespacesCreateOrUpdateOrgSecretError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # Create or update a repository secret
    ///
    /// Creates or updates a repository development environment secret with an encrypted value. Encrypt your secret using
    /// [LibSodium](https://libsodium.gitbook.io/doc/bindings_for_other_languages). For more information, see "[Encrypting secrets for the REST API](https://docs.github.com/rest/guides/encrypting-secrets-for-the-rest-api)."
    /// 
    /// OAuth app tokens and personal access tokens (classic) need the `repo` scope to use this endpoint.
    ///
    /// [GitHub API docs for create_or_update_repo_secret](https://docs.github.com/rest/codespaces/repository-secrets#create-or-update-a-repository-secret)
    ///
    /// ---
    pub async fn create_or_update_repo_secret_async(&self, owner: &str, repo: &str, secret_name: &str, body: PutCodespacesCreateOrUpdateRepoSecret) -> Result<EmptyObject, AdapterError> {

        let request_uri = format!("{}/repos/{}/{}/codespaces/secrets/{}", super::GITHUB_BASE_API_URL, owner, repo, secret_name);


        let req = GitHubRequest {
            uri: request_uri,
            body: Some(C::from_json::<PutCodespacesCreateOrUpdateRepoSecret>(body)?),
            method: "PUT",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch_async(request).await?;

        // --

        if github_response.is_success() {
            Ok(github_response.to_json_async().await?)
        } else {
            match github_response.status_code() {
                204 => Err(CodespacesCreateOrUpdateRepoSecretError::Status204.into()),
                code => Err(CodespacesCreateOrUpdateRepoSecretError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # Create or update a repository secret
    ///
    /// Creates or updates a repository development environment secret with an encrypted value. Encrypt your secret using
    /// [LibSodium](https://libsodium.gitbook.io/doc/bindings_for_other_languages). For more information, see "[Encrypting secrets for the REST API](https://docs.github.com/rest/guides/encrypting-secrets-for-the-rest-api)."
    /// 
    /// OAuth app tokens and personal access tokens (classic) need the `repo` scope to use this endpoint.
    ///
    /// [GitHub API docs for create_or_update_repo_secret](https://docs.github.com/rest/codespaces/repository-secrets#create-or-update-a-repository-secret)
    ///
    /// ---
    #[cfg(not(target_arch = "wasm32"))]
    pub fn create_or_update_repo_secret(&self, owner: &str, repo: &str, secret_name: &str, body: PutCodespacesCreateOrUpdateRepoSecret) -> Result<EmptyObject, AdapterError> {

        let request_uri = format!("{}/repos/{}/{}/codespaces/secrets/{}", super::GITHUB_BASE_API_URL, owner, repo, secret_name);


        let req = GitHubRequest {
            uri: request_uri,
            body: Some(C::from_json::<PutCodespacesCreateOrUpdateRepoSecret>(body)?),
            method: "PUT",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch(request)?;

        // --

        if github_response.is_success() {
            Ok(github_response.to_json()?)
        } else {
            match github_response.status_code() {
                204 => Err(CodespacesCreateOrUpdateRepoSecretError::Status204.into()),
                code => Err(CodespacesCreateOrUpdateRepoSecretError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # Create or update a secret for the authenticated user
    ///
    /// Creates or updates a development environment secret for a user's codespace with an encrypted value. Encrypt your secret using
    /// [LibSodium](https://libsodium.gitbook.io/doc/bindings_for_other_languages). For more information, see "[Encrypting secrets for the REST API](https://docs.github.com/rest/guides/encrypting-secrets-for-the-rest-api)."
    /// 
    /// The authenticated user must have Codespaces access to use this endpoint.
    /// 
    /// OAuth app tokens and personal access tokens (classic) need the `codespace` or `codespace:secrets` scope to use this endpoint.
    ///
    /// [GitHub API docs for create_or_update_secret_for_authenticated_user](https://docs.github.com/rest/codespaces/secrets#create-or-update-a-secret-for-the-authenticated-user)
    ///
    /// ---
    pub async fn create_or_update_secret_for_authenticated_user_async(&self, secret_name: &str, body: PutCodespacesCreateOrUpdateSecretForAuthenticatedUser) -> Result<EmptyObject, AdapterError> {

        let request_uri = format!("{}/user/codespaces/secrets/{}", super::GITHUB_BASE_API_URL, secret_name);


        let req = GitHubRequest {
            uri: request_uri,
            body: Some(C::from_json::<PutCodespacesCreateOrUpdateSecretForAuthenticatedUser>(body)?),
            method: "PUT",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch_async(request).await?;

        // --

        if github_response.is_success() {
            Ok(github_response.to_json_async().await?)
        } else {
            match github_response.status_code() {
                204 => Err(CodespacesCreateOrUpdateSecretForAuthenticatedUserError::Status204.into()),
                422 => Err(CodespacesCreateOrUpdateSecretForAuthenticatedUserError::Status422(github_response.to_json_async().await?).into()),
                404 => Err(CodespacesCreateOrUpdateSecretForAuthenticatedUserError::Status404(github_response.to_json_async().await?).into()),
                code => Err(CodespacesCreateOrUpdateSecretForAuthenticatedUserError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # Create or update a secret for the authenticated user
    ///
    /// Creates or updates a development environment secret for a user's codespace with an encrypted value. Encrypt your secret using
    /// [LibSodium](https://libsodium.gitbook.io/doc/bindings_for_other_languages). For more information, see "[Encrypting secrets for the REST API](https://docs.github.com/rest/guides/encrypting-secrets-for-the-rest-api)."
    /// 
    /// The authenticated user must have Codespaces access to use this endpoint.
    /// 
    /// OAuth app tokens and personal access tokens (classic) need the `codespace` or `codespace:secrets` scope to use this endpoint.
    ///
    /// [GitHub API docs for create_or_update_secret_for_authenticated_user](https://docs.github.com/rest/codespaces/secrets#create-or-update-a-secret-for-the-authenticated-user)
    ///
    /// ---
    #[cfg(not(target_arch = "wasm32"))]
    pub fn create_or_update_secret_for_authenticated_user(&self, secret_name: &str, body: PutCodespacesCreateOrUpdateSecretForAuthenticatedUser) -> Result<EmptyObject, AdapterError> {

        let request_uri = format!("{}/user/codespaces/secrets/{}", super::GITHUB_BASE_API_URL, secret_name);


        let req = GitHubRequest {
            uri: request_uri,
            body: Some(C::from_json::<PutCodespacesCreateOrUpdateSecretForAuthenticatedUser>(body)?),
            method: "PUT",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch(request)?;

        // --

        if github_response.is_success() {
            Ok(github_response.to_json()?)
        } else {
            match github_response.status_code() {
                204 => Err(CodespacesCreateOrUpdateSecretForAuthenticatedUserError::Status204.into()),
                422 => Err(CodespacesCreateOrUpdateSecretForAuthenticatedUserError::Status422(github_response.to_json()?).into()),
                404 => Err(CodespacesCreateOrUpdateSecretForAuthenticatedUserError::Status404(github_response.to_json()?).into()),
                code => Err(CodespacesCreateOrUpdateSecretForAuthenticatedUserError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # Create a codespace from a pull request
    ///
    /// Creates a codespace owned by the authenticated user for the specified pull request.
    /// 
    /// OAuth app tokens and personal access tokens (classic) need the `codespace` scope to use this endpoint.
    ///
    /// [GitHub API docs for create_with_pr_for_authenticated_user](https://docs.github.com/rest/codespaces/codespaces#create-a-codespace-from-a-pull-request)
    ///
    /// ---
    pub async fn create_with_pr_for_authenticated_user_async(&self, owner: &str, repo: &str, pull_number: i32, body: PostCodespacesCreateWithPrForAuthenticatedUser) -> Result<Codespace, AdapterError> {

        let request_uri = format!("{}/repos/{}/{}/pulls/{}/codespaces", super::GITHUB_BASE_API_URL, owner, repo, pull_number);


        let req = GitHubRequest {
            uri: request_uri,
            body: Some(C::from_json::<PostCodespacesCreateWithPrForAuthenticatedUser>(body)?),
            method: "POST",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch_async(request).await?;

        // --

        if github_response.is_success() {
            Ok(github_response.to_json_async().await?)
        } else {
            match github_response.status_code() {
                202 => Err(CodespacesCreateWithPrForAuthenticatedUserError::Status202(github_response.to_json_async().await?).into()),
                401 => Err(CodespacesCreateWithPrForAuthenticatedUserError::Status401(github_response.to_json_async().await?).into()),
                403 => Err(CodespacesCreateWithPrForAuthenticatedUserError::Status403(github_response.to_json_async().await?).into()),
                404 => Err(CodespacesCreateWithPrForAuthenticatedUserError::Status404(github_response.to_json_async().await?).into()),
                503 => Err(CodespacesCreateWithPrForAuthenticatedUserError::Status503(github_response.to_json_async().await?).into()),
                code => Err(CodespacesCreateWithPrForAuthenticatedUserError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # Create a codespace from a pull request
    ///
    /// Creates a codespace owned by the authenticated user for the specified pull request.
    /// 
    /// OAuth app tokens and personal access tokens (classic) need the `codespace` scope to use this endpoint.
    ///
    /// [GitHub API docs for create_with_pr_for_authenticated_user](https://docs.github.com/rest/codespaces/codespaces#create-a-codespace-from-a-pull-request)
    ///
    /// ---
    #[cfg(not(target_arch = "wasm32"))]
    pub fn create_with_pr_for_authenticated_user(&self, owner: &str, repo: &str, pull_number: i32, body: PostCodespacesCreateWithPrForAuthenticatedUser) -> Result<Codespace, AdapterError> {

        let request_uri = format!("{}/repos/{}/{}/pulls/{}/codespaces", super::GITHUB_BASE_API_URL, owner, repo, pull_number);


        let req = GitHubRequest {
            uri: request_uri,
            body: Some(C::from_json::<PostCodespacesCreateWithPrForAuthenticatedUser>(body)?),
            method: "POST",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch(request)?;

        // --

        if github_response.is_success() {
            Ok(github_response.to_json()?)
        } else {
            match github_response.status_code() {
                202 => Err(CodespacesCreateWithPrForAuthenticatedUserError::Status202(github_response.to_json()?).into()),
                401 => Err(CodespacesCreateWithPrForAuthenticatedUserError::Status401(github_response.to_json()?).into()),
                403 => Err(CodespacesCreateWithPrForAuthenticatedUserError::Status403(github_response.to_json()?).into()),
                404 => Err(CodespacesCreateWithPrForAuthenticatedUserError::Status404(github_response.to_json()?).into()),
                503 => Err(CodespacesCreateWithPrForAuthenticatedUserError::Status503(github_response.to_json()?).into()),
                code => Err(CodespacesCreateWithPrForAuthenticatedUserError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # Create a codespace in a repository
    ///
    /// Creates a codespace owned by the authenticated user in the specified repository.
    /// 
    /// OAuth app tokens and personal access tokens (classic) need the `codespace` scope to use this endpoint.
    ///
    /// [GitHub API docs for create_with_repo_for_authenticated_user](https://docs.github.com/rest/codespaces/codespaces#create-a-codespace-in-a-repository)
    ///
    /// ---
    pub async fn create_with_repo_for_authenticated_user_async(&self, owner: &str, repo: &str, body: PostCodespacesCreateWithRepoForAuthenticatedUser) -> Result<Codespace, AdapterError> {

        let request_uri = format!("{}/repos/{}/{}/codespaces", super::GITHUB_BASE_API_URL, owner, repo);


        let req = GitHubRequest {
            uri: request_uri,
            body: Some(C::from_json::<PostCodespacesCreateWithRepoForAuthenticatedUser>(body)?),
            method: "POST",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch_async(request).await?;

        // --

        if github_response.is_success() {
            Ok(github_response.to_json_async().await?)
        } else {
            match github_response.status_code() {
                202 => Err(CodespacesCreateWithRepoForAuthenticatedUserError::Status202(github_response.to_json_async().await?).into()),
                400 => Err(CodespacesCreateWithRepoForAuthenticatedUserError::Status400(github_response.to_json_async().await?).into()),
                401 => Err(CodespacesCreateWithRepoForAuthenticatedUserError::Status401(github_response.to_json_async().await?).into()),
                403 => Err(CodespacesCreateWithRepoForAuthenticatedUserError::Status403(github_response.to_json_async().await?).into()),
                404 => Err(CodespacesCreateWithRepoForAuthenticatedUserError::Status404(github_response.to_json_async().await?).into()),
                503 => Err(CodespacesCreateWithRepoForAuthenticatedUserError::Status503(github_response.to_json_async().await?).into()),
                code => Err(CodespacesCreateWithRepoForAuthenticatedUserError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # Create a codespace in a repository
    ///
    /// Creates a codespace owned by the authenticated user in the specified repository.
    /// 
    /// OAuth app tokens and personal access tokens (classic) need the `codespace` scope to use this endpoint.
    ///
    /// [GitHub API docs for create_with_repo_for_authenticated_user](https://docs.github.com/rest/codespaces/codespaces#create-a-codespace-in-a-repository)
    ///
    /// ---
    #[cfg(not(target_arch = "wasm32"))]
    pub fn create_with_repo_for_authenticated_user(&self, owner: &str, repo: &str, body: PostCodespacesCreateWithRepoForAuthenticatedUser) -> Result<Codespace, AdapterError> {

        let request_uri = format!("{}/repos/{}/{}/codespaces", super::GITHUB_BASE_API_URL, owner, repo);


        let req = GitHubRequest {
            uri: request_uri,
            body: Some(C::from_json::<PostCodespacesCreateWithRepoForAuthenticatedUser>(body)?),
            method: "POST",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch(request)?;

        // --

        if github_response.is_success() {
            Ok(github_response.to_json()?)
        } else {
            match github_response.status_code() {
                202 => Err(CodespacesCreateWithRepoForAuthenticatedUserError::Status202(github_response.to_json()?).into()),
                400 => Err(CodespacesCreateWithRepoForAuthenticatedUserError::Status400(github_response.to_json()?).into()),
                401 => Err(CodespacesCreateWithRepoForAuthenticatedUserError::Status401(github_response.to_json()?).into()),
                403 => Err(CodespacesCreateWithRepoForAuthenticatedUserError::Status403(github_response.to_json()?).into()),
                404 => Err(CodespacesCreateWithRepoForAuthenticatedUserError::Status404(github_response.to_json()?).into()),
                503 => Err(CodespacesCreateWithRepoForAuthenticatedUserError::Status503(github_response.to_json()?).into()),
                code => Err(CodespacesCreateWithRepoForAuthenticatedUserError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # Remove users from Codespaces access for an organization
    ///
    /// Codespaces for the specified users will no longer be billed to the organization.
    /// 
    /// To use this endpoint, the access settings for the organization must be set to `selected_members`.
    /// For information on how to change this setting, see "[Manage access control for organization codespaces](https://docs.github.com/rest/codespaces/organizations#manage-access-control-for-organization-codespaces)."
    /// 
    /// OAuth app tokens and personal access tokens (classic) need the `admin:org` scope to use this endpoint.
    ///
    /// [GitHub API docs for delete_codespaces_access_users](https://docs.github.com/rest/codespaces/organizations#remove-users-from-codespaces-access-for-an-organization)
    ///
    /// ---
    pub async fn delete_codespaces_access_users_async(&self, org: &str, body: DeleteCodespacesDeleteCodespacesAccessUsers) -> Result<(), AdapterError> {

        let request_uri = format!("{}/orgs/{}/codespaces/access/selected_users", super::GITHUB_BASE_API_URL, org);


        let req = GitHubRequest {
            uri: request_uri,
            body: Some(C::from_json::<DeleteCodespacesDeleteCodespacesAccessUsers>(body)?),
            method: "DELETE",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch_async(request).await?;

        // --

        if github_response.is_success() {
            Ok(github_response.to_json_async().await?)
        } else {
            match github_response.status_code() {
                304 => Err(CodespacesDeleteCodespacesAccessUsersError::Status304.into()),
                400 => Err(CodespacesDeleteCodespacesAccessUsersError::Status400.into()),
                404 => Err(CodespacesDeleteCodespacesAccessUsersError::Status404(github_response.to_json_async().await?).into()),
                422 => Err(CodespacesDeleteCodespacesAccessUsersError::Status422(github_response.to_json_async().await?).into()),
                500 => Err(CodespacesDeleteCodespacesAccessUsersError::Status500(github_response.to_json_async().await?).into()),
                code => Err(CodespacesDeleteCodespacesAccessUsersError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # Remove users from Codespaces access for an organization
    ///
    /// Codespaces for the specified users will no longer be billed to the organization.
    /// 
    /// To use this endpoint, the access settings for the organization must be set to `selected_members`.
    /// For information on how to change this setting, see "[Manage access control for organization codespaces](https://docs.github.com/rest/codespaces/organizations#manage-access-control-for-organization-codespaces)."
    /// 
    /// OAuth app tokens and personal access tokens (classic) need the `admin:org` scope to use this endpoint.
    ///
    /// [GitHub API docs for delete_codespaces_access_users](https://docs.github.com/rest/codespaces/organizations#remove-users-from-codespaces-access-for-an-organization)
    ///
    /// ---
    #[cfg(not(target_arch = "wasm32"))]
    pub fn delete_codespaces_access_users(&self, org: &str, body: DeleteCodespacesDeleteCodespacesAccessUsers) -> Result<(), AdapterError> {

        let request_uri = format!("{}/orgs/{}/codespaces/access/selected_users", super::GITHUB_BASE_API_URL, org);


        let req = GitHubRequest {
            uri: request_uri,
            body: Some(C::from_json::<DeleteCodespacesDeleteCodespacesAccessUsers>(body)?),
            method: "DELETE",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch(request)?;

        // --

        if github_response.is_success() {
            Ok(github_response.to_json()?)
        } else {
            match github_response.status_code() {
                304 => Err(CodespacesDeleteCodespacesAccessUsersError::Status304.into()),
                400 => Err(CodespacesDeleteCodespacesAccessUsersError::Status400.into()),
                404 => Err(CodespacesDeleteCodespacesAccessUsersError::Status404(github_response.to_json()?).into()),
                422 => Err(CodespacesDeleteCodespacesAccessUsersError::Status422(github_response.to_json()?).into()),
                500 => Err(CodespacesDeleteCodespacesAccessUsersError::Status500(github_response.to_json()?).into()),
                code => Err(CodespacesDeleteCodespacesAccessUsersError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # Delete a codespace for the authenticated user
    ///
    /// Deletes a user's codespace.
    /// 
    /// OAuth app tokens and personal access tokens (classic) need the `codespace` scope to use this endpoint.
    ///
    /// [GitHub API docs for delete_for_authenticated_user](https://docs.github.com/rest/codespaces/codespaces#delete-a-codespace-for-the-authenticated-user)
    ///
    /// ---
    pub async fn delete_for_authenticated_user_async(&self, codespace_name: &str) -> Result<HashMap<String, Value>, AdapterError> {

        let request_uri = format!("{}/user/codespaces/{}", super::GITHUB_BASE_API_URL, codespace_name);


        let req = GitHubRequest {
            uri: request_uri,
            body: None::<C::Body>,
            method: "DELETE",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch_async(request).await?;

        // --

        if github_response.is_success() {
            Ok(github_response.to_json_async().await?)
        } else {
            match github_response.status_code() {
                304 => Err(CodespacesDeleteForAuthenticatedUserError::Status304.into()),
                500 => Err(CodespacesDeleteForAuthenticatedUserError::Status500(github_response.to_json_async().await?).into()),
                401 => Err(CodespacesDeleteForAuthenticatedUserError::Status401(github_response.to_json_async().await?).into()),
                403 => Err(CodespacesDeleteForAuthenticatedUserError::Status403(github_response.to_json_async().await?).into()),
                404 => Err(CodespacesDeleteForAuthenticatedUserError::Status404(github_response.to_json_async().await?).into()),
                code => Err(CodespacesDeleteForAuthenticatedUserError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # Delete a codespace for the authenticated user
    ///
    /// Deletes a user's codespace.
    /// 
    /// OAuth app tokens and personal access tokens (classic) need the `codespace` scope to use this endpoint.
    ///
    /// [GitHub API docs for delete_for_authenticated_user](https://docs.github.com/rest/codespaces/codespaces#delete-a-codespace-for-the-authenticated-user)
    ///
    /// ---
    #[cfg(not(target_arch = "wasm32"))]
    pub fn delete_for_authenticated_user(&self, codespace_name: &str) -> Result<HashMap<String, Value>, AdapterError> {

        let request_uri = format!("{}/user/codespaces/{}", super::GITHUB_BASE_API_URL, codespace_name);


        let req = GitHubRequest {
            uri: request_uri,
            body: None,
            method: "DELETE",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch(request)?;

        // --

        if github_response.is_success() {
            Ok(github_response.to_json()?)
        } else {
            match github_response.status_code() {
                304 => Err(CodespacesDeleteForAuthenticatedUserError::Status304.into()),
                500 => Err(CodespacesDeleteForAuthenticatedUserError::Status500(github_response.to_json()?).into()),
                401 => Err(CodespacesDeleteForAuthenticatedUserError::Status401(github_response.to_json()?).into()),
                403 => Err(CodespacesDeleteForAuthenticatedUserError::Status403(github_response.to_json()?).into()),
                404 => Err(CodespacesDeleteForAuthenticatedUserError::Status404(github_response.to_json()?).into()),
                code => Err(CodespacesDeleteForAuthenticatedUserError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # Delete a codespace from the organization
    ///
    /// Deletes a user's codespace.
    /// 
    /// OAuth app tokens and personal access tokens (classic) need the `admin:org` scope to use this endpoint.
    ///
    /// [GitHub API docs for delete_from_organization](https://docs.github.com/rest/codespaces/organizations#delete-a-codespace-from-the-organization)
    ///
    /// ---
    pub async fn delete_from_organization_async(&self, org: &str, username: &str, codespace_name: &str) -> Result<HashMap<String, Value>, AdapterError> {

        let request_uri = format!("{}/orgs/{}/members/{}/codespaces/{}", super::GITHUB_BASE_API_URL, org, username, codespace_name);


        let req = GitHubRequest {
            uri: request_uri,
            body: None::<C::Body>,
            method: "DELETE",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch_async(request).await?;

        // --

        if github_response.is_success() {
            Ok(github_response.to_json_async().await?)
        } else {
            match github_response.status_code() {
                304 => Err(CodespacesDeleteFromOrganizationError::Status304.into()),
                500 => Err(CodespacesDeleteFromOrganizationError::Status500(github_response.to_json_async().await?).into()),
                401 => Err(CodespacesDeleteFromOrganizationError::Status401(github_response.to_json_async().await?).into()),
                403 => Err(CodespacesDeleteFromOrganizationError::Status403(github_response.to_json_async().await?).into()),
                404 => Err(CodespacesDeleteFromOrganizationError::Status404(github_response.to_json_async().await?).into()),
                code => Err(CodespacesDeleteFromOrganizationError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # Delete a codespace from the organization
    ///
    /// Deletes a user's codespace.
    /// 
    /// OAuth app tokens and personal access tokens (classic) need the `admin:org` scope to use this endpoint.
    ///
    /// [GitHub API docs for delete_from_organization](https://docs.github.com/rest/codespaces/organizations#delete-a-codespace-from-the-organization)
    ///
    /// ---
    #[cfg(not(target_arch = "wasm32"))]
    pub fn delete_from_organization(&self, org: &str, username: &str, codespace_name: &str) -> Result<HashMap<String, Value>, AdapterError> {

        let request_uri = format!("{}/orgs/{}/members/{}/codespaces/{}", super::GITHUB_BASE_API_URL, org, username, codespace_name);


        let req = GitHubRequest {
            uri: request_uri,
            body: None,
            method: "DELETE",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch(request)?;

        // --

        if github_response.is_success() {
            Ok(github_response.to_json()?)
        } else {
            match github_response.status_code() {
                304 => Err(CodespacesDeleteFromOrganizationError::Status304.into()),
                500 => Err(CodespacesDeleteFromOrganizationError::Status500(github_response.to_json()?).into()),
                401 => Err(CodespacesDeleteFromOrganizationError::Status401(github_response.to_json()?).into()),
                403 => Err(CodespacesDeleteFromOrganizationError::Status403(github_response.to_json()?).into()),
                404 => Err(CodespacesDeleteFromOrganizationError::Status404(github_response.to_json()?).into()),
                code => Err(CodespacesDeleteFromOrganizationError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # Delete an organization secret
    ///
    /// Deletes an organization development environment secret using the secret name.
    /// 
    /// OAuth app tokens and personal access tokens (classic) need the `admin:org` scope to use this endpoint.
    ///
    /// [GitHub API docs for delete_org_secret](https://docs.github.com/rest/codespaces/organization-secrets#delete-an-organization-secret)
    ///
    /// ---
    pub async fn delete_org_secret_async(&self, org: &str, secret_name: &str) -> Result<(), AdapterError> {

        let request_uri = format!("{}/orgs/{}/codespaces/secrets/{}", super::GITHUB_BASE_API_URL, org, secret_name);


        let req = GitHubRequest {
            uri: request_uri,
            body: None::<C::Body>,
            method: "DELETE",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch_async(request).await?;

        // --

        if github_response.is_success() {
            Ok(github_response.to_json_async().await?)
        } else {
            match github_response.status_code() {
                404 => Err(CodespacesDeleteOrgSecretError::Status404(github_response.to_json_async().await?).into()),
                code => Err(CodespacesDeleteOrgSecretError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # Delete an organization secret
    ///
    /// Deletes an organization development environment secret using the secret name.
    /// 
    /// OAuth app tokens and personal access tokens (classic) need the `admin:org` scope to use this endpoint.
    ///
    /// [GitHub API docs for delete_org_secret](https://docs.github.com/rest/codespaces/organization-secrets#delete-an-organization-secret)
    ///
    /// ---
    #[cfg(not(target_arch = "wasm32"))]
    pub fn delete_org_secret(&self, org: &str, secret_name: &str) -> Result<(), AdapterError> {

        let request_uri = format!("{}/orgs/{}/codespaces/secrets/{}", super::GITHUB_BASE_API_URL, org, secret_name);


        let req = GitHubRequest {
            uri: request_uri,
            body: None,
            method: "DELETE",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch(request)?;

        // --

        if github_response.is_success() {
            Ok(github_response.to_json()?)
        } else {
            match github_response.status_code() {
                404 => Err(CodespacesDeleteOrgSecretError::Status404(github_response.to_json()?).into()),
                code => Err(CodespacesDeleteOrgSecretError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # Delete a repository secret
    ///
    /// Deletes a development environment secret in a repository using the secret name.
    /// 
    /// OAuth app tokens and personal access tokens (classic) need the `repo` scope to use this endpoint.
    ///
    /// [GitHub API docs for delete_repo_secret](https://docs.github.com/rest/codespaces/repository-secrets#delete-a-repository-secret)
    ///
    /// ---
    pub async fn delete_repo_secret_async(&self, owner: &str, repo: &str, secret_name: &str) -> Result<(), AdapterError> {

        let request_uri = format!("{}/repos/{}/{}/codespaces/secrets/{}", super::GITHUB_BASE_API_URL, owner, repo, secret_name);


        let req = GitHubRequest {
            uri: request_uri,
            body: None::<C::Body>,
            method: "DELETE",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch_async(request).await?;

        // --

        if github_response.is_success() {
            Ok(github_response.to_json_async().await?)
        } else {
            match github_response.status_code() {
                code => Err(CodespacesDeleteRepoSecretError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # Delete a repository secret
    ///
    /// Deletes a development environment secret in a repository using the secret name.
    /// 
    /// OAuth app tokens and personal access tokens (classic) need the `repo` scope to use this endpoint.
    ///
    /// [GitHub API docs for delete_repo_secret](https://docs.github.com/rest/codespaces/repository-secrets#delete-a-repository-secret)
    ///
    /// ---
    #[cfg(not(target_arch = "wasm32"))]
    pub fn delete_repo_secret(&self, owner: &str, repo: &str, secret_name: &str) -> Result<(), AdapterError> {

        let request_uri = format!("{}/repos/{}/{}/codespaces/secrets/{}", super::GITHUB_BASE_API_URL, owner, repo, secret_name);


        let req = GitHubRequest {
            uri: request_uri,
            body: None,
            method: "DELETE",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch(request)?;

        // --

        if github_response.is_success() {
            Ok(github_response.to_json()?)
        } else {
            match github_response.status_code() {
                code => Err(CodespacesDeleteRepoSecretError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # Delete a secret for the authenticated user
    ///
    /// Deletes a development environment secret from a user's codespaces using the secret name. Deleting the secret will remove access from all codespaces that were allowed to access the secret.
    /// 
    /// The authenticated user must have Codespaces access to use this endpoint.
    /// 
    /// OAuth app tokens and personal access tokens (classic) need the `codespace` or `codespace:secrets` scope to use this endpoint.
    ///
    /// [GitHub API docs for delete_secret_for_authenticated_user](https://docs.github.com/rest/codespaces/secrets#delete-a-secret-for-the-authenticated-user)
    ///
    /// ---
    pub async fn delete_secret_for_authenticated_user_async(&self, secret_name: &str) -> Result<(), AdapterError> {

        let request_uri = format!("{}/user/codespaces/secrets/{}", super::GITHUB_BASE_API_URL, secret_name);


        let req = GitHubRequest {
            uri: request_uri,
            body: None::<C::Body>,
            method: "DELETE",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch_async(request).await?;

        // --

        if github_response.is_success() {
            Ok(github_response.to_json_async().await?)
        } else {
            match github_response.status_code() {
                code => Err(CodespacesDeleteSecretForAuthenticatedUserError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # Delete a secret for the authenticated user
    ///
    /// Deletes a development environment secret from a user's codespaces using the secret name. Deleting the secret will remove access from all codespaces that were allowed to access the secret.
    /// 
    /// The authenticated user must have Codespaces access to use this endpoint.
    /// 
    /// OAuth app tokens and personal access tokens (classic) need the `codespace` or `codespace:secrets` scope to use this endpoint.
    ///
    /// [GitHub API docs for delete_secret_for_authenticated_user](https://docs.github.com/rest/codespaces/secrets#delete-a-secret-for-the-authenticated-user)
    ///
    /// ---
    #[cfg(not(target_arch = "wasm32"))]
    pub fn delete_secret_for_authenticated_user(&self, secret_name: &str) -> Result<(), AdapterError> {

        let request_uri = format!("{}/user/codespaces/secrets/{}", super::GITHUB_BASE_API_URL, secret_name);


        let req = GitHubRequest {
            uri: request_uri,
            body: None,
            method: "DELETE",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch(request)?;

        // --

        if github_response.is_success() {
            Ok(github_response.to_json()?)
        } else {
            match github_response.status_code() {
                code => Err(CodespacesDeleteSecretForAuthenticatedUserError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # Export a codespace for the authenticated user
    ///
    /// Triggers an export of the specified codespace and returns a URL and ID where the status of the export can be monitored.
    /// 
    /// If changes cannot be pushed to the codespace's repository, they will be pushed to a new or previously-existing fork instead.
    /// 
    /// OAuth app tokens and personal access tokens (classic) need the `codespace` scope to use this endpoint.
    ///
    /// [GitHub API docs for export_for_authenticated_user](https://docs.github.com/rest/codespaces/codespaces#export-a-codespace-for-the-authenticated-user)
    ///
    /// ---
    pub async fn export_for_authenticated_user_async(&self, codespace_name: &str) -> Result<CodespaceExportDetails, AdapterError> {

        let request_uri = format!("{}/user/codespaces/{}/exports", super::GITHUB_BASE_API_URL, codespace_name);


        let req = GitHubRequest {
            uri: request_uri,
            body: None::<C::Body>,
            method: "POST",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch_async(request).await?;

        // --

        if github_response.is_success() {
            Ok(github_response.to_json_async().await?)
        } else {
            match github_response.status_code() {
                500 => Err(CodespacesExportForAuthenticatedUserError::Status500(github_response.to_json_async().await?).into()),
                401 => Err(CodespacesExportForAuthenticatedUserError::Status401(github_response.to_json_async().await?).into()),
                403 => Err(CodespacesExportForAuthenticatedUserError::Status403(github_response.to_json_async().await?).into()),
                404 => Err(CodespacesExportForAuthenticatedUserError::Status404(github_response.to_json_async().await?).into()),
                422 => Err(CodespacesExportForAuthenticatedUserError::Status422(github_response.to_json_async().await?).into()),
                code => Err(CodespacesExportForAuthenticatedUserError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # Export a codespace for the authenticated user
    ///
    /// Triggers an export of the specified codespace and returns a URL and ID where the status of the export can be monitored.
    /// 
    /// If changes cannot be pushed to the codespace's repository, they will be pushed to a new or previously-existing fork instead.
    /// 
    /// OAuth app tokens and personal access tokens (classic) need the `codespace` scope to use this endpoint.
    ///
    /// [GitHub API docs for export_for_authenticated_user](https://docs.github.com/rest/codespaces/codespaces#export-a-codespace-for-the-authenticated-user)
    ///
    /// ---
    #[cfg(not(target_arch = "wasm32"))]
    pub fn export_for_authenticated_user(&self, codespace_name: &str) -> Result<CodespaceExportDetails, AdapterError> {

        let request_uri = format!("{}/user/codespaces/{}/exports", super::GITHUB_BASE_API_URL, codespace_name);


        let req = GitHubRequest {
            uri: request_uri,
            body: None,
            method: "POST",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch(request)?;

        // --

        if github_response.is_success() {
            Ok(github_response.to_json()?)
        } else {
            match github_response.status_code() {
                500 => Err(CodespacesExportForAuthenticatedUserError::Status500(github_response.to_json()?).into()),
                401 => Err(CodespacesExportForAuthenticatedUserError::Status401(github_response.to_json()?).into()),
                403 => Err(CodespacesExportForAuthenticatedUserError::Status403(github_response.to_json()?).into()),
                404 => Err(CodespacesExportForAuthenticatedUserError::Status404(github_response.to_json()?).into()),
                422 => Err(CodespacesExportForAuthenticatedUserError::Status422(github_response.to_json()?).into()),
                code => Err(CodespacesExportForAuthenticatedUserError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # List codespaces for a user in organization
    ///
    /// Lists the codespaces that a member of an organization has for repositories in that organization.
    /// 
    /// OAuth app tokens and personal access tokens (classic) need the `admin:org` scope to use this endpoint.
    ///
    /// [GitHub API docs for get_codespaces_for_user_in_org](https://docs.github.com/rest/codespaces/organizations#list-codespaces-for-a-user-in-organization)
    ///
    /// ---
    pub async fn get_codespaces_for_user_in_org_async(&self, org: &str, username: &str, query_params: Option<impl Into<CodespacesGetCodespacesForUserInOrgParams>>) -> Result<GetCodespacesListForAuthenticatedUserResponse200, AdapterError> {

        let mut request_uri = format!("{}/orgs/{}/members/{}/codespaces", super::GITHUB_BASE_API_URL, org, username);

        if let Some(params) = query_params {
            request_uri.push_str("?");
            request_uri.push_str(&serde_urlencoded::to_string(params.into())?);
        }

        let req = GitHubRequest {
            uri: request_uri,
            body: None::<C::Body>,
            method: "GET",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch_async(request).await?;

        // --

        if github_response.is_success() {
            Ok(github_response.to_json_async().await?)
        } else {
            match github_response.status_code() {
                304 => Err(CodespacesGetCodespacesForUserInOrgError::Status304.into()),
                500 => Err(CodespacesGetCodespacesForUserInOrgError::Status500(github_response.to_json_async().await?).into()),
                401 => Err(CodespacesGetCodespacesForUserInOrgError::Status401(github_response.to_json_async().await?).into()),
                403 => Err(CodespacesGetCodespacesForUserInOrgError::Status403(github_response.to_json_async().await?).into()),
                404 => Err(CodespacesGetCodespacesForUserInOrgError::Status404(github_response.to_json_async().await?).into()),
                code => Err(CodespacesGetCodespacesForUserInOrgError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # List codespaces for a user in organization
    ///
    /// Lists the codespaces that a member of an organization has for repositories in that organization.
    /// 
    /// OAuth app tokens and personal access tokens (classic) need the `admin:org` scope to use this endpoint.
    ///
    /// [GitHub API docs for get_codespaces_for_user_in_org](https://docs.github.com/rest/codespaces/organizations#list-codespaces-for-a-user-in-organization)
    ///
    /// ---
    #[cfg(not(target_arch = "wasm32"))]
    pub fn get_codespaces_for_user_in_org(&self, org: &str, username: &str, query_params: Option<impl Into<CodespacesGetCodespacesForUserInOrgParams>>) -> Result<GetCodespacesListForAuthenticatedUserResponse200, AdapterError> {

        let mut request_uri = format!("{}/orgs/{}/members/{}/codespaces", super::GITHUB_BASE_API_URL, org, username);

        if let Some(params) = query_params {
            request_uri.push_str("?");
            let qp: CodespacesGetCodespacesForUserInOrgParams = params.into();
            request_uri.push_str(&serde_urlencoded::to_string(qp)?);
        }

        let req = GitHubRequest {
            uri: request_uri,
            body: None,
            method: "GET",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch(request)?;

        // --

        if github_response.is_success() {
            Ok(github_response.to_json()?)
        } else {
            match github_response.status_code() {
                304 => Err(CodespacesGetCodespacesForUserInOrgError::Status304.into()),
                500 => Err(CodespacesGetCodespacesForUserInOrgError::Status500(github_response.to_json()?).into()),
                401 => Err(CodespacesGetCodespacesForUserInOrgError::Status401(github_response.to_json()?).into()),
                403 => Err(CodespacesGetCodespacesForUserInOrgError::Status403(github_response.to_json()?).into()),
                404 => Err(CodespacesGetCodespacesForUserInOrgError::Status404(github_response.to_json()?).into()),
                code => Err(CodespacesGetCodespacesForUserInOrgError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # Get details about a codespace export
    ///
    /// Gets information about an export of a codespace.
    /// 
    /// OAuth app tokens and personal access tokens (classic) need the `codespace` scope to use this endpoint.
    ///
    /// [GitHub API docs for get_export_details_for_authenticated_user](https://docs.github.com/rest/codespaces/codespaces#get-details-about-a-codespace-export)
    ///
    /// ---
    pub async fn get_export_details_for_authenticated_user_async(&self, codespace_name: &str, export_id: &str) -> Result<CodespaceExportDetails, AdapterError> {

        let request_uri = format!("{}/user/codespaces/{}/exports/{}", super::GITHUB_BASE_API_URL, codespace_name, export_id);


        let req = GitHubRequest {
            uri: request_uri,
            body: None::<C::Body>,
            method: "GET",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch_async(request).await?;

        // --

        if github_response.is_success() {
            Ok(github_response.to_json_async().await?)
        } else {
            match github_response.status_code() {
                404 => Err(CodespacesGetExportDetailsForAuthenticatedUserError::Status404(github_response.to_json_async().await?).into()),
                code => Err(CodespacesGetExportDetailsForAuthenticatedUserError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # Get details about a codespace export
    ///
    /// Gets information about an export of a codespace.
    /// 
    /// OAuth app tokens and personal access tokens (classic) need the `codespace` scope to use this endpoint.
    ///
    /// [GitHub API docs for get_export_details_for_authenticated_user](https://docs.github.com/rest/codespaces/codespaces#get-details-about-a-codespace-export)
    ///
    /// ---
    #[cfg(not(target_arch = "wasm32"))]
    pub fn get_export_details_for_authenticated_user(&self, codespace_name: &str, export_id: &str) -> Result<CodespaceExportDetails, AdapterError> {

        let request_uri = format!("{}/user/codespaces/{}/exports/{}", super::GITHUB_BASE_API_URL, codespace_name, export_id);


        let req = GitHubRequest {
            uri: request_uri,
            body: None,
            method: "GET",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch(request)?;

        // --

        if github_response.is_success() {
            Ok(github_response.to_json()?)
        } else {
            match github_response.status_code() {
                404 => Err(CodespacesGetExportDetailsForAuthenticatedUserError::Status404(github_response.to_json()?).into()),
                code => Err(CodespacesGetExportDetailsForAuthenticatedUserError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # Get a codespace for the authenticated user
    ///
    /// Gets information about a user's codespace.
    /// 
    /// OAuth app tokens and personal access tokens (classic) need the `codespace` scope to use this endpoint.
    ///
    /// [GitHub API docs for get_for_authenticated_user](https://docs.github.com/rest/codespaces/codespaces#get-a-codespace-for-the-authenticated-user)
    ///
    /// ---
    pub async fn get_for_authenticated_user_async(&self, codespace_name: &str) -> Result<Codespace, AdapterError> {

        let request_uri = format!("{}/user/codespaces/{}", super::GITHUB_BASE_API_URL, codespace_name);


        let req = GitHubRequest {
            uri: request_uri,
            body: None::<C::Body>,
            method: "GET",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch_async(request).await?;

        // --

        if github_response.is_success() {
            Ok(github_response.to_json_async().await?)
        } else {
            match github_response.status_code() {
                304 => Err(CodespacesGetForAuthenticatedUserError::Status304.into()),
                500 => Err(CodespacesGetForAuthenticatedUserError::Status500(github_response.to_json_async().await?).into()),
                401 => Err(CodespacesGetForAuthenticatedUserError::Status401(github_response.to_json_async().await?).into()),
                403 => Err(CodespacesGetForAuthenticatedUserError::Status403(github_response.to_json_async().await?).into()),
                404 => Err(CodespacesGetForAuthenticatedUserError::Status404(github_response.to_json_async().await?).into()),
                code => Err(CodespacesGetForAuthenticatedUserError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # Get a codespace for the authenticated user
    ///
    /// Gets information about a user's codespace.
    /// 
    /// OAuth app tokens and personal access tokens (classic) need the `codespace` scope to use this endpoint.
    ///
    /// [GitHub API docs for get_for_authenticated_user](https://docs.github.com/rest/codespaces/codespaces#get-a-codespace-for-the-authenticated-user)
    ///
    /// ---
    #[cfg(not(target_arch = "wasm32"))]
    pub fn get_for_authenticated_user(&self, codespace_name: &str) -> Result<Codespace, AdapterError> {

        let request_uri = format!("{}/user/codespaces/{}", super::GITHUB_BASE_API_URL, codespace_name);


        let req = GitHubRequest {
            uri: request_uri,
            body: None,
            method: "GET",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch(request)?;

        // --

        if github_response.is_success() {
            Ok(github_response.to_json()?)
        } else {
            match github_response.status_code() {
                304 => Err(CodespacesGetForAuthenticatedUserError::Status304.into()),
                500 => Err(CodespacesGetForAuthenticatedUserError::Status500(github_response.to_json()?).into()),
                401 => Err(CodespacesGetForAuthenticatedUserError::Status401(github_response.to_json()?).into()),
                403 => Err(CodespacesGetForAuthenticatedUserError::Status403(github_response.to_json()?).into()),
                404 => Err(CodespacesGetForAuthenticatedUserError::Status404(github_response.to_json()?).into()),
                code => Err(CodespacesGetForAuthenticatedUserError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # Get an organization public key
    ///
    /// Gets a public key for an organization, which is required in order to encrypt secrets. You need to encrypt the value of a secret before you can create or update secrets.
    /// OAuth app tokens and personal access tokens (classic) need the `admin:org` scope to use this endpoint.
    ///
    /// [GitHub API docs for get_org_public_key](https://docs.github.com/rest/codespaces/organization-secrets#get-an-organization-public-key)
    ///
    /// ---
    pub async fn get_org_public_key_async(&self, org: &str) -> Result<CodespacesPublicKey, AdapterError> {

        let request_uri = format!("{}/orgs/{}/codespaces/secrets/public-key", super::GITHUB_BASE_API_URL, org);


        let req = GitHubRequest {
            uri: request_uri,
            body: None::<C::Body>,
            method: "GET",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch_async(request).await?;

        // --

        if github_response.is_success() {
            Ok(github_response.to_json_async().await?)
        } else {
            match github_response.status_code() {
                code => Err(CodespacesGetOrgPublicKeyError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # Get an organization public key
    ///
    /// Gets a public key for an organization, which is required in order to encrypt secrets. You need to encrypt the value of a secret before you can create or update secrets.
    /// OAuth app tokens and personal access tokens (classic) need the `admin:org` scope to use this endpoint.
    ///
    /// [GitHub API docs for get_org_public_key](https://docs.github.com/rest/codespaces/organization-secrets#get-an-organization-public-key)
    ///
    /// ---
    #[cfg(not(target_arch = "wasm32"))]
    pub fn get_org_public_key(&self, org: &str) -> Result<CodespacesPublicKey, AdapterError> {

        let request_uri = format!("{}/orgs/{}/codespaces/secrets/public-key", super::GITHUB_BASE_API_URL, org);


        let req = GitHubRequest {
            uri: request_uri,
            body: None,
            method: "GET",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch(request)?;

        // --

        if github_response.is_success() {
            Ok(github_response.to_json()?)
        } else {
            match github_response.status_code() {
                code => Err(CodespacesGetOrgPublicKeyError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # Get an organization secret
    ///
    /// Gets an organization development environment secret without revealing its encrypted value.
    /// 
    /// OAuth app tokens and personal access tokens (classic) need the `admin:org` scope to use this endpoint.
    ///
    /// [GitHub API docs for get_org_secret](https://docs.github.com/rest/codespaces/organization-secrets#get-an-organization-secret)
    ///
    /// ---
    pub async fn get_org_secret_async(&self, org: &str, secret_name: &str) -> Result<CodespacesOrgSecret, AdapterError> {

        let request_uri = format!("{}/orgs/{}/codespaces/secrets/{}", super::GITHUB_BASE_API_URL, org, secret_name);


        let req = GitHubRequest {
            uri: request_uri,
            body: None::<C::Body>,
            method: "GET",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch_async(request).await?;

        // --

        if github_response.is_success() {
            Ok(github_response.to_json_async().await?)
        } else {
            match github_response.status_code() {
                code => Err(CodespacesGetOrgSecretError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # Get an organization secret
    ///
    /// Gets an organization development environment secret without revealing its encrypted value.
    /// 
    /// OAuth app tokens and personal access tokens (classic) need the `admin:org` scope to use this endpoint.
    ///
    /// [GitHub API docs for get_org_secret](https://docs.github.com/rest/codespaces/organization-secrets#get-an-organization-secret)
    ///
    /// ---
    #[cfg(not(target_arch = "wasm32"))]
    pub fn get_org_secret(&self, org: &str, secret_name: &str) -> Result<CodespacesOrgSecret, AdapterError> {

        let request_uri = format!("{}/orgs/{}/codespaces/secrets/{}", super::GITHUB_BASE_API_URL, org, secret_name);


        let req = GitHubRequest {
            uri: request_uri,
            body: None,
            method: "GET",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch(request)?;

        // --

        if github_response.is_success() {
            Ok(github_response.to_json()?)
        } else {
            match github_response.status_code() {
                code => Err(CodespacesGetOrgSecretError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # Get public key for the authenticated user
    ///
    /// Gets your public key, which you need to encrypt secrets. You need to encrypt a secret before you can create or update secrets.
    /// 
    /// The authenticated user must have Codespaces access to use this endpoint.
    /// 
    /// OAuth app tokens and personal access tokens (classic) need the `codespace` or `codespace:secrets` scope to use this endpoint.
    ///
    /// [GitHub API docs for get_public_key_for_authenticated_user](https://docs.github.com/rest/codespaces/secrets#get-public-key-for-the-authenticated-user)
    ///
    /// ---
    pub async fn get_public_key_for_authenticated_user_async(&self) -> Result<CodespacesUserPublicKey, AdapterError> {

        let request_uri = format!("{}/user/codespaces/secrets/public-key", super::GITHUB_BASE_API_URL);


        let req = GitHubRequest {
            uri: request_uri,
            body: None::<C::Body>,
            method: "GET",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch_async(request).await?;

        // --

        if github_response.is_success() {
            Ok(github_response.to_json_async().await?)
        } else {
            match github_response.status_code() {
                code => Err(CodespacesGetPublicKeyForAuthenticatedUserError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # Get public key for the authenticated user
    ///
    /// Gets your public key, which you need to encrypt secrets. You need to encrypt a secret before you can create or update secrets.
    /// 
    /// The authenticated user must have Codespaces access to use this endpoint.
    /// 
    /// OAuth app tokens and personal access tokens (classic) need the `codespace` or `codespace:secrets` scope to use this endpoint.
    ///
    /// [GitHub API docs for get_public_key_for_authenticated_user](https://docs.github.com/rest/codespaces/secrets#get-public-key-for-the-authenticated-user)
    ///
    /// ---
    #[cfg(not(target_arch = "wasm32"))]
    pub fn get_public_key_for_authenticated_user(&self) -> Result<CodespacesUserPublicKey, AdapterError> {

        let request_uri = format!("{}/user/codespaces/secrets/public-key", super::GITHUB_BASE_API_URL);


        let req = GitHubRequest {
            uri: request_uri,
            body: None,
            method: "GET",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch(request)?;

        // --

        if github_response.is_success() {
            Ok(github_response.to_json()?)
        } else {
            match github_response.status_code() {
                code => Err(CodespacesGetPublicKeyForAuthenticatedUserError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # Get a repository public key
    ///
    /// Gets your public key, which you need to encrypt secrets. You need to
    /// encrypt a secret before you can create or update secrets.
    /// 
    /// If the repository is private, OAuth app tokens and personal access tokens (classic) need the `repo` scope to use this endpoint.
    ///
    /// [GitHub API docs for get_repo_public_key](https://docs.github.com/rest/codespaces/repository-secrets#get-a-repository-public-key)
    ///
    /// ---
    pub async fn get_repo_public_key_async(&self, owner: &str, repo: &str) -> Result<CodespacesPublicKey, AdapterError> {

        let request_uri = format!("{}/repos/{}/{}/codespaces/secrets/public-key", super::GITHUB_BASE_API_URL, owner, repo);


        let req = GitHubRequest {
            uri: request_uri,
            body: None::<C::Body>,
            method: "GET",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch_async(request).await?;

        // --

        if github_response.is_success() {
            Ok(github_response.to_json_async().await?)
        } else {
            match github_response.status_code() {
                code => Err(CodespacesGetRepoPublicKeyError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # Get a repository public key
    ///
    /// Gets your public key, which you need to encrypt secrets. You need to
    /// encrypt a secret before you can create or update secrets.
    /// 
    /// If the repository is private, OAuth app tokens and personal access tokens (classic) need the `repo` scope to use this endpoint.
    ///
    /// [GitHub API docs for get_repo_public_key](https://docs.github.com/rest/codespaces/repository-secrets#get-a-repository-public-key)
    ///
    /// ---
    #[cfg(not(target_arch = "wasm32"))]
    pub fn get_repo_public_key(&self, owner: &str, repo: &str) -> Result<CodespacesPublicKey, AdapterError> {

        let request_uri = format!("{}/repos/{}/{}/codespaces/secrets/public-key", super::GITHUB_BASE_API_URL, owner, repo);


        let req = GitHubRequest {
            uri: request_uri,
            body: None,
            method: "GET",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch(request)?;

        // --

        if github_response.is_success() {
            Ok(github_response.to_json()?)
        } else {
            match github_response.status_code() {
                code => Err(CodespacesGetRepoPublicKeyError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # Get a repository secret
    ///
    /// Gets a single repository development environment secret without revealing its encrypted value.
    /// 
    /// OAuth app tokens and personal access tokens (classic) need the `repo` scope to use this endpoint.
    ///
    /// [GitHub API docs for get_repo_secret](https://docs.github.com/rest/codespaces/repository-secrets#get-a-repository-secret)
    ///
    /// ---
    pub async fn get_repo_secret_async(&self, owner: &str, repo: &str, secret_name: &str) -> Result<RepoCodespacesSecret, AdapterError> {

        let request_uri = format!("{}/repos/{}/{}/codespaces/secrets/{}", super::GITHUB_BASE_API_URL, owner, repo, secret_name);


        let req = GitHubRequest {
            uri: request_uri,
            body: None::<C::Body>,
            method: "GET",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch_async(request).await?;

        // --

        if github_response.is_success() {
            Ok(github_response.to_json_async().await?)
        } else {
            match github_response.status_code() {
                code => Err(CodespacesGetRepoSecretError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # Get a repository secret
    ///
    /// Gets a single repository development environment secret without revealing its encrypted value.
    /// 
    /// OAuth app tokens and personal access tokens (classic) need the `repo` scope to use this endpoint.
    ///
    /// [GitHub API docs for get_repo_secret](https://docs.github.com/rest/codespaces/repository-secrets#get-a-repository-secret)
    ///
    /// ---
    #[cfg(not(target_arch = "wasm32"))]
    pub fn get_repo_secret(&self, owner: &str, repo: &str, secret_name: &str) -> Result<RepoCodespacesSecret, AdapterError> {

        let request_uri = format!("{}/repos/{}/{}/codespaces/secrets/{}", super::GITHUB_BASE_API_URL, owner, repo, secret_name);


        let req = GitHubRequest {
            uri: request_uri,
            body: None,
            method: "GET",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch(request)?;

        // --

        if github_response.is_success() {
            Ok(github_response.to_json()?)
        } else {
            match github_response.status_code() {
                code => Err(CodespacesGetRepoSecretError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # Get a secret for the authenticated user
    ///
    /// Gets a development environment secret available to a user's codespaces without revealing its encrypted value.
    /// 
    /// The authenticated user must have Codespaces access to use this endpoint.
    /// 
    /// OAuth app tokens and personal access tokens (classic) need the `codespace` or `codespace:secrets` scope to use this endpoint.
    ///
    /// [GitHub API docs for get_secret_for_authenticated_user](https://docs.github.com/rest/codespaces/secrets#get-a-secret-for-the-authenticated-user)
    ///
    /// ---
    pub async fn get_secret_for_authenticated_user_async(&self, secret_name: &str) -> Result<CodespacesSecret, AdapterError> {

        let request_uri = format!("{}/user/codespaces/secrets/{}", super::GITHUB_BASE_API_URL, secret_name);


        let req = GitHubRequest {
            uri: request_uri,
            body: None::<C::Body>,
            method: "GET",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch_async(request).await?;

        // --

        if github_response.is_success() {
            Ok(github_response.to_json_async().await?)
        } else {
            match github_response.status_code() {
                code => Err(CodespacesGetSecretForAuthenticatedUserError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # Get a secret for the authenticated user
    ///
    /// Gets a development environment secret available to a user's codespaces without revealing its encrypted value.
    /// 
    /// The authenticated user must have Codespaces access to use this endpoint.
    /// 
    /// OAuth app tokens and personal access tokens (classic) need the `codespace` or `codespace:secrets` scope to use this endpoint.
    ///
    /// [GitHub API docs for get_secret_for_authenticated_user](https://docs.github.com/rest/codespaces/secrets#get-a-secret-for-the-authenticated-user)
    ///
    /// ---
    #[cfg(not(target_arch = "wasm32"))]
    pub fn get_secret_for_authenticated_user(&self, secret_name: &str) -> Result<CodespacesSecret, AdapterError> {

        let request_uri = format!("{}/user/codespaces/secrets/{}", super::GITHUB_BASE_API_URL, secret_name);


        let req = GitHubRequest {
            uri: request_uri,
            body: None,
            method: "GET",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch(request)?;

        // --

        if github_response.is_success() {
            Ok(github_response.to_json()?)
        } else {
            match github_response.status_code() {
                code => Err(CodespacesGetSecretForAuthenticatedUserError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # List devcontainer configurations in a repository for the authenticated user
    ///
    /// Lists the devcontainer.json files associated with a specified repository and the authenticated user. These files
    /// specify launchpoint configurations for codespaces created within the repository.
    /// 
    /// OAuth app tokens and personal access tokens (classic) need the `codespace` scope to use this endpoint.
    ///
    /// [GitHub API docs for list_devcontainers_in_repository_for_authenticated_user](https://docs.github.com/rest/codespaces/codespaces#list-devcontainer-configurations-in-a-repository-for-the-authenticated-user)
    ///
    /// ---
    pub async fn list_devcontainers_in_repository_for_authenticated_user_async(&self, owner: &str, repo: &str, query_params: Option<impl Into<CodespacesListDevcontainersInRepositoryForAuthenticatedUserParams>>) -> Result<GetCodespacesListDevcontainersInRepositoryForAuthenticatedUserResponse200, AdapterError> {

        let mut request_uri = format!("{}/repos/{}/{}/codespaces/devcontainers", super::GITHUB_BASE_API_URL, owner, repo);

        if let Some(params) = query_params {
            request_uri.push_str("?");
            request_uri.push_str(&serde_urlencoded::to_string(params.into())?);
        }

        let req = GitHubRequest {
            uri: request_uri,
            body: None::<C::Body>,
            method: "GET",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch_async(request).await?;

        // --

        if github_response.is_success() {
            Ok(github_response.to_json_async().await?)
        } else {
            match github_response.status_code() {
                500 => Err(CodespacesListDevcontainersInRepositoryForAuthenticatedUserError::Status500(github_response.to_json_async().await?).into()),
                400 => Err(CodespacesListDevcontainersInRepositoryForAuthenticatedUserError::Status400(github_response.to_json_async().await?).into()),
                401 => Err(CodespacesListDevcontainersInRepositoryForAuthenticatedUserError::Status401(github_response.to_json_async().await?).into()),
                403 => Err(CodespacesListDevcontainersInRepositoryForAuthenticatedUserError::Status403(github_response.to_json_async().await?).into()),
                404 => Err(CodespacesListDevcontainersInRepositoryForAuthenticatedUserError::Status404(github_response.to_json_async().await?).into()),
                code => Err(CodespacesListDevcontainersInRepositoryForAuthenticatedUserError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # List devcontainer configurations in a repository for the authenticated user
    ///
    /// Lists the devcontainer.json files associated with a specified repository and the authenticated user. These files
    /// specify launchpoint configurations for codespaces created within the repository.
    /// 
    /// OAuth app tokens and personal access tokens (classic) need the `codespace` scope to use this endpoint.
    ///
    /// [GitHub API docs for list_devcontainers_in_repository_for_authenticated_user](https://docs.github.com/rest/codespaces/codespaces#list-devcontainer-configurations-in-a-repository-for-the-authenticated-user)
    ///
    /// ---
    #[cfg(not(target_arch = "wasm32"))]
    pub fn list_devcontainers_in_repository_for_authenticated_user(&self, owner: &str, repo: &str, query_params: Option<impl Into<CodespacesListDevcontainersInRepositoryForAuthenticatedUserParams>>) -> Result<GetCodespacesListDevcontainersInRepositoryForAuthenticatedUserResponse200, AdapterError> {

        let mut request_uri = format!("{}/repos/{}/{}/codespaces/devcontainers", super::GITHUB_BASE_API_URL, owner, repo);

        if let Some(params) = query_params {
            request_uri.push_str("?");
            let qp: CodespacesListDevcontainersInRepositoryForAuthenticatedUserParams = params.into();
            request_uri.push_str(&serde_urlencoded::to_string(qp)?);
        }

        let req = GitHubRequest {
            uri: request_uri,
            body: None,
            method: "GET",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch(request)?;

        // --

        if github_response.is_success() {
            Ok(github_response.to_json()?)
        } else {
            match github_response.status_code() {
                500 => Err(CodespacesListDevcontainersInRepositoryForAuthenticatedUserError::Status500(github_response.to_json()?).into()),
                400 => Err(CodespacesListDevcontainersInRepositoryForAuthenticatedUserError::Status400(github_response.to_json()?).into()),
                401 => Err(CodespacesListDevcontainersInRepositoryForAuthenticatedUserError::Status401(github_response.to_json()?).into()),
                403 => Err(CodespacesListDevcontainersInRepositoryForAuthenticatedUserError::Status403(github_response.to_json()?).into()),
                404 => Err(CodespacesListDevcontainersInRepositoryForAuthenticatedUserError::Status404(github_response.to_json()?).into()),
                code => Err(CodespacesListDevcontainersInRepositoryForAuthenticatedUserError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # List codespaces for the authenticated user
    ///
    /// Lists the authenticated user's codespaces.
    /// 
    /// OAuth app tokens and personal access tokens (classic) need the `codespace` scope to use this endpoint.
    ///
    /// [GitHub API docs for list_for_authenticated_user](https://docs.github.com/rest/codespaces/codespaces#list-codespaces-for-the-authenticated-user)
    ///
    /// ---
    pub async fn list_for_authenticated_user_async(&self, query_params: Option<impl Into<CodespacesListForAuthenticatedUserParams>>) -> Result<GetCodespacesListForAuthenticatedUserResponse200, AdapterError> {

        let mut request_uri = format!("{}/user/codespaces", super::GITHUB_BASE_API_URL);

        if let Some(params) = query_params {
            request_uri.push_str("?");
            request_uri.push_str(&serde_urlencoded::to_string(params.into())?);
        }

        let req = GitHubRequest {
            uri: request_uri,
            body: None::<C::Body>,
            method: "GET",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch_async(request).await?;

        // --

        if github_response.is_success() {
            Ok(github_response.to_json_async().await?)
        } else {
            match github_response.status_code() {
                304 => Err(CodespacesListForAuthenticatedUserError::Status304.into()),
                500 => Err(CodespacesListForAuthenticatedUserError::Status500(github_response.to_json_async().await?).into()),
                401 => Err(CodespacesListForAuthenticatedUserError::Status401(github_response.to_json_async().await?).into()),
                403 => Err(CodespacesListForAuthenticatedUserError::Status403(github_response.to_json_async().await?).into()),
                404 => Err(CodespacesListForAuthenticatedUserError::Status404(github_response.to_json_async().await?).into()),
                code => Err(CodespacesListForAuthenticatedUserError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # List codespaces for the authenticated user
    ///
    /// Lists the authenticated user's codespaces.
    /// 
    /// OAuth app tokens and personal access tokens (classic) need the `codespace` scope to use this endpoint.
    ///
    /// [GitHub API docs for list_for_authenticated_user](https://docs.github.com/rest/codespaces/codespaces#list-codespaces-for-the-authenticated-user)
    ///
    /// ---
    #[cfg(not(target_arch = "wasm32"))]
    pub fn list_for_authenticated_user(&self, query_params: Option<impl Into<CodespacesListForAuthenticatedUserParams>>) -> Result<GetCodespacesListForAuthenticatedUserResponse200, AdapterError> {

        let mut request_uri = format!("{}/user/codespaces", super::GITHUB_BASE_API_URL);

        if let Some(params) = query_params {
            request_uri.push_str("?");
            let qp: CodespacesListForAuthenticatedUserParams = params.into();
            request_uri.push_str(&serde_urlencoded::to_string(qp)?);
        }

        let req = GitHubRequest {
            uri: request_uri,
            body: None,
            method: "GET",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch(request)?;

        // --

        if github_response.is_success() {
            Ok(github_response.to_json()?)
        } else {
            match github_response.status_code() {
                304 => Err(CodespacesListForAuthenticatedUserError::Status304.into()),
                500 => Err(CodespacesListForAuthenticatedUserError::Status500(github_response.to_json()?).into()),
                401 => Err(CodespacesListForAuthenticatedUserError::Status401(github_response.to_json()?).into()),
                403 => Err(CodespacesListForAuthenticatedUserError::Status403(github_response.to_json()?).into()),
                404 => Err(CodespacesListForAuthenticatedUserError::Status404(github_response.to_json()?).into()),
                code => Err(CodespacesListForAuthenticatedUserError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # List codespaces for the organization
    ///
    /// Lists the codespaces associated to a specified organization.
    /// 
    /// OAuth app tokens and personal access tokens (classic) need the `admin:org` scope to use this endpoint.
    ///
    /// [GitHub API docs for list_in_organization](https://docs.github.com/rest/codespaces/organizations#list-codespaces-for-the-organization)
    ///
    /// ---
    pub async fn list_in_organization_async(&self, org: &str, query_params: Option<impl Into<CodespacesListInOrganizationParams>>) -> Result<GetCodespacesListForAuthenticatedUserResponse200, AdapterError> {

        let mut request_uri = format!("{}/orgs/{}/codespaces", super::GITHUB_BASE_API_URL, org);

        if let Some(params) = query_params {
            request_uri.push_str("?");
            request_uri.push_str(&serde_urlencoded::to_string(params.into())?);
        }

        let req = GitHubRequest {
            uri: request_uri,
            body: None::<C::Body>,
            method: "GET",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch_async(request).await?;

        // --

        if github_response.is_success() {
            Ok(github_response.to_json_async().await?)
        } else {
            match github_response.status_code() {
                304 => Err(CodespacesListInOrganizationError::Status304.into()),
                500 => Err(CodespacesListInOrganizationError::Status500(github_response.to_json_async().await?).into()),
                401 => Err(CodespacesListInOrganizationError::Status401(github_response.to_json_async().await?).into()),
                403 => Err(CodespacesListInOrganizationError::Status403(github_response.to_json_async().await?).into()),
                404 => Err(CodespacesListInOrganizationError::Status404(github_response.to_json_async().await?).into()),
                code => Err(CodespacesListInOrganizationError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # List codespaces for the organization
    ///
    /// Lists the codespaces associated to a specified organization.
    /// 
    /// OAuth app tokens and personal access tokens (classic) need the `admin:org` scope to use this endpoint.
    ///
    /// [GitHub API docs for list_in_organization](https://docs.github.com/rest/codespaces/organizations#list-codespaces-for-the-organization)
    ///
    /// ---
    #[cfg(not(target_arch = "wasm32"))]
    pub fn list_in_organization(&self, org: &str, query_params: Option<impl Into<CodespacesListInOrganizationParams>>) -> Result<GetCodespacesListForAuthenticatedUserResponse200, AdapterError> {

        let mut request_uri = format!("{}/orgs/{}/codespaces", super::GITHUB_BASE_API_URL, org);

        if let Some(params) = query_params {
            request_uri.push_str("?");
            let qp: CodespacesListInOrganizationParams = params.into();
            request_uri.push_str(&serde_urlencoded::to_string(qp)?);
        }

        let req = GitHubRequest {
            uri: request_uri,
            body: None,
            method: "GET",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch(request)?;

        // --

        if github_response.is_success() {
            Ok(github_response.to_json()?)
        } else {
            match github_response.status_code() {
                304 => Err(CodespacesListInOrganizationError::Status304.into()),
                500 => Err(CodespacesListInOrganizationError::Status500(github_response.to_json()?).into()),
                401 => Err(CodespacesListInOrganizationError::Status401(github_response.to_json()?).into()),
                403 => Err(CodespacesListInOrganizationError::Status403(github_response.to_json()?).into()),
                404 => Err(CodespacesListInOrganizationError::Status404(github_response.to_json()?).into()),
                code => Err(CodespacesListInOrganizationError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # List codespaces in a repository for the authenticated user
    ///
    /// Lists the codespaces associated to a specified repository and the authenticated user.
    /// 
    /// OAuth app tokens and personal access tokens (classic) need the `codespace` scope to use this endpoint.
    ///
    /// [GitHub API docs for list_in_repository_for_authenticated_user](https://docs.github.com/rest/codespaces/codespaces#list-codespaces-in-a-repository-for-the-authenticated-user)
    ///
    /// ---
    pub async fn list_in_repository_for_authenticated_user_async(&self, owner: &str, repo: &str, query_params: Option<impl Into<CodespacesListInRepositoryForAuthenticatedUserParams>>) -> Result<GetCodespacesListForAuthenticatedUserResponse200, AdapterError> {

        let mut request_uri = format!("{}/repos/{}/{}/codespaces", super::GITHUB_BASE_API_URL, owner, repo);

        if let Some(params) = query_params {
            request_uri.push_str("?");
            request_uri.push_str(&serde_urlencoded::to_string(params.into())?);
        }

        let req = GitHubRequest {
            uri: request_uri,
            body: None::<C::Body>,
            method: "GET",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch_async(request).await?;

        // --

        if github_response.is_success() {
            Ok(github_response.to_json_async().await?)
        } else {
            match github_response.status_code() {
                500 => Err(CodespacesListInRepositoryForAuthenticatedUserError::Status500(github_response.to_json_async().await?).into()),
                401 => Err(CodespacesListInRepositoryForAuthenticatedUserError::Status401(github_response.to_json_async().await?).into()),
                403 => Err(CodespacesListInRepositoryForAuthenticatedUserError::Status403(github_response.to_json_async().await?).into()),
                404 => Err(CodespacesListInRepositoryForAuthenticatedUserError::Status404(github_response.to_json_async().await?).into()),
                code => Err(CodespacesListInRepositoryForAuthenticatedUserError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # List codespaces in a repository for the authenticated user
    ///
    /// Lists the codespaces associated to a specified repository and the authenticated user.
    /// 
    /// OAuth app tokens and personal access tokens (classic) need the `codespace` scope to use this endpoint.
    ///
    /// [GitHub API docs for list_in_repository_for_authenticated_user](https://docs.github.com/rest/codespaces/codespaces#list-codespaces-in-a-repository-for-the-authenticated-user)
    ///
    /// ---
    #[cfg(not(target_arch = "wasm32"))]
    pub fn list_in_repository_for_authenticated_user(&self, owner: &str, repo: &str, query_params: Option<impl Into<CodespacesListInRepositoryForAuthenticatedUserParams>>) -> Result<GetCodespacesListForAuthenticatedUserResponse200, AdapterError> {

        let mut request_uri = format!("{}/repos/{}/{}/codespaces", super::GITHUB_BASE_API_URL, owner, repo);

        if let Some(params) = query_params {
            request_uri.push_str("?");
            let qp: CodespacesListInRepositoryForAuthenticatedUserParams = params.into();
            request_uri.push_str(&serde_urlencoded::to_string(qp)?);
        }

        let req = GitHubRequest {
            uri: request_uri,
            body: None,
            method: "GET",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch(request)?;

        // --

        if github_response.is_success() {
            Ok(github_response.to_json()?)
        } else {
            match github_response.status_code() {
                500 => Err(CodespacesListInRepositoryForAuthenticatedUserError::Status500(github_response.to_json()?).into()),
                401 => Err(CodespacesListInRepositoryForAuthenticatedUserError::Status401(github_response.to_json()?).into()),
                403 => Err(CodespacesListInRepositoryForAuthenticatedUserError::Status403(github_response.to_json()?).into()),
                404 => Err(CodespacesListInRepositoryForAuthenticatedUserError::Status404(github_response.to_json()?).into()),
                code => Err(CodespacesListInRepositoryForAuthenticatedUserError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # List organization secrets
    ///
    /// Lists all Codespaces development environment secrets available at the organization-level without revealing their encrypted
    /// values.
    /// 
    /// OAuth app tokens and personal access tokens (classic) need the `admin:org` scope to use this endpoint.
    ///
    /// [GitHub API docs for list_org_secrets](https://docs.github.com/rest/codespaces/organization-secrets#list-organization-secrets)
    ///
    /// ---
    pub async fn list_org_secrets_async(&self, org: &str, query_params: Option<impl Into<CodespacesListOrgSecretsParams>>) -> Result<GetCodespacesListOrgSecretsResponse200, AdapterError> {

        let mut request_uri = format!("{}/orgs/{}/codespaces/secrets", super::GITHUB_BASE_API_URL, org);

        if let Some(params) = query_params {
            request_uri.push_str("?");
            request_uri.push_str(&serde_urlencoded::to_string(params.into())?);
        }

        let req = GitHubRequest {
            uri: request_uri,
            body: None::<C::Body>,
            method: "GET",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch_async(request).await?;

        // --

        if github_response.is_success() {
            Ok(github_response.to_json_async().await?)
        } else {
            match github_response.status_code() {
                code => Err(CodespacesListOrgSecretsError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # List organization secrets
    ///
    /// Lists all Codespaces development environment secrets available at the organization-level without revealing their encrypted
    /// values.
    /// 
    /// OAuth app tokens and personal access tokens (classic) need the `admin:org` scope to use this endpoint.
    ///
    /// [GitHub API docs for list_org_secrets](https://docs.github.com/rest/codespaces/organization-secrets#list-organization-secrets)
    ///
    /// ---
    #[cfg(not(target_arch = "wasm32"))]
    pub fn list_org_secrets(&self, org: &str, query_params: Option<impl Into<CodespacesListOrgSecretsParams>>) -> Result<GetCodespacesListOrgSecretsResponse200, AdapterError> {

        let mut request_uri = format!("{}/orgs/{}/codespaces/secrets", super::GITHUB_BASE_API_URL, org);

        if let Some(params) = query_params {
            request_uri.push_str("?");
            let qp: CodespacesListOrgSecretsParams = params.into();
            request_uri.push_str(&serde_urlencoded::to_string(qp)?);
        }

        let req = GitHubRequest {
            uri: request_uri,
            body: None,
            method: "GET",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch(request)?;

        // --

        if github_response.is_success() {
            Ok(github_response.to_json()?)
        } else {
            match github_response.status_code() {
                code => Err(CodespacesListOrgSecretsError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # List repository secrets
    ///
    /// Lists all development environment secrets available in a repository without revealing their encrypted
    /// values.
    /// 
    /// OAuth app tokens and personal access tokens (classic) need the `repo` scope to use this endpoint.
    ///
    /// [GitHub API docs for list_repo_secrets](https://docs.github.com/rest/codespaces/repository-secrets#list-repository-secrets)
    ///
    /// ---
    pub async fn list_repo_secrets_async(&self, owner: &str, repo: &str, query_params: Option<impl Into<CodespacesListRepoSecretsParams>>) -> Result<GetCodespacesListRepoSecretsResponse200, AdapterError> {

        let mut request_uri = format!("{}/repos/{}/{}/codespaces/secrets", super::GITHUB_BASE_API_URL, owner, repo);

        if let Some(params) = query_params {
            request_uri.push_str("?");
            request_uri.push_str(&serde_urlencoded::to_string(params.into())?);
        }

        let req = GitHubRequest {
            uri: request_uri,
            body: None::<C::Body>,
            method: "GET",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch_async(request).await?;

        // --

        if github_response.is_success() {
            Ok(github_response.to_json_async().await?)
        } else {
            match github_response.status_code() {
                code => Err(CodespacesListRepoSecretsError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # List repository secrets
    ///
    /// Lists all development environment secrets available in a repository without revealing their encrypted
    /// values.
    /// 
    /// OAuth app tokens and personal access tokens (classic) need the `repo` scope to use this endpoint.
    ///
    /// [GitHub API docs for list_repo_secrets](https://docs.github.com/rest/codespaces/repository-secrets#list-repository-secrets)
    ///
    /// ---
    #[cfg(not(target_arch = "wasm32"))]
    pub fn list_repo_secrets(&self, owner: &str, repo: &str, query_params: Option<impl Into<CodespacesListRepoSecretsParams>>) -> Result<GetCodespacesListRepoSecretsResponse200, AdapterError> {

        let mut request_uri = format!("{}/repos/{}/{}/codespaces/secrets", super::GITHUB_BASE_API_URL, owner, repo);

        if let Some(params) = query_params {
            request_uri.push_str("?");
            let qp: CodespacesListRepoSecretsParams = params.into();
            request_uri.push_str(&serde_urlencoded::to_string(qp)?);
        }

        let req = GitHubRequest {
            uri: request_uri,
            body: None,
            method: "GET",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch(request)?;

        // --

        if github_response.is_success() {
            Ok(github_response.to_json()?)
        } else {
            match github_response.status_code() {
                code => Err(CodespacesListRepoSecretsError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # List selected repositories for a user secret
    ///
    /// List the repositories that have been granted the ability to use a user's development environment secret.
    /// 
    /// The authenticated user must have Codespaces access to use this endpoint.
    /// 
    /// OAuth app tokens and personal access tokens (classic) need the `codespace` or `codespace:secrets` scope to use this endpoint.
    ///
    /// [GitHub API docs for list_repositories_for_secret_for_authenticated_user](https://docs.github.com/rest/codespaces/secrets#list-selected-repositories-for-a-user-secret)
    ///
    /// ---
    pub async fn list_repositories_for_secret_for_authenticated_user_async(&self, secret_name: &str) -> Result<GetCodespacesListRepositoriesForSecretForAuthenticatedUserResponse200, AdapterError> {

        let request_uri = format!("{}/user/codespaces/secrets/{}/repositories", super::GITHUB_BASE_API_URL, secret_name);


        let req = GitHubRequest {
            uri: request_uri,
            body: None::<C::Body>,
            method: "GET",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch_async(request).await?;

        // --

        if github_response.is_success() {
            Ok(github_response.to_json_async().await?)
        } else {
            match github_response.status_code() {
                401 => Err(CodespacesListRepositoriesForSecretForAuthenticatedUserError::Status401(github_response.to_json_async().await?).into()),
                403 => Err(CodespacesListRepositoriesForSecretForAuthenticatedUserError::Status403(github_response.to_json_async().await?).into()),
                404 => Err(CodespacesListRepositoriesForSecretForAuthenticatedUserError::Status404(github_response.to_json_async().await?).into()),
                500 => Err(CodespacesListRepositoriesForSecretForAuthenticatedUserError::Status500(github_response.to_json_async().await?).into()),
                code => Err(CodespacesListRepositoriesForSecretForAuthenticatedUserError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # List selected repositories for a user secret
    ///
    /// List the repositories that have been granted the ability to use a user's development environment secret.
    /// 
    /// The authenticated user must have Codespaces access to use this endpoint.
    /// 
    /// OAuth app tokens and personal access tokens (classic) need the `codespace` or `codespace:secrets` scope to use this endpoint.
    ///
    /// [GitHub API docs for list_repositories_for_secret_for_authenticated_user](https://docs.github.com/rest/codespaces/secrets#list-selected-repositories-for-a-user-secret)
    ///
    /// ---
    #[cfg(not(target_arch = "wasm32"))]
    pub fn list_repositories_for_secret_for_authenticated_user(&self, secret_name: &str) -> Result<GetCodespacesListRepositoriesForSecretForAuthenticatedUserResponse200, AdapterError> {

        let request_uri = format!("{}/user/codespaces/secrets/{}/repositories", super::GITHUB_BASE_API_URL, secret_name);


        let req = GitHubRequest {
            uri: request_uri,
            body: None,
            method: "GET",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch(request)?;

        // --

        if github_response.is_success() {
            Ok(github_response.to_json()?)
        } else {
            match github_response.status_code() {
                401 => Err(CodespacesListRepositoriesForSecretForAuthenticatedUserError::Status401(github_response.to_json()?).into()),
                403 => Err(CodespacesListRepositoriesForSecretForAuthenticatedUserError::Status403(github_response.to_json()?).into()),
                404 => Err(CodespacesListRepositoriesForSecretForAuthenticatedUserError::Status404(github_response.to_json()?).into()),
                500 => Err(CodespacesListRepositoriesForSecretForAuthenticatedUserError::Status500(github_response.to_json()?).into()),
                code => Err(CodespacesListRepositoriesForSecretForAuthenticatedUserError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # List secrets for the authenticated user
    ///
    /// Lists all development environment secrets available for a user's codespaces without revealing their
    /// encrypted values.
    /// 
    /// The authenticated user must have Codespaces access to use this endpoint.
    /// 
    /// OAuth app tokens and personal access tokens (classic) need the `codespace` or `codespace:secrets` scope to use this endpoint.
    ///
    /// [GitHub API docs for list_secrets_for_authenticated_user](https://docs.github.com/rest/codespaces/secrets#list-secrets-for-the-authenticated-user)
    ///
    /// ---
    pub async fn list_secrets_for_authenticated_user_async(&self, query_params: Option<impl Into<CodespacesListSecretsForAuthenticatedUserParams>>) -> Result<GetCodespacesListSecretsForAuthenticatedUserResponse200, AdapterError> {

        let mut request_uri = format!("{}/user/codespaces/secrets", super::GITHUB_BASE_API_URL);

        if let Some(params) = query_params {
            request_uri.push_str("?");
            request_uri.push_str(&serde_urlencoded::to_string(params.into())?);
        }

        let req = GitHubRequest {
            uri: request_uri,
            body: None::<C::Body>,
            method: "GET",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch_async(request).await?;

        // --

        if github_response.is_success() {
            Ok(github_response.to_json_async().await?)
        } else {
            match github_response.status_code() {
                code => Err(CodespacesListSecretsForAuthenticatedUserError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # List secrets for the authenticated user
    ///
    /// Lists all development environment secrets available for a user's codespaces without revealing their
    /// encrypted values.
    /// 
    /// The authenticated user must have Codespaces access to use this endpoint.
    /// 
    /// OAuth app tokens and personal access tokens (classic) need the `codespace` or `codespace:secrets` scope to use this endpoint.
    ///
    /// [GitHub API docs for list_secrets_for_authenticated_user](https://docs.github.com/rest/codespaces/secrets#list-secrets-for-the-authenticated-user)
    ///
    /// ---
    #[cfg(not(target_arch = "wasm32"))]
    pub fn list_secrets_for_authenticated_user(&self, query_params: Option<impl Into<CodespacesListSecretsForAuthenticatedUserParams>>) -> Result<GetCodespacesListSecretsForAuthenticatedUserResponse200, AdapterError> {

        let mut request_uri = format!("{}/user/codespaces/secrets", super::GITHUB_BASE_API_URL);

        if let Some(params) = query_params {
            request_uri.push_str("?");
            let qp: CodespacesListSecretsForAuthenticatedUserParams = params.into();
            request_uri.push_str(&serde_urlencoded::to_string(qp)?);
        }

        let req = GitHubRequest {
            uri: request_uri,
            body: None,
            method: "GET",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch(request)?;

        // --

        if github_response.is_success() {
            Ok(github_response.to_json()?)
        } else {
            match github_response.status_code() {
                code => Err(CodespacesListSecretsForAuthenticatedUserError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # List selected repositories for an organization secret
    ///
    /// Lists all repositories that have been selected when the `visibility`
    /// for repository access to a secret is set to `selected`.
    /// 
    /// OAuth app tokens and personal access tokens (classic) need the `admin:org` scope to use this endpoint.
    ///
    /// [GitHub API docs for list_selected_repos_for_org_secret](https://docs.github.com/rest/codespaces/organization-secrets#list-selected-repositories-for-an-organization-secret)
    ///
    /// ---
    pub async fn list_selected_repos_for_org_secret_async(&self, org: &str, secret_name: &str, query_params: Option<impl Into<CodespacesListSelectedReposForOrgSecretParams>>) -> Result<GetCodespacesListRepositoriesForSecretForAuthenticatedUserResponse200, AdapterError> {

        let mut request_uri = format!("{}/orgs/{}/codespaces/secrets/{}/repositories", super::GITHUB_BASE_API_URL, org, secret_name);

        if let Some(params) = query_params {
            request_uri.push_str("?");
            request_uri.push_str(&serde_urlencoded::to_string(params.into())?);
        }

        let req = GitHubRequest {
            uri: request_uri,
            body: None::<C::Body>,
            method: "GET",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch_async(request).await?;

        // --

        if github_response.is_success() {
            Ok(github_response.to_json_async().await?)
        } else {
            match github_response.status_code() {
                404 => Err(CodespacesListSelectedReposForOrgSecretError::Status404(github_response.to_json_async().await?).into()),
                code => Err(CodespacesListSelectedReposForOrgSecretError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # List selected repositories for an organization secret
    ///
    /// Lists all repositories that have been selected when the `visibility`
    /// for repository access to a secret is set to `selected`.
    /// 
    /// OAuth app tokens and personal access tokens (classic) need the `admin:org` scope to use this endpoint.
    ///
    /// [GitHub API docs for list_selected_repos_for_org_secret](https://docs.github.com/rest/codespaces/organization-secrets#list-selected-repositories-for-an-organization-secret)
    ///
    /// ---
    #[cfg(not(target_arch = "wasm32"))]
    pub fn list_selected_repos_for_org_secret(&self, org: &str, secret_name: &str, query_params: Option<impl Into<CodespacesListSelectedReposForOrgSecretParams>>) -> Result<GetCodespacesListRepositoriesForSecretForAuthenticatedUserResponse200, AdapterError> {

        let mut request_uri = format!("{}/orgs/{}/codespaces/secrets/{}/repositories", super::GITHUB_BASE_API_URL, org, secret_name);

        if let Some(params) = query_params {
            request_uri.push_str("?");
            let qp: CodespacesListSelectedReposForOrgSecretParams = params.into();
            request_uri.push_str(&serde_urlencoded::to_string(qp)?);
        }

        let req = GitHubRequest {
            uri: request_uri,
            body: None,
            method: "GET",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch(request)?;

        // --

        if github_response.is_success() {
            Ok(github_response.to_json()?)
        } else {
            match github_response.status_code() {
                404 => Err(CodespacesListSelectedReposForOrgSecretError::Status404(github_response.to_json()?).into()),
                code => Err(CodespacesListSelectedReposForOrgSecretError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # Get default attributes for a codespace
    ///
    /// Gets the default attributes for codespaces created by the user with the repository.
    /// 
    /// OAuth app tokens and personal access tokens (classic) need the `codespace` scope to use this endpoint.
    ///
    /// [GitHub API docs for pre_flight_with_repo_for_authenticated_user](https://docs.github.com/rest/codespaces/codespaces#get-default-attributes-for-a-codespace)
    ///
    /// ---
    pub async fn pre_flight_with_repo_for_authenticated_user_async(&self, owner: &str, repo: &str, query_params: Option<impl Into<CodespacesPreFlightWithRepoForAuthenticatedUserParams<'api>>>) -> Result<GetCodespacesPreFlightWithRepoForAuthenticatedUserResponse200, AdapterError> {

        let mut request_uri = format!("{}/repos/{}/{}/codespaces/new", super::GITHUB_BASE_API_URL, owner, repo);

        if let Some(params) = query_params {
            request_uri.push_str("?");
            request_uri.push_str(&serde_urlencoded::to_string(params.into())?);
        }

        let req = GitHubRequest {
            uri: request_uri,
            body: None::<C::Body>,
            method: "GET",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch_async(request).await?;

        // --

        if github_response.is_success() {
            Ok(github_response.to_json_async().await?)
        } else {
            match github_response.status_code() {
                401 => Err(CodespacesPreFlightWithRepoForAuthenticatedUserError::Status401(github_response.to_json_async().await?).into()),
                403 => Err(CodespacesPreFlightWithRepoForAuthenticatedUserError::Status403(github_response.to_json_async().await?).into()),
                404 => Err(CodespacesPreFlightWithRepoForAuthenticatedUserError::Status404(github_response.to_json_async().await?).into()),
                code => Err(CodespacesPreFlightWithRepoForAuthenticatedUserError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # Get default attributes for a codespace
    ///
    /// Gets the default attributes for codespaces created by the user with the repository.
    /// 
    /// OAuth app tokens and personal access tokens (classic) need the `codespace` scope to use this endpoint.
    ///
    /// [GitHub API docs for pre_flight_with_repo_for_authenticated_user](https://docs.github.com/rest/codespaces/codespaces#get-default-attributes-for-a-codespace)
    ///
    /// ---
    #[cfg(not(target_arch = "wasm32"))]
    pub fn pre_flight_with_repo_for_authenticated_user(&self, owner: &str, repo: &str, query_params: Option<impl Into<CodespacesPreFlightWithRepoForAuthenticatedUserParams<'api>>>) -> Result<GetCodespacesPreFlightWithRepoForAuthenticatedUserResponse200, AdapterError> {

        let mut request_uri = format!("{}/repos/{}/{}/codespaces/new", super::GITHUB_BASE_API_URL, owner, repo);

        if let Some(params) = query_params {
            request_uri.push_str("?");
            let qp: CodespacesPreFlightWithRepoForAuthenticatedUserParams = params.into();
            request_uri.push_str(&serde_urlencoded::to_string(qp)?);
        }

        let req = GitHubRequest {
            uri: request_uri,
            body: None,
            method: "GET",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch(request)?;

        // --

        if github_response.is_success() {
            Ok(github_response.to_json()?)
        } else {
            match github_response.status_code() {
                401 => Err(CodespacesPreFlightWithRepoForAuthenticatedUserError::Status401(github_response.to_json()?).into()),
                403 => Err(CodespacesPreFlightWithRepoForAuthenticatedUserError::Status403(github_response.to_json()?).into()),
                404 => Err(CodespacesPreFlightWithRepoForAuthenticatedUserError::Status404(github_response.to_json()?).into()),
                code => Err(CodespacesPreFlightWithRepoForAuthenticatedUserError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # Create a repository from an unpublished codespace
    ///
    /// Publishes an unpublished codespace, creating a new repository and assigning it to the codespace.
    /// 
    /// The codespace's token is granted write permissions to the repository, allowing the user to push their changes.
    /// 
    /// This will fail for a codespace that is already published, meaning it has an associated repository.
    /// 
    /// OAuth app tokens and personal access tokens (classic) need the `codespace` scope to use this endpoint.
    ///
    /// [GitHub API docs for publish_for_authenticated_user](https://docs.github.com/rest/codespaces/codespaces#create-a-repository-from-an-unpublished-codespace)
    ///
    /// ---
    pub async fn publish_for_authenticated_user_async(&self, codespace_name: &str, body: PostCodespacesPublishForAuthenticatedUser) -> Result<CodespaceWithFullRepository, AdapterError> {

        let request_uri = format!("{}/user/codespaces/{}/publish", super::GITHUB_BASE_API_URL, codespace_name);


        let req = GitHubRequest {
            uri: request_uri,
            body: Some(C::from_json::<PostCodespacesPublishForAuthenticatedUser>(body)?),
            method: "POST",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch_async(request).await?;

        // --

        if github_response.is_success() {
            Ok(github_response.to_json_async().await?)
        } else {
            match github_response.status_code() {
                401 => Err(CodespacesPublishForAuthenticatedUserError::Status401(github_response.to_json_async().await?).into()),
                403 => Err(CodespacesPublishForAuthenticatedUserError::Status403(github_response.to_json_async().await?).into()),
                404 => Err(CodespacesPublishForAuthenticatedUserError::Status404(github_response.to_json_async().await?).into()),
                422 => Err(CodespacesPublishForAuthenticatedUserError::Status422(github_response.to_json_async().await?).into()),
                code => Err(CodespacesPublishForAuthenticatedUserError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # Create a repository from an unpublished codespace
    ///
    /// Publishes an unpublished codespace, creating a new repository and assigning it to the codespace.
    /// 
    /// The codespace's token is granted write permissions to the repository, allowing the user to push their changes.
    /// 
    /// This will fail for a codespace that is already published, meaning it has an associated repository.
    /// 
    /// OAuth app tokens and personal access tokens (classic) need the `codespace` scope to use this endpoint.
    ///
    /// [GitHub API docs for publish_for_authenticated_user](https://docs.github.com/rest/codespaces/codespaces#create-a-repository-from-an-unpublished-codespace)
    ///
    /// ---
    #[cfg(not(target_arch = "wasm32"))]
    pub fn publish_for_authenticated_user(&self, codespace_name: &str, body: PostCodespacesPublishForAuthenticatedUser) -> Result<CodespaceWithFullRepository, AdapterError> {

        let request_uri = format!("{}/user/codespaces/{}/publish", super::GITHUB_BASE_API_URL, codespace_name);


        let req = GitHubRequest {
            uri: request_uri,
            body: Some(C::from_json::<PostCodespacesPublishForAuthenticatedUser>(body)?),
            method: "POST",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch(request)?;

        // --

        if github_response.is_success() {
            Ok(github_response.to_json()?)
        } else {
            match github_response.status_code() {
                401 => Err(CodespacesPublishForAuthenticatedUserError::Status401(github_response.to_json()?).into()),
                403 => Err(CodespacesPublishForAuthenticatedUserError::Status403(github_response.to_json()?).into()),
                404 => Err(CodespacesPublishForAuthenticatedUserError::Status404(github_response.to_json()?).into()),
                422 => Err(CodespacesPublishForAuthenticatedUserError::Status422(github_response.to_json()?).into()),
                code => Err(CodespacesPublishForAuthenticatedUserError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # Remove a selected repository from a user secret
    ///
    /// Removes a repository from the selected repositories for a user's development environment secret.
    /// 
    /// The authenticated user must have Codespaces access to use this endpoint.
    /// 
    /// OAuth app tokens and personal access tokens (classic) need the `codespace` or `codespace:secrets` scope to use this endpoint.
    ///
    /// [GitHub API docs for remove_repository_for_secret_for_authenticated_user](https://docs.github.com/rest/codespaces/secrets#remove-a-selected-repository-from-a-user-secret)
    ///
    /// ---
    pub async fn remove_repository_for_secret_for_authenticated_user_async(&self, secret_name: &str, repository_id: i32) -> Result<(), AdapterError> {

        let request_uri = format!("{}/user/codespaces/secrets/{}/repositories/{}", super::GITHUB_BASE_API_URL, secret_name, repository_id);


        let req = GitHubRequest {
            uri: request_uri,
            body: None::<C::Body>,
            method: "DELETE",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch_async(request).await?;

        // --

        if github_response.is_success() {
            Ok(github_response.to_json_async().await?)
        } else {
            match github_response.status_code() {
                401 => Err(CodespacesRemoveRepositoryForSecretForAuthenticatedUserError::Status401(github_response.to_json_async().await?).into()),
                403 => Err(CodespacesRemoveRepositoryForSecretForAuthenticatedUserError::Status403(github_response.to_json_async().await?).into()),
                404 => Err(CodespacesRemoveRepositoryForSecretForAuthenticatedUserError::Status404(github_response.to_json_async().await?).into()),
                500 => Err(CodespacesRemoveRepositoryForSecretForAuthenticatedUserError::Status500(github_response.to_json_async().await?).into()),
                code => Err(CodespacesRemoveRepositoryForSecretForAuthenticatedUserError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # Remove a selected repository from a user secret
    ///
    /// Removes a repository from the selected repositories for a user's development environment secret.
    /// 
    /// The authenticated user must have Codespaces access to use this endpoint.
    /// 
    /// OAuth app tokens and personal access tokens (classic) need the `codespace` or `codespace:secrets` scope to use this endpoint.
    ///
    /// [GitHub API docs for remove_repository_for_secret_for_authenticated_user](https://docs.github.com/rest/codespaces/secrets#remove-a-selected-repository-from-a-user-secret)
    ///
    /// ---
    #[cfg(not(target_arch = "wasm32"))]
    pub fn remove_repository_for_secret_for_authenticated_user(&self, secret_name: &str, repository_id: i32) -> Result<(), AdapterError> {

        let request_uri = format!("{}/user/codespaces/secrets/{}/repositories/{}", super::GITHUB_BASE_API_URL, secret_name, repository_id);


        let req = GitHubRequest {
            uri: request_uri,
            body: None,
            method: "DELETE",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch(request)?;

        // --

        if github_response.is_success() {
            Ok(github_response.to_json()?)
        } else {
            match github_response.status_code() {
                401 => Err(CodespacesRemoveRepositoryForSecretForAuthenticatedUserError::Status401(github_response.to_json()?).into()),
                403 => Err(CodespacesRemoveRepositoryForSecretForAuthenticatedUserError::Status403(github_response.to_json()?).into()),
                404 => Err(CodespacesRemoveRepositoryForSecretForAuthenticatedUserError::Status404(github_response.to_json()?).into()),
                500 => Err(CodespacesRemoveRepositoryForSecretForAuthenticatedUserError::Status500(github_response.to_json()?).into()),
                code => Err(CodespacesRemoveRepositoryForSecretForAuthenticatedUserError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # Remove selected repository from an organization secret
    ///
    /// Removes a repository from an organization development environment secret when the `visibility`
    /// for repository access is set to `selected`. The visibility is set when you [Create
    /// or update an organization secret](https://docs.github.com/rest/codespaces/organization-secrets#create-or-update-an-organization-secret).
    /// 
    /// OAuth app tokens and personal access tokens (classic) need the `admin:org` scope to use this endpoint.
    ///
    /// [GitHub API docs for remove_selected_repo_from_org_secret](https://docs.github.com/rest/codespaces/organization-secrets#remove-selected-repository-from-an-organization-secret)
    ///
    /// ---
    pub async fn remove_selected_repo_from_org_secret_async(&self, org: &str, secret_name: &str, repository_id: i32) -> Result<(), AdapterError> {

        let request_uri = format!("{}/orgs/{}/codespaces/secrets/{}/repositories/{}", super::GITHUB_BASE_API_URL, org, secret_name, repository_id);


        let req = GitHubRequest {
            uri: request_uri,
            body: None::<C::Body>,
            method: "DELETE",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch_async(request).await?;

        // --

        if github_response.is_success() {
            Ok(github_response.to_json_async().await?)
        } else {
            match github_response.status_code() {
                404 => Err(CodespacesRemoveSelectedRepoFromOrgSecretError::Status404(github_response.to_json_async().await?).into()),
                409 => Err(CodespacesRemoveSelectedRepoFromOrgSecretError::Status409.into()),
                422 => Err(CodespacesRemoveSelectedRepoFromOrgSecretError::Status422(github_response.to_json_async().await?).into()),
                code => Err(CodespacesRemoveSelectedRepoFromOrgSecretError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # Remove selected repository from an organization secret
    ///
    /// Removes a repository from an organization development environment secret when the `visibility`
    /// for repository access is set to `selected`. The visibility is set when you [Create
    /// or update an organization secret](https://docs.github.com/rest/codespaces/organization-secrets#create-or-update-an-organization-secret).
    /// 
    /// OAuth app tokens and personal access tokens (classic) need the `admin:org` scope to use this endpoint.
    ///
    /// [GitHub API docs for remove_selected_repo_from_org_secret](https://docs.github.com/rest/codespaces/organization-secrets#remove-selected-repository-from-an-organization-secret)
    ///
    /// ---
    #[cfg(not(target_arch = "wasm32"))]
    pub fn remove_selected_repo_from_org_secret(&self, org: &str, secret_name: &str, repository_id: i32) -> Result<(), AdapterError> {

        let request_uri = format!("{}/orgs/{}/codespaces/secrets/{}/repositories/{}", super::GITHUB_BASE_API_URL, org, secret_name, repository_id);


        let req = GitHubRequest {
            uri: request_uri,
            body: None,
            method: "DELETE",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch(request)?;

        // --

        if github_response.is_success() {
            Ok(github_response.to_json()?)
        } else {
            match github_response.status_code() {
                404 => Err(CodespacesRemoveSelectedRepoFromOrgSecretError::Status404(github_response.to_json()?).into()),
                409 => Err(CodespacesRemoveSelectedRepoFromOrgSecretError::Status409.into()),
                422 => Err(CodespacesRemoveSelectedRepoFromOrgSecretError::Status422(github_response.to_json()?).into()),
                code => Err(CodespacesRemoveSelectedRepoFromOrgSecretError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # List available machine types for a repository
    ///
    /// List the machine types available for a given repository based on its configuration.
    /// 
    /// OAuth app tokens and personal access tokens (classic) need the `codespace` scope to use this endpoint.
    ///
    /// [GitHub API docs for repo_machines_for_authenticated_user](https://docs.github.com/rest/codespaces/machines#list-available-machine-types-for-a-repository)
    ///
    /// ---
    pub async fn repo_machines_for_authenticated_user_async(&self, owner: &str, repo: &str, query_params: Option<impl Into<CodespacesRepoMachinesForAuthenticatedUserParams<'api>>>) -> Result<GetCodespacesCodespaceMachinesForAuthenticatedUserResponse200, AdapterError> {

        let mut request_uri = format!("{}/repos/{}/{}/codespaces/machines", super::GITHUB_BASE_API_URL, owner, repo);

        if let Some(params) = query_params {
            request_uri.push_str("?");
            request_uri.push_str(&serde_urlencoded::to_string(params.into())?);
        }

        let req = GitHubRequest {
            uri: request_uri,
            body: None::<C::Body>,
            method: "GET",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch_async(request).await?;

        // --

        if github_response.is_success() {
            Ok(github_response.to_json_async().await?)
        } else {
            match github_response.status_code() {
                304 => Err(CodespacesRepoMachinesForAuthenticatedUserError::Status304.into()),
                500 => Err(CodespacesRepoMachinesForAuthenticatedUserError::Status500(github_response.to_json_async().await?).into()),
                401 => Err(CodespacesRepoMachinesForAuthenticatedUserError::Status401(github_response.to_json_async().await?).into()),
                403 => Err(CodespacesRepoMachinesForAuthenticatedUserError::Status403(github_response.to_json_async().await?).into()),
                404 => Err(CodespacesRepoMachinesForAuthenticatedUserError::Status404(github_response.to_json_async().await?).into()),
                code => Err(CodespacesRepoMachinesForAuthenticatedUserError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # List available machine types for a repository
    ///
    /// List the machine types available for a given repository based on its configuration.
    /// 
    /// OAuth app tokens and personal access tokens (classic) need the `codespace` scope to use this endpoint.
    ///
    /// [GitHub API docs for repo_machines_for_authenticated_user](https://docs.github.com/rest/codespaces/machines#list-available-machine-types-for-a-repository)
    ///
    /// ---
    #[cfg(not(target_arch = "wasm32"))]
    pub fn repo_machines_for_authenticated_user(&self, owner: &str, repo: &str, query_params: Option<impl Into<CodespacesRepoMachinesForAuthenticatedUserParams<'api>>>) -> Result<GetCodespacesCodespaceMachinesForAuthenticatedUserResponse200, AdapterError> {

        let mut request_uri = format!("{}/repos/{}/{}/codespaces/machines", super::GITHUB_BASE_API_URL, owner, repo);

        if let Some(params) = query_params {
            request_uri.push_str("?");
            let qp: CodespacesRepoMachinesForAuthenticatedUserParams = params.into();
            request_uri.push_str(&serde_urlencoded::to_string(qp)?);
        }

        let req = GitHubRequest {
            uri: request_uri,
            body: None,
            method: "GET",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch(request)?;

        // --

        if github_response.is_success() {
            Ok(github_response.to_json()?)
        } else {
            match github_response.status_code() {
                304 => Err(CodespacesRepoMachinesForAuthenticatedUserError::Status304.into()),
                500 => Err(CodespacesRepoMachinesForAuthenticatedUserError::Status500(github_response.to_json()?).into()),
                401 => Err(CodespacesRepoMachinesForAuthenticatedUserError::Status401(github_response.to_json()?).into()),
                403 => Err(CodespacesRepoMachinesForAuthenticatedUserError::Status403(github_response.to_json()?).into()),
                404 => Err(CodespacesRepoMachinesForAuthenticatedUserError::Status404(github_response.to_json()?).into()),
                code => Err(CodespacesRepoMachinesForAuthenticatedUserError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # Manage access control for organization codespaces
    ///
    /// Sets which users can access codespaces in an organization. This is synonymous with granting or revoking codespaces access permissions for users according to the visibility.
    /// OAuth app tokens and personal access tokens (classic) need the `admin:org` scope to use this endpoint.
    ///
    /// [GitHub API docs for set_codespaces_access](https://docs.github.com/rest/codespaces/organizations#manage-access-control-for-organization-codespaces)
    ///
    /// ---
    pub async fn set_codespaces_access_async(&self, org: &str, body: PutCodespacesSetCodespacesAccess) -> Result<(), AdapterError> {

        let request_uri = format!("{}/orgs/{}/codespaces/access", super::GITHUB_BASE_API_URL, org);


        let req = GitHubRequest {
            uri: request_uri,
            body: Some(C::from_json::<PutCodespacesSetCodespacesAccess>(body)?),
            method: "PUT",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch_async(request).await?;

        // --

        if github_response.is_success() {
            Ok(github_response.to_json_async().await?)
        } else {
            match github_response.status_code() {
                304 => Err(CodespacesSetCodespacesAccessError::Status304.into()),
                400 => Err(CodespacesSetCodespacesAccessError::Status400.into()),
                404 => Err(CodespacesSetCodespacesAccessError::Status404(github_response.to_json_async().await?).into()),
                422 => Err(CodespacesSetCodespacesAccessError::Status422(github_response.to_json_async().await?).into()),
                500 => Err(CodespacesSetCodespacesAccessError::Status500(github_response.to_json_async().await?).into()),
                code => Err(CodespacesSetCodespacesAccessError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # Manage access control for organization codespaces
    ///
    /// Sets which users can access codespaces in an organization. This is synonymous with granting or revoking codespaces access permissions for users according to the visibility.
    /// OAuth app tokens and personal access tokens (classic) need the `admin:org` scope to use this endpoint.
    ///
    /// [GitHub API docs for set_codespaces_access](https://docs.github.com/rest/codespaces/organizations#manage-access-control-for-organization-codespaces)
    ///
    /// ---
    #[cfg(not(target_arch = "wasm32"))]
    pub fn set_codespaces_access(&self, org: &str, body: PutCodespacesSetCodespacesAccess) -> Result<(), AdapterError> {

        let request_uri = format!("{}/orgs/{}/codespaces/access", super::GITHUB_BASE_API_URL, org);


        let req = GitHubRequest {
            uri: request_uri,
            body: Some(C::from_json::<PutCodespacesSetCodespacesAccess>(body)?),
            method: "PUT",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch(request)?;

        // --

        if github_response.is_success() {
            Ok(github_response.to_json()?)
        } else {
            match github_response.status_code() {
                304 => Err(CodespacesSetCodespacesAccessError::Status304.into()),
                400 => Err(CodespacesSetCodespacesAccessError::Status400.into()),
                404 => Err(CodespacesSetCodespacesAccessError::Status404(github_response.to_json()?).into()),
                422 => Err(CodespacesSetCodespacesAccessError::Status422(github_response.to_json()?).into()),
                500 => Err(CodespacesSetCodespacesAccessError::Status500(github_response.to_json()?).into()),
                code => Err(CodespacesSetCodespacesAccessError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # Add users to Codespaces access for an organization
    ///
    /// Codespaces for the specified users will be billed to the organization.
    /// 
    /// To use this endpoint, the access settings for the organization must be set to `selected_members`.
    /// For information on how to change this setting, see "[Manage access control for organization codespaces](https://docs.github.com/rest/codespaces/organizations#manage-access-control-for-organization-codespaces)."
    /// 
    /// OAuth app tokens and personal access tokens (classic) need the `admin:org` scope to use this endpoint.
    ///
    /// [GitHub API docs for set_codespaces_access_users](https://docs.github.com/rest/codespaces/organizations#add-users-to-codespaces-access-for-an-organization)
    ///
    /// ---
    pub async fn set_codespaces_access_users_async(&self, org: &str, body: PostCodespacesSetCodespacesAccessUsers) -> Result<(), AdapterError> {

        let request_uri = format!("{}/orgs/{}/codespaces/access/selected_users", super::GITHUB_BASE_API_URL, org);


        let req = GitHubRequest {
            uri: request_uri,
            body: Some(C::from_json::<PostCodespacesSetCodespacesAccessUsers>(body)?),
            method: "POST",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch_async(request).await?;

        // --

        if github_response.is_success() {
            Ok(github_response.to_json_async().await?)
        } else {
            match github_response.status_code() {
                304 => Err(CodespacesSetCodespacesAccessUsersError::Status304.into()),
                400 => Err(CodespacesSetCodespacesAccessUsersError::Status400.into()),
                404 => Err(CodespacesSetCodespacesAccessUsersError::Status404(github_response.to_json_async().await?).into()),
                422 => Err(CodespacesSetCodespacesAccessUsersError::Status422(github_response.to_json_async().await?).into()),
                500 => Err(CodespacesSetCodespacesAccessUsersError::Status500(github_response.to_json_async().await?).into()),
                code => Err(CodespacesSetCodespacesAccessUsersError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # Add users to Codespaces access for an organization
    ///
    /// Codespaces for the specified users will be billed to the organization.
    /// 
    /// To use this endpoint, the access settings for the organization must be set to `selected_members`.
    /// For information on how to change this setting, see "[Manage access control for organization codespaces](https://docs.github.com/rest/codespaces/organizations#manage-access-control-for-organization-codespaces)."
    /// 
    /// OAuth app tokens and personal access tokens (classic) need the `admin:org` scope to use this endpoint.
    ///
    /// [GitHub API docs for set_codespaces_access_users](https://docs.github.com/rest/codespaces/organizations#add-users-to-codespaces-access-for-an-organization)
    ///
    /// ---
    #[cfg(not(target_arch = "wasm32"))]
    pub fn set_codespaces_access_users(&self, org: &str, body: PostCodespacesSetCodespacesAccessUsers) -> Result<(), AdapterError> {

        let request_uri = format!("{}/orgs/{}/codespaces/access/selected_users", super::GITHUB_BASE_API_URL, org);


        let req = GitHubRequest {
            uri: request_uri,
            body: Some(C::from_json::<PostCodespacesSetCodespacesAccessUsers>(body)?),
            method: "POST",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch(request)?;

        // --

        if github_response.is_success() {
            Ok(github_response.to_json()?)
        } else {
            match github_response.status_code() {
                304 => Err(CodespacesSetCodespacesAccessUsersError::Status304.into()),
                400 => Err(CodespacesSetCodespacesAccessUsersError::Status400.into()),
                404 => Err(CodespacesSetCodespacesAccessUsersError::Status404(github_response.to_json()?).into()),
                422 => Err(CodespacesSetCodespacesAccessUsersError::Status422(github_response.to_json()?).into()),
                500 => Err(CodespacesSetCodespacesAccessUsersError::Status500(github_response.to_json()?).into()),
                code => Err(CodespacesSetCodespacesAccessUsersError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # Set selected repositories for a user secret
    ///
    /// Select the repositories that will use a user's development environment secret.
    /// 
    /// The authenticated user must have Codespaces access to use this endpoint.
    /// 
    /// OAuth app tokens and personal access tokens (classic) need the `codespace` or `codespace:secrets` scope to use this endpoint.
    ///
    /// [GitHub API docs for set_repositories_for_secret_for_authenticated_user](https://docs.github.com/rest/codespaces/secrets#set-selected-repositories-for-a-user-secret)
    ///
    /// ---
    pub async fn set_repositories_for_secret_for_authenticated_user_async(&self, secret_name: &str, body: PutCodespacesSetRepositoriesForSecretForAuthenticatedUser) -> Result<(), AdapterError> {

        let request_uri = format!("{}/user/codespaces/secrets/{}/repositories", super::GITHUB_BASE_API_URL, secret_name);


        let req = GitHubRequest {
            uri: request_uri,
            body: Some(C::from_json::<PutCodespacesSetRepositoriesForSecretForAuthenticatedUser>(body)?),
            method: "PUT",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch_async(request).await?;

        // --

        if github_response.is_success() {
            Ok(github_response.to_json_async().await?)
        } else {
            match github_response.status_code() {
                401 => Err(CodespacesSetRepositoriesForSecretForAuthenticatedUserError::Status401(github_response.to_json_async().await?).into()),
                403 => Err(CodespacesSetRepositoriesForSecretForAuthenticatedUserError::Status403(github_response.to_json_async().await?).into()),
                404 => Err(CodespacesSetRepositoriesForSecretForAuthenticatedUserError::Status404(github_response.to_json_async().await?).into()),
                500 => Err(CodespacesSetRepositoriesForSecretForAuthenticatedUserError::Status500(github_response.to_json_async().await?).into()),
                code => Err(CodespacesSetRepositoriesForSecretForAuthenticatedUserError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # Set selected repositories for a user secret
    ///
    /// Select the repositories that will use a user's development environment secret.
    /// 
    /// The authenticated user must have Codespaces access to use this endpoint.
    /// 
    /// OAuth app tokens and personal access tokens (classic) need the `codespace` or `codespace:secrets` scope to use this endpoint.
    ///
    /// [GitHub API docs for set_repositories_for_secret_for_authenticated_user](https://docs.github.com/rest/codespaces/secrets#set-selected-repositories-for-a-user-secret)
    ///
    /// ---
    #[cfg(not(target_arch = "wasm32"))]
    pub fn set_repositories_for_secret_for_authenticated_user(&self, secret_name: &str, body: PutCodespacesSetRepositoriesForSecretForAuthenticatedUser) -> Result<(), AdapterError> {

        let request_uri = format!("{}/user/codespaces/secrets/{}/repositories", super::GITHUB_BASE_API_URL, secret_name);


        let req = GitHubRequest {
            uri: request_uri,
            body: Some(C::from_json::<PutCodespacesSetRepositoriesForSecretForAuthenticatedUser>(body)?),
            method: "PUT",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch(request)?;

        // --

        if github_response.is_success() {
            Ok(github_response.to_json()?)
        } else {
            match github_response.status_code() {
                401 => Err(CodespacesSetRepositoriesForSecretForAuthenticatedUserError::Status401(github_response.to_json()?).into()),
                403 => Err(CodespacesSetRepositoriesForSecretForAuthenticatedUserError::Status403(github_response.to_json()?).into()),
                404 => Err(CodespacesSetRepositoriesForSecretForAuthenticatedUserError::Status404(github_response.to_json()?).into()),
                500 => Err(CodespacesSetRepositoriesForSecretForAuthenticatedUserError::Status500(github_response.to_json()?).into()),
                code => Err(CodespacesSetRepositoriesForSecretForAuthenticatedUserError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # Set selected repositories for an organization secret
    ///
    /// Replaces all repositories for an organization development environment secret when the `visibility`
    /// for repository access is set to `selected`. The visibility is set when you [Create
    /// or update an organization secret](https://docs.github.com/rest/codespaces/organization-secrets#create-or-update-an-organization-secret).
    /// 
    /// OAuth app tokens and personal access tokens (classic) need the `admin:org` scope to use this endpoint.
    ///
    /// [GitHub API docs for set_selected_repos_for_org_secret](https://docs.github.com/rest/codespaces/organization-secrets#set-selected-repositories-for-an-organization-secret)
    ///
    /// ---
    pub async fn set_selected_repos_for_org_secret_async(&self, org: &str, secret_name: &str, body: PutCodespacesSetSelectedReposForOrgSecret) -> Result<(), AdapterError> {

        let request_uri = format!("{}/orgs/{}/codespaces/secrets/{}/repositories", super::GITHUB_BASE_API_URL, org, secret_name);


        let req = GitHubRequest {
            uri: request_uri,
            body: Some(C::from_json::<PutCodespacesSetSelectedReposForOrgSecret>(body)?),
            method: "PUT",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch_async(request).await?;

        // --

        if github_response.is_success() {
            Ok(github_response.to_json_async().await?)
        } else {
            match github_response.status_code() {
                404 => Err(CodespacesSetSelectedReposForOrgSecretError::Status404(github_response.to_json_async().await?).into()),
                409 => Err(CodespacesSetSelectedReposForOrgSecretError::Status409.into()),
                code => Err(CodespacesSetSelectedReposForOrgSecretError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # Set selected repositories for an organization secret
    ///
    /// Replaces all repositories for an organization development environment secret when the `visibility`
    /// for repository access is set to `selected`. The visibility is set when you [Create
    /// or update an organization secret](https://docs.github.com/rest/codespaces/organization-secrets#create-or-update-an-organization-secret).
    /// 
    /// OAuth app tokens and personal access tokens (classic) need the `admin:org` scope to use this endpoint.
    ///
    /// [GitHub API docs for set_selected_repos_for_org_secret](https://docs.github.com/rest/codespaces/organization-secrets#set-selected-repositories-for-an-organization-secret)
    ///
    /// ---
    #[cfg(not(target_arch = "wasm32"))]
    pub fn set_selected_repos_for_org_secret(&self, org: &str, secret_name: &str, body: PutCodespacesSetSelectedReposForOrgSecret) -> Result<(), AdapterError> {

        let request_uri = format!("{}/orgs/{}/codespaces/secrets/{}/repositories", super::GITHUB_BASE_API_URL, org, secret_name);


        let req = GitHubRequest {
            uri: request_uri,
            body: Some(C::from_json::<PutCodespacesSetSelectedReposForOrgSecret>(body)?),
            method: "PUT",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch(request)?;

        // --

        if github_response.is_success() {
            Ok(github_response.to_json()?)
        } else {
            match github_response.status_code() {
                404 => Err(CodespacesSetSelectedReposForOrgSecretError::Status404(github_response.to_json()?).into()),
                409 => Err(CodespacesSetSelectedReposForOrgSecretError::Status409.into()),
                code => Err(CodespacesSetSelectedReposForOrgSecretError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # Start a codespace for the authenticated user
    ///
    /// Starts a user's codespace.
    /// 
    /// OAuth app tokens and personal access tokens (classic) need the `codespace` scope to use this endpoint.
    ///
    /// [GitHub API docs for start_for_authenticated_user](https://docs.github.com/rest/codespaces/codespaces#start-a-codespace-for-the-authenticated-user)
    ///
    /// ---
    pub async fn start_for_authenticated_user_async(&self, codespace_name: &str) -> Result<Codespace, AdapterError> {

        let request_uri = format!("{}/user/codespaces/{}/start", super::GITHUB_BASE_API_URL, codespace_name);


        let req = GitHubRequest {
            uri: request_uri,
            body: None::<C::Body>,
            method: "POST",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch_async(request).await?;

        // --

        if github_response.is_success() {
            Ok(github_response.to_json_async().await?)
        } else {
            match github_response.status_code() {
                304 => Err(CodespacesStartForAuthenticatedUserError::Status304.into()),
                500 => Err(CodespacesStartForAuthenticatedUserError::Status500(github_response.to_json_async().await?).into()),
                400 => Err(CodespacesStartForAuthenticatedUserError::Status400(github_response.to_json_async().await?).into()),
                401 => Err(CodespacesStartForAuthenticatedUserError::Status401(github_response.to_json_async().await?).into()),
                402 => Err(CodespacesStartForAuthenticatedUserError::Status402(github_response.to_json_async().await?).into()),
                403 => Err(CodespacesStartForAuthenticatedUserError::Status403(github_response.to_json_async().await?).into()),
                404 => Err(CodespacesStartForAuthenticatedUserError::Status404(github_response.to_json_async().await?).into()),
                409 => Err(CodespacesStartForAuthenticatedUserError::Status409(github_response.to_json_async().await?).into()),
                code => Err(CodespacesStartForAuthenticatedUserError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # Start a codespace for the authenticated user
    ///
    /// Starts a user's codespace.
    /// 
    /// OAuth app tokens and personal access tokens (classic) need the `codespace` scope to use this endpoint.
    ///
    /// [GitHub API docs for start_for_authenticated_user](https://docs.github.com/rest/codespaces/codespaces#start-a-codespace-for-the-authenticated-user)
    ///
    /// ---
    #[cfg(not(target_arch = "wasm32"))]
    pub fn start_for_authenticated_user(&self, codespace_name: &str) -> Result<Codespace, AdapterError> {

        let request_uri = format!("{}/user/codespaces/{}/start", super::GITHUB_BASE_API_URL, codespace_name);


        let req = GitHubRequest {
            uri: request_uri,
            body: None,
            method: "POST",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch(request)?;

        // --

        if github_response.is_success() {
            Ok(github_response.to_json()?)
        } else {
            match github_response.status_code() {
                304 => Err(CodespacesStartForAuthenticatedUserError::Status304.into()),
                500 => Err(CodespacesStartForAuthenticatedUserError::Status500(github_response.to_json()?).into()),
                400 => Err(CodespacesStartForAuthenticatedUserError::Status400(github_response.to_json()?).into()),
                401 => Err(CodespacesStartForAuthenticatedUserError::Status401(github_response.to_json()?).into()),
                402 => Err(CodespacesStartForAuthenticatedUserError::Status402(github_response.to_json()?).into()),
                403 => Err(CodespacesStartForAuthenticatedUserError::Status403(github_response.to_json()?).into()),
                404 => Err(CodespacesStartForAuthenticatedUserError::Status404(github_response.to_json()?).into()),
                409 => Err(CodespacesStartForAuthenticatedUserError::Status409(github_response.to_json()?).into()),
                code => Err(CodespacesStartForAuthenticatedUserError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # Stop a codespace for the authenticated user
    ///
    /// Stops a user's codespace.
    /// 
    /// OAuth app tokens and personal access tokens (classic) need the `codespace` scope to use this endpoint.
    ///
    /// [GitHub API docs for stop_for_authenticated_user](https://docs.github.com/rest/codespaces/codespaces#stop-a-codespace-for-the-authenticated-user)
    ///
    /// ---
    pub async fn stop_for_authenticated_user_async(&self, codespace_name: &str) -> Result<Codespace, AdapterError> {

        let request_uri = format!("{}/user/codespaces/{}/stop", super::GITHUB_BASE_API_URL, codespace_name);


        let req = GitHubRequest {
            uri: request_uri,
            body: None::<C::Body>,
            method: "POST",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch_async(request).await?;

        // --

        if github_response.is_success() {
            Ok(github_response.to_json_async().await?)
        } else {
            match github_response.status_code() {
                500 => Err(CodespacesStopForAuthenticatedUserError::Status500(github_response.to_json_async().await?).into()),
                401 => Err(CodespacesStopForAuthenticatedUserError::Status401(github_response.to_json_async().await?).into()),
                403 => Err(CodespacesStopForAuthenticatedUserError::Status403(github_response.to_json_async().await?).into()),
                404 => Err(CodespacesStopForAuthenticatedUserError::Status404(github_response.to_json_async().await?).into()),
                code => Err(CodespacesStopForAuthenticatedUserError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # Stop a codespace for the authenticated user
    ///
    /// Stops a user's codespace.
    /// 
    /// OAuth app tokens and personal access tokens (classic) need the `codespace` scope to use this endpoint.
    ///
    /// [GitHub API docs for stop_for_authenticated_user](https://docs.github.com/rest/codespaces/codespaces#stop-a-codespace-for-the-authenticated-user)
    ///
    /// ---
    #[cfg(not(target_arch = "wasm32"))]
    pub fn stop_for_authenticated_user(&self, codespace_name: &str) -> Result<Codespace, AdapterError> {

        let request_uri = format!("{}/user/codespaces/{}/stop", super::GITHUB_BASE_API_URL, codespace_name);


        let req = GitHubRequest {
            uri: request_uri,
            body: None,
            method: "POST",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch(request)?;

        // --

        if github_response.is_success() {
            Ok(github_response.to_json()?)
        } else {
            match github_response.status_code() {
                500 => Err(CodespacesStopForAuthenticatedUserError::Status500(github_response.to_json()?).into()),
                401 => Err(CodespacesStopForAuthenticatedUserError::Status401(github_response.to_json()?).into()),
                403 => Err(CodespacesStopForAuthenticatedUserError::Status403(github_response.to_json()?).into()),
                404 => Err(CodespacesStopForAuthenticatedUserError::Status404(github_response.to_json()?).into()),
                code => Err(CodespacesStopForAuthenticatedUserError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # Stop a codespace for an organization user
    ///
    /// Stops a user's codespace.
    /// 
    /// OAuth app tokens and personal access tokens (classic) need the `admin:org` scope to use this endpoint.
    ///
    /// [GitHub API docs for stop_in_organization](https://docs.github.com/rest/codespaces/organizations#stop-a-codespace-for-an-organization-user)
    ///
    /// ---
    pub async fn stop_in_organization_async(&self, org: &str, username: &str, codespace_name: &str) -> Result<Codespace, AdapterError> {

        let request_uri = format!("{}/orgs/{}/members/{}/codespaces/{}/stop", super::GITHUB_BASE_API_URL, org, username, codespace_name);


        let req = GitHubRequest {
            uri: request_uri,
            body: None::<C::Body>,
            method: "POST",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch_async(request).await?;

        // --

        if github_response.is_success() {
            Ok(github_response.to_json_async().await?)
        } else {
            match github_response.status_code() {
                304 => Err(CodespacesStopInOrganizationError::Status304.into()),
                500 => Err(CodespacesStopInOrganizationError::Status500(github_response.to_json_async().await?).into()),
                401 => Err(CodespacesStopInOrganizationError::Status401(github_response.to_json_async().await?).into()),
                403 => Err(CodespacesStopInOrganizationError::Status403(github_response.to_json_async().await?).into()),
                404 => Err(CodespacesStopInOrganizationError::Status404(github_response.to_json_async().await?).into()),
                code => Err(CodespacesStopInOrganizationError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # Stop a codespace for an organization user
    ///
    /// Stops a user's codespace.
    /// 
    /// OAuth app tokens and personal access tokens (classic) need the `admin:org` scope to use this endpoint.
    ///
    /// [GitHub API docs for stop_in_organization](https://docs.github.com/rest/codespaces/organizations#stop-a-codespace-for-an-organization-user)
    ///
    /// ---
    #[cfg(not(target_arch = "wasm32"))]
    pub fn stop_in_organization(&self, org: &str, username: &str, codespace_name: &str) -> Result<Codespace, AdapterError> {

        let request_uri = format!("{}/orgs/{}/members/{}/codespaces/{}/stop", super::GITHUB_BASE_API_URL, org, username, codespace_name);


        let req = GitHubRequest {
            uri: request_uri,
            body: None,
            method: "POST",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch(request)?;

        // --

        if github_response.is_success() {
            Ok(github_response.to_json()?)
        } else {
            match github_response.status_code() {
                304 => Err(CodespacesStopInOrganizationError::Status304.into()),
                500 => Err(CodespacesStopInOrganizationError::Status500(github_response.to_json()?).into()),
                401 => Err(CodespacesStopInOrganizationError::Status401(github_response.to_json()?).into()),
                403 => Err(CodespacesStopInOrganizationError::Status403(github_response.to_json()?).into()),
                404 => Err(CodespacesStopInOrganizationError::Status404(github_response.to_json()?).into()),
                code => Err(CodespacesStopInOrganizationError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # Update a codespace for the authenticated user
    ///
    /// Updates a codespace owned by the authenticated user. Currently only the codespace's machine type and recent folders can be modified using this endpoint.
    /// 
    /// If you specify a new machine type it will be applied the next time your codespace is started.
    /// 
    /// OAuth app tokens and personal access tokens (classic) need the `codespace` scope to use this endpoint.
    ///
    /// [GitHub API docs for update_for_authenticated_user](https://docs.github.com/rest/codespaces/codespaces#update-a-codespace-for-the-authenticated-user)
    ///
    /// ---
    pub async fn update_for_authenticated_user_async(&self, codespace_name: &str, body: PatchCodespacesUpdateForAuthenticatedUser) -> Result<Codespace, AdapterError> {

        let request_uri = format!("{}/user/codespaces/{}", super::GITHUB_BASE_API_URL, codespace_name);


        let req = GitHubRequest {
            uri: request_uri,
            body: Some(C::from_json::<PatchCodespacesUpdateForAuthenticatedUser>(body)?),
            method: "PATCH",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch_async(request).await?;

        // --

        if github_response.is_success() {
            Ok(github_response.to_json_async().await?)
        } else {
            match github_response.status_code() {
                401 => Err(CodespacesUpdateForAuthenticatedUserError::Status401(github_response.to_json_async().await?).into()),
                403 => Err(CodespacesUpdateForAuthenticatedUserError::Status403(github_response.to_json_async().await?).into()),
                404 => Err(CodespacesUpdateForAuthenticatedUserError::Status404(github_response.to_json_async().await?).into()),
                code => Err(CodespacesUpdateForAuthenticatedUserError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # Update a codespace for the authenticated user
    ///
    /// Updates a codespace owned by the authenticated user. Currently only the codespace's machine type and recent folders can be modified using this endpoint.
    /// 
    /// If you specify a new machine type it will be applied the next time your codespace is started.
    /// 
    /// OAuth app tokens and personal access tokens (classic) need the `codespace` scope to use this endpoint.
    ///
    /// [GitHub API docs for update_for_authenticated_user](https://docs.github.com/rest/codespaces/codespaces#update-a-codespace-for-the-authenticated-user)
    ///
    /// ---
    #[cfg(not(target_arch = "wasm32"))]
    pub fn update_for_authenticated_user(&self, codespace_name: &str, body: PatchCodespacesUpdateForAuthenticatedUser) -> Result<Codespace, AdapterError> {

        let request_uri = format!("{}/user/codespaces/{}", super::GITHUB_BASE_API_URL, codespace_name);


        let req = GitHubRequest {
            uri: request_uri,
            body: Some(C::from_json::<PatchCodespacesUpdateForAuthenticatedUser>(body)?),
            method: "PATCH",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch(request)?;

        // --

        if github_response.is_success() {
            Ok(github_response.to_json()?)
        } else {
            match github_response.status_code() {
                401 => Err(CodespacesUpdateForAuthenticatedUserError::Status401(github_response.to_json()?).into()),
                403 => Err(CodespacesUpdateForAuthenticatedUserError::Status403(github_response.to_json()?).into()),
                404 => Err(CodespacesUpdateForAuthenticatedUserError::Status404(github_response.to_json()?).into()),
                code => Err(CodespacesUpdateForAuthenticatedUserError::Generic { code }.into()),
            }
        }
    }

}
