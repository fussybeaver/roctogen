//! Method, error and parameter types for the Activity endpoint.
#![allow(
    clippy::all
)]
/* 
 * GitHub v3 REST API
 *
 * GitHub's v3 REST API.
 *
 * OpenAPI spec version: 1.1.4
 * 
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 */

use serde::Deserialize;

use crate::adapters::{AdapterError, Client, GitHubRequest, GitHubResponseExt};
use crate::models::*;

use super::PerPage;

use std::collections::HashMap;
use serde_json::value::Value;

pub struct Activity<'api, C: Client> where AdapterError: From<<C as Client>::Err> {
    client: &'api C
}

pub fn new<C: Client>(client: &C) -> Activity<C> where AdapterError: From<<C as Client>::Err> {
    Activity { client }
}

/// Errors for the [Check if a repository is starred by the authenticated user](Activity::check_repo_is_starred_by_authenticated_user_async()) endpoint.
#[derive(Debug, thiserror::Error)]
pub enum ActivityCheckRepoIsStarredByAuthenticatedUserError {
    #[error("Not Found if this repository is not starred by you")]
    Status404(BasicError),
    #[error("Requires authentication")]
    Status401(BasicError),
    #[error("Not modified")]
    Status304,
    #[error("Forbidden")]
    Status403(BasicError),
    #[error("Status code: {}", code)]
    Generic { code: u16 },
}

impl From<ActivityCheckRepoIsStarredByAuthenticatedUserError> for AdapterError {
    fn from(err: ActivityCheckRepoIsStarredByAuthenticatedUserError) -> Self {
        let (description, status_code) = match err {
            ActivityCheckRepoIsStarredByAuthenticatedUserError::Status404(_) => (String::from("Not Found if this repository is not starred by you"), 404),
            ActivityCheckRepoIsStarredByAuthenticatedUserError::Status401(_) => (String::from("Requires authentication"), 401),
            ActivityCheckRepoIsStarredByAuthenticatedUserError::Status304 => (String::from("Not modified"), 304),
            ActivityCheckRepoIsStarredByAuthenticatedUserError::Status403(_) => (String::from("Forbidden"), 403),
            ActivityCheckRepoIsStarredByAuthenticatedUserError::Generic { code } => (String::from("Generic"), code)
        };

        Self::Endpoint {
            description,
            status_code,
            source: Some(Box::new(err))
        }
    }
}

/// Errors for the [Delete a repository subscription](Activity::delete_repo_subscription_async()) endpoint.
#[derive(Debug, thiserror::Error)]
pub enum ActivityDeleteRepoSubscriptionError {
    #[error("Status code: {}", code)]
    Generic { code: u16 },
}

impl From<ActivityDeleteRepoSubscriptionError> for AdapterError {
    fn from(err: ActivityDeleteRepoSubscriptionError) -> Self {
        let (description, status_code) = match err {
            ActivityDeleteRepoSubscriptionError::Generic { code } => (String::from("Generic"), code)
        };

        Self::Endpoint {
            description,
            status_code,
            source: Some(Box::new(err))
        }
    }
}

/// Errors for the [Delete a thread subscription](Activity::delete_thread_subscription_async()) endpoint.
#[derive(Debug, thiserror::Error)]
pub enum ActivityDeleteThreadSubscriptionError {
    #[error("Not modified")]
    Status304,
    #[error("Forbidden")]
    Status403(BasicError),
    #[error("Requires authentication")]
    Status401(BasicError),
    #[error("Status code: {}", code)]
    Generic { code: u16 },
}

impl From<ActivityDeleteThreadSubscriptionError> for AdapterError {
    fn from(err: ActivityDeleteThreadSubscriptionError) -> Self {
        let (description, status_code) = match err {
            ActivityDeleteThreadSubscriptionError::Status304 => (String::from("Not modified"), 304),
            ActivityDeleteThreadSubscriptionError::Status403(_) => (String::from("Forbidden"), 403),
            ActivityDeleteThreadSubscriptionError::Status401(_) => (String::from("Requires authentication"), 401),
            ActivityDeleteThreadSubscriptionError::Generic { code } => (String::from("Generic"), code)
        };

        Self::Endpoint {
            description,
            status_code,
            source: Some(Box::new(err))
        }
    }
}

/// Errors for the [Get feeds](Activity::get_feeds_async()) endpoint.
#[derive(Debug, thiserror::Error)]
pub enum ActivityGetFeedsError {
    #[error("Status code: {}", code)]
    Generic { code: u16 },
}

impl From<ActivityGetFeedsError> for AdapterError {
    fn from(err: ActivityGetFeedsError) -> Self {
        let (description, status_code) = match err {
            ActivityGetFeedsError::Generic { code } => (String::from("Generic"), code)
        };

        Self::Endpoint {
            description,
            status_code,
            source: Some(Box::new(err))
        }
    }
}

/// Errors for the [Get a repository subscription](Activity::get_repo_subscription_async()) endpoint.
#[derive(Debug, thiserror::Error)]
pub enum ActivityGetRepoSubscriptionError {
    #[error("Not Found if you don't subscribe to the repository")]
    Status404,
    #[error("Forbidden")]
    Status403(BasicError),
    #[error("Status code: {}", code)]
    Generic { code: u16 },
}

impl From<ActivityGetRepoSubscriptionError> for AdapterError {
    fn from(err: ActivityGetRepoSubscriptionError) -> Self {
        let (description, status_code) = match err {
            ActivityGetRepoSubscriptionError::Status404 => (String::from("Not Found if you don't subscribe to the repository"), 404),
            ActivityGetRepoSubscriptionError::Status403(_) => (String::from("Forbidden"), 403),
            ActivityGetRepoSubscriptionError::Generic { code } => (String::from("Generic"), code)
        };

        Self::Endpoint {
            description,
            status_code,
            source: Some(Box::new(err))
        }
    }
}

/// Errors for the [Get a thread](Activity::get_thread_async()) endpoint.
#[derive(Debug, thiserror::Error)]
pub enum ActivityGetThreadError {
    #[error("Not modified")]
    Status304,
    #[error("Forbidden")]
    Status403(BasicError),
    #[error("Requires authentication")]
    Status401(BasicError),
    #[error("Status code: {}", code)]
    Generic { code: u16 },
}

impl From<ActivityGetThreadError> for AdapterError {
    fn from(err: ActivityGetThreadError) -> Self {
        let (description, status_code) = match err {
            ActivityGetThreadError::Status304 => (String::from("Not modified"), 304),
            ActivityGetThreadError::Status403(_) => (String::from("Forbidden"), 403),
            ActivityGetThreadError::Status401(_) => (String::from("Requires authentication"), 401),
            ActivityGetThreadError::Generic { code } => (String::from("Generic"), code)
        };

        Self::Endpoint {
            description,
            status_code,
            source: Some(Box::new(err))
        }
    }
}

/// Errors for the [Get a thread subscription for the authenticated user](Activity::get_thread_subscription_for_authenticated_user_async()) endpoint.
#[derive(Debug, thiserror::Error)]
pub enum ActivityGetThreadSubscriptionForAuthenticatedUserError {
    #[error("Not modified")]
    Status304,
    #[error("Forbidden")]
    Status403(BasicError),
    #[error("Requires authentication")]
    Status401(BasicError),
    #[error("Status code: {}", code)]
    Generic { code: u16 },
}

impl From<ActivityGetThreadSubscriptionForAuthenticatedUserError> for AdapterError {
    fn from(err: ActivityGetThreadSubscriptionForAuthenticatedUserError) -> Self {
        let (description, status_code) = match err {
            ActivityGetThreadSubscriptionForAuthenticatedUserError::Status304 => (String::from("Not modified"), 304),
            ActivityGetThreadSubscriptionForAuthenticatedUserError::Status403(_) => (String::from("Forbidden"), 403),
            ActivityGetThreadSubscriptionForAuthenticatedUserError::Status401(_) => (String::from("Requires authentication"), 401),
            ActivityGetThreadSubscriptionForAuthenticatedUserError::Generic { code } => (String::from("Generic"), code)
        };

        Self::Endpoint {
            description,
            status_code,
            source: Some(Box::new(err))
        }
    }
}

/// Errors for the [List events for the authenticated user](Activity::list_events_for_authenticated_user_async()) endpoint.
#[derive(Debug, thiserror::Error)]
pub enum ActivityListEventsForAuthenticatedUserError {
    #[error("Status code: {}", code)]
    Generic { code: u16 },
}

impl From<ActivityListEventsForAuthenticatedUserError> for AdapterError {
    fn from(err: ActivityListEventsForAuthenticatedUserError) -> Self {
        let (description, status_code) = match err {
            ActivityListEventsForAuthenticatedUserError::Generic { code } => (String::from("Generic"), code)
        };

        Self::Endpoint {
            description,
            status_code,
            source: Some(Box::new(err))
        }
    }
}

/// Errors for the [List notifications for the authenticated user](Activity::list_notifications_for_authenticated_user_async()) endpoint.
#[derive(Debug, thiserror::Error)]
pub enum ActivityListNotificationsForAuthenticatedUserError {
    #[error("Not modified")]
    Status304,
    #[error("Forbidden")]
    Status403(BasicError),
    #[error("Requires authentication")]
    Status401(BasicError),
    #[error("Validation failed, or the endpoint has been spammed.")]
    Status422(ValidationError),
    #[error("Status code: {}", code)]
    Generic { code: u16 },
}

impl From<ActivityListNotificationsForAuthenticatedUserError> for AdapterError {
    fn from(err: ActivityListNotificationsForAuthenticatedUserError) -> Self {
        let (description, status_code) = match err {
            ActivityListNotificationsForAuthenticatedUserError::Status304 => (String::from("Not modified"), 304),
            ActivityListNotificationsForAuthenticatedUserError::Status403(_) => (String::from("Forbidden"), 403),
            ActivityListNotificationsForAuthenticatedUserError::Status401(_) => (String::from("Requires authentication"), 401),
            ActivityListNotificationsForAuthenticatedUserError::Status422(_) => (String::from("Validation failed, or the endpoint has been spammed."), 422),
            ActivityListNotificationsForAuthenticatedUserError::Generic { code } => (String::from("Generic"), code)
        };

        Self::Endpoint {
            description,
            status_code,
            source: Some(Box::new(err))
        }
    }
}

/// Errors for the [List organization events for the authenticated user](Activity::list_org_events_for_authenticated_user_async()) endpoint.
#[derive(Debug, thiserror::Error)]
pub enum ActivityListOrgEventsForAuthenticatedUserError {
    #[error("Status code: {}", code)]
    Generic { code: u16 },
}

impl From<ActivityListOrgEventsForAuthenticatedUserError> for AdapterError {
    fn from(err: ActivityListOrgEventsForAuthenticatedUserError) -> Self {
        let (description, status_code) = match err {
            ActivityListOrgEventsForAuthenticatedUserError::Generic { code } => (String::from("Generic"), code)
        };

        Self::Endpoint {
            description,
            status_code,
            source: Some(Box::new(err))
        }
    }
}

/// Errors for the [List public events](Activity::list_public_events_async()) endpoint.
#[derive(Debug, thiserror::Error)]
pub enum ActivityListPublicEventsError {
    #[error("Not modified")]
    Status304,
    #[error("Forbidden")]
    Status403(BasicError),
    #[error("Service unavailable")]
    Status503(PostCodespacesCreateForAuthenticatedUserResponse503),
    #[error("Status code: {}", code)]
    Generic { code: u16 },
}

impl From<ActivityListPublicEventsError> for AdapterError {
    fn from(err: ActivityListPublicEventsError) -> Self {
        let (description, status_code) = match err {
            ActivityListPublicEventsError::Status304 => (String::from("Not modified"), 304),
            ActivityListPublicEventsError::Status403(_) => (String::from("Forbidden"), 403),
            ActivityListPublicEventsError::Status503(_) => (String::from("Service unavailable"), 503),
            ActivityListPublicEventsError::Generic { code } => (String::from("Generic"), code)
        };

        Self::Endpoint {
            description,
            status_code,
            source: Some(Box::new(err))
        }
    }
}

/// Errors for the [List public events for a network of repositories](Activity::list_public_events_for_repo_network_async()) endpoint.
#[derive(Debug, thiserror::Error)]
pub enum ActivityListPublicEventsForRepoNetworkError {
    #[error("Resource not found")]
    Status404(BasicError),
    #[error("Forbidden")]
    Status403(BasicError),
    #[error("Not modified")]
    Status304,
    #[error("Moved permanently")]
    Status301(BasicError),
    #[error("Status code: {}", code)]
    Generic { code: u16 },
}

impl From<ActivityListPublicEventsForRepoNetworkError> for AdapterError {
    fn from(err: ActivityListPublicEventsForRepoNetworkError) -> Self {
        let (description, status_code) = match err {
            ActivityListPublicEventsForRepoNetworkError::Status404(_) => (String::from("Resource not found"), 404),
            ActivityListPublicEventsForRepoNetworkError::Status403(_) => (String::from("Forbidden"), 403),
            ActivityListPublicEventsForRepoNetworkError::Status304 => (String::from("Not modified"), 304),
            ActivityListPublicEventsForRepoNetworkError::Status301(_) => (String::from("Moved permanently"), 301),
            ActivityListPublicEventsForRepoNetworkError::Generic { code } => (String::from("Generic"), code)
        };

        Self::Endpoint {
            description,
            status_code,
            source: Some(Box::new(err))
        }
    }
}

/// Errors for the [List public events for a user](Activity::list_public_events_for_user_async()) endpoint.
#[derive(Debug, thiserror::Error)]
pub enum ActivityListPublicEventsForUserError {
    #[error("Status code: {}", code)]
    Generic { code: u16 },
}

impl From<ActivityListPublicEventsForUserError> for AdapterError {
    fn from(err: ActivityListPublicEventsForUserError) -> Self {
        let (description, status_code) = match err {
            ActivityListPublicEventsForUserError::Generic { code } => (String::from("Generic"), code)
        };

        Self::Endpoint {
            description,
            status_code,
            source: Some(Box::new(err))
        }
    }
}

/// Errors for the [List public organization events](Activity::list_public_org_events_async()) endpoint.
#[derive(Debug, thiserror::Error)]
pub enum ActivityListPublicOrgEventsError {
    #[error("Status code: {}", code)]
    Generic { code: u16 },
}

impl From<ActivityListPublicOrgEventsError> for AdapterError {
    fn from(err: ActivityListPublicOrgEventsError) -> Self {
        let (description, status_code) = match err {
            ActivityListPublicOrgEventsError::Generic { code } => (String::from("Generic"), code)
        };

        Self::Endpoint {
            description,
            status_code,
            source: Some(Box::new(err))
        }
    }
}

/// Errors for the [List events received by the authenticated user](Activity::list_received_events_for_user_async()) endpoint.
#[derive(Debug, thiserror::Error)]
pub enum ActivityListReceivedEventsForUserError {
    #[error("Status code: {}", code)]
    Generic { code: u16 },
}

impl From<ActivityListReceivedEventsForUserError> for AdapterError {
    fn from(err: ActivityListReceivedEventsForUserError) -> Self {
        let (description, status_code) = match err {
            ActivityListReceivedEventsForUserError::Generic { code } => (String::from("Generic"), code)
        };

        Self::Endpoint {
            description,
            status_code,
            source: Some(Box::new(err))
        }
    }
}

/// Errors for the [List public events received by a user](Activity::list_received_public_events_for_user_async()) endpoint.
#[derive(Debug, thiserror::Error)]
pub enum ActivityListReceivedPublicEventsForUserError {
    #[error("Status code: {}", code)]
    Generic { code: u16 },
}

impl From<ActivityListReceivedPublicEventsForUserError> for AdapterError {
    fn from(err: ActivityListReceivedPublicEventsForUserError) -> Self {
        let (description, status_code) = match err {
            ActivityListReceivedPublicEventsForUserError::Generic { code } => (String::from("Generic"), code)
        };

        Self::Endpoint {
            description,
            status_code,
            source: Some(Box::new(err))
        }
    }
}

/// Errors for the [List repository events](Activity::list_repo_events_async()) endpoint.
#[derive(Debug, thiserror::Error)]
pub enum ActivityListRepoEventsError {
    #[error("Status code: {}", code)]
    Generic { code: u16 },
}

impl From<ActivityListRepoEventsError> for AdapterError {
    fn from(err: ActivityListRepoEventsError) -> Self {
        let (description, status_code) = match err {
            ActivityListRepoEventsError::Generic { code } => (String::from("Generic"), code)
        };

        Self::Endpoint {
            description,
            status_code,
            source: Some(Box::new(err))
        }
    }
}

/// Errors for the [List repository notifications for the authenticated user](Activity::list_repo_notifications_for_authenticated_user_async()) endpoint.
#[derive(Debug, thiserror::Error)]
pub enum ActivityListRepoNotificationsForAuthenticatedUserError {
    #[error("Status code: {}", code)]
    Generic { code: u16 },
}

impl From<ActivityListRepoNotificationsForAuthenticatedUserError> for AdapterError {
    fn from(err: ActivityListRepoNotificationsForAuthenticatedUserError) -> Self {
        let (description, status_code) = match err {
            ActivityListRepoNotificationsForAuthenticatedUserError::Generic { code } => (String::from("Generic"), code)
        };

        Self::Endpoint {
            description,
            status_code,
            source: Some(Box::new(err))
        }
    }
}

/// Errors for the [List repositories starred by the authenticated user](Activity::list_repos_starred_by_authenticated_user_async()) endpoint.
#[derive(Debug, thiserror::Error)]
pub enum ActivityListReposStarredByAuthenticatedUserError {
    #[error("Not modified")]
    Status304,
    #[error("Forbidden")]
    Status403(BasicError),
    #[error("Requires authentication")]
    Status401(BasicError),
    #[error("Status code: {}", code)]
    Generic { code: u16 },
}

impl From<ActivityListReposStarredByAuthenticatedUserError> for AdapterError {
    fn from(err: ActivityListReposStarredByAuthenticatedUserError) -> Self {
        let (description, status_code) = match err {
            ActivityListReposStarredByAuthenticatedUserError::Status304 => (String::from("Not modified"), 304),
            ActivityListReposStarredByAuthenticatedUserError::Status403(_) => (String::from("Forbidden"), 403),
            ActivityListReposStarredByAuthenticatedUserError::Status401(_) => (String::from("Requires authentication"), 401),
            ActivityListReposStarredByAuthenticatedUserError::Generic { code } => (String::from("Generic"), code)
        };

        Self::Endpoint {
            description,
            status_code,
            source: Some(Box::new(err))
        }
    }
}

/// Errors for the [List repositories starred by a user](Activity::list_repos_starred_by_user_async()) endpoint.
#[derive(Debug, thiserror::Error)]
pub enum ActivityListReposStarredByUserError {
    #[error("Status code: {}", code)]
    Generic { code: u16 },
}

impl From<ActivityListReposStarredByUserError> for AdapterError {
    fn from(err: ActivityListReposStarredByUserError) -> Self {
        let (description, status_code) = match err {
            ActivityListReposStarredByUserError::Generic { code } => (String::from("Generic"), code)
        };

        Self::Endpoint {
            description,
            status_code,
            source: Some(Box::new(err))
        }
    }
}

/// Errors for the [List repositories watched by a user](Activity::list_repos_watched_by_user_async()) endpoint.
#[derive(Debug, thiserror::Error)]
pub enum ActivityListReposWatchedByUserError {
    #[error("Status code: {}", code)]
    Generic { code: u16 },
}

impl From<ActivityListReposWatchedByUserError> for AdapterError {
    fn from(err: ActivityListReposWatchedByUserError) -> Self {
        let (description, status_code) = match err {
            ActivityListReposWatchedByUserError::Generic { code } => (String::from("Generic"), code)
        };

        Self::Endpoint {
            description,
            status_code,
            source: Some(Box::new(err))
        }
    }
}

/// Errors for the [List stargazers](Activity::list_stargazers_for_repo_async()) endpoint.
#[derive(Debug, thiserror::Error)]
pub enum ActivityListStargazersForRepoError {
    #[error("Validation failed, or the endpoint has been spammed.")]
    Status422(ValidationError),
    #[error("Status code: {}", code)]
    Generic { code: u16 },
}

impl From<ActivityListStargazersForRepoError> for AdapterError {
    fn from(err: ActivityListStargazersForRepoError) -> Self {
        let (description, status_code) = match err {
            ActivityListStargazersForRepoError::Status422(_) => (String::from("Validation failed, or the endpoint has been spammed."), 422),
            ActivityListStargazersForRepoError::Generic { code } => (String::from("Generic"), code)
        };

        Self::Endpoint {
            description,
            status_code,
            source: Some(Box::new(err))
        }
    }
}

/// Errors for the [List repositories watched by the authenticated user](Activity::list_watched_repos_for_authenticated_user_async()) endpoint.
#[derive(Debug, thiserror::Error)]
pub enum ActivityListWatchedReposForAuthenticatedUserError {
    #[error("Not modified")]
    Status304,
    #[error("Forbidden")]
    Status403(BasicError),
    #[error("Requires authentication")]
    Status401(BasicError),
    #[error("Status code: {}", code)]
    Generic { code: u16 },
}

impl From<ActivityListWatchedReposForAuthenticatedUserError> for AdapterError {
    fn from(err: ActivityListWatchedReposForAuthenticatedUserError) -> Self {
        let (description, status_code) = match err {
            ActivityListWatchedReposForAuthenticatedUserError::Status304 => (String::from("Not modified"), 304),
            ActivityListWatchedReposForAuthenticatedUserError::Status403(_) => (String::from("Forbidden"), 403),
            ActivityListWatchedReposForAuthenticatedUserError::Status401(_) => (String::from("Requires authentication"), 401),
            ActivityListWatchedReposForAuthenticatedUserError::Generic { code } => (String::from("Generic"), code)
        };

        Self::Endpoint {
            description,
            status_code,
            source: Some(Box::new(err))
        }
    }
}

/// Errors for the [List watchers](Activity::list_watchers_for_repo_async()) endpoint.
#[derive(Debug, thiserror::Error)]
pub enum ActivityListWatchersForRepoError {
    #[error("Status code: {}", code)]
    Generic { code: u16 },
}

impl From<ActivityListWatchersForRepoError> for AdapterError {
    fn from(err: ActivityListWatchersForRepoError) -> Self {
        let (description, status_code) = match err {
            ActivityListWatchersForRepoError::Generic { code } => (String::from("Generic"), code)
        };

        Self::Endpoint {
            description,
            status_code,
            source: Some(Box::new(err))
        }
    }
}

/// Errors for the [Mark notifications as read](Activity::mark_notifications_as_read_async()) endpoint.
#[derive(Debug, thiserror::Error)]
pub enum ActivityMarkNotificationsAsReadError {
    #[error("Reset Content")]
    Status205,
    #[error("Not modified")]
    Status304,
    #[error("Forbidden")]
    Status403(BasicError),
    #[error("Requires authentication")]
    Status401(BasicError),
    #[error("Status code: {}", code)]
    Generic { code: u16 },
}

impl From<ActivityMarkNotificationsAsReadError> for AdapterError {
    fn from(err: ActivityMarkNotificationsAsReadError) -> Self {
        let (description, status_code) = match err {
            ActivityMarkNotificationsAsReadError::Status205 => (String::from("Reset Content"), 205),
            ActivityMarkNotificationsAsReadError::Status304 => (String::from("Not modified"), 304),
            ActivityMarkNotificationsAsReadError::Status403(_) => (String::from("Forbidden"), 403),
            ActivityMarkNotificationsAsReadError::Status401(_) => (String::from("Requires authentication"), 401),
            ActivityMarkNotificationsAsReadError::Generic { code } => (String::from("Generic"), code)
        };

        Self::Endpoint {
            description,
            status_code,
            source: Some(Box::new(err))
        }
    }
}

/// Errors for the [Mark repository notifications as read](Activity::mark_repo_notifications_as_read_async()) endpoint.
#[derive(Debug, thiserror::Error)]
pub enum ActivityMarkRepoNotificationsAsReadError {
    #[error("Reset Content")]
    Status205,
    #[error("Status code: {}", code)]
    Generic { code: u16 },
}

impl From<ActivityMarkRepoNotificationsAsReadError> for AdapterError {
    fn from(err: ActivityMarkRepoNotificationsAsReadError) -> Self {
        let (description, status_code) = match err {
            ActivityMarkRepoNotificationsAsReadError::Status205 => (String::from("Reset Content"), 205),
            ActivityMarkRepoNotificationsAsReadError::Generic { code } => (String::from("Generic"), code)
        };

        Self::Endpoint {
            description,
            status_code,
            source: Some(Box::new(err))
        }
    }
}

/// Errors for the [Mark a thread as done](Activity::mark_thread_as_done_async()) endpoint.
#[derive(Debug, thiserror::Error)]
pub enum ActivityMarkThreadAsDoneError {
    #[error("Status code: {}", code)]
    Generic { code: u16 },
}

impl From<ActivityMarkThreadAsDoneError> for AdapterError {
    fn from(err: ActivityMarkThreadAsDoneError) -> Self {
        let (description, status_code) = match err {
            ActivityMarkThreadAsDoneError::Generic { code } => (String::from("Generic"), code)
        };

        Self::Endpoint {
            description,
            status_code,
            source: Some(Box::new(err))
        }
    }
}

/// Errors for the [Mark a thread as read](Activity::mark_thread_as_read_async()) endpoint.
#[derive(Debug, thiserror::Error)]
pub enum ActivityMarkThreadAsReadError {
    #[error("Not modified")]
    Status304,
    #[error("Forbidden")]
    Status403(BasicError),
    #[error("Status code: {}", code)]
    Generic { code: u16 },
}

impl From<ActivityMarkThreadAsReadError> for AdapterError {
    fn from(err: ActivityMarkThreadAsReadError) -> Self {
        let (description, status_code) = match err {
            ActivityMarkThreadAsReadError::Status304 => (String::from("Not modified"), 304),
            ActivityMarkThreadAsReadError::Status403(_) => (String::from("Forbidden"), 403),
            ActivityMarkThreadAsReadError::Generic { code } => (String::from("Generic"), code)
        };

        Self::Endpoint {
            description,
            status_code,
            source: Some(Box::new(err))
        }
    }
}

/// Errors for the [Set a repository subscription](Activity::set_repo_subscription_async()) endpoint.
#[derive(Debug, thiserror::Error)]
pub enum ActivitySetRepoSubscriptionError {
    #[error("Status code: {}", code)]
    Generic { code: u16 },
}

impl From<ActivitySetRepoSubscriptionError> for AdapterError {
    fn from(err: ActivitySetRepoSubscriptionError) -> Self {
        let (description, status_code) = match err {
            ActivitySetRepoSubscriptionError::Generic { code } => (String::from("Generic"), code)
        };

        Self::Endpoint {
            description,
            status_code,
            source: Some(Box::new(err))
        }
    }
}

/// Errors for the [Set a thread subscription](Activity::set_thread_subscription_async()) endpoint.
#[derive(Debug, thiserror::Error)]
pub enum ActivitySetThreadSubscriptionError {
    #[error("Not modified")]
    Status304,
    #[error("Forbidden")]
    Status403(BasicError),
    #[error("Requires authentication")]
    Status401(BasicError),
    #[error("Status code: {}", code)]
    Generic { code: u16 },
}

impl From<ActivitySetThreadSubscriptionError> for AdapterError {
    fn from(err: ActivitySetThreadSubscriptionError) -> Self {
        let (description, status_code) = match err {
            ActivitySetThreadSubscriptionError::Status304 => (String::from("Not modified"), 304),
            ActivitySetThreadSubscriptionError::Status403(_) => (String::from("Forbidden"), 403),
            ActivitySetThreadSubscriptionError::Status401(_) => (String::from("Requires authentication"), 401),
            ActivitySetThreadSubscriptionError::Generic { code } => (String::from("Generic"), code)
        };

        Self::Endpoint {
            description,
            status_code,
            source: Some(Box::new(err))
        }
    }
}

/// Errors for the [Star a repository for the authenticated user](Activity::star_repo_for_authenticated_user_async()) endpoint.
#[derive(Debug, thiserror::Error)]
pub enum ActivityStarRepoForAuthenticatedUserError {
    #[error("Forbidden")]
    Status403(BasicError),
    #[error("Resource not found")]
    Status404(BasicError),
    #[error("Requires authentication")]
    Status401(BasicError),
    #[error("Not modified")]
    Status304,
    #[error("Status code: {}", code)]
    Generic { code: u16 },
}

impl From<ActivityStarRepoForAuthenticatedUserError> for AdapterError {
    fn from(err: ActivityStarRepoForAuthenticatedUserError) -> Self {
        let (description, status_code) = match err {
            ActivityStarRepoForAuthenticatedUserError::Status403(_) => (String::from("Forbidden"), 403),
            ActivityStarRepoForAuthenticatedUserError::Status404(_) => (String::from("Resource not found"), 404),
            ActivityStarRepoForAuthenticatedUserError::Status401(_) => (String::from("Requires authentication"), 401),
            ActivityStarRepoForAuthenticatedUserError::Status304 => (String::from("Not modified"), 304),
            ActivityStarRepoForAuthenticatedUserError::Generic { code } => (String::from("Generic"), code)
        };

        Self::Endpoint {
            description,
            status_code,
            source: Some(Box::new(err))
        }
    }
}

/// Errors for the [Unstar a repository for the authenticated user](Activity::unstar_repo_for_authenticated_user_async()) endpoint.
#[derive(Debug, thiserror::Error)]
pub enum ActivityUnstarRepoForAuthenticatedUserError {
    #[error("Resource not found")]
    Status404(BasicError),
    #[error("Requires authentication")]
    Status401(BasicError),
    #[error("Not modified")]
    Status304,
    #[error("Forbidden")]
    Status403(BasicError),
    #[error("Status code: {}", code)]
    Generic { code: u16 },
}

impl From<ActivityUnstarRepoForAuthenticatedUserError> for AdapterError {
    fn from(err: ActivityUnstarRepoForAuthenticatedUserError) -> Self {
        let (description, status_code) = match err {
            ActivityUnstarRepoForAuthenticatedUserError::Status404(_) => (String::from("Resource not found"), 404),
            ActivityUnstarRepoForAuthenticatedUserError::Status401(_) => (String::from("Requires authentication"), 401),
            ActivityUnstarRepoForAuthenticatedUserError::Status304 => (String::from("Not modified"), 304),
            ActivityUnstarRepoForAuthenticatedUserError::Status403(_) => (String::from("Forbidden"), 403),
            ActivityUnstarRepoForAuthenticatedUserError::Generic { code } => (String::from("Generic"), code)
        };

        Self::Endpoint {
            description,
            status_code,
            source: Some(Box::new(err))
        }
    }
}


/// Query parameters for the [List events for the authenticated user](Activity::list_events_for_authenticated_user_async()) endpoint.
#[derive(Default, Serialize)]
pub struct ActivityListEventsForAuthenticatedUserParams {
    /// The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    per_page: Option<u16>, 
    /// The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    page: Option<u16>
}

impl ActivityListEventsForAuthenticatedUserParams {
    pub fn new() -> Self {
        Self::default()
    }

    /// The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    pub fn per_page(self, per_page: u16) -> Self {
        Self {
            per_page: Some(per_page),
            page: self.page, 
        }
    }

    /// The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    pub fn page(self, page: u16) -> Self {
        Self {
            per_page: self.per_page, 
            page: Some(page),
        }
    }
}

impl<'enc> From<&'enc PerPage> for ActivityListEventsForAuthenticatedUserParams {
    fn from(per_page: &'enc PerPage) -> Self {
        Self {
            per_page: Some(per_page.per_page),
            page: Some(per_page.page),
            ..Default::default()
        }
    }
}
/// Query parameters for the [List notifications for the authenticated user](Activity::list_notifications_for_authenticated_user_async()) endpoint.
#[derive(Default, Serialize)]
pub struct ActivityListNotificationsForAuthenticatedUserParams {
    /// If `true`, show notifications marked as read.
    all: Option<bool>, 
    /// If `true`, only shows notifications in which the user is directly participating or mentioned.
    participating: Option<bool>, 
    /// Only show results that were last updated after the given time. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.
    since: Option<chrono::DateTime<chrono::Utc>>, 
    /// Only show notifications updated before the given time. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.
    before: Option<chrono::DateTime<chrono::Utc>>, 
    /// The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    page: Option<u16>, 
    /// The number of results per page (max 50). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    per_page: Option<u16>
}

impl ActivityListNotificationsForAuthenticatedUserParams {
    pub fn new() -> Self {
        Self::default()
    }

    /// If `true`, show notifications marked as read.
    pub fn all(self, all: bool) -> Self {
        Self {
            all: Some(all),
            participating: self.participating, 
            since: self.since, 
            before: self.before, 
            page: self.page, 
            per_page: self.per_page, 
        }
    }

    /// If `true`, only shows notifications in which the user is directly participating or mentioned.
    pub fn participating(self, participating: bool) -> Self {
        Self {
            all: self.all, 
            participating: Some(participating),
            since: self.since, 
            before: self.before, 
            page: self.page, 
            per_page: self.per_page, 
        }
    }

    /// Only show results that were last updated after the given time. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.
    pub fn since(self, since: chrono::DateTime<chrono::Utc>) -> Self {
        Self {
            all: self.all, 
            participating: self.participating, 
            since: Some(since),
            before: self.before, 
            page: self.page, 
            per_page: self.per_page, 
        }
    }

    /// Only show notifications updated before the given time. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.
    pub fn before(self, before: chrono::DateTime<chrono::Utc>) -> Self {
        Self {
            all: self.all, 
            participating: self.participating, 
            since: self.since, 
            before: Some(before),
            page: self.page, 
            per_page: self.per_page, 
        }
    }

    /// The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    pub fn page(self, page: u16) -> Self {
        Self {
            all: self.all, 
            participating: self.participating, 
            since: self.since, 
            before: self.before, 
            page: Some(page),
            per_page: self.per_page, 
        }
    }

    /// The number of results per page (max 50). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    pub fn per_page(self, per_page: u16) -> Self {
        Self {
            all: self.all, 
            participating: self.participating, 
            since: self.since, 
            before: self.before, 
            page: self.page, 
            per_page: Some(per_page),
        }
    }
}

impl<'enc> From<&'enc PerPage> for ActivityListNotificationsForAuthenticatedUserParams {
    fn from(per_page: &'enc PerPage) -> Self {
        Self {
            per_page: Some(per_page.per_page),
            page: Some(per_page.page),
            ..Default::default()
        }
    }
}
/// Query parameters for the [List organization events for the authenticated user](Activity::list_org_events_for_authenticated_user_async()) endpoint.
#[derive(Default, Serialize)]
pub struct ActivityListOrgEventsForAuthenticatedUserParams {
    /// The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    per_page: Option<u16>, 
    /// The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    page: Option<u16>
}

impl ActivityListOrgEventsForAuthenticatedUserParams {
    pub fn new() -> Self {
        Self::default()
    }

    /// The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    pub fn per_page(self, per_page: u16) -> Self {
        Self {
            per_page: Some(per_page),
            page: self.page, 
        }
    }

    /// The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    pub fn page(self, page: u16) -> Self {
        Self {
            per_page: self.per_page, 
            page: Some(page),
        }
    }
}

impl<'enc> From<&'enc PerPage> for ActivityListOrgEventsForAuthenticatedUserParams {
    fn from(per_page: &'enc PerPage) -> Self {
        Self {
            per_page: Some(per_page.per_page),
            page: Some(per_page.page),
            ..Default::default()
        }
    }
}
/// Query parameters for the [List public events](Activity::list_public_events_async()) endpoint.
#[derive(Default, Serialize)]
pub struct ActivityListPublicEventsParams {
    /// The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    per_page: Option<u16>, 
    /// The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    page: Option<u16>
}

impl ActivityListPublicEventsParams {
    pub fn new() -> Self {
        Self::default()
    }

    /// The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    pub fn per_page(self, per_page: u16) -> Self {
        Self {
            per_page: Some(per_page),
            page: self.page, 
        }
    }

    /// The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    pub fn page(self, page: u16) -> Self {
        Self {
            per_page: self.per_page, 
            page: Some(page),
        }
    }
}

impl<'enc> From<&'enc PerPage> for ActivityListPublicEventsParams {
    fn from(per_page: &'enc PerPage) -> Self {
        Self {
            per_page: Some(per_page.per_page),
            page: Some(per_page.page),
            ..Default::default()
        }
    }
}
/// Query parameters for the [List public events for a network of repositories](Activity::list_public_events_for_repo_network_async()) endpoint.
#[derive(Default, Serialize)]
pub struct ActivityListPublicEventsForRepoNetworkParams {
    /// The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    per_page: Option<u16>, 
    /// The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    page: Option<u16>
}

impl ActivityListPublicEventsForRepoNetworkParams {
    pub fn new() -> Self {
        Self::default()
    }

    /// The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    pub fn per_page(self, per_page: u16) -> Self {
        Self {
            per_page: Some(per_page),
            page: self.page, 
        }
    }

    /// The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    pub fn page(self, page: u16) -> Self {
        Self {
            per_page: self.per_page, 
            page: Some(page),
        }
    }
}

impl<'enc> From<&'enc PerPage> for ActivityListPublicEventsForRepoNetworkParams {
    fn from(per_page: &'enc PerPage) -> Self {
        Self {
            per_page: Some(per_page.per_page),
            page: Some(per_page.page),
            ..Default::default()
        }
    }
}
/// Query parameters for the [List public events for a user](Activity::list_public_events_for_user_async()) endpoint.
#[derive(Default, Serialize)]
pub struct ActivityListPublicEventsForUserParams {
    /// The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    per_page: Option<u16>, 
    /// The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    page: Option<u16>
}

impl ActivityListPublicEventsForUserParams {
    pub fn new() -> Self {
        Self::default()
    }

    /// The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    pub fn per_page(self, per_page: u16) -> Self {
        Self {
            per_page: Some(per_page),
            page: self.page, 
        }
    }

    /// The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    pub fn page(self, page: u16) -> Self {
        Self {
            per_page: self.per_page, 
            page: Some(page),
        }
    }
}

impl<'enc> From<&'enc PerPage> for ActivityListPublicEventsForUserParams {
    fn from(per_page: &'enc PerPage) -> Self {
        Self {
            per_page: Some(per_page.per_page),
            page: Some(per_page.page),
            ..Default::default()
        }
    }
}
/// Query parameters for the [List public organization events](Activity::list_public_org_events_async()) endpoint.
#[derive(Default, Serialize)]
pub struct ActivityListPublicOrgEventsParams {
    /// The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    per_page: Option<u16>, 
    /// The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    page: Option<u16>
}

impl ActivityListPublicOrgEventsParams {
    pub fn new() -> Self {
        Self::default()
    }

    /// The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    pub fn per_page(self, per_page: u16) -> Self {
        Self {
            per_page: Some(per_page),
            page: self.page, 
        }
    }

    /// The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    pub fn page(self, page: u16) -> Self {
        Self {
            per_page: self.per_page, 
            page: Some(page),
        }
    }
}

impl<'enc> From<&'enc PerPage> for ActivityListPublicOrgEventsParams {
    fn from(per_page: &'enc PerPage) -> Self {
        Self {
            per_page: Some(per_page.per_page),
            page: Some(per_page.page),
            ..Default::default()
        }
    }
}
/// Query parameters for the [List events received by the authenticated user](Activity::list_received_events_for_user_async()) endpoint.
#[derive(Default, Serialize)]
pub struct ActivityListReceivedEventsForUserParams {
    /// The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    per_page: Option<u16>, 
    /// The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    page: Option<u16>
}

impl ActivityListReceivedEventsForUserParams {
    pub fn new() -> Self {
        Self::default()
    }

    /// The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    pub fn per_page(self, per_page: u16) -> Self {
        Self {
            per_page: Some(per_page),
            page: self.page, 
        }
    }

    /// The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    pub fn page(self, page: u16) -> Self {
        Self {
            per_page: self.per_page, 
            page: Some(page),
        }
    }
}

impl<'enc> From<&'enc PerPage> for ActivityListReceivedEventsForUserParams {
    fn from(per_page: &'enc PerPage) -> Self {
        Self {
            per_page: Some(per_page.per_page),
            page: Some(per_page.page),
            ..Default::default()
        }
    }
}
/// Query parameters for the [List public events received by a user](Activity::list_received_public_events_for_user_async()) endpoint.
#[derive(Default, Serialize)]
pub struct ActivityListReceivedPublicEventsForUserParams {
    /// The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    per_page: Option<u16>, 
    /// The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    page: Option<u16>
}

impl ActivityListReceivedPublicEventsForUserParams {
    pub fn new() -> Self {
        Self::default()
    }

    /// The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    pub fn per_page(self, per_page: u16) -> Self {
        Self {
            per_page: Some(per_page),
            page: self.page, 
        }
    }

    /// The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    pub fn page(self, page: u16) -> Self {
        Self {
            per_page: self.per_page, 
            page: Some(page),
        }
    }
}

impl<'enc> From<&'enc PerPage> for ActivityListReceivedPublicEventsForUserParams {
    fn from(per_page: &'enc PerPage) -> Self {
        Self {
            per_page: Some(per_page.per_page),
            page: Some(per_page.page),
            ..Default::default()
        }
    }
}
/// Query parameters for the [List repository events](Activity::list_repo_events_async()) endpoint.
#[derive(Default, Serialize)]
pub struct ActivityListRepoEventsParams {
    /// The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    per_page: Option<u16>, 
    /// The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    page: Option<u16>
}

impl ActivityListRepoEventsParams {
    pub fn new() -> Self {
        Self::default()
    }

    /// The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    pub fn per_page(self, per_page: u16) -> Self {
        Self {
            per_page: Some(per_page),
            page: self.page, 
        }
    }

    /// The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    pub fn page(self, page: u16) -> Self {
        Self {
            per_page: self.per_page, 
            page: Some(page),
        }
    }
}

impl<'enc> From<&'enc PerPage> for ActivityListRepoEventsParams {
    fn from(per_page: &'enc PerPage) -> Self {
        Self {
            per_page: Some(per_page.per_page),
            page: Some(per_page.page),
            ..Default::default()
        }
    }
}
/// Query parameters for the [List repository notifications for the authenticated user](Activity::list_repo_notifications_for_authenticated_user_async()) endpoint.
#[derive(Default, Serialize)]
pub struct ActivityListRepoNotificationsForAuthenticatedUserParams {
    /// If `true`, show notifications marked as read.
    all: Option<bool>, 
    /// If `true`, only shows notifications in which the user is directly participating or mentioned.
    participating: Option<bool>, 
    /// Only show results that were last updated after the given time. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.
    since: Option<chrono::DateTime<chrono::Utc>>, 
    /// Only show notifications updated before the given time. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.
    before: Option<chrono::DateTime<chrono::Utc>>, 
    /// The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    per_page: Option<u16>, 
    /// The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    page: Option<u16>
}

impl ActivityListRepoNotificationsForAuthenticatedUserParams {
    pub fn new() -> Self {
        Self::default()
    }

    /// If `true`, show notifications marked as read.
    pub fn all(self, all: bool) -> Self {
        Self {
            all: Some(all),
            participating: self.participating, 
            since: self.since, 
            before: self.before, 
            per_page: self.per_page, 
            page: self.page, 
        }
    }

    /// If `true`, only shows notifications in which the user is directly participating or mentioned.
    pub fn participating(self, participating: bool) -> Self {
        Self {
            all: self.all, 
            participating: Some(participating),
            since: self.since, 
            before: self.before, 
            per_page: self.per_page, 
            page: self.page, 
        }
    }

    /// Only show results that were last updated after the given time. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.
    pub fn since(self, since: chrono::DateTime<chrono::Utc>) -> Self {
        Self {
            all: self.all, 
            participating: self.participating, 
            since: Some(since),
            before: self.before, 
            per_page: self.per_page, 
            page: self.page, 
        }
    }

    /// Only show notifications updated before the given time. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.
    pub fn before(self, before: chrono::DateTime<chrono::Utc>) -> Self {
        Self {
            all: self.all, 
            participating: self.participating, 
            since: self.since, 
            before: Some(before),
            per_page: self.per_page, 
            page: self.page, 
        }
    }

    /// The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    pub fn per_page(self, per_page: u16) -> Self {
        Self {
            all: self.all, 
            participating: self.participating, 
            since: self.since, 
            before: self.before, 
            per_page: Some(per_page),
            page: self.page, 
        }
    }

    /// The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    pub fn page(self, page: u16) -> Self {
        Self {
            all: self.all, 
            participating: self.participating, 
            since: self.since, 
            before: self.before, 
            per_page: self.per_page, 
            page: Some(page),
        }
    }
}

impl<'enc> From<&'enc PerPage> for ActivityListRepoNotificationsForAuthenticatedUserParams {
    fn from(per_page: &'enc PerPage) -> Self {
        Self {
            per_page: Some(per_page.per_page),
            page: Some(per_page.page),
            ..Default::default()
        }
    }
}
/// Query parameters for the [List repositories starred by the authenticated user](Activity::list_repos_starred_by_authenticated_user_async()) endpoint.
#[derive(Default, Serialize)]
pub struct ActivityListReposStarredByAuthenticatedUserParams<'req> {
    /// The property to sort the results by. `created` means when the repository was starred. `updated` means when the repository was last pushed to.
    sort: Option<&'req str>, 
    /// The direction to sort the results by.
    direction: Option<&'req str>, 
    /// The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    per_page: Option<u16>, 
    /// The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    page: Option<u16>
}

impl<'req> ActivityListReposStarredByAuthenticatedUserParams<'req> {
    pub fn new() -> Self {
        Self::default()
    }

    /// The property to sort the results by. `created` means when the repository was starred. `updated` means when the repository was last pushed to.
    pub fn sort(self, sort: &'req str) -> Self {
        Self {
            sort: Some(sort),
            direction: self.direction, 
            per_page: self.per_page, 
            page: self.page, 
        }
    }

    /// The direction to sort the results by.
    pub fn direction(self, direction: &'req str) -> Self {
        Self {
            sort: self.sort, 
            direction: Some(direction),
            per_page: self.per_page, 
            page: self.page, 
        }
    }

    /// The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    pub fn per_page(self, per_page: u16) -> Self {
        Self {
            sort: self.sort, 
            direction: self.direction, 
            per_page: Some(per_page),
            page: self.page, 
        }
    }

    /// The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    pub fn page(self, page: u16) -> Self {
        Self {
            sort: self.sort, 
            direction: self.direction, 
            per_page: self.per_page, 
            page: Some(page),
        }
    }
}

impl<'enc> From<&'enc PerPage> for ActivityListReposStarredByAuthenticatedUserParams<'enc> {
    fn from(per_page: &'enc PerPage) -> Self {
        Self {
            per_page: Some(per_page.per_page),
            page: Some(per_page.page),
            ..Default::default()
        }
    }
}
/// Query parameters for the [List repositories starred by a user](Activity::list_repos_starred_by_user_async()) endpoint.
#[derive(Default, Serialize)]
pub struct ActivityListReposStarredByUserParams<'req> {
    /// The property to sort the results by. `created` means when the repository was starred. `updated` means when the repository was last pushed to.
    sort: Option<&'req str>, 
    /// The direction to sort the results by.
    direction: Option<&'req str>, 
    /// The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    per_page: Option<u16>, 
    /// The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    page: Option<u16>
}

impl<'req> ActivityListReposStarredByUserParams<'req> {
    pub fn new() -> Self {
        Self::default()
    }

    /// The property to sort the results by. `created` means when the repository was starred. `updated` means when the repository was last pushed to.
    pub fn sort(self, sort: &'req str) -> Self {
        Self {
            sort: Some(sort),
            direction: self.direction, 
            per_page: self.per_page, 
            page: self.page, 
        }
    }

    /// The direction to sort the results by.
    pub fn direction(self, direction: &'req str) -> Self {
        Self {
            sort: self.sort, 
            direction: Some(direction),
            per_page: self.per_page, 
            page: self.page, 
        }
    }

    /// The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    pub fn per_page(self, per_page: u16) -> Self {
        Self {
            sort: self.sort, 
            direction: self.direction, 
            per_page: Some(per_page),
            page: self.page, 
        }
    }

    /// The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    pub fn page(self, page: u16) -> Self {
        Self {
            sort: self.sort, 
            direction: self.direction, 
            per_page: self.per_page, 
            page: Some(page),
        }
    }
}

impl<'enc> From<&'enc PerPage> for ActivityListReposStarredByUserParams<'enc> {
    fn from(per_page: &'enc PerPage) -> Self {
        Self {
            per_page: Some(per_page.per_page),
            page: Some(per_page.page),
            ..Default::default()
        }
    }
}
/// Query parameters for the [List repositories watched by a user](Activity::list_repos_watched_by_user_async()) endpoint.
#[derive(Default, Serialize)]
pub struct ActivityListReposWatchedByUserParams {
    /// The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    per_page: Option<u16>, 
    /// The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    page: Option<u16>
}

impl ActivityListReposWatchedByUserParams {
    pub fn new() -> Self {
        Self::default()
    }

    /// The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    pub fn per_page(self, per_page: u16) -> Self {
        Self {
            per_page: Some(per_page),
            page: self.page, 
        }
    }

    /// The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    pub fn page(self, page: u16) -> Self {
        Self {
            per_page: self.per_page, 
            page: Some(page),
        }
    }
}

impl<'enc> From<&'enc PerPage> for ActivityListReposWatchedByUserParams {
    fn from(per_page: &'enc PerPage) -> Self {
        Self {
            per_page: Some(per_page.per_page),
            page: Some(per_page.page),
            ..Default::default()
        }
    }
}
/// Query parameters for the [List stargazers](Activity::list_stargazers_for_repo_async()) endpoint.
#[derive(Default, Serialize)]
pub struct ActivityListStargazersForRepoParams {
    /// The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    per_page: Option<u16>, 
    /// The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    page: Option<u16>
}

impl ActivityListStargazersForRepoParams {
    pub fn new() -> Self {
        Self::default()
    }

    /// The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    pub fn per_page(self, per_page: u16) -> Self {
        Self {
            per_page: Some(per_page),
            page: self.page, 
        }
    }

    /// The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    pub fn page(self, page: u16) -> Self {
        Self {
            per_page: self.per_page, 
            page: Some(page),
        }
    }
}

impl<'enc> From<&'enc PerPage> for ActivityListStargazersForRepoParams {
    fn from(per_page: &'enc PerPage) -> Self {
        Self {
            per_page: Some(per_page.per_page),
            page: Some(per_page.page),
            ..Default::default()
        }
    }
}
/// Query parameters for the [List repositories watched by the authenticated user](Activity::list_watched_repos_for_authenticated_user_async()) endpoint.
#[derive(Default, Serialize)]
pub struct ActivityListWatchedReposForAuthenticatedUserParams {
    /// The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    per_page: Option<u16>, 
    /// The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    page: Option<u16>
}

impl ActivityListWatchedReposForAuthenticatedUserParams {
    pub fn new() -> Self {
        Self::default()
    }

    /// The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    pub fn per_page(self, per_page: u16) -> Self {
        Self {
            per_page: Some(per_page),
            page: self.page, 
        }
    }

    /// The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    pub fn page(self, page: u16) -> Self {
        Self {
            per_page: self.per_page, 
            page: Some(page),
        }
    }
}

impl<'enc> From<&'enc PerPage> for ActivityListWatchedReposForAuthenticatedUserParams {
    fn from(per_page: &'enc PerPage) -> Self {
        Self {
            per_page: Some(per_page.per_page),
            page: Some(per_page.page),
            ..Default::default()
        }
    }
}
/// Query parameters for the [List watchers](Activity::list_watchers_for_repo_async()) endpoint.
#[derive(Default, Serialize)]
pub struct ActivityListWatchersForRepoParams {
    /// The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    per_page: Option<u16>, 
    /// The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    page: Option<u16>
}

impl ActivityListWatchersForRepoParams {
    pub fn new() -> Self {
        Self::default()
    }

    /// The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    pub fn per_page(self, per_page: u16) -> Self {
        Self {
            per_page: Some(per_page),
            page: self.page, 
        }
    }

    /// The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    pub fn page(self, page: u16) -> Self {
        Self {
            per_page: self.per_page, 
            page: Some(page),
        }
    }
}

impl<'enc> From<&'enc PerPage> for ActivityListWatchersForRepoParams {
    fn from(per_page: &'enc PerPage) -> Self {
        Self {
            per_page: Some(per_page.per_page),
            page: Some(per_page.page),
            ..Default::default()
        }
    }
}

impl<'api, C: Client> Activity<'api, C> where AdapterError: From<<C as Client>::Err> {
    /// ---
    ///
    /// # Check if a repository is starred by the authenticated user
    ///
    /// Whether the authenticated user has starred the repository.
    ///
    /// [GitHub API docs for check_repo_is_starred_by_authenticated_user](https://docs.github.com/rest/activity/starring#check-if-a-repository-is-starred-by-the-authenticated-user)
    ///
    /// ---
    pub async fn check_repo_is_starred_by_authenticated_user_async(&self, owner: &str, repo: &str) -> Result<(), AdapterError> {

        let request_uri = format!("{}/user/starred/{}/{}", super::GITHUB_BASE_API_URL, owner, repo);


        let req = GitHubRequest {
            uri: request_uri,
            body: None::<C::Body>,
            method: "GET",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch_async(request).await?;

        // --

        if github_response.is_success() {
            Ok(github_response.to_json_async().await?)
        } else {
            match github_response.status_code() {
                404 => Err(ActivityCheckRepoIsStarredByAuthenticatedUserError::Status404(github_response.to_json_async().await?).into()),
                401 => Err(ActivityCheckRepoIsStarredByAuthenticatedUserError::Status401(github_response.to_json_async().await?).into()),
                304 => Err(ActivityCheckRepoIsStarredByAuthenticatedUserError::Status304.into()),
                403 => Err(ActivityCheckRepoIsStarredByAuthenticatedUserError::Status403(github_response.to_json_async().await?).into()),
                code => Err(ActivityCheckRepoIsStarredByAuthenticatedUserError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # Check if a repository is starred by the authenticated user
    ///
    /// Whether the authenticated user has starred the repository.
    ///
    /// [GitHub API docs for check_repo_is_starred_by_authenticated_user](https://docs.github.com/rest/activity/starring#check-if-a-repository-is-starred-by-the-authenticated-user)
    ///
    /// ---
    #[cfg(not(target_arch = "wasm32"))]
    pub fn check_repo_is_starred_by_authenticated_user(&self, owner: &str, repo: &str) -> Result<(), AdapterError> {

        let request_uri = format!("{}/user/starred/{}/{}", super::GITHUB_BASE_API_URL, owner, repo);


        let req = GitHubRequest {
            uri: request_uri,
            body: None,
            method: "GET",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch(request)?;

        // --

        if github_response.is_success() {
            Ok(github_response.to_json()?)
        } else {
            match github_response.status_code() {
                404 => Err(ActivityCheckRepoIsStarredByAuthenticatedUserError::Status404(github_response.to_json()?).into()),
                401 => Err(ActivityCheckRepoIsStarredByAuthenticatedUserError::Status401(github_response.to_json()?).into()),
                304 => Err(ActivityCheckRepoIsStarredByAuthenticatedUserError::Status304.into()),
                403 => Err(ActivityCheckRepoIsStarredByAuthenticatedUserError::Status403(github_response.to_json()?).into()),
                code => Err(ActivityCheckRepoIsStarredByAuthenticatedUserError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # Delete a repository subscription
    ///
    /// This endpoint should only be used to stop watching a repository. To control whether or not you wish to receive notifications from a repository, [set the repository's subscription manually](https://docs.github.com/rest/activity/watching#set-a-repository-subscription).
    ///
    /// [GitHub API docs for delete_repo_subscription](https://docs.github.com/rest/activity/watching#delete-a-repository-subscription)
    ///
    /// ---
    pub async fn delete_repo_subscription_async(&self, owner: &str, repo: &str) -> Result<(), AdapterError> {

        let request_uri = format!("{}/repos/{}/{}/subscription", super::GITHUB_BASE_API_URL, owner, repo);


        let req = GitHubRequest {
            uri: request_uri,
            body: None::<C::Body>,
            method: "DELETE",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch_async(request).await?;

        // --

        if github_response.is_success() {
            Ok(github_response.to_json_async().await?)
        } else {
            match github_response.status_code() {
                code => Err(ActivityDeleteRepoSubscriptionError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # Delete a repository subscription
    ///
    /// This endpoint should only be used to stop watching a repository. To control whether or not you wish to receive notifications from a repository, [set the repository's subscription manually](https://docs.github.com/rest/activity/watching#set-a-repository-subscription).
    ///
    /// [GitHub API docs for delete_repo_subscription](https://docs.github.com/rest/activity/watching#delete-a-repository-subscription)
    ///
    /// ---
    #[cfg(not(target_arch = "wasm32"))]
    pub fn delete_repo_subscription(&self, owner: &str, repo: &str) -> Result<(), AdapterError> {

        let request_uri = format!("{}/repos/{}/{}/subscription", super::GITHUB_BASE_API_URL, owner, repo);


        let req = GitHubRequest {
            uri: request_uri,
            body: None,
            method: "DELETE",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch(request)?;

        // --

        if github_response.is_success() {
            Ok(github_response.to_json()?)
        } else {
            match github_response.status_code() {
                code => Err(ActivityDeleteRepoSubscriptionError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # Delete a thread subscription
    ///
    /// Mutes all future notifications for a conversation until you comment on the thread or get an **@mention**. If you are watching the repository of the thread, you will still receive notifications. To ignore future notifications for a repository you are watching, use the [Set a thread subscription](https://docs.github.com/rest/activity/notifications#set-a-thread-subscription) endpoint and set `ignore` to `true`.
    ///
    /// [GitHub API docs for delete_thread_subscription](https://docs.github.com/rest/activity/notifications#delete-a-thread-subscription)
    ///
    /// ---
    pub async fn delete_thread_subscription_async(&self, thread_id: i32) -> Result<(), AdapterError> {

        let request_uri = format!("{}/notifications/threads/{}/subscription", super::GITHUB_BASE_API_URL, thread_id);


        let req = GitHubRequest {
            uri: request_uri,
            body: None::<C::Body>,
            method: "DELETE",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch_async(request).await?;

        // --

        if github_response.is_success() {
            Ok(github_response.to_json_async().await?)
        } else {
            match github_response.status_code() {
                304 => Err(ActivityDeleteThreadSubscriptionError::Status304.into()),
                403 => Err(ActivityDeleteThreadSubscriptionError::Status403(github_response.to_json_async().await?).into()),
                401 => Err(ActivityDeleteThreadSubscriptionError::Status401(github_response.to_json_async().await?).into()),
                code => Err(ActivityDeleteThreadSubscriptionError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # Delete a thread subscription
    ///
    /// Mutes all future notifications for a conversation until you comment on the thread or get an **@mention**. If you are watching the repository of the thread, you will still receive notifications. To ignore future notifications for a repository you are watching, use the [Set a thread subscription](https://docs.github.com/rest/activity/notifications#set-a-thread-subscription) endpoint and set `ignore` to `true`.
    ///
    /// [GitHub API docs for delete_thread_subscription](https://docs.github.com/rest/activity/notifications#delete-a-thread-subscription)
    ///
    /// ---
    #[cfg(not(target_arch = "wasm32"))]
    pub fn delete_thread_subscription(&self, thread_id: i32) -> Result<(), AdapterError> {

        let request_uri = format!("{}/notifications/threads/{}/subscription", super::GITHUB_BASE_API_URL, thread_id);


        let req = GitHubRequest {
            uri: request_uri,
            body: None,
            method: "DELETE",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch(request)?;

        // --

        if github_response.is_success() {
            Ok(github_response.to_json()?)
        } else {
            match github_response.status_code() {
                304 => Err(ActivityDeleteThreadSubscriptionError::Status304.into()),
                403 => Err(ActivityDeleteThreadSubscriptionError::Status403(github_response.to_json()?).into()),
                401 => Err(ActivityDeleteThreadSubscriptionError::Status401(github_response.to_json()?).into()),
                code => Err(ActivityDeleteThreadSubscriptionError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # Get feeds
    ///
    /// Lists the feeds available to the authenticated user. The response provides a URL for each feed. You can then get a specific feed by sending a request to one of the feed URLs.
    /// 
    /// *   **Timeline**: The GitHub global public timeline
    /// *   **User**: The public timeline for any user, using `uri_template`. For more information, see "[Hypermedia](https://docs.github.com/rest/using-the-rest-api/getting-started-with-the-rest-api#hypermedia)."
    /// *   **Current user public**: The public timeline for the authenticated user
    /// *   **Current user**: The private timeline for the authenticated user
    /// *   **Current user actor**: The private timeline for activity created by the authenticated user
    /// *   **Current user organizations**: The private timeline for the organizations the authenticated user is a member of.
    /// *   **Security advisories**: A collection of public announcements that provide information about security-related vulnerabilities in software on GitHub.
    /// 
    /// By default, timeline resources are returned in JSON. You can specify the `application/atom+xml` type in the `Accept` header to return timeline resources in Atom format. For more information, see "[Media types](https://docs.github.com/rest/using-the-rest-api/getting-started-with-the-rest-api#media-types)."
    /// 
    /// > [!NOTE]
    /// > Private feeds are only returned when [authenticating via Basic Auth](https://docs.github.com/rest/authentication/authenticating-to-the-rest-api#using-basic-authentication) since current feed URIs use the older, non revocable auth tokens.
    ///
    /// [GitHub API docs for get_feeds](https://docs.github.com/rest/activity/feeds#get-feeds)
    ///
    /// ---
    pub async fn get_feeds_async(&self) -> Result<Feed, AdapterError> {

        let request_uri = format!("{}/feeds", super::GITHUB_BASE_API_URL);


        let req = GitHubRequest {
            uri: request_uri,
            body: None::<C::Body>,
            method: "GET",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch_async(request).await?;

        // --

        if github_response.is_success() {
            Ok(github_response.to_json_async().await?)
        } else {
            match github_response.status_code() {
                code => Err(ActivityGetFeedsError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # Get feeds
    ///
    /// Lists the feeds available to the authenticated user. The response provides a URL for each feed. You can then get a specific feed by sending a request to one of the feed URLs.
    /// 
    /// *   **Timeline**: The GitHub global public timeline
    /// *   **User**: The public timeline for any user, using `uri_template`. For more information, see "[Hypermedia](https://docs.github.com/rest/using-the-rest-api/getting-started-with-the-rest-api#hypermedia)."
    /// *   **Current user public**: The public timeline for the authenticated user
    /// *   **Current user**: The private timeline for the authenticated user
    /// *   **Current user actor**: The private timeline for activity created by the authenticated user
    /// *   **Current user organizations**: The private timeline for the organizations the authenticated user is a member of.
    /// *   **Security advisories**: A collection of public announcements that provide information about security-related vulnerabilities in software on GitHub.
    /// 
    /// By default, timeline resources are returned in JSON. You can specify the `application/atom+xml` type in the `Accept` header to return timeline resources in Atom format. For more information, see "[Media types](https://docs.github.com/rest/using-the-rest-api/getting-started-with-the-rest-api#media-types)."
    /// 
    /// > [!NOTE]
    /// > Private feeds are only returned when [authenticating via Basic Auth](https://docs.github.com/rest/authentication/authenticating-to-the-rest-api#using-basic-authentication) since current feed URIs use the older, non revocable auth tokens.
    ///
    /// [GitHub API docs for get_feeds](https://docs.github.com/rest/activity/feeds#get-feeds)
    ///
    /// ---
    #[cfg(not(target_arch = "wasm32"))]
    pub fn get_feeds(&self) -> Result<Feed, AdapterError> {

        let request_uri = format!("{}/feeds", super::GITHUB_BASE_API_URL);


        let req = GitHubRequest {
            uri: request_uri,
            body: None,
            method: "GET",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch(request)?;

        // --

        if github_response.is_success() {
            Ok(github_response.to_json()?)
        } else {
            match github_response.status_code() {
                code => Err(ActivityGetFeedsError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # Get a repository subscription
    ///
    /// Gets information about whether the authenticated user is subscribed to the repository.
    ///
    /// [GitHub API docs for get_repo_subscription](https://docs.github.com/rest/activity/watching#get-a-repository-subscription)
    ///
    /// ---
    pub async fn get_repo_subscription_async(&self, owner: &str, repo: &str) -> Result<RepositorySubscription, AdapterError> {

        let request_uri = format!("{}/repos/{}/{}/subscription", super::GITHUB_BASE_API_URL, owner, repo);


        let req = GitHubRequest {
            uri: request_uri,
            body: None::<C::Body>,
            method: "GET",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch_async(request).await?;

        // --

        if github_response.is_success() {
            Ok(github_response.to_json_async().await?)
        } else {
            match github_response.status_code() {
                404 => Err(ActivityGetRepoSubscriptionError::Status404.into()),
                403 => Err(ActivityGetRepoSubscriptionError::Status403(github_response.to_json_async().await?).into()),
                code => Err(ActivityGetRepoSubscriptionError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # Get a repository subscription
    ///
    /// Gets information about whether the authenticated user is subscribed to the repository.
    ///
    /// [GitHub API docs for get_repo_subscription](https://docs.github.com/rest/activity/watching#get-a-repository-subscription)
    ///
    /// ---
    #[cfg(not(target_arch = "wasm32"))]
    pub fn get_repo_subscription(&self, owner: &str, repo: &str) -> Result<RepositorySubscription, AdapterError> {

        let request_uri = format!("{}/repos/{}/{}/subscription", super::GITHUB_BASE_API_URL, owner, repo);


        let req = GitHubRequest {
            uri: request_uri,
            body: None,
            method: "GET",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch(request)?;

        // --

        if github_response.is_success() {
            Ok(github_response.to_json()?)
        } else {
            match github_response.status_code() {
                404 => Err(ActivityGetRepoSubscriptionError::Status404.into()),
                403 => Err(ActivityGetRepoSubscriptionError::Status403(github_response.to_json()?).into()),
                code => Err(ActivityGetRepoSubscriptionError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # Get a thread
    ///
    /// Gets information about a notification thread.
    ///
    /// [GitHub API docs for get_thread](https://docs.github.com/rest/activity/notifications#get-a-thread)
    ///
    /// ---
    pub async fn get_thread_async(&self, thread_id: i32) -> Result<Thread, AdapterError> {

        let request_uri = format!("{}/notifications/threads/{}", super::GITHUB_BASE_API_URL, thread_id);


        let req = GitHubRequest {
            uri: request_uri,
            body: None::<C::Body>,
            method: "GET",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch_async(request).await?;

        // --

        if github_response.is_success() {
            Ok(github_response.to_json_async().await?)
        } else {
            match github_response.status_code() {
                304 => Err(ActivityGetThreadError::Status304.into()),
                403 => Err(ActivityGetThreadError::Status403(github_response.to_json_async().await?).into()),
                401 => Err(ActivityGetThreadError::Status401(github_response.to_json_async().await?).into()),
                code => Err(ActivityGetThreadError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # Get a thread
    ///
    /// Gets information about a notification thread.
    ///
    /// [GitHub API docs for get_thread](https://docs.github.com/rest/activity/notifications#get-a-thread)
    ///
    /// ---
    #[cfg(not(target_arch = "wasm32"))]
    pub fn get_thread(&self, thread_id: i32) -> Result<Thread, AdapterError> {

        let request_uri = format!("{}/notifications/threads/{}", super::GITHUB_BASE_API_URL, thread_id);


        let req = GitHubRequest {
            uri: request_uri,
            body: None,
            method: "GET",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch(request)?;

        // --

        if github_response.is_success() {
            Ok(github_response.to_json()?)
        } else {
            match github_response.status_code() {
                304 => Err(ActivityGetThreadError::Status304.into()),
                403 => Err(ActivityGetThreadError::Status403(github_response.to_json()?).into()),
                401 => Err(ActivityGetThreadError::Status401(github_response.to_json()?).into()),
                code => Err(ActivityGetThreadError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # Get a thread subscription for the authenticated user
    ///
    /// This checks to see if the current user is subscribed to a thread. You can also [get a repository subscription](https://docs.github.com/rest/activity/watching#get-a-repository-subscription).
    /// 
    /// Note that subscriptions are only generated if a user is participating in a conversation--for example, they've replied to the thread, were **@mentioned**, or manually subscribe to a thread.
    ///
    /// [GitHub API docs for get_thread_subscription_for_authenticated_user](https://docs.github.com/rest/activity/notifications#get-a-thread-subscription-for-the-authenticated-user)
    ///
    /// ---
    pub async fn get_thread_subscription_for_authenticated_user_async(&self, thread_id: i32) -> Result<ThreadSubscription, AdapterError> {

        let request_uri = format!("{}/notifications/threads/{}/subscription", super::GITHUB_BASE_API_URL, thread_id);


        let req = GitHubRequest {
            uri: request_uri,
            body: None::<C::Body>,
            method: "GET",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch_async(request).await?;

        // --

        if github_response.is_success() {
            Ok(github_response.to_json_async().await?)
        } else {
            match github_response.status_code() {
                304 => Err(ActivityGetThreadSubscriptionForAuthenticatedUserError::Status304.into()),
                403 => Err(ActivityGetThreadSubscriptionForAuthenticatedUserError::Status403(github_response.to_json_async().await?).into()),
                401 => Err(ActivityGetThreadSubscriptionForAuthenticatedUserError::Status401(github_response.to_json_async().await?).into()),
                code => Err(ActivityGetThreadSubscriptionForAuthenticatedUserError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # Get a thread subscription for the authenticated user
    ///
    /// This checks to see if the current user is subscribed to a thread. You can also [get a repository subscription](https://docs.github.com/rest/activity/watching#get-a-repository-subscription).
    /// 
    /// Note that subscriptions are only generated if a user is participating in a conversation--for example, they've replied to the thread, were **@mentioned**, or manually subscribe to a thread.
    ///
    /// [GitHub API docs for get_thread_subscription_for_authenticated_user](https://docs.github.com/rest/activity/notifications#get-a-thread-subscription-for-the-authenticated-user)
    ///
    /// ---
    #[cfg(not(target_arch = "wasm32"))]
    pub fn get_thread_subscription_for_authenticated_user(&self, thread_id: i32) -> Result<ThreadSubscription, AdapterError> {

        let request_uri = format!("{}/notifications/threads/{}/subscription", super::GITHUB_BASE_API_URL, thread_id);


        let req = GitHubRequest {
            uri: request_uri,
            body: None,
            method: "GET",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch(request)?;

        // --

        if github_response.is_success() {
            Ok(github_response.to_json()?)
        } else {
            match github_response.status_code() {
                304 => Err(ActivityGetThreadSubscriptionForAuthenticatedUserError::Status304.into()),
                403 => Err(ActivityGetThreadSubscriptionForAuthenticatedUserError::Status403(github_response.to_json()?).into()),
                401 => Err(ActivityGetThreadSubscriptionForAuthenticatedUserError::Status401(github_response.to_json()?).into()),
                code => Err(ActivityGetThreadSubscriptionForAuthenticatedUserError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # List events for the authenticated user
    ///
    /// If you are authenticated as the given user, you will see your private events. Otherwise, you'll only see public events.
    /// 
    /// > [!NOTE]
    /// > This API is not built to serve real-time use cases. Depending on the time of day, event latency can be anywhere from 30s to 6h.
    ///
    /// [GitHub API docs for list_events_for_authenticated_user](https://docs.github.com/rest/activity/events#list-events-for-the-authenticated-user)
    ///
    /// ---
    pub async fn list_events_for_authenticated_user_async(&self, username: &str, query_params: Option<impl Into<ActivityListEventsForAuthenticatedUserParams>>) -> Result<Vec<Event>, AdapterError> {

        let mut request_uri = format!("{}/users/{}/events", super::GITHUB_BASE_API_URL, username);

        if let Some(params) = query_params {
            request_uri.push_str("?");
            request_uri.push_str(&serde_urlencoded::to_string(params.into())?);
        }

        let req = GitHubRequest {
            uri: request_uri,
            body: None::<C::Body>,
            method: "GET",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch_async(request).await?;

        // --

        if github_response.is_success() {
            Ok(github_response.to_json_async().await?)
        } else {
            match github_response.status_code() {
                code => Err(ActivityListEventsForAuthenticatedUserError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # List events for the authenticated user
    ///
    /// If you are authenticated as the given user, you will see your private events. Otherwise, you'll only see public events.
    /// 
    /// > [!NOTE]
    /// > This API is not built to serve real-time use cases. Depending on the time of day, event latency can be anywhere from 30s to 6h.
    ///
    /// [GitHub API docs for list_events_for_authenticated_user](https://docs.github.com/rest/activity/events#list-events-for-the-authenticated-user)
    ///
    /// ---
    #[cfg(not(target_arch = "wasm32"))]
    pub fn list_events_for_authenticated_user(&self, username: &str, query_params: Option<impl Into<ActivityListEventsForAuthenticatedUserParams>>) -> Result<Vec<Event>, AdapterError> {

        let mut request_uri = format!("{}/users/{}/events", super::GITHUB_BASE_API_URL, username);

        if let Some(params) = query_params {
            request_uri.push_str("?");
            let qp: ActivityListEventsForAuthenticatedUserParams = params.into();
            request_uri.push_str(&serde_urlencoded::to_string(qp)?);
        }

        let req = GitHubRequest {
            uri: request_uri,
            body: None,
            method: "GET",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch(request)?;

        // --

        if github_response.is_success() {
            Ok(github_response.to_json()?)
        } else {
            match github_response.status_code() {
                code => Err(ActivityListEventsForAuthenticatedUserError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # List notifications for the authenticated user
    ///
    /// List all notifications for the current user, sorted by most recently updated.
    ///
    /// [GitHub API docs for list_notifications_for_authenticated_user](https://docs.github.com/rest/activity/notifications#list-notifications-for-the-authenticated-user)
    ///
    /// ---
    pub async fn list_notifications_for_authenticated_user_async(&self, query_params: Option<impl Into<ActivityListNotificationsForAuthenticatedUserParams>>) -> Result<Vec<Thread>, AdapterError> {

        let mut request_uri = format!("{}/notifications", super::GITHUB_BASE_API_URL);

        if let Some(params) = query_params {
            request_uri.push_str("?");
            request_uri.push_str(&serde_urlencoded::to_string(params.into())?);
        }

        let req = GitHubRequest {
            uri: request_uri,
            body: None::<C::Body>,
            method: "GET",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch_async(request).await?;

        // --

        if github_response.is_success() {
            Ok(github_response.to_json_async().await?)
        } else {
            match github_response.status_code() {
                304 => Err(ActivityListNotificationsForAuthenticatedUserError::Status304.into()),
                403 => Err(ActivityListNotificationsForAuthenticatedUserError::Status403(github_response.to_json_async().await?).into()),
                401 => Err(ActivityListNotificationsForAuthenticatedUserError::Status401(github_response.to_json_async().await?).into()),
                422 => Err(ActivityListNotificationsForAuthenticatedUserError::Status422(github_response.to_json_async().await?).into()),
                code => Err(ActivityListNotificationsForAuthenticatedUserError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # List notifications for the authenticated user
    ///
    /// List all notifications for the current user, sorted by most recently updated.
    ///
    /// [GitHub API docs for list_notifications_for_authenticated_user](https://docs.github.com/rest/activity/notifications#list-notifications-for-the-authenticated-user)
    ///
    /// ---
    #[cfg(not(target_arch = "wasm32"))]
    pub fn list_notifications_for_authenticated_user(&self, query_params: Option<impl Into<ActivityListNotificationsForAuthenticatedUserParams>>) -> Result<Vec<Thread>, AdapterError> {

        let mut request_uri = format!("{}/notifications", super::GITHUB_BASE_API_URL);

        if let Some(params) = query_params {
            request_uri.push_str("?");
            let qp: ActivityListNotificationsForAuthenticatedUserParams = params.into();
            request_uri.push_str(&serde_urlencoded::to_string(qp)?);
        }

        let req = GitHubRequest {
            uri: request_uri,
            body: None,
            method: "GET",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch(request)?;

        // --

        if github_response.is_success() {
            Ok(github_response.to_json()?)
        } else {
            match github_response.status_code() {
                304 => Err(ActivityListNotificationsForAuthenticatedUserError::Status304.into()),
                403 => Err(ActivityListNotificationsForAuthenticatedUserError::Status403(github_response.to_json()?).into()),
                401 => Err(ActivityListNotificationsForAuthenticatedUserError::Status401(github_response.to_json()?).into()),
                422 => Err(ActivityListNotificationsForAuthenticatedUserError::Status422(github_response.to_json()?).into()),
                code => Err(ActivityListNotificationsForAuthenticatedUserError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # List organization events for the authenticated user
    ///
    /// This is the user's organization dashboard. You must be authenticated as the user to view this.
    /// 
    /// > [!NOTE]
    /// > This API is not built to serve real-time use cases. Depending on the time of day, event latency can be anywhere from 30s to 6h.
    ///
    /// [GitHub API docs for list_org_events_for_authenticated_user](https://docs.github.com/rest/activity/events#list-organization-events-for-the-authenticated-user)
    ///
    /// ---
    pub async fn list_org_events_for_authenticated_user_async(&self, username: &str, org: &str, query_params: Option<impl Into<ActivityListOrgEventsForAuthenticatedUserParams>>) -> Result<Vec<Event>, AdapterError> {

        let mut request_uri = format!("{}/users/{}/events/orgs/{}", super::GITHUB_BASE_API_URL, username, org);

        if let Some(params) = query_params {
            request_uri.push_str("?");
            request_uri.push_str(&serde_urlencoded::to_string(params.into())?);
        }

        let req = GitHubRequest {
            uri: request_uri,
            body: None::<C::Body>,
            method: "GET",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch_async(request).await?;

        // --

        if github_response.is_success() {
            Ok(github_response.to_json_async().await?)
        } else {
            match github_response.status_code() {
                code => Err(ActivityListOrgEventsForAuthenticatedUserError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # List organization events for the authenticated user
    ///
    /// This is the user's organization dashboard. You must be authenticated as the user to view this.
    /// 
    /// > [!NOTE]
    /// > This API is not built to serve real-time use cases. Depending on the time of day, event latency can be anywhere from 30s to 6h.
    ///
    /// [GitHub API docs for list_org_events_for_authenticated_user](https://docs.github.com/rest/activity/events#list-organization-events-for-the-authenticated-user)
    ///
    /// ---
    #[cfg(not(target_arch = "wasm32"))]
    pub fn list_org_events_for_authenticated_user(&self, username: &str, org: &str, query_params: Option<impl Into<ActivityListOrgEventsForAuthenticatedUserParams>>) -> Result<Vec<Event>, AdapterError> {

        let mut request_uri = format!("{}/users/{}/events/orgs/{}", super::GITHUB_BASE_API_URL, username, org);

        if let Some(params) = query_params {
            request_uri.push_str("?");
            let qp: ActivityListOrgEventsForAuthenticatedUserParams = params.into();
            request_uri.push_str(&serde_urlencoded::to_string(qp)?);
        }

        let req = GitHubRequest {
            uri: request_uri,
            body: None,
            method: "GET",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch(request)?;

        // --

        if github_response.is_success() {
            Ok(github_response.to_json()?)
        } else {
            match github_response.status_code() {
                code => Err(ActivityListOrgEventsForAuthenticatedUserError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # List public events
    ///
    /// > [!NOTE]
    /// > This API is not built to serve real-time use cases. Depending on the time of day, event latency can be anywhere from 30s to 6h.
    ///
    /// [GitHub API docs for list_public_events](https://docs.github.com/rest/activity/events#list-public-events)
    ///
    /// ---
    pub async fn list_public_events_async(&self, query_params: Option<impl Into<ActivityListPublicEventsParams>>) -> Result<Vec<Event>, AdapterError> {

        let mut request_uri = format!("{}/events", super::GITHUB_BASE_API_URL);

        if let Some(params) = query_params {
            request_uri.push_str("?");
            request_uri.push_str(&serde_urlencoded::to_string(params.into())?);
        }

        let req = GitHubRequest {
            uri: request_uri,
            body: None::<C::Body>,
            method: "GET",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch_async(request).await?;

        // --

        if github_response.is_success() {
            Ok(github_response.to_json_async().await?)
        } else {
            match github_response.status_code() {
                304 => Err(ActivityListPublicEventsError::Status304.into()),
                403 => Err(ActivityListPublicEventsError::Status403(github_response.to_json_async().await?).into()),
                503 => Err(ActivityListPublicEventsError::Status503(github_response.to_json_async().await?).into()),
                code => Err(ActivityListPublicEventsError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # List public events
    ///
    /// > [!NOTE]
    /// > This API is not built to serve real-time use cases. Depending on the time of day, event latency can be anywhere from 30s to 6h.
    ///
    /// [GitHub API docs for list_public_events](https://docs.github.com/rest/activity/events#list-public-events)
    ///
    /// ---
    #[cfg(not(target_arch = "wasm32"))]
    pub fn list_public_events(&self, query_params: Option<impl Into<ActivityListPublicEventsParams>>) -> Result<Vec<Event>, AdapterError> {

        let mut request_uri = format!("{}/events", super::GITHUB_BASE_API_URL);

        if let Some(params) = query_params {
            request_uri.push_str("?");
            let qp: ActivityListPublicEventsParams = params.into();
            request_uri.push_str(&serde_urlencoded::to_string(qp)?);
        }

        let req = GitHubRequest {
            uri: request_uri,
            body: None,
            method: "GET",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch(request)?;

        // --

        if github_response.is_success() {
            Ok(github_response.to_json()?)
        } else {
            match github_response.status_code() {
                304 => Err(ActivityListPublicEventsError::Status304.into()),
                403 => Err(ActivityListPublicEventsError::Status403(github_response.to_json()?).into()),
                503 => Err(ActivityListPublicEventsError::Status503(github_response.to_json()?).into()),
                code => Err(ActivityListPublicEventsError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # List public events for a network of repositories
    ///
    /// > [!NOTE]
    /// > This API is not built to serve real-time use cases. Depending on the time of day, event latency can be anywhere from 30s to 6h.
    ///
    /// [GitHub API docs for list_public_events_for_repo_network](https://docs.github.com/rest/activity/events#list-public-events-for-a-network-of-repositories)
    ///
    /// ---
    pub async fn list_public_events_for_repo_network_async(&self, owner: &str, repo: &str, query_params: Option<impl Into<ActivityListPublicEventsForRepoNetworkParams>>) -> Result<Vec<Event>, AdapterError> {

        let mut request_uri = format!("{}/networks/{}/{}/events", super::GITHUB_BASE_API_URL, owner, repo);

        if let Some(params) = query_params {
            request_uri.push_str("?");
            request_uri.push_str(&serde_urlencoded::to_string(params.into())?);
        }

        let req = GitHubRequest {
            uri: request_uri,
            body: None::<C::Body>,
            method: "GET",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch_async(request).await?;

        // --

        if github_response.is_success() {
            Ok(github_response.to_json_async().await?)
        } else {
            match github_response.status_code() {
                404 => Err(ActivityListPublicEventsForRepoNetworkError::Status404(github_response.to_json_async().await?).into()),
                403 => Err(ActivityListPublicEventsForRepoNetworkError::Status403(github_response.to_json_async().await?).into()),
                304 => Err(ActivityListPublicEventsForRepoNetworkError::Status304.into()),
                301 => Err(ActivityListPublicEventsForRepoNetworkError::Status301(github_response.to_json_async().await?).into()),
                code => Err(ActivityListPublicEventsForRepoNetworkError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # List public events for a network of repositories
    ///
    /// > [!NOTE]
    /// > This API is not built to serve real-time use cases. Depending on the time of day, event latency can be anywhere from 30s to 6h.
    ///
    /// [GitHub API docs for list_public_events_for_repo_network](https://docs.github.com/rest/activity/events#list-public-events-for-a-network-of-repositories)
    ///
    /// ---
    #[cfg(not(target_arch = "wasm32"))]
    pub fn list_public_events_for_repo_network(&self, owner: &str, repo: &str, query_params: Option<impl Into<ActivityListPublicEventsForRepoNetworkParams>>) -> Result<Vec<Event>, AdapterError> {

        let mut request_uri = format!("{}/networks/{}/{}/events", super::GITHUB_BASE_API_URL, owner, repo);

        if let Some(params) = query_params {
            request_uri.push_str("?");
            let qp: ActivityListPublicEventsForRepoNetworkParams = params.into();
            request_uri.push_str(&serde_urlencoded::to_string(qp)?);
        }

        let req = GitHubRequest {
            uri: request_uri,
            body: None,
            method: "GET",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch(request)?;

        // --

        if github_response.is_success() {
            Ok(github_response.to_json()?)
        } else {
            match github_response.status_code() {
                404 => Err(ActivityListPublicEventsForRepoNetworkError::Status404(github_response.to_json()?).into()),
                403 => Err(ActivityListPublicEventsForRepoNetworkError::Status403(github_response.to_json()?).into()),
                304 => Err(ActivityListPublicEventsForRepoNetworkError::Status304.into()),
                301 => Err(ActivityListPublicEventsForRepoNetworkError::Status301(github_response.to_json()?).into()),
                code => Err(ActivityListPublicEventsForRepoNetworkError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # List public events for a user
    ///
    /// > [!NOTE]
    /// > This API is not built to serve real-time use cases. Depending on the time of day, event latency can be anywhere from 30s to 6h.
    ///
    /// [GitHub API docs for list_public_events_for_user](https://docs.github.com/rest/activity/events#list-public-events-for-a-user)
    ///
    /// ---
    pub async fn list_public_events_for_user_async(&self, username: &str, query_params: Option<impl Into<ActivityListPublicEventsForUserParams>>) -> Result<Vec<Event>, AdapterError> {

        let mut request_uri = format!("{}/users/{}/events/public", super::GITHUB_BASE_API_URL, username);

        if let Some(params) = query_params {
            request_uri.push_str("?");
            request_uri.push_str(&serde_urlencoded::to_string(params.into())?);
        }

        let req = GitHubRequest {
            uri: request_uri,
            body: None::<C::Body>,
            method: "GET",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch_async(request).await?;

        // --

        if github_response.is_success() {
            Ok(github_response.to_json_async().await?)
        } else {
            match github_response.status_code() {
                code => Err(ActivityListPublicEventsForUserError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # List public events for a user
    ///
    /// > [!NOTE]
    /// > This API is not built to serve real-time use cases. Depending on the time of day, event latency can be anywhere from 30s to 6h.
    ///
    /// [GitHub API docs for list_public_events_for_user](https://docs.github.com/rest/activity/events#list-public-events-for-a-user)
    ///
    /// ---
    #[cfg(not(target_arch = "wasm32"))]
    pub fn list_public_events_for_user(&self, username: &str, query_params: Option<impl Into<ActivityListPublicEventsForUserParams>>) -> Result<Vec<Event>, AdapterError> {

        let mut request_uri = format!("{}/users/{}/events/public", super::GITHUB_BASE_API_URL, username);

        if let Some(params) = query_params {
            request_uri.push_str("?");
            let qp: ActivityListPublicEventsForUserParams = params.into();
            request_uri.push_str(&serde_urlencoded::to_string(qp)?);
        }

        let req = GitHubRequest {
            uri: request_uri,
            body: None,
            method: "GET",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch(request)?;

        // --

        if github_response.is_success() {
            Ok(github_response.to_json()?)
        } else {
            match github_response.status_code() {
                code => Err(ActivityListPublicEventsForUserError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # List public organization events
    ///
    /// > [!NOTE]
    /// > This API is not built to serve real-time use cases. Depending on the time of day, event latency can be anywhere from 30s to 6h.
    ///
    /// [GitHub API docs for list_public_org_events](https://docs.github.com/rest/activity/events#list-public-organization-events)
    ///
    /// ---
    pub async fn list_public_org_events_async(&self, org: &str, query_params: Option<impl Into<ActivityListPublicOrgEventsParams>>) -> Result<Vec<Event>, AdapterError> {

        let mut request_uri = format!("{}/orgs/{}/events", super::GITHUB_BASE_API_URL, org);

        if let Some(params) = query_params {
            request_uri.push_str("?");
            request_uri.push_str(&serde_urlencoded::to_string(params.into())?);
        }

        let req = GitHubRequest {
            uri: request_uri,
            body: None::<C::Body>,
            method: "GET",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch_async(request).await?;

        // --

        if github_response.is_success() {
            Ok(github_response.to_json_async().await?)
        } else {
            match github_response.status_code() {
                code => Err(ActivityListPublicOrgEventsError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # List public organization events
    ///
    /// > [!NOTE]
    /// > This API is not built to serve real-time use cases. Depending on the time of day, event latency can be anywhere from 30s to 6h.
    ///
    /// [GitHub API docs for list_public_org_events](https://docs.github.com/rest/activity/events#list-public-organization-events)
    ///
    /// ---
    #[cfg(not(target_arch = "wasm32"))]
    pub fn list_public_org_events(&self, org: &str, query_params: Option<impl Into<ActivityListPublicOrgEventsParams>>) -> Result<Vec<Event>, AdapterError> {

        let mut request_uri = format!("{}/orgs/{}/events", super::GITHUB_BASE_API_URL, org);

        if let Some(params) = query_params {
            request_uri.push_str("?");
            let qp: ActivityListPublicOrgEventsParams = params.into();
            request_uri.push_str(&serde_urlencoded::to_string(qp)?);
        }

        let req = GitHubRequest {
            uri: request_uri,
            body: None,
            method: "GET",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch(request)?;

        // --

        if github_response.is_success() {
            Ok(github_response.to_json()?)
        } else {
            match github_response.status_code() {
                code => Err(ActivityListPublicOrgEventsError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # List events received by the authenticated user
    ///
    /// These are events that you've received by watching repositories and following users. If you are authenticated as the
    /// given user, you will see private events. Otherwise, you'll only see public events.
    /// 
    /// > [!NOTE]
    /// > This API is not built to serve real-time use cases. Depending on the time of day, event latency can be anywhere from 30s to 6h.
    ///
    /// [GitHub API docs for list_received_events_for_user](https://docs.github.com/rest/activity/events#list-events-received-by-the-authenticated-user)
    ///
    /// ---
    pub async fn list_received_events_for_user_async(&self, username: &str, query_params: Option<impl Into<ActivityListReceivedEventsForUserParams>>) -> Result<Vec<Event>, AdapterError> {

        let mut request_uri = format!("{}/users/{}/received_events", super::GITHUB_BASE_API_URL, username);

        if let Some(params) = query_params {
            request_uri.push_str("?");
            request_uri.push_str(&serde_urlencoded::to_string(params.into())?);
        }

        let req = GitHubRequest {
            uri: request_uri,
            body: None::<C::Body>,
            method: "GET",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch_async(request).await?;

        // --

        if github_response.is_success() {
            Ok(github_response.to_json_async().await?)
        } else {
            match github_response.status_code() {
                code => Err(ActivityListReceivedEventsForUserError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # List events received by the authenticated user
    ///
    /// These are events that you've received by watching repositories and following users. If you are authenticated as the
    /// given user, you will see private events. Otherwise, you'll only see public events.
    /// 
    /// > [!NOTE]
    /// > This API is not built to serve real-time use cases. Depending on the time of day, event latency can be anywhere from 30s to 6h.
    ///
    /// [GitHub API docs for list_received_events_for_user](https://docs.github.com/rest/activity/events#list-events-received-by-the-authenticated-user)
    ///
    /// ---
    #[cfg(not(target_arch = "wasm32"))]
    pub fn list_received_events_for_user(&self, username: &str, query_params: Option<impl Into<ActivityListReceivedEventsForUserParams>>) -> Result<Vec<Event>, AdapterError> {

        let mut request_uri = format!("{}/users/{}/received_events", super::GITHUB_BASE_API_URL, username);

        if let Some(params) = query_params {
            request_uri.push_str("?");
            let qp: ActivityListReceivedEventsForUserParams = params.into();
            request_uri.push_str(&serde_urlencoded::to_string(qp)?);
        }

        let req = GitHubRequest {
            uri: request_uri,
            body: None,
            method: "GET",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch(request)?;

        // --

        if github_response.is_success() {
            Ok(github_response.to_json()?)
        } else {
            match github_response.status_code() {
                code => Err(ActivityListReceivedEventsForUserError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # List public events received by a user
    ///
    /// > [!NOTE]
    /// > This API is not built to serve real-time use cases. Depending on the time of day, event latency can be anywhere from 30s to 6h.
    ///
    /// [GitHub API docs for list_received_public_events_for_user](https://docs.github.com/rest/activity/events#list-public-events-received-by-a-user)
    ///
    /// ---
    pub async fn list_received_public_events_for_user_async(&self, username: &str, query_params: Option<impl Into<ActivityListReceivedPublicEventsForUserParams>>) -> Result<Vec<Event>, AdapterError> {

        let mut request_uri = format!("{}/users/{}/received_events/public", super::GITHUB_BASE_API_URL, username);

        if let Some(params) = query_params {
            request_uri.push_str("?");
            request_uri.push_str(&serde_urlencoded::to_string(params.into())?);
        }

        let req = GitHubRequest {
            uri: request_uri,
            body: None::<C::Body>,
            method: "GET",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch_async(request).await?;

        // --

        if github_response.is_success() {
            Ok(github_response.to_json_async().await?)
        } else {
            match github_response.status_code() {
                code => Err(ActivityListReceivedPublicEventsForUserError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # List public events received by a user
    ///
    /// > [!NOTE]
    /// > This API is not built to serve real-time use cases. Depending on the time of day, event latency can be anywhere from 30s to 6h.
    ///
    /// [GitHub API docs for list_received_public_events_for_user](https://docs.github.com/rest/activity/events#list-public-events-received-by-a-user)
    ///
    /// ---
    #[cfg(not(target_arch = "wasm32"))]
    pub fn list_received_public_events_for_user(&self, username: &str, query_params: Option<impl Into<ActivityListReceivedPublicEventsForUserParams>>) -> Result<Vec<Event>, AdapterError> {

        let mut request_uri = format!("{}/users/{}/received_events/public", super::GITHUB_BASE_API_URL, username);

        if let Some(params) = query_params {
            request_uri.push_str("?");
            let qp: ActivityListReceivedPublicEventsForUserParams = params.into();
            request_uri.push_str(&serde_urlencoded::to_string(qp)?);
        }

        let req = GitHubRequest {
            uri: request_uri,
            body: None,
            method: "GET",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch(request)?;

        // --

        if github_response.is_success() {
            Ok(github_response.to_json()?)
        } else {
            match github_response.status_code() {
                code => Err(ActivityListReceivedPublicEventsForUserError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # List repository events
    ///
    /// > [!NOTE]
    /// > This API is not built to serve real-time use cases. Depending on the time of day, event latency can be anywhere from 30s to 6h.
    ///
    /// [GitHub API docs for list_repo_events](https://docs.github.com/rest/activity/events#list-repository-events)
    ///
    /// ---
    pub async fn list_repo_events_async(&self, owner: &str, repo: &str, query_params: Option<impl Into<ActivityListRepoEventsParams>>) -> Result<Vec<Event>, AdapterError> {

        let mut request_uri = format!("{}/repos/{}/{}/events", super::GITHUB_BASE_API_URL, owner, repo);

        if let Some(params) = query_params {
            request_uri.push_str("?");
            request_uri.push_str(&serde_urlencoded::to_string(params.into())?);
        }

        let req = GitHubRequest {
            uri: request_uri,
            body: None::<C::Body>,
            method: "GET",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch_async(request).await?;

        // --

        if github_response.is_success() {
            Ok(github_response.to_json_async().await?)
        } else {
            match github_response.status_code() {
                code => Err(ActivityListRepoEventsError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # List repository events
    ///
    /// > [!NOTE]
    /// > This API is not built to serve real-time use cases. Depending on the time of day, event latency can be anywhere from 30s to 6h.
    ///
    /// [GitHub API docs for list_repo_events](https://docs.github.com/rest/activity/events#list-repository-events)
    ///
    /// ---
    #[cfg(not(target_arch = "wasm32"))]
    pub fn list_repo_events(&self, owner: &str, repo: &str, query_params: Option<impl Into<ActivityListRepoEventsParams>>) -> Result<Vec<Event>, AdapterError> {

        let mut request_uri = format!("{}/repos/{}/{}/events", super::GITHUB_BASE_API_URL, owner, repo);

        if let Some(params) = query_params {
            request_uri.push_str("?");
            let qp: ActivityListRepoEventsParams = params.into();
            request_uri.push_str(&serde_urlencoded::to_string(qp)?);
        }

        let req = GitHubRequest {
            uri: request_uri,
            body: None,
            method: "GET",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch(request)?;

        // --

        if github_response.is_success() {
            Ok(github_response.to_json()?)
        } else {
            match github_response.status_code() {
                code => Err(ActivityListRepoEventsError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # List repository notifications for the authenticated user
    ///
    /// Lists all notifications for the current user in the specified repository.
    ///
    /// [GitHub API docs for list_repo_notifications_for_authenticated_user](https://docs.github.com/rest/activity/notifications#list-repository-notifications-for-the-authenticated-user)
    ///
    /// ---
    pub async fn list_repo_notifications_for_authenticated_user_async(&self, owner: &str, repo: &str, query_params: Option<impl Into<ActivityListRepoNotificationsForAuthenticatedUserParams>>) -> Result<Vec<Thread>, AdapterError> {

        let mut request_uri = format!("{}/repos/{}/{}/notifications", super::GITHUB_BASE_API_URL, owner, repo);

        if let Some(params) = query_params {
            request_uri.push_str("?");
            request_uri.push_str(&serde_urlencoded::to_string(params.into())?);
        }

        let req = GitHubRequest {
            uri: request_uri,
            body: None::<C::Body>,
            method: "GET",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch_async(request).await?;

        // --

        if github_response.is_success() {
            Ok(github_response.to_json_async().await?)
        } else {
            match github_response.status_code() {
                code => Err(ActivityListRepoNotificationsForAuthenticatedUserError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # List repository notifications for the authenticated user
    ///
    /// Lists all notifications for the current user in the specified repository.
    ///
    /// [GitHub API docs for list_repo_notifications_for_authenticated_user](https://docs.github.com/rest/activity/notifications#list-repository-notifications-for-the-authenticated-user)
    ///
    /// ---
    #[cfg(not(target_arch = "wasm32"))]
    pub fn list_repo_notifications_for_authenticated_user(&self, owner: &str, repo: &str, query_params: Option<impl Into<ActivityListRepoNotificationsForAuthenticatedUserParams>>) -> Result<Vec<Thread>, AdapterError> {

        let mut request_uri = format!("{}/repos/{}/{}/notifications", super::GITHUB_BASE_API_URL, owner, repo);

        if let Some(params) = query_params {
            request_uri.push_str("?");
            let qp: ActivityListRepoNotificationsForAuthenticatedUserParams = params.into();
            request_uri.push_str(&serde_urlencoded::to_string(qp)?);
        }

        let req = GitHubRequest {
            uri: request_uri,
            body: None,
            method: "GET",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch(request)?;

        // --

        if github_response.is_success() {
            Ok(github_response.to_json()?)
        } else {
            match github_response.status_code() {
                code => Err(ActivityListRepoNotificationsForAuthenticatedUserError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # List repositories starred by the authenticated user
    ///
    /// Lists repositories the authenticated user has starred.
    /// 
    /// This endpoint supports the following custom media types. For more information, see "[Media types](https://docs.github.com/rest/using-the-rest-api/getting-started-with-the-rest-api#media-types)."
    /// 
    /// - **`application/vnd.github.star+json`**: Includes a timestamp of when the star was created.
    ///
    /// [GitHub API docs for list_repos_starred_by_authenticated_user](https://docs.github.com/rest/activity/starring#list-repositories-starred-by-the-authenticated-user)
    ///
    /// ---
    pub async fn list_repos_starred_by_authenticated_user_async(&self, query_params: Option<impl Into<ActivityListReposStarredByAuthenticatedUserParams<'api>>>) -> Result<Vec<Repository>, AdapterError> {

        let mut request_uri = format!("{}/user/starred", super::GITHUB_BASE_API_URL);

        if let Some(params) = query_params {
            request_uri.push_str("?");
            request_uri.push_str(&serde_urlencoded::to_string(params.into())?);
        }

        let req = GitHubRequest {
            uri: request_uri,
            body: None::<C::Body>,
            method: "GET",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch_async(request).await?;

        // --

        if github_response.is_success() {
            Ok(github_response.to_json_async().await?)
        } else {
            match github_response.status_code() {
                304 => Err(ActivityListReposStarredByAuthenticatedUserError::Status304.into()),
                403 => Err(ActivityListReposStarredByAuthenticatedUserError::Status403(github_response.to_json_async().await?).into()),
                401 => Err(ActivityListReposStarredByAuthenticatedUserError::Status401(github_response.to_json_async().await?).into()),
                code => Err(ActivityListReposStarredByAuthenticatedUserError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # List repositories starred by the authenticated user
    ///
    /// Lists repositories the authenticated user has starred.
    /// 
    /// This endpoint supports the following custom media types. For more information, see "[Media types](https://docs.github.com/rest/using-the-rest-api/getting-started-with-the-rest-api#media-types)."
    /// 
    /// - **`application/vnd.github.star+json`**: Includes a timestamp of when the star was created.
    ///
    /// [GitHub API docs for list_repos_starred_by_authenticated_user](https://docs.github.com/rest/activity/starring#list-repositories-starred-by-the-authenticated-user)
    ///
    /// ---
    #[cfg(not(target_arch = "wasm32"))]
    pub fn list_repos_starred_by_authenticated_user(&self, query_params: Option<impl Into<ActivityListReposStarredByAuthenticatedUserParams<'api>>>) -> Result<Vec<Repository>, AdapterError> {

        let mut request_uri = format!("{}/user/starred", super::GITHUB_BASE_API_URL);

        if let Some(params) = query_params {
            request_uri.push_str("?");
            let qp: ActivityListReposStarredByAuthenticatedUserParams = params.into();
            request_uri.push_str(&serde_urlencoded::to_string(qp)?);
        }

        let req = GitHubRequest {
            uri: request_uri,
            body: None,
            method: "GET",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch(request)?;

        // --

        if github_response.is_success() {
            Ok(github_response.to_json()?)
        } else {
            match github_response.status_code() {
                304 => Err(ActivityListReposStarredByAuthenticatedUserError::Status304.into()),
                403 => Err(ActivityListReposStarredByAuthenticatedUserError::Status403(github_response.to_json()?).into()),
                401 => Err(ActivityListReposStarredByAuthenticatedUserError::Status401(github_response.to_json()?).into()),
                code => Err(ActivityListReposStarredByAuthenticatedUserError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # List repositories starred by a user
    ///
    /// Lists repositories a user has starred.
    /// 
    /// This endpoint supports the following custom media types. For more information, see "[Media types](https://docs.github.com/rest/using-the-rest-api/getting-started-with-the-rest-api#media-types)."
    /// 
    /// - **`application/vnd.github.star+json`**: Includes a timestamp of when the star was created.
    ///
    /// [GitHub API docs for list_repos_starred_by_user](https://docs.github.com/rest/activity/starring#list-repositories-starred-by-a-user)
    ///
    /// ---
    pub async fn list_repos_starred_by_user_async(&self, username: &str, query_params: Option<impl Into<ActivityListReposStarredByUserParams<'api>>>) -> Result<GetActivityListReposStarredByUserResponse200, AdapterError> {

        let mut request_uri = format!("{}/users/{}/starred", super::GITHUB_BASE_API_URL, username);

        if let Some(params) = query_params {
            request_uri.push_str("?");
            request_uri.push_str(&serde_urlencoded::to_string(params.into())?);
        }

        let req = GitHubRequest {
            uri: request_uri,
            body: None::<C::Body>,
            method: "GET",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch_async(request).await?;

        // --

        if github_response.is_success() {
            Ok(github_response.to_json_async().await?)
        } else {
            match github_response.status_code() {
                code => Err(ActivityListReposStarredByUserError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # List repositories starred by a user
    ///
    /// Lists repositories a user has starred.
    /// 
    /// This endpoint supports the following custom media types. For more information, see "[Media types](https://docs.github.com/rest/using-the-rest-api/getting-started-with-the-rest-api#media-types)."
    /// 
    /// - **`application/vnd.github.star+json`**: Includes a timestamp of when the star was created.
    ///
    /// [GitHub API docs for list_repos_starred_by_user](https://docs.github.com/rest/activity/starring#list-repositories-starred-by-a-user)
    ///
    /// ---
    #[cfg(not(target_arch = "wasm32"))]
    pub fn list_repos_starred_by_user(&self, username: &str, query_params: Option<impl Into<ActivityListReposStarredByUserParams<'api>>>) -> Result<GetActivityListReposStarredByUserResponse200, AdapterError> {

        let mut request_uri = format!("{}/users/{}/starred", super::GITHUB_BASE_API_URL, username);

        if let Some(params) = query_params {
            request_uri.push_str("?");
            let qp: ActivityListReposStarredByUserParams = params.into();
            request_uri.push_str(&serde_urlencoded::to_string(qp)?);
        }

        let req = GitHubRequest {
            uri: request_uri,
            body: None,
            method: "GET",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch(request)?;

        // --

        if github_response.is_success() {
            Ok(github_response.to_json()?)
        } else {
            match github_response.status_code() {
                code => Err(ActivityListReposStarredByUserError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # List repositories watched by a user
    ///
    /// Lists repositories a user is watching.
    ///
    /// [GitHub API docs for list_repos_watched_by_user](https://docs.github.com/rest/activity/watching#list-repositories-watched-by-a-user)
    ///
    /// ---
    pub async fn list_repos_watched_by_user_async(&self, username: &str, query_params: Option<impl Into<ActivityListReposWatchedByUserParams>>) -> Result<Vec<MinimalRepository>, AdapterError> {

        let mut request_uri = format!("{}/users/{}/subscriptions", super::GITHUB_BASE_API_URL, username);

        if let Some(params) = query_params {
            request_uri.push_str("?");
            request_uri.push_str(&serde_urlencoded::to_string(params.into())?);
        }

        let req = GitHubRequest {
            uri: request_uri,
            body: None::<C::Body>,
            method: "GET",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch_async(request).await?;

        // --

        if github_response.is_success() {
            Ok(github_response.to_json_async().await?)
        } else {
            match github_response.status_code() {
                code => Err(ActivityListReposWatchedByUserError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # List repositories watched by a user
    ///
    /// Lists repositories a user is watching.
    ///
    /// [GitHub API docs for list_repos_watched_by_user](https://docs.github.com/rest/activity/watching#list-repositories-watched-by-a-user)
    ///
    /// ---
    #[cfg(not(target_arch = "wasm32"))]
    pub fn list_repos_watched_by_user(&self, username: &str, query_params: Option<impl Into<ActivityListReposWatchedByUserParams>>) -> Result<Vec<MinimalRepository>, AdapterError> {

        let mut request_uri = format!("{}/users/{}/subscriptions", super::GITHUB_BASE_API_URL, username);

        if let Some(params) = query_params {
            request_uri.push_str("?");
            let qp: ActivityListReposWatchedByUserParams = params.into();
            request_uri.push_str(&serde_urlencoded::to_string(qp)?);
        }

        let req = GitHubRequest {
            uri: request_uri,
            body: None,
            method: "GET",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch(request)?;

        // --

        if github_response.is_success() {
            Ok(github_response.to_json()?)
        } else {
            match github_response.status_code() {
                code => Err(ActivityListReposWatchedByUserError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # List stargazers
    ///
    /// Lists the people that have starred the repository.
    /// 
    /// This endpoint supports the following custom media types. For more information, see "[Media types](https://docs.github.com/rest/using-the-rest-api/getting-started-with-the-rest-api#media-types)."
    /// 
    /// - **`application/vnd.github.star+json`**: Includes a timestamp of when the star was created.
    ///
    /// [GitHub API docs for list_stargazers_for_repo](https://docs.github.com/rest/activity/starring#list-stargazers)
    ///
    /// ---
    pub async fn list_stargazers_for_repo_async(&self, owner: &str, repo: &str, query_params: Option<impl Into<ActivityListStargazersForRepoParams>>) -> Result<GetActivityListStargazersForRepoResponse200, AdapterError> {

        let mut request_uri = format!("{}/repos/{}/{}/stargazers", super::GITHUB_BASE_API_URL, owner, repo);

        if let Some(params) = query_params {
            request_uri.push_str("?");
            request_uri.push_str(&serde_urlencoded::to_string(params.into())?);
        }

        let req = GitHubRequest {
            uri: request_uri,
            body: None::<C::Body>,
            method: "GET",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch_async(request).await?;

        // --

        if github_response.is_success() {
            Ok(github_response.to_json_async().await?)
        } else {
            match github_response.status_code() {
                422 => Err(ActivityListStargazersForRepoError::Status422(github_response.to_json_async().await?).into()),
                code => Err(ActivityListStargazersForRepoError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # List stargazers
    ///
    /// Lists the people that have starred the repository.
    /// 
    /// This endpoint supports the following custom media types. For more information, see "[Media types](https://docs.github.com/rest/using-the-rest-api/getting-started-with-the-rest-api#media-types)."
    /// 
    /// - **`application/vnd.github.star+json`**: Includes a timestamp of when the star was created.
    ///
    /// [GitHub API docs for list_stargazers_for_repo](https://docs.github.com/rest/activity/starring#list-stargazers)
    ///
    /// ---
    #[cfg(not(target_arch = "wasm32"))]
    pub fn list_stargazers_for_repo(&self, owner: &str, repo: &str, query_params: Option<impl Into<ActivityListStargazersForRepoParams>>) -> Result<GetActivityListStargazersForRepoResponse200, AdapterError> {

        let mut request_uri = format!("{}/repos/{}/{}/stargazers", super::GITHUB_BASE_API_URL, owner, repo);

        if let Some(params) = query_params {
            request_uri.push_str("?");
            let qp: ActivityListStargazersForRepoParams = params.into();
            request_uri.push_str(&serde_urlencoded::to_string(qp)?);
        }

        let req = GitHubRequest {
            uri: request_uri,
            body: None,
            method: "GET",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch(request)?;

        // --

        if github_response.is_success() {
            Ok(github_response.to_json()?)
        } else {
            match github_response.status_code() {
                422 => Err(ActivityListStargazersForRepoError::Status422(github_response.to_json()?).into()),
                code => Err(ActivityListStargazersForRepoError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # List repositories watched by the authenticated user
    ///
    /// Lists repositories the authenticated user is watching.
    ///
    /// [GitHub API docs for list_watched_repos_for_authenticated_user](https://docs.github.com/rest/activity/watching#list-repositories-watched-by-the-authenticated-user)
    ///
    /// ---
    pub async fn list_watched_repos_for_authenticated_user_async(&self, query_params: Option<impl Into<ActivityListWatchedReposForAuthenticatedUserParams>>) -> Result<Vec<MinimalRepository>, AdapterError> {

        let mut request_uri = format!("{}/user/subscriptions", super::GITHUB_BASE_API_URL);

        if let Some(params) = query_params {
            request_uri.push_str("?");
            request_uri.push_str(&serde_urlencoded::to_string(params.into())?);
        }

        let req = GitHubRequest {
            uri: request_uri,
            body: None::<C::Body>,
            method: "GET",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch_async(request).await?;

        // --

        if github_response.is_success() {
            Ok(github_response.to_json_async().await?)
        } else {
            match github_response.status_code() {
                304 => Err(ActivityListWatchedReposForAuthenticatedUserError::Status304.into()),
                403 => Err(ActivityListWatchedReposForAuthenticatedUserError::Status403(github_response.to_json_async().await?).into()),
                401 => Err(ActivityListWatchedReposForAuthenticatedUserError::Status401(github_response.to_json_async().await?).into()),
                code => Err(ActivityListWatchedReposForAuthenticatedUserError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # List repositories watched by the authenticated user
    ///
    /// Lists repositories the authenticated user is watching.
    ///
    /// [GitHub API docs for list_watched_repos_for_authenticated_user](https://docs.github.com/rest/activity/watching#list-repositories-watched-by-the-authenticated-user)
    ///
    /// ---
    #[cfg(not(target_arch = "wasm32"))]
    pub fn list_watched_repos_for_authenticated_user(&self, query_params: Option<impl Into<ActivityListWatchedReposForAuthenticatedUserParams>>) -> Result<Vec<MinimalRepository>, AdapterError> {

        let mut request_uri = format!("{}/user/subscriptions", super::GITHUB_BASE_API_URL);

        if let Some(params) = query_params {
            request_uri.push_str("?");
            let qp: ActivityListWatchedReposForAuthenticatedUserParams = params.into();
            request_uri.push_str(&serde_urlencoded::to_string(qp)?);
        }

        let req = GitHubRequest {
            uri: request_uri,
            body: None,
            method: "GET",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch(request)?;

        // --

        if github_response.is_success() {
            Ok(github_response.to_json()?)
        } else {
            match github_response.status_code() {
                304 => Err(ActivityListWatchedReposForAuthenticatedUserError::Status304.into()),
                403 => Err(ActivityListWatchedReposForAuthenticatedUserError::Status403(github_response.to_json()?).into()),
                401 => Err(ActivityListWatchedReposForAuthenticatedUserError::Status401(github_response.to_json()?).into()),
                code => Err(ActivityListWatchedReposForAuthenticatedUserError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # List watchers
    ///
    /// Lists the people watching the specified repository.
    ///
    /// [GitHub API docs for list_watchers_for_repo](https://docs.github.com/rest/activity/watching#list-watchers)
    ///
    /// ---
    pub async fn list_watchers_for_repo_async(&self, owner: &str, repo: &str, query_params: Option<impl Into<ActivityListWatchersForRepoParams>>) -> Result<Vec<SimpleUser>, AdapterError> {

        let mut request_uri = format!("{}/repos/{}/{}/subscribers", super::GITHUB_BASE_API_URL, owner, repo);

        if let Some(params) = query_params {
            request_uri.push_str("?");
            request_uri.push_str(&serde_urlencoded::to_string(params.into())?);
        }

        let req = GitHubRequest {
            uri: request_uri,
            body: None::<C::Body>,
            method: "GET",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch_async(request).await?;

        // --

        if github_response.is_success() {
            Ok(github_response.to_json_async().await?)
        } else {
            match github_response.status_code() {
                code => Err(ActivityListWatchersForRepoError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # List watchers
    ///
    /// Lists the people watching the specified repository.
    ///
    /// [GitHub API docs for list_watchers_for_repo](https://docs.github.com/rest/activity/watching#list-watchers)
    ///
    /// ---
    #[cfg(not(target_arch = "wasm32"))]
    pub fn list_watchers_for_repo(&self, owner: &str, repo: &str, query_params: Option<impl Into<ActivityListWatchersForRepoParams>>) -> Result<Vec<SimpleUser>, AdapterError> {

        let mut request_uri = format!("{}/repos/{}/{}/subscribers", super::GITHUB_BASE_API_URL, owner, repo);

        if let Some(params) = query_params {
            request_uri.push_str("?");
            let qp: ActivityListWatchersForRepoParams = params.into();
            request_uri.push_str(&serde_urlencoded::to_string(qp)?);
        }

        let req = GitHubRequest {
            uri: request_uri,
            body: None,
            method: "GET",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch(request)?;

        // --

        if github_response.is_success() {
            Ok(github_response.to_json()?)
        } else {
            match github_response.status_code() {
                code => Err(ActivityListWatchersForRepoError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # Mark notifications as read
    ///
    /// Marks all notifications as "read" for the current user. If the number of notifications is too large to complete in one request, you will receive a `202 Accepted` status and GitHub will run an asynchronous process to mark notifications as "read." To check whether any "unread" notifications remain, you can use the [List notifications for the authenticated user](https://docs.github.com/rest/activity/notifications#list-notifications-for-the-authenticated-user) endpoint and pass the query parameter `all=false`.
    ///
    /// [GitHub API docs for mark_notifications_as_read](https://docs.github.com/rest/activity/notifications#mark-notifications-as-read)
    ///
    /// ---
    pub async fn mark_notifications_as_read_async(&self, body: PutActivityMarkNotificationsAsRead) -> Result<PostReposCreateDeploymentResponse202, AdapterError> {

        let request_uri = format!("{}/notifications", super::GITHUB_BASE_API_URL);


        let req = GitHubRequest {
            uri: request_uri,
            body: Some(C::from_json::<PutActivityMarkNotificationsAsRead>(body)?),
            method: "PUT",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch_async(request).await?;

        // --

        if github_response.is_success() {
            Ok(github_response.to_json_async().await?)
        } else {
            match github_response.status_code() {
                205 => Err(ActivityMarkNotificationsAsReadError::Status205.into()),
                304 => Err(ActivityMarkNotificationsAsReadError::Status304.into()),
                403 => Err(ActivityMarkNotificationsAsReadError::Status403(github_response.to_json_async().await?).into()),
                401 => Err(ActivityMarkNotificationsAsReadError::Status401(github_response.to_json_async().await?).into()),
                code => Err(ActivityMarkNotificationsAsReadError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # Mark notifications as read
    ///
    /// Marks all notifications as "read" for the current user. If the number of notifications is too large to complete in one request, you will receive a `202 Accepted` status and GitHub will run an asynchronous process to mark notifications as "read." To check whether any "unread" notifications remain, you can use the [List notifications for the authenticated user](https://docs.github.com/rest/activity/notifications#list-notifications-for-the-authenticated-user) endpoint and pass the query parameter `all=false`.
    ///
    /// [GitHub API docs for mark_notifications_as_read](https://docs.github.com/rest/activity/notifications#mark-notifications-as-read)
    ///
    /// ---
    #[cfg(not(target_arch = "wasm32"))]
    pub fn mark_notifications_as_read(&self, body: PutActivityMarkNotificationsAsRead) -> Result<PostReposCreateDeploymentResponse202, AdapterError> {

        let request_uri = format!("{}/notifications", super::GITHUB_BASE_API_URL);


        let req = GitHubRequest {
            uri: request_uri,
            body: Some(C::from_json::<PutActivityMarkNotificationsAsRead>(body)?),
            method: "PUT",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch(request)?;

        // --

        if github_response.is_success() {
            Ok(github_response.to_json()?)
        } else {
            match github_response.status_code() {
                205 => Err(ActivityMarkNotificationsAsReadError::Status205.into()),
                304 => Err(ActivityMarkNotificationsAsReadError::Status304.into()),
                403 => Err(ActivityMarkNotificationsAsReadError::Status403(github_response.to_json()?).into()),
                401 => Err(ActivityMarkNotificationsAsReadError::Status401(github_response.to_json()?).into()),
                code => Err(ActivityMarkNotificationsAsReadError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # Mark repository notifications as read
    ///
    /// Marks all notifications in a repository as "read" for the current user. If the number of notifications is too large to complete in one request, you will receive a `202 Accepted` status and GitHub will run an asynchronous process to mark notifications as "read." To check whether any "unread" notifications remain, you can use the [List repository notifications for the authenticated user](https://docs.github.com/rest/activity/notifications#list-repository-notifications-for-the-authenticated-user) endpoint and pass the query parameter `all=false`.
    ///
    /// [GitHub API docs for mark_repo_notifications_as_read](https://docs.github.com/rest/activity/notifications#mark-repository-notifications-as-read)
    ///
    /// ---
    pub async fn mark_repo_notifications_as_read_async(&self, owner: &str, repo: &str, body: PutActivityMarkRepoNotificationsAsRead) -> Result<PutPullsUpdateBranchResponse202, AdapterError> {

        let request_uri = format!("{}/repos/{}/{}/notifications", super::GITHUB_BASE_API_URL, owner, repo);


        let req = GitHubRequest {
            uri: request_uri,
            body: Some(C::from_json::<PutActivityMarkRepoNotificationsAsRead>(body)?),
            method: "PUT",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch_async(request).await?;

        // --

        if github_response.is_success() {
            Ok(github_response.to_json_async().await?)
        } else {
            match github_response.status_code() {
                205 => Err(ActivityMarkRepoNotificationsAsReadError::Status205.into()),
                code => Err(ActivityMarkRepoNotificationsAsReadError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # Mark repository notifications as read
    ///
    /// Marks all notifications in a repository as "read" for the current user. If the number of notifications is too large to complete in one request, you will receive a `202 Accepted` status and GitHub will run an asynchronous process to mark notifications as "read." To check whether any "unread" notifications remain, you can use the [List repository notifications for the authenticated user](https://docs.github.com/rest/activity/notifications#list-repository-notifications-for-the-authenticated-user) endpoint and pass the query parameter `all=false`.
    ///
    /// [GitHub API docs for mark_repo_notifications_as_read](https://docs.github.com/rest/activity/notifications#mark-repository-notifications-as-read)
    ///
    /// ---
    #[cfg(not(target_arch = "wasm32"))]
    pub fn mark_repo_notifications_as_read(&self, owner: &str, repo: &str, body: PutActivityMarkRepoNotificationsAsRead) -> Result<PutPullsUpdateBranchResponse202, AdapterError> {

        let request_uri = format!("{}/repos/{}/{}/notifications", super::GITHUB_BASE_API_URL, owner, repo);


        let req = GitHubRequest {
            uri: request_uri,
            body: Some(C::from_json::<PutActivityMarkRepoNotificationsAsRead>(body)?),
            method: "PUT",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch(request)?;

        // --

        if github_response.is_success() {
            Ok(github_response.to_json()?)
        } else {
            match github_response.status_code() {
                205 => Err(ActivityMarkRepoNotificationsAsReadError::Status205.into()),
                code => Err(ActivityMarkRepoNotificationsAsReadError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # Mark a thread as done
    ///
    /// Marks a thread as "done." Marking a thread as "done" is equivalent to marking a notification in your notification inbox on GitHub as done: https://github.com/notifications.
    ///
    /// [GitHub API docs for mark_thread_as_done](https://docs.github.com/rest/activity/notifications#mark-a-thread-as-done)
    ///
    /// ---
    pub async fn mark_thread_as_done_async(&self, thread_id: i32) -> Result<(), AdapterError> {

        let request_uri = format!("{}/notifications/threads/{}", super::GITHUB_BASE_API_URL, thread_id);


        let req = GitHubRequest {
            uri: request_uri,
            body: None::<C::Body>,
            method: "DELETE",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch_async(request).await?;

        // --

        if github_response.is_success() {
            Ok(github_response.to_json_async().await?)
        } else {
            match github_response.status_code() {
                code => Err(ActivityMarkThreadAsDoneError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # Mark a thread as done
    ///
    /// Marks a thread as "done." Marking a thread as "done" is equivalent to marking a notification in your notification inbox on GitHub as done: https://github.com/notifications.
    ///
    /// [GitHub API docs for mark_thread_as_done](https://docs.github.com/rest/activity/notifications#mark-a-thread-as-done)
    ///
    /// ---
    #[cfg(not(target_arch = "wasm32"))]
    pub fn mark_thread_as_done(&self, thread_id: i32) -> Result<(), AdapterError> {

        let request_uri = format!("{}/notifications/threads/{}", super::GITHUB_BASE_API_URL, thread_id);


        let req = GitHubRequest {
            uri: request_uri,
            body: None,
            method: "DELETE",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch(request)?;

        // --

        if github_response.is_success() {
            Ok(github_response.to_json()?)
        } else {
            match github_response.status_code() {
                code => Err(ActivityMarkThreadAsDoneError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # Mark a thread as read
    ///
    /// Marks a thread as "read." Marking a thread as "read" is equivalent to clicking a notification in your notification inbox on GitHub: https://github.com/notifications.
    ///
    /// [GitHub API docs for mark_thread_as_read](https://docs.github.com/rest/activity/notifications#mark-a-thread-as-read)
    ///
    /// ---
    pub async fn mark_thread_as_read_async(&self, thread_id: i32) -> Result<(), AdapterError> {

        let request_uri = format!("{}/notifications/threads/{}", super::GITHUB_BASE_API_URL, thread_id);


        let req = GitHubRequest {
            uri: request_uri,
            body: None::<C::Body>,
            method: "PATCH",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch_async(request).await?;

        // --

        if github_response.is_success() {
            Ok(github_response.to_json_async().await?)
        } else {
            match github_response.status_code() {
                304 => Err(ActivityMarkThreadAsReadError::Status304.into()),
                403 => Err(ActivityMarkThreadAsReadError::Status403(github_response.to_json_async().await?).into()),
                code => Err(ActivityMarkThreadAsReadError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # Mark a thread as read
    ///
    /// Marks a thread as "read." Marking a thread as "read" is equivalent to clicking a notification in your notification inbox on GitHub: https://github.com/notifications.
    ///
    /// [GitHub API docs for mark_thread_as_read](https://docs.github.com/rest/activity/notifications#mark-a-thread-as-read)
    ///
    /// ---
    #[cfg(not(target_arch = "wasm32"))]
    pub fn mark_thread_as_read(&self, thread_id: i32) -> Result<(), AdapterError> {

        let request_uri = format!("{}/notifications/threads/{}", super::GITHUB_BASE_API_URL, thread_id);


        let req = GitHubRequest {
            uri: request_uri,
            body: None,
            method: "PATCH",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch(request)?;

        // --

        if github_response.is_success() {
            Ok(github_response.to_json()?)
        } else {
            match github_response.status_code() {
                304 => Err(ActivityMarkThreadAsReadError::Status304.into()),
                403 => Err(ActivityMarkThreadAsReadError::Status403(github_response.to_json()?).into()),
                code => Err(ActivityMarkThreadAsReadError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # Set a repository subscription
    ///
    /// If you would like to watch a repository, set `subscribed` to `true`. If you would like to ignore notifications made within a repository, set `ignored` to `true`. If you would like to stop watching a repository, [delete the repository's subscription](https://docs.github.com/rest/activity/watching#delete-a-repository-subscription) completely.
    ///
    /// [GitHub API docs for set_repo_subscription](https://docs.github.com/rest/activity/watching#set-a-repository-subscription)
    ///
    /// ---
    pub async fn set_repo_subscription_async(&self, owner: &str, repo: &str, body: PutActivitySetRepoSubscription) -> Result<RepositorySubscription, AdapterError> {

        let request_uri = format!("{}/repos/{}/{}/subscription", super::GITHUB_BASE_API_URL, owner, repo);


        let req = GitHubRequest {
            uri: request_uri,
            body: Some(C::from_json::<PutActivitySetRepoSubscription>(body)?),
            method: "PUT",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch_async(request).await?;

        // --

        if github_response.is_success() {
            Ok(github_response.to_json_async().await?)
        } else {
            match github_response.status_code() {
                code => Err(ActivitySetRepoSubscriptionError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # Set a repository subscription
    ///
    /// If you would like to watch a repository, set `subscribed` to `true`. If you would like to ignore notifications made within a repository, set `ignored` to `true`. If you would like to stop watching a repository, [delete the repository's subscription](https://docs.github.com/rest/activity/watching#delete-a-repository-subscription) completely.
    ///
    /// [GitHub API docs for set_repo_subscription](https://docs.github.com/rest/activity/watching#set-a-repository-subscription)
    ///
    /// ---
    #[cfg(not(target_arch = "wasm32"))]
    pub fn set_repo_subscription(&self, owner: &str, repo: &str, body: PutActivitySetRepoSubscription) -> Result<RepositorySubscription, AdapterError> {

        let request_uri = format!("{}/repos/{}/{}/subscription", super::GITHUB_BASE_API_URL, owner, repo);


        let req = GitHubRequest {
            uri: request_uri,
            body: Some(C::from_json::<PutActivitySetRepoSubscription>(body)?),
            method: "PUT",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch(request)?;

        // --

        if github_response.is_success() {
            Ok(github_response.to_json()?)
        } else {
            match github_response.status_code() {
                code => Err(ActivitySetRepoSubscriptionError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # Set a thread subscription
    ///
    /// If you are watching a repository, you receive notifications for all threads by default. Use this endpoint to ignore future notifications for threads until you comment on the thread or get an **@mention**.
    /// 
    /// You can also use this endpoint to subscribe to threads that you are currently not receiving notifications for or to subscribed to threads that you have previously ignored.
    /// 
    /// Unsubscribing from a conversation in a repository that you are not watching is functionally equivalent to the [Delete a thread subscription](https://docs.github.com/rest/activity/notifications#delete-a-thread-subscription) endpoint.
    ///
    /// [GitHub API docs for set_thread_subscription](https://docs.github.com/rest/activity/notifications#set-a-thread-subscription)
    ///
    /// ---
    pub async fn set_thread_subscription_async(&self, thread_id: i32, body: PutActivitySetThreadSubscription) -> Result<ThreadSubscription, AdapterError> {

        let request_uri = format!("{}/notifications/threads/{}/subscription", super::GITHUB_BASE_API_URL, thread_id);


        let req = GitHubRequest {
            uri: request_uri,
            body: Some(C::from_json::<PutActivitySetThreadSubscription>(body)?),
            method: "PUT",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch_async(request).await?;

        // --

        if github_response.is_success() {
            Ok(github_response.to_json_async().await?)
        } else {
            match github_response.status_code() {
                304 => Err(ActivitySetThreadSubscriptionError::Status304.into()),
                403 => Err(ActivitySetThreadSubscriptionError::Status403(github_response.to_json_async().await?).into()),
                401 => Err(ActivitySetThreadSubscriptionError::Status401(github_response.to_json_async().await?).into()),
                code => Err(ActivitySetThreadSubscriptionError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # Set a thread subscription
    ///
    /// If you are watching a repository, you receive notifications for all threads by default. Use this endpoint to ignore future notifications for threads until you comment on the thread or get an **@mention**.
    /// 
    /// You can also use this endpoint to subscribe to threads that you are currently not receiving notifications for or to subscribed to threads that you have previously ignored.
    /// 
    /// Unsubscribing from a conversation in a repository that you are not watching is functionally equivalent to the [Delete a thread subscription](https://docs.github.com/rest/activity/notifications#delete-a-thread-subscription) endpoint.
    ///
    /// [GitHub API docs for set_thread_subscription](https://docs.github.com/rest/activity/notifications#set-a-thread-subscription)
    ///
    /// ---
    #[cfg(not(target_arch = "wasm32"))]
    pub fn set_thread_subscription(&self, thread_id: i32, body: PutActivitySetThreadSubscription) -> Result<ThreadSubscription, AdapterError> {

        let request_uri = format!("{}/notifications/threads/{}/subscription", super::GITHUB_BASE_API_URL, thread_id);


        let req = GitHubRequest {
            uri: request_uri,
            body: Some(C::from_json::<PutActivitySetThreadSubscription>(body)?),
            method: "PUT",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch(request)?;

        // --

        if github_response.is_success() {
            Ok(github_response.to_json()?)
        } else {
            match github_response.status_code() {
                304 => Err(ActivitySetThreadSubscriptionError::Status304.into()),
                403 => Err(ActivitySetThreadSubscriptionError::Status403(github_response.to_json()?).into()),
                401 => Err(ActivitySetThreadSubscriptionError::Status401(github_response.to_json()?).into()),
                code => Err(ActivitySetThreadSubscriptionError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # Star a repository for the authenticated user
    ///
    /// Note that you'll need to set `Content-Length` to zero when calling out to this endpoint. For more information, see "[HTTP method](https://docs.github.com/rest/guides/getting-started-with-the-rest-api#http-method)."
    ///
    /// [GitHub API docs for star_repo_for_authenticated_user](https://docs.github.com/rest/activity/starring#star-a-repository-for-the-authenticated-user)
    ///
    /// ---
    pub async fn star_repo_for_authenticated_user_async(&self, owner: &str, repo: &str) -> Result<(), AdapterError> {

        let request_uri = format!("{}/user/starred/{}/{}", super::GITHUB_BASE_API_URL, owner, repo);


        let req = GitHubRequest {
            uri: request_uri,
            body: None::<C::Body>,
            method: "PUT",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch_async(request).await?;

        // --

        if github_response.is_success() {
            Ok(github_response.to_json_async().await?)
        } else {
            match github_response.status_code() {
                403 => Err(ActivityStarRepoForAuthenticatedUserError::Status403(github_response.to_json_async().await?).into()),
                404 => Err(ActivityStarRepoForAuthenticatedUserError::Status404(github_response.to_json_async().await?).into()),
                401 => Err(ActivityStarRepoForAuthenticatedUserError::Status401(github_response.to_json_async().await?).into()),
                304 => Err(ActivityStarRepoForAuthenticatedUserError::Status304.into()),
                code => Err(ActivityStarRepoForAuthenticatedUserError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # Star a repository for the authenticated user
    ///
    /// Note that you'll need to set `Content-Length` to zero when calling out to this endpoint. For more information, see "[HTTP method](https://docs.github.com/rest/guides/getting-started-with-the-rest-api#http-method)."
    ///
    /// [GitHub API docs for star_repo_for_authenticated_user](https://docs.github.com/rest/activity/starring#star-a-repository-for-the-authenticated-user)
    ///
    /// ---
    #[cfg(not(target_arch = "wasm32"))]
    pub fn star_repo_for_authenticated_user(&self, owner: &str, repo: &str) -> Result<(), AdapterError> {

        let request_uri = format!("{}/user/starred/{}/{}", super::GITHUB_BASE_API_URL, owner, repo);


        let req = GitHubRequest {
            uri: request_uri,
            body: None,
            method: "PUT",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch(request)?;

        // --

        if github_response.is_success() {
            Ok(github_response.to_json()?)
        } else {
            match github_response.status_code() {
                403 => Err(ActivityStarRepoForAuthenticatedUserError::Status403(github_response.to_json()?).into()),
                404 => Err(ActivityStarRepoForAuthenticatedUserError::Status404(github_response.to_json()?).into()),
                401 => Err(ActivityStarRepoForAuthenticatedUserError::Status401(github_response.to_json()?).into()),
                304 => Err(ActivityStarRepoForAuthenticatedUserError::Status304.into()),
                code => Err(ActivityStarRepoForAuthenticatedUserError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # Unstar a repository for the authenticated user
    ///
    /// Unstar a repository that the authenticated user has previously starred.
    ///
    /// [GitHub API docs for unstar_repo_for_authenticated_user](https://docs.github.com/rest/activity/starring#unstar-a-repository-for-the-authenticated-user)
    ///
    /// ---
    pub async fn unstar_repo_for_authenticated_user_async(&self, owner: &str, repo: &str) -> Result<(), AdapterError> {

        let request_uri = format!("{}/user/starred/{}/{}", super::GITHUB_BASE_API_URL, owner, repo);


        let req = GitHubRequest {
            uri: request_uri,
            body: None::<C::Body>,
            method: "DELETE",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch_async(request).await?;

        // --

        if github_response.is_success() {
            Ok(github_response.to_json_async().await?)
        } else {
            match github_response.status_code() {
                404 => Err(ActivityUnstarRepoForAuthenticatedUserError::Status404(github_response.to_json_async().await?).into()),
                401 => Err(ActivityUnstarRepoForAuthenticatedUserError::Status401(github_response.to_json_async().await?).into()),
                304 => Err(ActivityUnstarRepoForAuthenticatedUserError::Status304.into()),
                403 => Err(ActivityUnstarRepoForAuthenticatedUserError::Status403(github_response.to_json_async().await?).into()),
                code => Err(ActivityUnstarRepoForAuthenticatedUserError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # Unstar a repository for the authenticated user
    ///
    /// Unstar a repository that the authenticated user has previously starred.
    ///
    /// [GitHub API docs for unstar_repo_for_authenticated_user](https://docs.github.com/rest/activity/starring#unstar-a-repository-for-the-authenticated-user)
    ///
    /// ---
    #[cfg(not(target_arch = "wasm32"))]
    pub fn unstar_repo_for_authenticated_user(&self, owner: &str, repo: &str) -> Result<(), AdapterError> {

        let request_uri = format!("{}/user/starred/{}/{}", super::GITHUB_BASE_API_URL, owner, repo);


        let req = GitHubRequest {
            uri: request_uri,
            body: None,
            method: "DELETE",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch(request)?;

        // --

        if github_response.is_success() {
            Ok(github_response.to_json()?)
        } else {
            match github_response.status_code() {
                404 => Err(ActivityUnstarRepoForAuthenticatedUserError::Status404(github_response.to_json()?).into()),
                401 => Err(ActivityUnstarRepoForAuthenticatedUserError::Status401(github_response.to_json()?).into()),
                304 => Err(ActivityUnstarRepoForAuthenticatedUserError::Status304.into()),
                403 => Err(ActivityUnstarRepoForAuthenticatedUserError::Status403(github_response.to_json()?).into()),
                code => Err(ActivityUnstarRepoForAuthenticatedUserError::Generic { code }.into()),
            }
        }
    }

}
