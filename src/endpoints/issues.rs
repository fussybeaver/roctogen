//! Method, error and parameter types for the Issues endpoint.
#![allow(
    clippy::all
)]
/* 
 * GitHub v3 REST API
 *
 * GitHub's v3 REST API.
 *
 * OpenAPI spec version: 1.1.4
 * 
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 */

use serde::Deserialize;

use crate::adapters::{AdapterError, Client, GitHubRequest, GitHubResponseExt};
use crate::models::*;

use super::PerPage;

use std::collections::HashMap;
use serde_json::value::Value;

pub struct Issues<'api, C: Client> where AdapterError: From<<C as Client>::Err> {
    client: &'api C
}

pub fn new<C: Client>(client: &C) -> Issues<C> where AdapterError: From<<C as Client>::Err> {
    Issues { client }
}

/// Errors for the [Add assignees to an issue](Issues::add_assignees_async()) endpoint.
#[derive(Debug, thiserror::Error)]
pub enum IssuesAddAssigneesError {
    #[error("Status code: {}", code)]
    Generic { code: u16 },
}

impl From<IssuesAddAssigneesError> for AdapterError {
    fn from(err: IssuesAddAssigneesError) -> Self {
        let (description, status_code) = match err {
            IssuesAddAssigneesError::Generic { code } => (String::from("Generic"), code)
        };

        Self::Endpoint {
            description,
            status_code,
            source: Some(Box::new(err))
        }
    }
}

/// Errors for the [Add labels to an issue](Issues::add_labels_async()) endpoint.
#[derive(Debug, thiserror::Error)]
pub enum IssuesAddLabelsError {
    #[error("Moved permanently")]
    Status301(BasicError),
    #[error("Resource not found")]
    Status404(BasicError),
    #[error("Gone")]
    Status410(BasicError),
    #[error("Validation failed, or the endpoint has been spammed.")]
    Status422(ValidationError),
    #[error("Status code: {}", code)]
    Generic { code: u16 },
}

impl From<IssuesAddLabelsError> for AdapterError {
    fn from(err: IssuesAddLabelsError) -> Self {
        let (description, status_code) = match err {
            IssuesAddLabelsError::Status301(_) => (String::from("Moved permanently"), 301),
            IssuesAddLabelsError::Status404(_) => (String::from("Resource not found"), 404),
            IssuesAddLabelsError::Status410(_) => (String::from("Gone"), 410),
            IssuesAddLabelsError::Status422(_) => (String::from("Validation failed, or the endpoint has been spammed."), 422),
            IssuesAddLabelsError::Generic { code } => (String::from("Generic"), code)
        };

        Self::Endpoint {
            description,
            status_code,
            source: Some(Box::new(err))
        }
    }
}

/// Errors for the [Check if a user can be assigned](Issues::check_user_can_be_assigned_async()) endpoint.
#[derive(Debug, thiserror::Error)]
pub enum IssuesCheckUserCanBeAssignedError {
    #[error("Otherwise a `404` status code is returned.")]
    Status404(BasicError),
    #[error("Status code: {}", code)]
    Generic { code: u16 },
}

impl From<IssuesCheckUserCanBeAssignedError> for AdapterError {
    fn from(err: IssuesCheckUserCanBeAssignedError) -> Self {
        let (description, status_code) = match err {
            IssuesCheckUserCanBeAssignedError::Status404(_) => (String::from("Otherwise a `404` status code is returned."), 404),
            IssuesCheckUserCanBeAssignedError::Generic { code } => (String::from("Generic"), code)
        };

        Self::Endpoint {
            description,
            status_code,
            source: Some(Box::new(err))
        }
    }
}

/// Errors for the [Check if a user can be assigned to a issue](Issues::check_user_can_be_assigned_to_issue_async()) endpoint.
#[derive(Debug, thiserror::Error)]
pub enum IssuesCheckUserCanBeAssignedToIssueError {
    #[error("Response if `assignee` can not be assigned to `issue_number`")]
    Status404(BasicError),
    #[error("Status code: {}", code)]
    Generic { code: u16 },
}

impl From<IssuesCheckUserCanBeAssignedToIssueError> for AdapterError {
    fn from(err: IssuesCheckUserCanBeAssignedToIssueError) -> Self {
        let (description, status_code) = match err {
            IssuesCheckUserCanBeAssignedToIssueError::Status404(_) => (String::from("Response if `assignee` can not be assigned to `issue_number`"), 404),
            IssuesCheckUserCanBeAssignedToIssueError::Generic { code } => (String::from("Generic"), code)
        };

        Self::Endpoint {
            description,
            status_code,
            source: Some(Box::new(err))
        }
    }
}

/// Errors for the [Create an issue](Issues::create_async()) endpoint.
#[derive(Debug, thiserror::Error)]
pub enum IssuesCreateError {
    #[error("Bad Request")]
    Status400(BasicError),
    #[error("Forbidden")]
    Status403(BasicError),
    #[error("Validation failed, or the endpoint has been spammed.")]
    Status422(ValidationError),
    #[error("Service unavailable")]
    Status503(PostCodespacesCreateForAuthenticatedUserResponse503),
    #[error("Resource not found")]
    Status404(BasicError),
    #[error("Gone")]
    Status410(BasicError),
    #[error("Status code: {}", code)]
    Generic { code: u16 },
}

impl From<IssuesCreateError> for AdapterError {
    fn from(err: IssuesCreateError) -> Self {
        let (description, status_code) = match err {
            IssuesCreateError::Status400(_) => (String::from("Bad Request"), 400),
            IssuesCreateError::Status403(_) => (String::from("Forbidden"), 403),
            IssuesCreateError::Status422(_) => (String::from("Validation failed, or the endpoint has been spammed."), 422),
            IssuesCreateError::Status503(_) => (String::from("Service unavailable"), 503),
            IssuesCreateError::Status404(_) => (String::from("Resource not found"), 404),
            IssuesCreateError::Status410(_) => (String::from("Gone"), 410),
            IssuesCreateError::Generic { code } => (String::from("Generic"), code)
        };

        Self::Endpoint {
            description,
            status_code,
            source: Some(Box::new(err))
        }
    }
}

/// Errors for the [Create an issue comment](Issues::create_comment_async()) endpoint.
#[derive(Debug, thiserror::Error)]
pub enum IssuesCreateCommentError {
    #[error("Forbidden")]
    Status403(BasicError),
    #[error("Gone")]
    Status410(BasicError),
    #[error("Validation failed, or the endpoint has been spammed.")]
    Status422(ValidationError),
    #[error("Resource not found")]
    Status404(BasicError),
    #[error("Status code: {}", code)]
    Generic { code: u16 },
}

impl From<IssuesCreateCommentError> for AdapterError {
    fn from(err: IssuesCreateCommentError) -> Self {
        let (description, status_code) = match err {
            IssuesCreateCommentError::Status403(_) => (String::from("Forbidden"), 403),
            IssuesCreateCommentError::Status410(_) => (String::from("Gone"), 410),
            IssuesCreateCommentError::Status422(_) => (String::from("Validation failed, or the endpoint has been spammed."), 422),
            IssuesCreateCommentError::Status404(_) => (String::from("Resource not found"), 404),
            IssuesCreateCommentError::Generic { code } => (String::from("Generic"), code)
        };

        Self::Endpoint {
            description,
            status_code,
            source: Some(Box::new(err))
        }
    }
}

/// Errors for the [Create a label](Issues::create_label_async()) endpoint.
#[derive(Debug, thiserror::Error)]
pub enum IssuesCreateLabelError {
    #[error("Validation failed, or the endpoint has been spammed.")]
    Status422(ValidationError),
    #[error("Resource not found")]
    Status404(BasicError),
    #[error("Status code: {}", code)]
    Generic { code: u16 },
}

impl From<IssuesCreateLabelError> for AdapterError {
    fn from(err: IssuesCreateLabelError) -> Self {
        let (description, status_code) = match err {
            IssuesCreateLabelError::Status422(_) => (String::from("Validation failed, or the endpoint has been spammed."), 422),
            IssuesCreateLabelError::Status404(_) => (String::from("Resource not found"), 404),
            IssuesCreateLabelError::Generic { code } => (String::from("Generic"), code)
        };

        Self::Endpoint {
            description,
            status_code,
            source: Some(Box::new(err))
        }
    }
}

/// Errors for the [Create a milestone](Issues::create_milestone_async()) endpoint.
#[derive(Debug, thiserror::Error)]
pub enum IssuesCreateMilestoneError {
    #[error("Resource not found")]
    Status404(BasicError),
    #[error("Validation failed, or the endpoint has been spammed.")]
    Status422(ValidationError),
    #[error("Status code: {}", code)]
    Generic { code: u16 },
}

impl From<IssuesCreateMilestoneError> for AdapterError {
    fn from(err: IssuesCreateMilestoneError) -> Self {
        let (description, status_code) = match err {
            IssuesCreateMilestoneError::Status404(_) => (String::from("Resource not found"), 404),
            IssuesCreateMilestoneError::Status422(_) => (String::from("Validation failed, or the endpoint has been spammed."), 422),
            IssuesCreateMilestoneError::Generic { code } => (String::from("Generic"), code)
        };

        Self::Endpoint {
            description,
            status_code,
            source: Some(Box::new(err))
        }
    }
}

/// Errors for the [Delete an issue comment](Issues::delete_comment_async()) endpoint.
#[derive(Debug, thiserror::Error)]
pub enum IssuesDeleteCommentError {
    #[error("Status code: {}", code)]
    Generic { code: u16 },
}

impl From<IssuesDeleteCommentError> for AdapterError {
    fn from(err: IssuesDeleteCommentError) -> Self {
        let (description, status_code) = match err {
            IssuesDeleteCommentError::Generic { code } => (String::from("Generic"), code)
        };

        Self::Endpoint {
            description,
            status_code,
            source: Some(Box::new(err))
        }
    }
}

/// Errors for the [Delete a label](Issues::delete_label_async()) endpoint.
#[derive(Debug, thiserror::Error)]
pub enum IssuesDeleteLabelError {
    #[error("Status code: {}", code)]
    Generic { code: u16 },
}

impl From<IssuesDeleteLabelError> for AdapterError {
    fn from(err: IssuesDeleteLabelError) -> Self {
        let (description, status_code) = match err {
            IssuesDeleteLabelError::Generic { code } => (String::from("Generic"), code)
        };

        Self::Endpoint {
            description,
            status_code,
            source: Some(Box::new(err))
        }
    }
}

/// Errors for the [Delete a milestone](Issues::delete_milestone_async()) endpoint.
#[derive(Debug, thiserror::Error)]
pub enum IssuesDeleteMilestoneError {
    #[error("Resource not found")]
    Status404(BasicError),
    #[error("Status code: {}", code)]
    Generic { code: u16 },
}

impl From<IssuesDeleteMilestoneError> for AdapterError {
    fn from(err: IssuesDeleteMilestoneError) -> Self {
        let (description, status_code) = match err {
            IssuesDeleteMilestoneError::Status404(_) => (String::from("Resource not found"), 404),
            IssuesDeleteMilestoneError::Generic { code } => (String::from("Generic"), code)
        };

        Self::Endpoint {
            description,
            status_code,
            source: Some(Box::new(err))
        }
    }
}

/// Errors for the [Get an issue](Issues::get_async()) endpoint.
#[derive(Debug, thiserror::Error)]
pub enum IssuesGetError {
    #[error("Moved permanently")]
    Status301(BasicError),
    #[error("Resource not found")]
    Status404(BasicError),
    #[error("Gone")]
    Status410(BasicError),
    #[error("Not modified")]
    Status304,
    #[error("Status code: {}", code)]
    Generic { code: u16 },
}

impl From<IssuesGetError> for AdapterError {
    fn from(err: IssuesGetError) -> Self {
        let (description, status_code) = match err {
            IssuesGetError::Status301(_) => (String::from("Moved permanently"), 301),
            IssuesGetError::Status404(_) => (String::from("Resource not found"), 404),
            IssuesGetError::Status410(_) => (String::from("Gone"), 410),
            IssuesGetError::Status304 => (String::from("Not modified"), 304),
            IssuesGetError::Generic { code } => (String::from("Generic"), code)
        };

        Self::Endpoint {
            description,
            status_code,
            source: Some(Box::new(err))
        }
    }
}

/// Errors for the [Get an issue comment](Issues::get_comment_async()) endpoint.
#[derive(Debug, thiserror::Error)]
pub enum IssuesGetCommentError {
    #[error("Resource not found")]
    Status404(BasicError),
    #[error("Status code: {}", code)]
    Generic { code: u16 },
}

impl From<IssuesGetCommentError> for AdapterError {
    fn from(err: IssuesGetCommentError) -> Self {
        let (description, status_code) = match err {
            IssuesGetCommentError::Status404(_) => (String::from("Resource not found"), 404),
            IssuesGetCommentError::Generic { code } => (String::from("Generic"), code)
        };

        Self::Endpoint {
            description,
            status_code,
            source: Some(Box::new(err))
        }
    }
}

/// Errors for the [Get an issue event](Issues::get_event_async()) endpoint.
#[derive(Debug, thiserror::Error)]
pub enum IssuesGetEventError {
    #[error("Resource not found")]
    Status404(BasicError),
    #[error("Gone")]
    Status410(BasicError),
    #[error("Forbidden")]
    Status403(BasicError),
    #[error("Status code: {}", code)]
    Generic { code: u16 },
}

impl From<IssuesGetEventError> for AdapterError {
    fn from(err: IssuesGetEventError) -> Self {
        let (description, status_code) = match err {
            IssuesGetEventError::Status404(_) => (String::from("Resource not found"), 404),
            IssuesGetEventError::Status410(_) => (String::from("Gone"), 410),
            IssuesGetEventError::Status403(_) => (String::from("Forbidden"), 403),
            IssuesGetEventError::Generic { code } => (String::from("Generic"), code)
        };

        Self::Endpoint {
            description,
            status_code,
            source: Some(Box::new(err))
        }
    }
}

/// Errors for the [Get a label](Issues::get_label_async()) endpoint.
#[derive(Debug, thiserror::Error)]
pub enum IssuesGetLabelError {
    #[error("Resource not found")]
    Status404(BasicError),
    #[error("Status code: {}", code)]
    Generic { code: u16 },
}

impl From<IssuesGetLabelError> for AdapterError {
    fn from(err: IssuesGetLabelError) -> Self {
        let (description, status_code) = match err {
            IssuesGetLabelError::Status404(_) => (String::from("Resource not found"), 404),
            IssuesGetLabelError::Generic { code } => (String::from("Generic"), code)
        };

        Self::Endpoint {
            description,
            status_code,
            source: Some(Box::new(err))
        }
    }
}

/// Errors for the [Get a milestone](Issues::get_milestone_async()) endpoint.
#[derive(Debug, thiserror::Error)]
pub enum IssuesGetMilestoneError {
    #[error("Resource not found")]
    Status404(BasicError),
    #[error("Status code: {}", code)]
    Generic { code: u16 },
}

impl From<IssuesGetMilestoneError> for AdapterError {
    fn from(err: IssuesGetMilestoneError) -> Self {
        let (description, status_code) = match err {
            IssuesGetMilestoneError::Status404(_) => (String::from("Resource not found"), 404),
            IssuesGetMilestoneError::Generic { code } => (String::from("Generic"), code)
        };

        Self::Endpoint {
            description,
            status_code,
            source: Some(Box::new(err))
        }
    }
}

/// Errors for the [List issues assigned to the authenticated user](Issues::list_async()) endpoint.
#[derive(Debug, thiserror::Error)]
pub enum IssuesListError {
    #[error("Validation failed, or the endpoint has been spammed.")]
    Status422(ValidationError),
    #[error("Not modified")]
    Status304,
    #[error("Resource not found")]
    Status404(BasicError),
    #[error("Status code: {}", code)]
    Generic { code: u16 },
}

impl From<IssuesListError> for AdapterError {
    fn from(err: IssuesListError) -> Self {
        let (description, status_code) = match err {
            IssuesListError::Status422(_) => (String::from("Validation failed, or the endpoint has been spammed."), 422),
            IssuesListError::Status304 => (String::from("Not modified"), 304),
            IssuesListError::Status404(_) => (String::from("Resource not found"), 404),
            IssuesListError::Generic { code } => (String::from("Generic"), code)
        };

        Self::Endpoint {
            description,
            status_code,
            source: Some(Box::new(err))
        }
    }
}

/// Errors for the [List assignees](Issues::list_assignees_async()) endpoint.
#[derive(Debug, thiserror::Error)]
pub enum IssuesListAssigneesError {
    #[error("Resource not found")]
    Status404(BasicError),
    #[error("Status code: {}", code)]
    Generic { code: u16 },
}

impl From<IssuesListAssigneesError> for AdapterError {
    fn from(err: IssuesListAssigneesError) -> Self {
        let (description, status_code) = match err {
            IssuesListAssigneesError::Status404(_) => (String::from("Resource not found"), 404),
            IssuesListAssigneesError::Generic { code } => (String::from("Generic"), code)
        };

        Self::Endpoint {
            description,
            status_code,
            source: Some(Box::new(err))
        }
    }
}

/// Errors for the [List issue comments](Issues::list_comments_async()) endpoint.
#[derive(Debug, thiserror::Error)]
pub enum IssuesListCommentsError {
    #[error("Resource not found")]
    Status404(BasicError),
    #[error("Gone")]
    Status410(BasicError),
    #[error("Status code: {}", code)]
    Generic { code: u16 },
}

impl From<IssuesListCommentsError> for AdapterError {
    fn from(err: IssuesListCommentsError) -> Self {
        let (description, status_code) = match err {
            IssuesListCommentsError::Status404(_) => (String::from("Resource not found"), 404),
            IssuesListCommentsError::Status410(_) => (String::from("Gone"), 410),
            IssuesListCommentsError::Generic { code } => (String::from("Generic"), code)
        };

        Self::Endpoint {
            description,
            status_code,
            source: Some(Box::new(err))
        }
    }
}

/// Errors for the [List issue comments for a repository](Issues::list_comments_for_repo_async()) endpoint.
#[derive(Debug, thiserror::Error)]
pub enum IssuesListCommentsForRepoError {
    #[error("Validation failed, or the endpoint has been spammed.")]
    Status422(ValidationError),
    #[error("Resource not found")]
    Status404(BasicError),
    #[error("Status code: {}", code)]
    Generic { code: u16 },
}

impl From<IssuesListCommentsForRepoError> for AdapterError {
    fn from(err: IssuesListCommentsForRepoError) -> Self {
        let (description, status_code) = match err {
            IssuesListCommentsForRepoError::Status422(_) => (String::from("Validation failed, or the endpoint has been spammed."), 422),
            IssuesListCommentsForRepoError::Status404(_) => (String::from("Resource not found"), 404),
            IssuesListCommentsForRepoError::Generic { code } => (String::from("Generic"), code)
        };

        Self::Endpoint {
            description,
            status_code,
            source: Some(Box::new(err))
        }
    }
}

/// Errors for the [List issue events](Issues::list_events_async()) endpoint.
#[derive(Debug, thiserror::Error)]
pub enum IssuesListEventsError {
    #[error("Gone")]
    Status410(BasicError),
    #[error("Status code: {}", code)]
    Generic { code: u16 },
}

impl From<IssuesListEventsError> for AdapterError {
    fn from(err: IssuesListEventsError) -> Self {
        let (description, status_code) = match err {
            IssuesListEventsError::Status410(_) => (String::from("Gone"), 410),
            IssuesListEventsError::Generic { code } => (String::from("Generic"), code)
        };

        Self::Endpoint {
            description,
            status_code,
            source: Some(Box::new(err))
        }
    }
}

/// Errors for the [List issue events for a repository](Issues::list_events_for_repo_async()) endpoint.
#[derive(Debug, thiserror::Error)]
pub enum IssuesListEventsForRepoError {
    #[error("Validation failed, or the endpoint has been spammed.")]
    Status422(ValidationError),
    #[error("Status code: {}", code)]
    Generic { code: u16 },
}

impl From<IssuesListEventsForRepoError> for AdapterError {
    fn from(err: IssuesListEventsForRepoError) -> Self {
        let (description, status_code) = match err {
            IssuesListEventsForRepoError::Status422(_) => (String::from("Validation failed, or the endpoint has been spammed."), 422),
            IssuesListEventsForRepoError::Generic { code } => (String::from("Generic"), code)
        };

        Self::Endpoint {
            description,
            status_code,
            source: Some(Box::new(err))
        }
    }
}

/// Errors for the [List timeline events for an issue](Issues::list_events_for_timeline_async()) endpoint.
#[derive(Debug, thiserror::Error)]
pub enum IssuesListEventsForTimelineError {
    #[error("Resource not found")]
    Status404(BasicError),
    #[error("Gone")]
    Status410(BasicError),
    #[error("Status code: {}", code)]
    Generic { code: u16 },
}

impl From<IssuesListEventsForTimelineError> for AdapterError {
    fn from(err: IssuesListEventsForTimelineError) -> Self {
        let (description, status_code) = match err {
            IssuesListEventsForTimelineError::Status404(_) => (String::from("Resource not found"), 404),
            IssuesListEventsForTimelineError::Status410(_) => (String::from("Gone"), 410),
            IssuesListEventsForTimelineError::Generic { code } => (String::from("Generic"), code)
        };

        Self::Endpoint {
            description,
            status_code,
            source: Some(Box::new(err))
        }
    }
}

/// Errors for the [List user account issues assigned to the authenticated user](Issues::list_for_authenticated_user_async()) endpoint.
#[derive(Debug, thiserror::Error)]
pub enum IssuesListForAuthenticatedUserError {
    #[error("Resource not found")]
    Status404(BasicError),
    #[error("Not modified")]
    Status304,
    #[error("Status code: {}", code)]
    Generic { code: u16 },
}

impl From<IssuesListForAuthenticatedUserError> for AdapterError {
    fn from(err: IssuesListForAuthenticatedUserError) -> Self {
        let (description, status_code) = match err {
            IssuesListForAuthenticatedUserError::Status404(_) => (String::from("Resource not found"), 404),
            IssuesListForAuthenticatedUserError::Status304 => (String::from("Not modified"), 304),
            IssuesListForAuthenticatedUserError::Generic { code } => (String::from("Generic"), code)
        };

        Self::Endpoint {
            description,
            status_code,
            source: Some(Box::new(err))
        }
    }
}

/// Errors for the [List organization issues assigned to the authenticated user](Issues::list_for_org_async()) endpoint.
#[derive(Debug, thiserror::Error)]
pub enum IssuesListForOrgError {
    #[error("Resource not found")]
    Status404(BasicError),
    #[error("Status code: {}", code)]
    Generic { code: u16 },
}

impl From<IssuesListForOrgError> for AdapterError {
    fn from(err: IssuesListForOrgError) -> Self {
        let (description, status_code) = match err {
            IssuesListForOrgError::Status404(_) => (String::from("Resource not found"), 404),
            IssuesListForOrgError::Generic { code } => (String::from("Generic"), code)
        };

        Self::Endpoint {
            description,
            status_code,
            source: Some(Box::new(err))
        }
    }
}

/// Errors for the [List repository issues](Issues::list_for_repo_async()) endpoint.
#[derive(Debug, thiserror::Error)]
pub enum IssuesListForRepoError {
    #[error("Moved permanently")]
    Status301(BasicError),
    #[error("Validation failed, or the endpoint has been spammed.")]
    Status422(ValidationError),
    #[error("Resource not found")]
    Status404(BasicError),
    #[error("Status code: {}", code)]
    Generic { code: u16 },
}

impl From<IssuesListForRepoError> for AdapterError {
    fn from(err: IssuesListForRepoError) -> Self {
        let (description, status_code) = match err {
            IssuesListForRepoError::Status301(_) => (String::from("Moved permanently"), 301),
            IssuesListForRepoError::Status422(_) => (String::from("Validation failed, or the endpoint has been spammed."), 422),
            IssuesListForRepoError::Status404(_) => (String::from("Resource not found"), 404),
            IssuesListForRepoError::Generic { code } => (String::from("Generic"), code)
        };

        Self::Endpoint {
            description,
            status_code,
            source: Some(Box::new(err))
        }
    }
}

/// Errors for the [List labels for issues in a milestone](Issues::list_labels_for_milestone_async()) endpoint.
#[derive(Debug, thiserror::Error)]
pub enum IssuesListLabelsForMilestoneError {
    #[error("Status code: {}", code)]
    Generic { code: u16 },
}

impl From<IssuesListLabelsForMilestoneError> for AdapterError {
    fn from(err: IssuesListLabelsForMilestoneError) -> Self {
        let (description, status_code) = match err {
            IssuesListLabelsForMilestoneError::Generic { code } => (String::from("Generic"), code)
        };

        Self::Endpoint {
            description,
            status_code,
            source: Some(Box::new(err))
        }
    }
}

/// Errors for the [List labels for a repository](Issues::list_labels_for_repo_async()) endpoint.
#[derive(Debug, thiserror::Error)]
pub enum IssuesListLabelsForRepoError {
    #[error("Resource not found")]
    Status404(BasicError),
    #[error("Status code: {}", code)]
    Generic { code: u16 },
}

impl From<IssuesListLabelsForRepoError> for AdapterError {
    fn from(err: IssuesListLabelsForRepoError) -> Self {
        let (description, status_code) = match err {
            IssuesListLabelsForRepoError::Status404(_) => (String::from("Resource not found"), 404),
            IssuesListLabelsForRepoError::Generic { code } => (String::from("Generic"), code)
        };

        Self::Endpoint {
            description,
            status_code,
            source: Some(Box::new(err))
        }
    }
}

/// Errors for the [List labels for an issue](Issues::list_labels_on_issue_async()) endpoint.
#[derive(Debug, thiserror::Error)]
pub enum IssuesListLabelsOnIssueError {
    #[error("Moved permanently")]
    Status301(BasicError),
    #[error("Resource not found")]
    Status404(BasicError),
    #[error("Gone")]
    Status410(BasicError),
    #[error("Status code: {}", code)]
    Generic { code: u16 },
}

impl From<IssuesListLabelsOnIssueError> for AdapterError {
    fn from(err: IssuesListLabelsOnIssueError) -> Self {
        let (description, status_code) = match err {
            IssuesListLabelsOnIssueError::Status301(_) => (String::from("Moved permanently"), 301),
            IssuesListLabelsOnIssueError::Status404(_) => (String::from("Resource not found"), 404),
            IssuesListLabelsOnIssueError::Status410(_) => (String::from("Gone"), 410),
            IssuesListLabelsOnIssueError::Generic { code } => (String::from("Generic"), code)
        };

        Self::Endpoint {
            description,
            status_code,
            source: Some(Box::new(err))
        }
    }
}

/// Errors for the [List milestones](Issues::list_milestones_async()) endpoint.
#[derive(Debug, thiserror::Error)]
pub enum IssuesListMilestonesError {
    #[error("Resource not found")]
    Status404(BasicError),
    #[error("Status code: {}", code)]
    Generic { code: u16 },
}

impl From<IssuesListMilestonesError> for AdapterError {
    fn from(err: IssuesListMilestonesError) -> Self {
        let (description, status_code) = match err {
            IssuesListMilestonesError::Status404(_) => (String::from("Resource not found"), 404),
            IssuesListMilestonesError::Generic { code } => (String::from("Generic"), code)
        };

        Self::Endpoint {
            description,
            status_code,
            source: Some(Box::new(err))
        }
    }
}

/// Errors for the [Lock an issue](Issues::lock_async()) endpoint.
#[derive(Debug, thiserror::Error)]
pub enum IssuesLockError {
    #[error("Forbidden")]
    Status403(BasicError),
    #[error("Gone")]
    Status410(BasicError),
    #[error("Resource not found")]
    Status404(BasicError),
    #[error("Validation failed, or the endpoint has been spammed.")]
    Status422(ValidationError),
    #[error("Status code: {}", code)]
    Generic { code: u16 },
}

impl From<IssuesLockError> for AdapterError {
    fn from(err: IssuesLockError) -> Self {
        let (description, status_code) = match err {
            IssuesLockError::Status403(_) => (String::from("Forbidden"), 403),
            IssuesLockError::Status410(_) => (String::from("Gone"), 410),
            IssuesLockError::Status404(_) => (String::from("Resource not found"), 404),
            IssuesLockError::Status422(_) => (String::from("Validation failed, or the endpoint has been spammed."), 422),
            IssuesLockError::Generic { code } => (String::from("Generic"), code)
        };

        Self::Endpoint {
            description,
            status_code,
            source: Some(Box::new(err))
        }
    }
}

/// Errors for the [Remove all labels from an issue](Issues::remove_all_labels_async()) endpoint.
#[derive(Debug, thiserror::Error)]
pub enum IssuesRemoveAllLabelsError {
    #[error("Moved permanently")]
    Status301(BasicError),
    #[error("Resource not found")]
    Status404(BasicError),
    #[error("Gone")]
    Status410(BasicError),
    #[error("Status code: {}", code)]
    Generic { code: u16 },
}

impl From<IssuesRemoveAllLabelsError> for AdapterError {
    fn from(err: IssuesRemoveAllLabelsError) -> Self {
        let (description, status_code) = match err {
            IssuesRemoveAllLabelsError::Status301(_) => (String::from("Moved permanently"), 301),
            IssuesRemoveAllLabelsError::Status404(_) => (String::from("Resource not found"), 404),
            IssuesRemoveAllLabelsError::Status410(_) => (String::from("Gone"), 410),
            IssuesRemoveAllLabelsError::Generic { code } => (String::from("Generic"), code)
        };

        Self::Endpoint {
            description,
            status_code,
            source: Some(Box::new(err))
        }
    }
}

/// Errors for the [Remove assignees from an issue](Issues::remove_assignees_async()) endpoint.
#[derive(Debug, thiserror::Error)]
pub enum IssuesRemoveAssigneesError {
    #[error("Status code: {}", code)]
    Generic { code: u16 },
}

impl From<IssuesRemoveAssigneesError> for AdapterError {
    fn from(err: IssuesRemoveAssigneesError) -> Self {
        let (description, status_code) = match err {
            IssuesRemoveAssigneesError::Generic { code } => (String::from("Generic"), code)
        };

        Self::Endpoint {
            description,
            status_code,
            source: Some(Box::new(err))
        }
    }
}

/// Errors for the [Remove a label from an issue](Issues::remove_label_async()) endpoint.
#[derive(Debug, thiserror::Error)]
pub enum IssuesRemoveLabelError {
    #[error("Moved permanently")]
    Status301(BasicError),
    #[error("Resource not found")]
    Status404(BasicError),
    #[error("Gone")]
    Status410(BasicError),
    #[error("Status code: {}", code)]
    Generic { code: u16 },
}

impl From<IssuesRemoveLabelError> for AdapterError {
    fn from(err: IssuesRemoveLabelError) -> Self {
        let (description, status_code) = match err {
            IssuesRemoveLabelError::Status301(_) => (String::from("Moved permanently"), 301),
            IssuesRemoveLabelError::Status404(_) => (String::from("Resource not found"), 404),
            IssuesRemoveLabelError::Status410(_) => (String::from("Gone"), 410),
            IssuesRemoveLabelError::Generic { code } => (String::from("Generic"), code)
        };

        Self::Endpoint {
            description,
            status_code,
            source: Some(Box::new(err))
        }
    }
}

/// Errors for the [Set labels for an issue](Issues::set_labels_async()) endpoint.
#[derive(Debug, thiserror::Error)]
pub enum IssuesSetLabelsError {
    #[error("Moved permanently")]
    Status301(BasicError),
    #[error("Resource not found")]
    Status404(BasicError),
    #[error("Gone")]
    Status410(BasicError),
    #[error("Validation failed, or the endpoint has been spammed.")]
    Status422(ValidationError),
    #[error("Status code: {}", code)]
    Generic { code: u16 },
}

impl From<IssuesSetLabelsError> for AdapterError {
    fn from(err: IssuesSetLabelsError) -> Self {
        let (description, status_code) = match err {
            IssuesSetLabelsError::Status301(_) => (String::from("Moved permanently"), 301),
            IssuesSetLabelsError::Status404(_) => (String::from("Resource not found"), 404),
            IssuesSetLabelsError::Status410(_) => (String::from("Gone"), 410),
            IssuesSetLabelsError::Status422(_) => (String::from("Validation failed, or the endpoint has been spammed."), 422),
            IssuesSetLabelsError::Generic { code } => (String::from("Generic"), code)
        };

        Self::Endpoint {
            description,
            status_code,
            source: Some(Box::new(err))
        }
    }
}

/// Errors for the [Unlock an issue](Issues::unlock_async()) endpoint.
#[derive(Debug, thiserror::Error)]
pub enum IssuesUnlockError {
    #[error("Forbidden")]
    Status403(BasicError),
    #[error("Resource not found")]
    Status404(BasicError),
    #[error("Status code: {}", code)]
    Generic { code: u16 },
}

impl From<IssuesUnlockError> for AdapterError {
    fn from(err: IssuesUnlockError) -> Self {
        let (description, status_code) = match err {
            IssuesUnlockError::Status403(_) => (String::from("Forbidden"), 403),
            IssuesUnlockError::Status404(_) => (String::from("Resource not found"), 404),
            IssuesUnlockError::Generic { code } => (String::from("Generic"), code)
        };

        Self::Endpoint {
            description,
            status_code,
            source: Some(Box::new(err))
        }
    }
}

/// Errors for the [Update an issue](Issues::update_async()) endpoint.
#[derive(Debug, thiserror::Error)]
pub enum IssuesUpdateError {
    #[error("Validation failed, or the endpoint has been spammed.")]
    Status422(ValidationError),
    #[error("Service unavailable")]
    Status503(PostCodespacesCreateForAuthenticatedUserResponse503),
    #[error("Forbidden")]
    Status403(BasicError),
    #[error("Moved permanently")]
    Status301(BasicError),
    #[error("Resource not found")]
    Status404(BasicError),
    #[error("Gone")]
    Status410(BasicError),
    #[error("Status code: {}", code)]
    Generic { code: u16 },
}

impl From<IssuesUpdateError> for AdapterError {
    fn from(err: IssuesUpdateError) -> Self {
        let (description, status_code) = match err {
            IssuesUpdateError::Status422(_) => (String::from("Validation failed, or the endpoint has been spammed."), 422),
            IssuesUpdateError::Status503(_) => (String::from("Service unavailable"), 503),
            IssuesUpdateError::Status403(_) => (String::from("Forbidden"), 403),
            IssuesUpdateError::Status301(_) => (String::from("Moved permanently"), 301),
            IssuesUpdateError::Status404(_) => (String::from("Resource not found"), 404),
            IssuesUpdateError::Status410(_) => (String::from("Gone"), 410),
            IssuesUpdateError::Generic { code } => (String::from("Generic"), code)
        };

        Self::Endpoint {
            description,
            status_code,
            source: Some(Box::new(err))
        }
    }
}

/// Errors for the [Update an issue comment](Issues::update_comment_async()) endpoint.
#[derive(Debug, thiserror::Error)]
pub enum IssuesUpdateCommentError {
    #[error("Validation failed, or the endpoint has been spammed.")]
    Status422(ValidationError),
    #[error("Status code: {}", code)]
    Generic { code: u16 },
}

impl From<IssuesUpdateCommentError> for AdapterError {
    fn from(err: IssuesUpdateCommentError) -> Self {
        let (description, status_code) = match err {
            IssuesUpdateCommentError::Status422(_) => (String::from("Validation failed, or the endpoint has been spammed."), 422),
            IssuesUpdateCommentError::Generic { code } => (String::from("Generic"), code)
        };

        Self::Endpoint {
            description,
            status_code,
            source: Some(Box::new(err))
        }
    }
}

/// Errors for the [Update a label](Issues::update_label_async()) endpoint.
#[derive(Debug, thiserror::Error)]
pub enum IssuesUpdateLabelError {
    #[error("Status code: {}", code)]
    Generic { code: u16 },
}

impl From<IssuesUpdateLabelError> for AdapterError {
    fn from(err: IssuesUpdateLabelError) -> Self {
        let (description, status_code) = match err {
            IssuesUpdateLabelError::Generic { code } => (String::from("Generic"), code)
        };

        Self::Endpoint {
            description,
            status_code,
            source: Some(Box::new(err))
        }
    }
}

/// Errors for the [Update a milestone](Issues::update_milestone_async()) endpoint.
#[derive(Debug, thiserror::Error)]
pub enum IssuesUpdateMilestoneError {
    #[error("Status code: {}", code)]
    Generic { code: u16 },
}

impl From<IssuesUpdateMilestoneError> for AdapterError {
    fn from(err: IssuesUpdateMilestoneError) -> Self {
        let (description, status_code) = match err {
            IssuesUpdateMilestoneError::Generic { code } => (String::from("Generic"), code)
        };

        Self::Endpoint {
            description,
            status_code,
            source: Some(Box::new(err))
        }
    }
}


/// Query parameters for the [List issues assigned to the authenticated user](Issues::list_async()) endpoint.
#[derive(Default, Serialize)]
pub struct IssuesListParams<'req> {
    /// Indicates which sorts of issues to return. `assigned` means issues assigned to you. `created` means issues created by you. `mentioned` means issues mentioning you. `subscribed` means issues you're subscribed to updates for. `all` or `repos` means all issues you can see, regardless of participation or creation.
    filter: Option<&'req str>, 
    /// Indicates the state of the issues to return.
    state: Option<&'req str>, 
    /// A list of comma separated label names. Example: `bug,ui,@high`
    labels: Option<&'req str>, 
    /// What to sort results by.
    sort: Option<&'req str>, 
    /// The direction to sort the results by.
    direction: Option<&'req str>, 
    /// Only show results that were last updated after the given time. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.
    since: Option<chrono::DateTime<chrono::Utc>>, 
    
    collab: Option<bool>, 
    
    orgs: Option<bool>, 
    
    owned: Option<bool>, 
    
    pulls: Option<bool>, 
    /// The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    per_page: Option<u16>, 
    /// The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    page: Option<u16>
}

impl<'req> IssuesListParams<'req> {
    pub fn new() -> Self {
        Self::default()
    }

    /// Indicates which sorts of issues to return. `assigned` means issues assigned to you. `created` means issues created by you. `mentioned` means issues mentioning you. `subscribed` means issues you're subscribed to updates for. `all` or `repos` means all issues you can see, regardless of participation or creation.
    pub fn filter(self, filter: &'req str) -> Self {
        Self {
            filter: Some(filter),
            state: self.state, 
            labels: self.labels, 
            sort: self.sort, 
            direction: self.direction, 
            since: self.since, 
            collab: self.collab, 
            orgs: self.orgs, 
            owned: self.owned, 
            pulls: self.pulls, 
            per_page: self.per_page, 
            page: self.page, 
        }
    }

    /// Indicates the state of the issues to return.
    pub fn state(self, state: &'req str) -> Self {
        Self {
            filter: self.filter, 
            state: Some(state),
            labels: self.labels, 
            sort: self.sort, 
            direction: self.direction, 
            since: self.since, 
            collab: self.collab, 
            orgs: self.orgs, 
            owned: self.owned, 
            pulls: self.pulls, 
            per_page: self.per_page, 
            page: self.page, 
        }
    }

    /// A list of comma separated label names. Example: `bug,ui,@high`
    pub fn labels(self, labels: &'req str) -> Self {
        Self {
            filter: self.filter, 
            state: self.state, 
            labels: Some(labels),
            sort: self.sort, 
            direction: self.direction, 
            since: self.since, 
            collab: self.collab, 
            orgs: self.orgs, 
            owned: self.owned, 
            pulls: self.pulls, 
            per_page: self.per_page, 
            page: self.page, 
        }
    }

    /// What to sort results by.
    pub fn sort(self, sort: &'req str) -> Self {
        Self {
            filter: self.filter, 
            state: self.state, 
            labels: self.labels, 
            sort: Some(sort),
            direction: self.direction, 
            since: self.since, 
            collab: self.collab, 
            orgs: self.orgs, 
            owned: self.owned, 
            pulls: self.pulls, 
            per_page: self.per_page, 
            page: self.page, 
        }
    }

    /// The direction to sort the results by.
    pub fn direction(self, direction: &'req str) -> Self {
        Self {
            filter: self.filter, 
            state: self.state, 
            labels: self.labels, 
            sort: self.sort, 
            direction: Some(direction),
            since: self.since, 
            collab: self.collab, 
            orgs: self.orgs, 
            owned: self.owned, 
            pulls: self.pulls, 
            per_page: self.per_page, 
            page: self.page, 
        }
    }

    /// Only show results that were last updated after the given time. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.
    pub fn since(self, since: chrono::DateTime<chrono::Utc>) -> Self {
        Self {
            filter: self.filter, 
            state: self.state, 
            labels: self.labels, 
            sort: self.sort, 
            direction: self.direction, 
            since: Some(since),
            collab: self.collab, 
            orgs: self.orgs, 
            owned: self.owned, 
            pulls: self.pulls, 
            per_page: self.per_page, 
            page: self.page, 
        }
    }

    
    pub fn collab(self, collab: bool) -> Self {
        Self {
            filter: self.filter, 
            state: self.state, 
            labels: self.labels, 
            sort: self.sort, 
            direction: self.direction, 
            since: self.since, 
            collab: Some(collab),
            orgs: self.orgs, 
            owned: self.owned, 
            pulls: self.pulls, 
            per_page: self.per_page, 
            page: self.page, 
        }
    }

    
    pub fn orgs(self, orgs: bool) -> Self {
        Self {
            filter: self.filter, 
            state: self.state, 
            labels: self.labels, 
            sort: self.sort, 
            direction: self.direction, 
            since: self.since, 
            collab: self.collab, 
            orgs: Some(orgs),
            owned: self.owned, 
            pulls: self.pulls, 
            per_page: self.per_page, 
            page: self.page, 
        }
    }

    
    pub fn owned(self, owned: bool) -> Self {
        Self {
            filter: self.filter, 
            state: self.state, 
            labels: self.labels, 
            sort: self.sort, 
            direction: self.direction, 
            since: self.since, 
            collab: self.collab, 
            orgs: self.orgs, 
            owned: Some(owned),
            pulls: self.pulls, 
            per_page: self.per_page, 
            page: self.page, 
        }
    }

    
    pub fn pulls(self, pulls: bool) -> Self {
        Self {
            filter: self.filter, 
            state: self.state, 
            labels: self.labels, 
            sort: self.sort, 
            direction: self.direction, 
            since: self.since, 
            collab: self.collab, 
            orgs: self.orgs, 
            owned: self.owned, 
            pulls: Some(pulls),
            per_page: self.per_page, 
            page: self.page, 
        }
    }

    /// The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    pub fn per_page(self, per_page: u16) -> Self {
        Self {
            filter: self.filter, 
            state: self.state, 
            labels: self.labels, 
            sort: self.sort, 
            direction: self.direction, 
            since: self.since, 
            collab: self.collab, 
            orgs: self.orgs, 
            owned: self.owned, 
            pulls: self.pulls, 
            per_page: Some(per_page),
            page: self.page, 
        }
    }

    /// The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    pub fn page(self, page: u16) -> Self {
        Self {
            filter: self.filter, 
            state: self.state, 
            labels: self.labels, 
            sort: self.sort, 
            direction: self.direction, 
            since: self.since, 
            collab: self.collab, 
            orgs: self.orgs, 
            owned: self.owned, 
            pulls: self.pulls, 
            per_page: self.per_page, 
            page: Some(page),
        }
    }
}

impl<'enc> From<&'enc PerPage> for IssuesListParams<'enc> {
    fn from(per_page: &'enc PerPage) -> Self {
        Self {
            per_page: Some(per_page.per_page),
            page: Some(per_page.page),
            ..Default::default()
        }
    }
}
/// Query parameters for the [List assignees](Issues::list_assignees_async()) endpoint.
#[derive(Default, Serialize)]
pub struct IssuesListAssigneesParams {
    /// The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    per_page: Option<u16>, 
    /// The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    page: Option<u16>
}

impl IssuesListAssigneesParams {
    pub fn new() -> Self {
        Self::default()
    }

    /// The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    pub fn per_page(self, per_page: u16) -> Self {
        Self {
            per_page: Some(per_page),
            page: self.page, 
        }
    }

    /// The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    pub fn page(self, page: u16) -> Self {
        Self {
            per_page: self.per_page, 
            page: Some(page),
        }
    }
}

impl<'enc> From<&'enc PerPage> for IssuesListAssigneesParams {
    fn from(per_page: &'enc PerPage) -> Self {
        Self {
            per_page: Some(per_page.per_page),
            page: Some(per_page.page),
            ..Default::default()
        }
    }
}
/// Query parameters for the [List issue comments](Issues::list_comments_async()) endpoint.
#[derive(Default, Serialize)]
pub struct IssuesListCommentsParams {
    /// Only show results that were last updated after the given time. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.
    since: Option<chrono::DateTime<chrono::Utc>>, 
    /// The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    per_page: Option<u16>, 
    /// The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    page: Option<u16>
}

impl IssuesListCommentsParams {
    pub fn new() -> Self {
        Self::default()
    }

    /// Only show results that were last updated after the given time. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.
    pub fn since(self, since: chrono::DateTime<chrono::Utc>) -> Self {
        Self {
            since: Some(since),
            per_page: self.per_page, 
            page: self.page, 
        }
    }

    /// The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    pub fn per_page(self, per_page: u16) -> Self {
        Self {
            since: self.since, 
            per_page: Some(per_page),
            page: self.page, 
        }
    }

    /// The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    pub fn page(self, page: u16) -> Self {
        Self {
            since: self.since, 
            per_page: self.per_page, 
            page: Some(page),
        }
    }
}

impl<'enc> From<&'enc PerPage> for IssuesListCommentsParams {
    fn from(per_page: &'enc PerPage) -> Self {
        Self {
            per_page: Some(per_page.per_page),
            page: Some(per_page.page),
            ..Default::default()
        }
    }
}
/// Query parameters for the [List issue comments for a repository](Issues::list_comments_for_repo_async()) endpoint.
#[derive(Default, Serialize)]
pub struct IssuesListCommentsForRepoParams<'req> {
    /// The property to sort the results by.
    sort: Option<&'req str>, 
    /// Either `asc` or `desc`. Ignored without the `sort` parameter.
    direction: Option<&'req str>, 
    /// Only show results that were last updated after the given time. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.
    since: Option<chrono::DateTime<chrono::Utc>>, 
    /// The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    per_page: Option<u16>, 
    /// The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    page: Option<u16>
}

impl<'req> IssuesListCommentsForRepoParams<'req> {
    pub fn new() -> Self {
        Self::default()
    }

    /// The property to sort the results by.
    pub fn sort(self, sort: &'req str) -> Self {
        Self {
            sort: Some(sort),
            direction: self.direction, 
            since: self.since, 
            per_page: self.per_page, 
            page: self.page, 
        }
    }

    /// Either `asc` or `desc`. Ignored without the `sort` parameter.
    pub fn direction(self, direction: &'req str) -> Self {
        Self {
            sort: self.sort, 
            direction: Some(direction),
            since: self.since, 
            per_page: self.per_page, 
            page: self.page, 
        }
    }

    /// Only show results that were last updated after the given time. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.
    pub fn since(self, since: chrono::DateTime<chrono::Utc>) -> Self {
        Self {
            sort: self.sort, 
            direction: self.direction, 
            since: Some(since),
            per_page: self.per_page, 
            page: self.page, 
        }
    }

    /// The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    pub fn per_page(self, per_page: u16) -> Self {
        Self {
            sort: self.sort, 
            direction: self.direction, 
            since: self.since, 
            per_page: Some(per_page),
            page: self.page, 
        }
    }

    /// The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    pub fn page(self, page: u16) -> Self {
        Self {
            sort: self.sort, 
            direction: self.direction, 
            since: self.since, 
            per_page: self.per_page, 
            page: Some(page),
        }
    }
}

impl<'enc> From<&'enc PerPage> for IssuesListCommentsForRepoParams<'enc> {
    fn from(per_page: &'enc PerPage) -> Self {
        Self {
            per_page: Some(per_page.per_page),
            page: Some(per_page.page),
            ..Default::default()
        }
    }
}
/// Query parameters for the [List issue events](Issues::list_events_async()) endpoint.
#[derive(Default, Serialize)]
pub struct IssuesListEventsParams {
    /// The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    per_page: Option<u16>, 
    /// The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    page: Option<u16>
}

impl IssuesListEventsParams {
    pub fn new() -> Self {
        Self::default()
    }

    /// The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    pub fn per_page(self, per_page: u16) -> Self {
        Self {
            per_page: Some(per_page),
            page: self.page, 
        }
    }

    /// The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    pub fn page(self, page: u16) -> Self {
        Self {
            per_page: self.per_page, 
            page: Some(page),
        }
    }
}

impl<'enc> From<&'enc PerPage> for IssuesListEventsParams {
    fn from(per_page: &'enc PerPage) -> Self {
        Self {
            per_page: Some(per_page.per_page),
            page: Some(per_page.page),
            ..Default::default()
        }
    }
}
/// Query parameters for the [List issue events for a repository](Issues::list_events_for_repo_async()) endpoint.
#[derive(Default, Serialize)]
pub struct IssuesListEventsForRepoParams {
    /// The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    per_page: Option<u16>, 
    /// The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    page: Option<u16>
}

impl IssuesListEventsForRepoParams {
    pub fn new() -> Self {
        Self::default()
    }

    /// The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    pub fn per_page(self, per_page: u16) -> Self {
        Self {
            per_page: Some(per_page),
            page: self.page, 
        }
    }

    /// The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    pub fn page(self, page: u16) -> Self {
        Self {
            per_page: self.per_page, 
            page: Some(page),
        }
    }
}

impl<'enc> From<&'enc PerPage> for IssuesListEventsForRepoParams {
    fn from(per_page: &'enc PerPage) -> Self {
        Self {
            per_page: Some(per_page.per_page),
            page: Some(per_page.page),
            ..Default::default()
        }
    }
}
/// Query parameters for the [List timeline events for an issue](Issues::list_events_for_timeline_async()) endpoint.
#[derive(Default, Serialize)]
pub struct IssuesListEventsForTimelineParams {
    /// The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    per_page: Option<u16>, 
    /// The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    page: Option<u16>
}

impl IssuesListEventsForTimelineParams {
    pub fn new() -> Self {
        Self::default()
    }

    /// The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    pub fn per_page(self, per_page: u16) -> Self {
        Self {
            per_page: Some(per_page),
            page: self.page, 
        }
    }

    /// The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    pub fn page(self, page: u16) -> Self {
        Self {
            per_page: self.per_page, 
            page: Some(page),
        }
    }
}

impl<'enc> From<&'enc PerPage> for IssuesListEventsForTimelineParams {
    fn from(per_page: &'enc PerPage) -> Self {
        Self {
            per_page: Some(per_page.per_page),
            page: Some(per_page.page),
            ..Default::default()
        }
    }
}
/// Query parameters for the [List user account issues assigned to the authenticated user](Issues::list_for_authenticated_user_async()) endpoint.
#[derive(Default, Serialize)]
pub struct IssuesListForAuthenticatedUserParams<'req> {
    /// Indicates which sorts of issues to return. `assigned` means issues assigned to you. `created` means issues created by you. `mentioned` means issues mentioning you. `subscribed` means issues you're subscribed to updates for. `all` or `repos` means all issues you can see, regardless of participation or creation.
    filter: Option<&'req str>, 
    /// Indicates the state of the issues to return.
    state: Option<&'req str>, 
    /// A list of comma separated label names. Example: `bug,ui,@high`
    labels: Option<&'req str>, 
    /// What to sort results by.
    sort: Option<&'req str>, 
    /// The direction to sort the results by.
    direction: Option<&'req str>, 
    /// Only show results that were last updated after the given time. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.
    since: Option<chrono::DateTime<chrono::Utc>>, 
    /// The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    per_page: Option<u16>, 
    /// The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    page: Option<u16>
}

impl<'req> IssuesListForAuthenticatedUserParams<'req> {
    pub fn new() -> Self {
        Self::default()
    }

    /// Indicates which sorts of issues to return. `assigned` means issues assigned to you. `created` means issues created by you. `mentioned` means issues mentioning you. `subscribed` means issues you're subscribed to updates for. `all` or `repos` means all issues you can see, regardless of participation or creation.
    pub fn filter(self, filter: &'req str) -> Self {
        Self {
            filter: Some(filter),
            state: self.state, 
            labels: self.labels, 
            sort: self.sort, 
            direction: self.direction, 
            since: self.since, 
            per_page: self.per_page, 
            page: self.page, 
        }
    }

    /// Indicates the state of the issues to return.
    pub fn state(self, state: &'req str) -> Self {
        Self {
            filter: self.filter, 
            state: Some(state),
            labels: self.labels, 
            sort: self.sort, 
            direction: self.direction, 
            since: self.since, 
            per_page: self.per_page, 
            page: self.page, 
        }
    }

    /// A list of comma separated label names. Example: `bug,ui,@high`
    pub fn labels(self, labels: &'req str) -> Self {
        Self {
            filter: self.filter, 
            state: self.state, 
            labels: Some(labels),
            sort: self.sort, 
            direction: self.direction, 
            since: self.since, 
            per_page: self.per_page, 
            page: self.page, 
        }
    }

    /// What to sort results by.
    pub fn sort(self, sort: &'req str) -> Self {
        Self {
            filter: self.filter, 
            state: self.state, 
            labels: self.labels, 
            sort: Some(sort),
            direction: self.direction, 
            since: self.since, 
            per_page: self.per_page, 
            page: self.page, 
        }
    }

    /// The direction to sort the results by.
    pub fn direction(self, direction: &'req str) -> Self {
        Self {
            filter: self.filter, 
            state: self.state, 
            labels: self.labels, 
            sort: self.sort, 
            direction: Some(direction),
            since: self.since, 
            per_page: self.per_page, 
            page: self.page, 
        }
    }

    /// Only show results that were last updated after the given time. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.
    pub fn since(self, since: chrono::DateTime<chrono::Utc>) -> Self {
        Self {
            filter: self.filter, 
            state: self.state, 
            labels: self.labels, 
            sort: self.sort, 
            direction: self.direction, 
            since: Some(since),
            per_page: self.per_page, 
            page: self.page, 
        }
    }

    /// The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    pub fn per_page(self, per_page: u16) -> Self {
        Self {
            filter: self.filter, 
            state: self.state, 
            labels: self.labels, 
            sort: self.sort, 
            direction: self.direction, 
            since: self.since, 
            per_page: Some(per_page),
            page: self.page, 
        }
    }

    /// The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    pub fn page(self, page: u16) -> Self {
        Self {
            filter: self.filter, 
            state: self.state, 
            labels: self.labels, 
            sort: self.sort, 
            direction: self.direction, 
            since: self.since, 
            per_page: self.per_page, 
            page: Some(page),
        }
    }
}

impl<'enc> From<&'enc PerPage> for IssuesListForAuthenticatedUserParams<'enc> {
    fn from(per_page: &'enc PerPage) -> Self {
        Self {
            per_page: Some(per_page.per_page),
            page: Some(per_page.page),
            ..Default::default()
        }
    }
}
/// Query parameters for the [List organization issues assigned to the authenticated user](Issues::list_for_org_async()) endpoint.
#[derive(Default, Serialize)]
pub struct IssuesListForOrgParams<'req> {
    /// Indicates which sorts of issues to return. `assigned` means issues assigned to you. `created` means issues created by you. `mentioned` means issues mentioning you. `subscribed` means issues you're subscribed to updates for. `all` or `repos` means all issues you can see, regardless of participation or creation.
    filter: Option<&'req str>, 
    /// Indicates the state of the issues to return.
    state: Option<&'req str>, 
    /// A list of comma separated label names. Example: `bug,ui,@high`
    labels: Option<&'req str>, 
    /// What to sort results by.
    sort: Option<&'req str>, 
    /// The direction to sort the results by.
    direction: Option<&'req str>, 
    /// Only show results that were last updated after the given time. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.
    since: Option<chrono::DateTime<chrono::Utc>>, 
    /// The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    per_page: Option<u16>, 
    /// The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    page: Option<u16>
}

impl<'req> IssuesListForOrgParams<'req> {
    pub fn new() -> Self {
        Self::default()
    }

    /// Indicates which sorts of issues to return. `assigned` means issues assigned to you. `created` means issues created by you. `mentioned` means issues mentioning you. `subscribed` means issues you're subscribed to updates for. `all` or `repos` means all issues you can see, regardless of participation or creation.
    pub fn filter(self, filter: &'req str) -> Self {
        Self {
            filter: Some(filter),
            state: self.state, 
            labels: self.labels, 
            sort: self.sort, 
            direction: self.direction, 
            since: self.since, 
            per_page: self.per_page, 
            page: self.page, 
        }
    }

    /// Indicates the state of the issues to return.
    pub fn state(self, state: &'req str) -> Self {
        Self {
            filter: self.filter, 
            state: Some(state),
            labels: self.labels, 
            sort: self.sort, 
            direction: self.direction, 
            since: self.since, 
            per_page: self.per_page, 
            page: self.page, 
        }
    }

    /// A list of comma separated label names. Example: `bug,ui,@high`
    pub fn labels(self, labels: &'req str) -> Self {
        Self {
            filter: self.filter, 
            state: self.state, 
            labels: Some(labels),
            sort: self.sort, 
            direction: self.direction, 
            since: self.since, 
            per_page: self.per_page, 
            page: self.page, 
        }
    }

    /// What to sort results by.
    pub fn sort(self, sort: &'req str) -> Self {
        Self {
            filter: self.filter, 
            state: self.state, 
            labels: self.labels, 
            sort: Some(sort),
            direction: self.direction, 
            since: self.since, 
            per_page: self.per_page, 
            page: self.page, 
        }
    }

    /// The direction to sort the results by.
    pub fn direction(self, direction: &'req str) -> Self {
        Self {
            filter: self.filter, 
            state: self.state, 
            labels: self.labels, 
            sort: self.sort, 
            direction: Some(direction),
            since: self.since, 
            per_page: self.per_page, 
            page: self.page, 
        }
    }

    /// Only show results that were last updated after the given time. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.
    pub fn since(self, since: chrono::DateTime<chrono::Utc>) -> Self {
        Self {
            filter: self.filter, 
            state: self.state, 
            labels: self.labels, 
            sort: self.sort, 
            direction: self.direction, 
            since: Some(since),
            per_page: self.per_page, 
            page: self.page, 
        }
    }

    /// The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    pub fn per_page(self, per_page: u16) -> Self {
        Self {
            filter: self.filter, 
            state: self.state, 
            labels: self.labels, 
            sort: self.sort, 
            direction: self.direction, 
            since: self.since, 
            per_page: Some(per_page),
            page: self.page, 
        }
    }

    /// The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    pub fn page(self, page: u16) -> Self {
        Self {
            filter: self.filter, 
            state: self.state, 
            labels: self.labels, 
            sort: self.sort, 
            direction: self.direction, 
            since: self.since, 
            per_page: self.per_page, 
            page: Some(page),
        }
    }
}

impl<'enc> From<&'enc PerPage> for IssuesListForOrgParams<'enc> {
    fn from(per_page: &'enc PerPage) -> Self {
        Self {
            per_page: Some(per_page.per_page),
            page: Some(per_page.page),
            ..Default::default()
        }
    }
}
/// Query parameters for the [List repository issues](Issues::list_for_repo_async()) endpoint.
#[derive(Default, Serialize)]
pub struct IssuesListForRepoParams<'req> {
    /// If an `integer` is passed, it should refer to a milestone by its `number` field. If the string `*` is passed, issues with any milestone are accepted. If the string `none` is passed, issues without milestones are returned.
    milestone: Option<&'req str>, 
    /// Indicates the state of the issues to return.
    state: Option<&'req str>, 
    /// Can be the name of a user. Pass in `none` for issues with no assigned user, and `*` for issues assigned to any user.
    assignee: Option<&'req str>, 
    /// The user that created the issue.
    creator: Option<&'req str>, 
    /// A user that's mentioned in the issue.
    mentioned: Option<&'req str>, 
    /// A list of comma separated label names. Example: `bug,ui,@high`
    labels: Option<&'req str>, 
    /// What to sort results by.
    sort: Option<&'req str>, 
    /// The direction to sort the results by.
    direction: Option<&'req str>, 
    /// Only show results that were last updated after the given time. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.
    since: Option<chrono::DateTime<chrono::Utc>>, 
    /// The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    per_page: Option<u16>, 
    /// The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    page: Option<u16>
}

impl<'req> IssuesListForRepoParams<'req> {
    pub fn new() -> Self {
        Self::default()
    }

    /// If an `integer` is passed, it should refer to a milestone by its `number` field. If the string `*` is passed, issues with any milestone are accepted. If the string `none` is passed, issues without milestones are returned.
    pub fn milestone(self, milestone: &'req str) -> Self {
        Self {
            milestone: Some(milestone),
            state: self.state, 
            assignee: self.assignee, 
            creator: self.creator, 
            mentioned: self.mentioned, 
            labels: self.labels, 
            sort: self.sort, 
            direction: self.direction, 
            since: self.since, 
            per_page: self.per_page, 
            page: self.page, 
        }
    }

    /// Indicates the state of the issues to return.
    pub fn state(self, state: &'req str) -> Self {
        Self {
            milestone: self.milestone, 
            state: Some(state),
            assignee: self.assignee, 
            creator: self.creator, 
            mentioned: self.mentioned, 
            labels: self.labels, 
            sort: self.sort, 
            direction: self.direction, 
            since: self.since, 
            per_page: self.per_page, 
            page: self.page, 
        }
    }

    /// Can be the name of a user. Pass in `none` for issues with no assigned user, and `*` for issues assigned to any user.
    pub fn assignee(self, assignee: &'req str) -> Self {
        Self {
            milestone: self.milestone, 
            state: self.state, 
            assignee: Some(assignee),
            creator: self.creator, 
            mentioned: self.mentioned, 
            labels: self.labels, 
            sort: self.sort, 
            direction: self.direction, 
            since: self.since, 
            per_page: self.per_page, 
            page: self.page, 
        }
    }

    /// The user that created the issue.
    pub fn creator(self, creator: &'req str) -> Self {
        Self {
            milestone: self.milestone, 
            state: self.state, 
            assignee: self.assignee, 
            creator: Some(creator),
            mentioned: self.mentioned, 
            labels: self.labels, 
            sort: self.sort, 
            direction: self.direction, 
            since: self.since, 
            per_page: self.per_page, 
            page: self.page, 
        }
    }

    /// A user that's mentioned in the issue.
    pub fn mentioned(self, mentioned: &'req str) -> Self {
        Self {
            milestone: self.milestone, 
            state: self.state, 
            assignee: self.assignee, 
            creator: self.creator, 
            mentioned: Some(mentioned),
            labels: self.labels, 
            sort: self.sort, 
            direction: self.direction, 
            since: self.since, 
            per_page: self.per_page, 
            page: self.page, 
        }
    }

    /// A list of comma separated label names. Example: `bug,ui,@high`
    pub fn labels(self, labels: &'req str) -> Self {
        Self {
            milestone: self.milestone, 
            state: self.state, 
            assignee: self.assignee, 
            creator: self.creator, 
            mentioned: self.mentioned, 
            labels: Some(labels),
            sort: self.sort, 
            direction: self.direction, 
            since: self.since, 
            per_page: self.per_page, 
            page: self.page, 
        }
    }

    /// What to sort results by.
    pub fn sort(self, sort: &'req str) -> Self {
        Self {
            milestone: self.milestone, 
            state: self.state, 
            assignee: self.assignee, 
            creator: self.creator, 
            mentioned: self.mentioned, 
            labels: self.labels, 
            sort: Some(sort),
            direction: self.direction, 
            since: self.since, 
            per_page: self.per_page, 
            page: self.page, 
        }
    }

    /// The direction to sort the results by.
    pub fn direction(self, direction: &'req str) -> Self {
        Self {
            milestone: self.milestone, 
            state: self.state, 
            assignee: self.assignee, 
            creator: self.creator, 
            mentioned: self.mentioned, 
            labels: self.labels, 
            sort: self.sort, 
            direction: Some(direction),
            since: self.since, 
            per_page: self.per_page, 
            page: self.page, 
        }
    }

    /// Only show results that were last updated after the given time. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.
    pub fn since(self, since: chrono::DateTime<chrono::Utc>) -> Self {
        Self {
            milestone: self.milestone, 
            state: self.state, 
            assignee: self.assignee, 
            creator: self.creator, 
            mentioned: self.mentioned, 
            labels: self.labels, 
            sort: self.sort, 
            direction: self.direction, 
            since: Some(since),
            per_page: self.per_page, 
            page: self.page, 
        }
    }

    /// The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    pub fn per_page(self, per_page: u16) -> Self {
        Self {
            milestone: self.milestone, 
            state: self.state, 
            assignee: self.assignee, 
            creator: self.creator, 
            mentioned: self.mentioned, 
            labels: self.labels, 
            sort: self.sort, 
            direction: self.direction, 
            since: self.since, 
            per_page: Some(per_page),
            page: self.page, 
        }
    }

    /// The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    pub fn page(self, page: u16) -> Self {
        Self {
            milestone: self.milestone, 
            state: self.state, 
            assignee: self.assignee, 
            creator: self.creator, 
            mentioned: self.mentioned, 
            labels: self.labels, 
            sort: self.sort, 
            direction: self.direction, 
            since: self.since, 
            per_page: self.per_page, 
            page: Some(page),
        }
    }
}

impl<'enc> From<&'enc PerPage> for IssuesListForRepoParams<'enc> {
    fn from(per_page: &'enc PerPage) -> Self {
        Self {
            per_page: Some(per_page.per_page),
            page: Some(per_page.page),
            ..Default::default()
        }
    }
}
/// Query parameters for the [List labels for issues in a milestone](Issues::list_labels_for_milestone_async()) endpoint.
#[derive(Default, Serialize)]
pub struct IssuesListLabelsForMilestoneParams {
    /// The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    per_page: Option<u16>, 
    /// The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    page: Option<u16>
}

impl IssuesListLabelsForMilestoneParams {
    pub fn new() -> Self {
        Self::default()
    }

    /// The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    pub fn per_page(self, per_page: u16) -> Self {
        Self {
            per_page: Some(per_page),
            page: self.page, 
        }
    }

    /// The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    pub fn page(self, page: u16) -> Self {
        Self {
            per_page: self.per_page, 
            page: Some(page),
        }
    }
}

impl<'enc> From<&'enc PerPage> for IssuesListLabelsForMilestoneParams {
    fn from(per_page: &'enc PerPage) -> Self {
        Self {
            per_page: Some(per_page.per_page),
            page: Some(per_page.page),
            ..Default::default()
        }
    }
}
/// Query parameters for the [List labels for a repository](Issues::list_labels_for_repo_async()) endpoint.
#[derive(Default, Serialize)]
pub struct IssuesListLabelsForRepoParams {
    /// The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    per_page: Option<u16>, 
    /// The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    page: Option<u16>
}

impl IssuesListLabelsForRepoParams {
    pub fn new() -> Self {
        Self::default()
    }

    /// The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    pub fn per_page(self, per_page: u16) -> Self {
        Self {
            per_page: Some(per_page),
            page: self.page, 
        }
    }

    /// The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    pub fn page(self, page: u16) -> Self {
        Self {
            per_page: self.per_page, 
            page: Some(page),
        }
    }
}

impl<'enc> From<&'enc PerPage> for IssuesListLabelsForRepoParams {
    fn from(per_page: &'enc PerPage) -> Self {
        Self {
            per_page: Some(per_page.per_page),
            page: Some(per_page.page),
            ..Default::default()
        }
    }
}
/// Query parameters for the [List labels for an issue](Issues::list_labels_on_issue_async()) endpoint.
#[derive(Default, Serialize)]
pub struct IssuesListLabelsOnIssueParams {
    /// The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    per_page: Option<u16>, 
    /// The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    page: Option<u16>
}

impl IssuesListLabelsOnIssueParams {
    pub fn new() -> Self {
        Self::default()
    }

    /// The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    pub fn per_page(self, per_page: u16) -> Self {
        Self {
            per_page: Some(per_page),
            page: self.page, 
        }
    }

    /// The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    pub fn page(self, page: u16) -> Self {
        Self {
            per_page: self.per_page, 
            page: Some(page),
        }
    }
}

impl<'enc> From<&'enc PerPage> for IssuesListLabelsOnIssueParams {
    fn from(per_page: &'enc PerPage) -> Self {
        Self {
            per_page: Some(per_page.per_page),
            page: Some(per_page.page),
            ..Default::default()
        }
    }
}
/// Query parameters for the [List milestones](Issues::list_milestones_async()) endpoint.
#[derive(Default, Serialize)]
pub struct IssuesListMilestonesParams<'req> {
    /// The state of the milestone. Either `open`, `closed`, or `all`.
    state: Option<&'req str>, 
    /// What to sort results by. Either `due_on` or `completeness`.
    sort: Option<&'req str>, 
    /// The direction of the sort. Either `asc` or `desc`.
    direction: Option<&'req str>, 
    /// The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    per_page: Option<u16>, 
    /// The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    page: Option<u16>
}

impl<'req> IssuesListMilestonesParams<'req> {
    pub fn new() -> Self {
        Self::default()
    }

    /// The state of the milestone. Either `open`, `closed`, or `all`.
    pub fn state(self, state: &'req str) -> Self {
        Self {
            state: Some(state),
            sort: self.sort, 
            direction: self.direction, 
            per_page: self.per_page, 
            page: self.page, 
        }
    }

    /// What to sort results by. Either `due_on` or `completeness`.
    pub fn sort(self, sort: &'req str) -> Self {
        Self {
            state: self.state, 
            sort: Some(sort),
            direction: self.direction, 
            per_page: self.per_page, 
            page: self.page, 
        }
    }

    /// The direction of the sort. Either `asc` or `desc`.
    pub fn direction(self, direction: &'req str) -> Self {
        Self {
            state: self.state, 
            sort: self.sort, 
            direction: Some(direction),
            per_page: self.per_page, 
            page: self.page, 
        }
    }

    /// The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    pub fn per_page(self, per_page: u16) -> Self {
        Self {
            state: self.state, 
            sort: self.sort, 
            direction: self.direction, 
            per_page: Some(per_page),
            page: self.page, 
        }
    }

    /// The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    pub fn page(self, page: u16) -> Self {
        Self {
            state: self.state, 
            sort: self.sort, 
            direction: self.direction, 
            per_page: self.per_page, 
            page: Some(page),
        }
    }
}

impl<'enc> From<&'enc PerPage> for IssuesListMilestonesParams<'enc> {
    fn from(per_page: &'enc PerPage) -> Self {
        Self {
            per_page: Some(per_page.per_page),
            page: Some(per_page.page),
            ..Default::default()
        }
    }
}

impl<'api, C: Client> Issues<'api, C> where AdapterError: From<<C as Client>::Err> {
    /// ---
    ///
    /// # Add assignees to an issue
    ///
    /// Adds up to 10 assignees to an issue. Users already assigned to an issue are not replaced.
    ///
    /// [GitHub API docs for add_assignees](https://docs.github.com/rest/issues/assignees#add-assignees-to-an-issue)
    ///
    /// ---
    pub async fn add_assignees_async(&self, owner: &str, repo: &str, issue_number: i32, body: PostIssuesAddAssignees) -> Result<Issue, AdapterError> {

        let request_uri = format!("{}/repos/{}/{}/issues/{}/assignees", super::GITHUB_BASE_API_URL, owner, repo, issue_number);


        let req = GitHubRequest {
            uri: request_uri,
            body: Some(C::from_json::<PostIssuesAddAssignees>(body)?),
            method: "POST",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch_async(request).await?;

        // --

        if github_response.is_success() {
            Ok(github_response.to_json_async().await?)
        } else {
            match github_response.status_code() {
                code => Err(IssuesAddAssigneesError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # Add assignees to an issue
    ///
    /// Adds up to 10 assignees to an issue. Users already assigned to an issue are not replaced.
    ///
    /// [GitHub API docs for add_assignees](https://docs.github.com/rest/issues/assignees#add-assignees-to-an-issue)
    ///
    /// ---
    #[cfg(not(target_arch = "wasm32"))]
    pub fn add_assignees(&self, owner: &str, repo: &str, issue_number: i32, body: PostIssuesAddAssignees) -> Result<Issue, AdapterError> {

        let request_uri = format!("{}/repos/{}/{}/issues/{}/assignees", super::GITHUB_BASE_API_URL, owner, repo, issue_number);


        let req = GitHubRequest {
            uri: request_uri,
            body: Some(C::from_json::<PostIssuesAddAssignees>(body)?),
            method: "POST",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch(request)?;

        // --

        if github_response.is_success() {
            Ok(github_response.to_json()?)
        } else {
            match github_response.status_code() {
                code => Err(IssuesAddAssigneesError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # Add labels to an issue
    ///
    /// Adds labels to an issue. If you provide an empty array of labels, all labels are removed from the issue. 
    ///
    /// [GitHub API docs for add_labels](https://docs.github.com/rest/issues/labels#add-labels-to-an-issue)
    ///
    /// ---
    pub async fn add_labels_async(&self, owner: &str, repo: &str, issue_number: i32, body: PostIssuesAddLabels) -> Result<Vec<Label>, AdapterError> {

        let request_uri = format!("{}/repos/{}/{}/issues/{}/labels", super::GITHUB_BASE_API_URL, owner, repo, issue_number);


        let req = GitHubRequest {
            uri: request_uri,
            body: Some(C::from_json::<PostIssuesAddLabels>(body)?),
            method: "POST",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch_async(request).await?;

        // --

        if github_response.is_success() {
            Ok(github_response.to_json_async().await?)
        } else {
            match github_response.status_code() {
                301 => Err(IssuesAddLabelsError::Status301(github_response.to_json_async().await?).into()),
                404 => Err(IssuesAddLabelsError::Status404(github_response.to_json_async().await?).into()),
                410 => Err(IssuesAddLabelsError::Status410(github_response.to_json_async().await?).into()),
                422 => Err(IssuesAddLabelsError::Status422(github_response.to_json_async().await?).into()),
                code => Err(IssuesAddLabelsError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # Add labels to an issue
    ///
    /// Adds labels to an issue. If you provide an empty array of labels, all labels are removed from the issue. 
    ///
    /// [GitHub API docs for add_labels](https://docs.github.com/rest/issues/labels#add-labels-to-an-issue)
    ///
    /// ---
    #[cfg(not(target_arch = "wasm32"))]
    pub fn add_labels(&self, owner: &str, repo: &str, issue_number: i32, body: PostIssuesAddLabels) -> Result<Vec<Label>, AdapterError> {

        let request_uri = format!("{}/repos/{}/{}/issues/{}/labels", super::GITHUB_BASE_API_URL, owner, repo, issue_number);


        let req = GitHubRequest {
            uri: request_uri,
            body: Some(C::from_json::<PostIssuesAddLabels>(body)?),
            method: "POST",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch(request)?;

        // --

        if github_response.is_success() {
            Ok(github_response.to_json()?)
        } else {
            match github_response.status_code() {
                301 => Err(IssuesAddLabelsError::Status301(github_response.to_json()?).into()),
                404 => Err(IssuesAddLabelsError::Status404(github_response.to_json()?).into()),
                410 => Err(IssuesAddLabelsError::Status410(github_response.to_json()?).into()),
                422 => Err(IssuesAddLabelsError::Status422(github_response.to_json()?).into()),
                code => Err(IssuesAddLabelsError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # Check if a user can be assigned
    ///
    /// Checks if a user has permission to be assigned to an issue in this repository.
    /// 
    /// If the `assignee` can be assigned to issues in the repository, a `204` header with no content is returned.
    /// 
    /// Otherwise a `404` status code is returned.
    ///
    /// [GitHub API docs for check_user_can_be_assigned](https://docs.github.com/rest/issues/assignees#check-if-a-user-can-be-assigned)
    ///
    /// ---
    pub async fn check_user_can_be_assigned_async(&self, owner: &str, repo: &str, assignee: &str) -> Result<(), AdapterError> {

        let request_uri = format!("{}/repos/{}/{}/assignees/{}", super::GITHUB_BASE_API_URL, owner, repo, assignee);


        let req = GitHubRequest {
            uri: request_uri,
            body: None::<C::Body>,
            method: "GET",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch_async(request).await?;

        // --

        if github_response.is_success() {
            Ok(())
        } else {
            match github_response.status_code() {
                404 => Err(IssuesCheckUserCanBeAssignedError::Status404(github_response.to_json_async().await?).into()),
                code => Err(IssuesCheckUserCanBeAssignedError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # Check if a user can be assigned
    ///
    /// Checks if a user has permission to be assigned to an issue in this repository.
    /// 
    /// If the `assignee` can be assigned to issues in the repository, a `204` header with no content is returned.
    /// 
    /// Otherwise a `404` status code is returned.
    ///
    /// [GitHub API docs for check_user_can_be_assigned](https://docs.github.com/rest/issues/assignees#check-if-a-user-can-be-assigned)
    ///
    /// ---
    #[cfg(not(target_arch = "wasm32"))]
    pub fn check_user_can_be_assigned(&self, owner: &str, repo: &str, assignee: &str) -> Result<(), AdapterError> {

        let request_uri = format!("{}/repos/{}/{}/assignees/{}", super::GITHUB_BASE_API_URL, owner, repo, assignee);


        let req = GitHubRequest {
            uri: request_uri,
            body: None,
            method: "GET",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch(request)?;

        // --

        if github_response.is_success() {
            Ok(())
        } else {
            match github_response.status_code() {
                404 => Err(IssuesCheckUserCanBeAssignedError::Status404(github_response.to_json()?).into()),
                code => Err(IssuesCheckUserCanBeAssignedError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # Check if a user can be assigned to a issue
    ///
    /// Checks if a user has permission to be assigned to a specific issue.
    /// 
    /// If the `assignee` can be assigned to this issue, a `204` status code with no content is returned.
    /// 
    /// Otherwise a `404` status code is returned.
    ///
    /// [GitHub API docs for check_user_can_be_assigned_to_issue](https://docs.github.com/rest/issues/assignees#check-if-a-user-can-be-assigned-to-a-issue)
    ///
    /// ---
    pub async fn check_user_can_be_assigned_to_issue_async(&self, owner: &str, repo: &str, issue_number: i32, assignee: &str) -> Result<(), AdapterError> {

        let request_uri = format!("{}/repos/{}/{}/issues/{}/assignees/{}", super::GITHUB_BASE_API_URL, owner, repo, issue_number, assignee);


        let req = GitHubRequest {
            uri: request_uri,
            body: None::<C::Body>,
            method: "GET",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch_async(request).await?;

        // --

        if github_response.is_success() {
            Ok(())
        } else {
            match github_response.status_code() {
                404 => Err(IssuesCheckUserCanBeAssignedToIssueError::Status404(github_response.to_json_async().await?).into()),
                code => Err(IssuesCheckUserCanBeAssignedToIssueError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # Check if a user can be assigned to a issue
    ///
    /// Checks if a user has permission to be assigned to a specific issue.
    /// 
    /// If the `assignee` can be assigned to this issue, a `204` status code with no content is returned.
    /// 
    /// Otherwise a `404` status code is returned.
    ///
    /// [GitHub API docs for check_user_can_be_assigned_to_issue](https://docs.github.com/rest/issues/assignees#check-if-a-user-can-be-assigned-to-a-issue)
    ///
    /// ---
    #[cfg(not(target_arch = "wasm32"))]
    pub fn check_user_can_be_assigned_to_issue(&self, owner: &str, repo: &str, issue_number: i32, assignee: &str) -> Result<(), AdapterError> {

        let request_uri = format!("{}/repos/{}/{}/issues/{}/assignees/{}", super::GITHUB_BASE_API_URL, owner, repo, issue_number, assignee);


        let req = GitHubRequest {
            uri: request_uri,
            body: None,
            method: "GET",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch(request)?;

        // --

        if github_response.is_success() {
            Ok(())
        } else {
            match github_response.status_code() {
                404 => Err(IssuesCheckUserCanBeAssignedToIssueError::Status404(github_response.to_json()?).into()),
                code => Err(IssuesCheckUserCanBeAssignedToIssueError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # Create an issue
    ///
    /// Any user with pull access to a repository can create an issue. If [issues are disabled in the repository](https://docs.github.com/articles/disabling-issues/), the API returns a `410 Gone` status.
    /// 
    /// This endpoint triggers [notifications](https://docs.github.com/github/managing-subscriptions-and-notifications-on-github/about-notifications). Creating content too quickly using this endpoint may result in secondary rate limiting. For more information, see "[Rate limits for the API](https://docs.github.com/rest/using-the-rest-api/rate-limits-for-the-rest-api#about-secondary-rate-limits)"
    /// and "[Best practices for using the REST API](https://docs.github.com/rest/guides/best-practices-for-using-the-rest-api)."
    /// 
    /// This endpoint supports the following custom media types. For more information, see "[Media types](https://docs.github.com/rest/using-the-rest-api/getting-started-with-the-rest-api#media-types)."
    /// 
    /// - **`application/vnd.github.raw+json`**: Returns the raw markdown body. Response will include `body`. This is the default if you do not pass any specific media type.
    /// - **`application/vnd.github.text+json`**: Returns a text only representation of the markdown body. Response will include `body_text`.
    /// - **`application/vnd.github.html+json`**: Returns HTML rendered from the body's markdown. Response will include `body_html`.
    /// - **`application/vnd.github.full+json`**: Returns raw, text, and HTML representations. Response will include `body`, `body_text`, and `body_html`.
    ///
    /// [GitHub API docs for create](https://docs.github.com/rest/issues/issues#create-an-issue)
    ///
    /// ---
    pub async fn create_async(&self, owner: &str, repo: &str, body: PostIssuesCreate) -> Result<Issue, AdapterError> {

        let request_uri = format!("{}/repos/{}/{}/issues", super::GITHUB_BASE_API_URL, owner, repo);


        let req = GitHubRequest {
            uri: request_uri,
            body: Some(C::from_json::<PostIssuesCreate>(body)?),
            method: "POST",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch_async(request).await?;

        // --

        if github_response.is_success() {
            Ok(github_response.to_json_async().await?)
        } else {
            match github_response.status_code() {
                400 => Err(IssuesCreateError::Status400(github_response.to_json_async().await?).into()),
                403 => Err(IssuesCreateError::Status403(github_response.to_json_async().await?).into()),
                422 => Err(IssuesCreateError::Status422(github_response.to_json_async().await?).into()),
                503 => Err(IssuesCreateError::Status503(github_response.to_json_async().await?).into()),
                404 => Err(IssuesCreateError::Status404(github_response.to_json_async().await?).into()),
                410 => Err(IssuesCreateError::Status410(github_response.to_json_async().await?).into()),
                code => Err(IssuesCreateError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # Create an issue
    ///
    /// Any user with pull access to a repository can create an issue. If [issues are disabled in the repository](https://docs.github.com/articles/disabling-issues/), the API returns a `410 Gone` status.
    /// 
    /// This endpoint triggers [notifications](https://docs.github.com/github/managing-subscriptions-and-notifications-on-github/about-notifications). Creating content too quickly using this endpoint may result in secondary rate limiting. For more information, see "[Rate limits for the API](https://docs.github.com/rest/using-the-rest-api/rate-limits-for-the-rest-api#about-secondary-rate-limits)"
    /// and "[Best practices for using the REST API](https://docs.github.com/rest/guides/best-practices-for-using-the-rest-api)."
    /// 
    /// This endpoint supports the following custom media types. For more information, see "[Media types](https://docs.github.com/rest/using-the-rest-api/getting-started-with-the-rest-api#media-types)."
    /// 
    /// - **`application/vnd.github.raw+json`**: Returns the raw markdown body. Response will include `body`. This is the default if you do not pass any specific media type.
    /// - **`application/vnd.github.text+json`**: Returns a text only representation of the markdown body. Response will include `body_text`.
    /// - **`application/vnd.github.html+json`**: Returns HTML rendered from the body's markdown. Response will include `body_html`.
    /// - **`application/vnd.github.full+json`**: Returns raw, text, and HTML representations. Response will include `body`, `body_text`, and `body_html`.
    ///
    /// [GitHub API docs for create](https://docs.github.com/rest/issues/issues#create-an-issue)
    ///
    /// ---
    #[cfg(not(target_arch = "wasm32"))]
    pub fn create(&self, owner: &str, repo: &str, body: PostIssuesCreate) -> Result<Issue, AdapterError> {

        let request_uri = format!("{}/repos/{}/{}/issues", super::GITHUB_BASE_API_URL, owner, repo);


        let req = GitHubRequest {
            uri: request_uri,
            body: Some(C::from_json::<PostIssuesCreate>(body)?),
            method: "POST",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch(request)?;

        // --

        if github_response.is_success() {
            Ok(github_response.to_json()?)
        } else {
            match github_response.status_code() {
                400 => Err(IssuesCreateError::Status400(github_response.to_json()?).into()),
                403 => Err(IssuesCreateError::Status403(github_response.to_json()?).into()),
                422 => Err(IssuesCreateError::Status422(github_response.to_json()?).into()),
                503 => Err(IssuesCreateError::Status503(github_response.to_json()?).into()),
                404 => Err(IssuesCreateError::Status404(github_response.to_json()?).into()),
                410 => Err(IssuesCreateError::Status410(github_response.to_json()?).into()),
                code => Err(IssuesCreateError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # Create an issue comment
    ///
    /// You can use the REST API to create comments on issues and pull requests. Every pull request is an issue, but not every issue is a pull request.
    /// 
    /// This endpoint triggers [notifications](https://docs.github.com/github/managing-subscriptions-and-notifications-on-github/about-notifications).
    /// Creating content too quickly using this endpoint may result in secondary rate limiting.
    /// For more information, see "[Rate limits for the API](https://docs.github.com/rest/using-the-rest-api/rate-limits-for-the-rest-api#about-secondary-rate-limits)"
    /// and "[Best practices for using the REST API](https://docs.github.com/rest/guides/best-practices-for-using-the-rest-api)."
    /// 
    /// This endpoint supports the following custom media types. For more information, see "[Media types](https://docs.github.com/rest/using-the-rest-api/getting-started-with-the-rest-api#media-types)."
    /// 
    /// - **`application/vnd.github.raw+json`**: Returns the raw markdown body. Response will include `body`. This is the default if you do not pass any specific media type.
    /// - **`application/vnd.github.text+json`**: Returns a text only representation of the markdown body. Response will include `body_text`.
    /// - **`application/vnd.github.html+json`**: Returns HTML rendered from the body's markdown. Response will include `body_html`.
    /// - **`application/vnd.github.full+json`**: Returns raw, text, and HTML representations. Response will include `body`, `body_text`, and `body_html`.
    ///
    /// [GitHub API docs for create_comment](https://docs.github.com/rest/issues/comments#create-an-issue-comment)
    ///
    /// ---
    pub async fn create_comment_async(&self, owner: &str, repo: &str, issue_number: i32, body: PostIssuesCreateComment) -> Result<IssueComment, AdapterError> {

        let request_uri = format!("{}/repos/{}/{}/issues/{}/comments", super::GITHUB_BASE_API_URL, owner, repo, issue_number);


        let req = GitHubRequest {
            uri: request_uri,
            body: Some(C::from_json::<PostIssuesCreateComment>(body)?),
            method: "POST",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch_async(request).await?;

        // --

        if github_response.is_success() {
            Ok(github_response.to_json_async().await?)
        } else {
            match github_response.status_code() {
                403 => Err(IssuesCreateCommentError::Status403(github_response.to_json_async().await?).into()),
                410 => Err(IssuesCreateCommentError::Status410(github_response.to_json_async().await?).into()),
                422 => Err(IssuesCreateCommentError::Status422(github_response.to_json_async().await?).into()),
                404 => Err(IssuesCreateCommentError::Status404(github_response.to_json_async().await?).into()),
                code => Err(IssuesCreateCommentError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # Create an issue comment
    ///
    /// You can use the REST API to create comments on issues and pull requests. Every pull request is an issue, but not every issue is a pull request.
    /// 
    /// This endpoint triggers [notifications](https://docs.github.com/github/managing-subscriptions-and-notifications-on-github/about-notifications).
    /// Creating content too quickly using this endpoint may result in secondary rate limiting.
    /// For more information, see "[Rate limits for the API](https://docs.github.com/rest/using-the-rest-api/rate-limits-for-the-rest-api#about-secondary-rate-limits)"
    /// and "[Best practices for using the REST API](https://docs.github.com/rest/guides/best-practices-for-using-the-rest-api)."
    /// 
    /// This endpoint supports the following custom media types. For more information, see "[Media types](https://docs.github.com/rest/using-the-rest-api/getting-started-with-the-rest-api#media-types)."
    /// 
    /// - **`application/vnd.github.raw+json`**: Returns the raw markdown body. Response will include `body`. This is the default if you do not pass any specific media type.
    /// - **`application/vnd.github.text+json`**: Returns a text only representation of the markdown body. Response will include `body_text`.
    /// - **`application/vnd.github.html+json`**: Returns HTML rendered from the body's markdown. Response will include `body_html`.
    /// - **`application/vnd.github.full+json`**: Returns raw, text, and HTML representations. Response will include `body`, `body_text`, and `body_html`.
    ///
    /// [GitHub API docs for create_comment](https://docs.github.com/rest/issues/comments#create-an-issue-comment)
    ///
    /// ---
    #[cfg(not(target_arch = "wasm32"))]
    pub fn create_comment(&self, owner: &str, repo: &str, issue_number: i32, body: PostIssuesCreateComment) -> Result<IssueComment, AdapterError> {

        let request_uri = format!("{}/repos/{}/{}/issues/{}/comments", super::GITHUB_BASE_API_URL, owner, repo, issue_number);


        let req = GitHubRequest {
            uri: request_uri,
            body: Some(C::from_json::<PostIssuesCreateComment>(body)?),
            method: "POST",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch(request)?;

        // --

        if github_response.is_success() {
            Ok(github_response.to_json()?)
        } else {
            match github_response.status_code() {
                403 => Err(IssuesCreateCommentError::Status403(github_response.to_json()?).into()),
                410 => Err(IssuesCreateCommentError::Status410(github_response.to_json()?).into()),
                422 => Err(IssuesCreateCommentError::Status422(github_response.to_json()?).into()),
                404 => Err(IssuesCreateCommentError::Status404(github_response.to_json()?).into()),
                code => Err(IssuesCreateCommentError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # Create a label
    ///
    /// Creates a label for the specified repository with the given name and color. The name and color parameters are required. The color must be a valid [hexadecimal color code](http://www.color-hex.com/).
    ///
    /// [GitHub API docs for create_label](https://docs.github.com/rest/issues/labels#create-a-label)
    ///
    /// ---
    pub async fn create_label_async(&self, owner: &str, repo: &str, body: PostIssuesCreateLabel) -> Result<Label, AdapterError> {

        let request_uri = format!("{}/repos/{}/{}/labels", super::GITHUB_BASE_API_URL, owner, repo);


        let req = GitHubRequest {
            uri: request_uri,
            body: Some(C::from_json::<PostIssuesCreateLabel>(body)?),
            method: "POST",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch_async(request).await?;

        // --

        if github_response.is_success() {
            Ok(github_response.to_json_async().await?)
        } else {
            match github_response.status_code() {
                422 => Err(IssuesCreateLabelError::Status422(github_response.to_json_async().await?).into()),
                404 => Err(IssuesCreateLabelError::Status404(github_response.to_json_async().await?).into()),
                code => Err(IssuesCreateLabelError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # Create a label
    ///
    /// Creates a label for the specified repository with the given name and color. The name and color parameters are required. The color must be a valid [hexadecimal color code](http://www.color-hex.com/).
    ///
    /// [GitHub API docs for create_label](https://docs.github.com/rest/issues/labels#create-a-label)
    ///
    /// ---
    #[cfg(not(target_arch = "wasm32"))]
    pub fn create_label(&self, owner: &str, repo: &str, body: PostIssuesCreateLabel) -> Result<Label, AdapterError> {

        let request_uri = format!("{}/repos/{}/{}/labels", super::GITHUB_BASE_API_URL, owner, repo);


        let req = GitHubRequest {
            uri: request_uri,
            body: Some(C::from_json::<PostIssuesCreateLabel>(body)?),
            method: "POST",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch(request)?;

        // --

        if github_response.is_success() {
            Ok(github_response.to_json()?)
        } else {
            match github_response.status_code() {
                422 => Err(IssuesCreateLabelError::Status422(github_response.to_json()?).into()),
                404 => Err(IssuesCreateLabelError::Status404(github_response.to_json()?).into()),
                code => Err(IssuesCreateLabelError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # Create a milestone
    ///
    /// Creates a milestone.
    ///
    /// [GitHub API docs for create_milestone](https://docs.github.com/rest/issues/milestones#create-a-milestone)
    ///
    /// ---
    pub async fn create_milestone_async(&self, owner: &str, repo: &str, body: PostIssuesCreateMilestone) -> Result<Milestone, AdapterError> {

        let request_uri = format!("{}/repos/{}/{}/milestones", super::GITHUB_BASE_API_URL, owner, repo);


        let req = GitHubRequest {
            uri: request_uri,
            body: Some(C::from_json::<PostIssuesCreateMilestone>(body)?),
            method: "POST",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch_async(request).await?;

        // --

        if github_response.is_success() {
            Ok(github_response.to_json_async().await?)
        } else {
            match github_response.status_code() {
                404 => Err(IssuesCreateMilestoneError::Status404(github_response.to_json_async().await?).into()),
                422 => Err(IssuesCreateMilestoneError::Status422(github_response.to_json_async().await?).into()),
                code => Err(IssuesCreateMilestoneError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # Create a milestone
    ///
    /// Creates a milestone.
    ///
    /// [GitHub API docs for create_milestone](https://docs.github.com/rest/issues/milestones#create-a-milestone)
    ///
    /// ---
    #[cfg(not(target_arch = "wasm32"))]
    pub fn create_milestone(&self, owner: &str, repo: &str, body: PostIssuesCreateMilestone) -> Result<Milestone, AdapterError> {

        let request_uri = format!("{}/repos/{}/{}/milestones", super::GITHUB_BASE_API_URL, owner, repo);


        let req = GitHubRequest {
            uri: request_uri,
            body: Some(C::from_json::<PostIssuesCreateMilestone>(body)?),
            method: "POST",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch(request)?;

        // --

        if github_response.is_success() {
            Ok(github_response.to_json()?)
        } else {
            match github_response.status_code() {
                404 => Err(IssuesCreateMilestoneError::Status404(github_response.to_json()?).into()),
                422 => Err(IssuesCreateMilestoneError::Status422(github_response.to_json()?).into()),
                code => Err(IssuesCreateMilestoneError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # Delete an issue comment
    ///
    /// You can use the REST API to delete comments on issues and pull requests. Every pull request is an issue, but not every issue is a pull request.
    ///
    /// [GitHub API docs for delete_comment](https://docs.github.com/rest/issues/comments#delete-an-issue-comment)
    ///
    /// ---
    pub async fn delete_comment_async(&self, owner: &str, repo: &str, comment_id: i64) -> Result<(), AdapterError> {

        let request_uri = format!("{}/repos/{}/{}/issues/comments/{}", super::GITHUB_BASE_API_URL, owner, repo, comment_id);


        let req = GitHubRequest {
            uri: request_uri,
            body: None::<C::Body>,
            method: "DELETE",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch_async(request).await?;

        // --

        if github_response.is_success() {
            Ok(())
        } else {
            match github_response.status_code() {
                code => Err(IssuesDeleteCommentError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # Delete an issue comment
    ///
    /// You can use the REST API to delete comments on issues and pull requests. Every pull request is an issue, but not every issue is a pull request.
    ///
    /// [GitHub API docs for delete_comment](https://docs.github.com/rest/issues/comments#delete-an-issue-comment)
    ///
    /// ---
    #[cfg(not(target_arch = "wasm32"))]
    pub fn delete_comment(&self, owner: &str, repo: &str, comment_id: i64) -> Result<(), AdapterError> {

        let request_uri = format!("{}/repos/{}/{}/issues/comments/{}", super::GITHUB_BASE_API_URL, owner, repo, comment_id);


        let req = GitHubRequest {
            uri: request_uri,
            body: None,
            method: "DELETE",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch(request)?;

        // --

        if github_response.is_success() {
            Ok(())
        } else {
            match github_response.status_code() {
                code => Err(IssuesDeleteCommentError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # Delete a label
    ///
    /// Deletes a label using the given label name.
    ///
    /// [GitHub API docs for delete_label](https://docs.github.com/rest/issues/labels#delete-a-label)
    ///
    /// ---
    pub async fn delete_label_async(&self, owner: &str, repo: &str, name: &str) -> Result<(), AdapterError> {

        let request_uri = format!("{}/repos/{}/{}/labels/{}", super::GITHUB_BASE_API_URL, owner, repo, name);


        let req = GitHubRequest {
            uri: request_uri,
            body: None::<C::Body>,
            method: "DELETE",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch_async(request).await?;

        // --

        if github_response.is_success() {
            Ok(())
        } else {
            match github_response.status_code() {
                code => Err(IssuesDeleteLabelError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # Delete a label
    ///
    /// Deletes a label using the given label name.
    ///
    /// [GitHub API docs for delete_label](https://docs.github.com/rest/issues/labels#delete-a-label)
    ///
    /// ---
    #[cfg(not(target_arch = "wasm32"))]
    pub fn delete_label(&self, owner: &str, repo: &str, name: &str) -> Result<(), AdapterError> {

        let request_uri = format!("{}/repos/{}/{}/labels/{}", super::GITHUB_BASE_API_URL, owner, repo, name);


        let req = GitHubRequest {
            uri: request_uri,
            body: None,
            method: "DELETE",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch(request)?;

        // --

        if github_response.is_success() {
            Ok(())
        } else {
            match github_response.status_code() {
                code => Err(IssuesDeleteLabelError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # Delete a milestone
    ///
    /// Deletes a milestone using the given milestone number.
    ///
    /// [GitHub API docs for delete_milestone](https://docs.github.com/rest/issues/milestones#delete-a-milestone)
    ///
    /// ---
    pub async fn delete_milestone_async(&self, owner: &str, repo: &str, milestone_number: i32) -> Result<(), AdapterError> {

        let request_uri = format!("{}/repos/{}/{}/milestones/{}", super::GITHUB_BASE_API_URL, owner, repo, milestone_number);


        let req = GitHubRequest {
            uri: request_uri,
            body: None::<C::Body>,
            method: "DELETE",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch_async(request).await?;

        // --

        if github_response.is_success() {
            Ok(())
        } else {
            match github_response.status_code() {
                404 => Err(IssuesDeleteMilestoneError::Status404(github_response.to_json_async().await?).into()),
                code => Err(IssuesDeleteMilestoneError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # Delete a milestone
    ///
    /// Deletes a milestone using the given milestone number.
    ///
    /// [GitHub API docs for delete_milestone](https://docs.github.com/rest/issues/milestones#delete-a-milestone)
    ///
    /// ---
    #[cfg(not(target_arch = "wasm32"))]
    pub fn delete_milestone(&self, owner: &str, repo: &str, milestone_number: i32) -> Result<(), AdapterError> {

        let request_uri = format!("{}/repos/{}/{}/milestones/{}", super::GITHUB_BASE_API_URL, owner, repo, milestone_number);


        let req = GitHubRequest {
            uri: request_uri,
            body: None,
            method: "DELETE",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch(request)?;

        // --

        if github_response.is_success() {
            Ok(())
        } else {
            match github_response.status_code() {
                404 => Err(IssuesDeleteMilestoneError::Status404(github_response.to_json()?).into()),
                code => Err(IssuesDeleteMilestoneError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # Get an issue
    ///
    /// The API returns a [`301 Moved Permanently` status](https://docs.github.com/rest/guides/best-practices-for-using-the-rest-api#follow-redirects) if the issue was
    /// [transferred](https://docs.github.com/articles/transferring-an-issue-to-another-repository/) to another repository. If
    /// the issue was transferred to or deleted from a repository where the authenticated user lacks read access, the API
    /// returns a `404 Not Found` status. If the issue was deleted from a repository where the authenticated user has read
    /// access, the API returns a `410 Gone` status. To receive webhook events for transferred and deleted issues, subscribe
    /// to the [`issues`](https://docs.github.com/webhooks/event-payloads/#issues) webhook.
    /// 
    /// > [!NOTE]
    /// > GitHub's REST API considers every pull request an issue, but not every issue is a pull request. For this reason, "Issues" endpoints may return both issues and pull requests in the response. You can identify pull requests by the `pull_request` key. Be aware that the `id` of a pull request returned from "Issues" endpoints will be an _issue id_. To find out the pull request id, use the "[List pull requests](https://docs.github.com/rest/pulls/pulls#list-pull-requests)" endpoint.
    /// 
    /// This endpoint supports the following custom media types. For more information, see "[Media types](https://docs.github.com/rest/using-the-rest-api/getting-started-with-the-rest-api#media-types)."
    /// 
    /// - **`application/vnd.github.raw+json`**: Returns the raw markdown body. Response will include `body`. This is the default if you do not pass any specific media type.
    /// - **`application/vnd.github.text+json`**: Returns a text only representation of the markdown body. Response will include `body_text`.
    /// - **`application/vnd.github.html+json`**: Returns HTML rendered from the body's markdown. Response will include `body_html`.
    /// - **`application/vnd.github.full+json`**: Returns raw, text, and HTML representations. Response will include `body`, `body_text`, and `body_html`.
    ///
    /// [GitHub API docs for get](https://docs.github.com/rest/issues/issues#get-an-issue)
    ///
    /// ---
    pub async fn get_async(&self, owner: &str, repo: &str, issue_number: i32) -> Result<Issue, AdapterError> {

        let request_uri = format!("{}/repos/{}/{}/issues/{}", super::GITHUB_BASE_API_URL, owner, repo, issue_number);


        let req = GitHubRequest {
            uri: request_uri,
            body: None::<C::Body>,
            method: "GET",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch_async(request).await?;

        // --

        if github_response.is_success() {
            Ok(github_response.to_json_async().await?)
        } else {
            match github_response.status_code() {
                301 => Err(IssuesGetError::Status301(github_response.to_json_async().await?).into()),
                404 => Err(IssuesGetError::Status404(github_response.to_json_async().await?).into()),
                410 => Err(IssuesGetError::Status410(github_response.to_json_async().await?).into()),
                304 => Err(IssuesGetError::Status304.into()),
                code => Err(IssuesGetError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # Get an issue
    ///
    /// The API returns a [`301 Moved Permanently` status](https://docs.github.com/rest/guides/best-practices-for-using-the-rest-api#follow-redirects) if the issue was
    /// [transferred](https://docs.github.com/articles/transferring-an-issue-to-another-repository/) to another repository. If
    /// the issue was transferred to or deleted from a repository where the authenticated user lacks read access, the API
    /// returns a `404 Not Found` status. If the issue was deleted from a repository where the authenticated user has read
    /// access, the API returns a `410 Gone` status. To receive webhook events for transferred and deleted issues, subscribe
    /// to the [`issues`](https://docs.github.com/webhooks/event-payloads/#issues) webhook.
    /// 
    /// > [!NOTE]
    /// > GitHub's REST API considers every pull request an issue, but not every issue is a pull request. For this reason, "Issues" endpoints may return both issues and pull requests in the response. You can identify pull requests by the `pull_request` key. Be aware that the `id` of a pull request returned from "Issues" endpoints will be an _issue id_. To find out the pull request id, use the "[List pull requests](https://docs.github.com/rest/pulls/pulls#list-pull-requests)" endpoint.
    /// 
    /// This endpoint supports the following custom media types. For more information, see "[Media types](https://docs.github.com/rest/using-the-rest-api/getting-started-with-the-rest-api#media-types)."
    /// 
    /// - **`application/vnd.github.raw+json`**: Returns the raw markdown body. Response will include `body`. This is the default if you do not pass any specific media type.
    /// - **`application/vnd.github.text+json`**: Returns a text only representation of the markdown body. Response will include `body_text`.
    /// - **`application/vnd.github.html+json`**: Returns HTML rendered from the body's markdown. Response will include `body_html`.
    /// - **`application/vnd.github.full+json`**: Returns raw, text, and HTML representations. Response will include `body`, `body_text`, and `body_html`.
    ///
    /// [GitHub API docs for get](https://docs.github.com/rest/issues/issues#get-an-issue)
    ///
    /// ---
    #[cfg(not(target_arch = "wasm32"))]
    pub fn get(&self, owner: &str, repo: &str, issue_number: i32) -> Result<Issue, AdapterError> {

        let request_uri = format!("{}/repos/{}/{}/issues/{}", super::GITHUB_BASE_API_URL, owner, repo, issue_number);


        let req = GitHubRequest {
            uri: request_uri,
            body: None,
            method: "GET",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch(request)?;

        // --

        if github_response.is_success() {
            Ok(github_response.to_json()?)
        } else {
            match github_response.status_code() {
                301 => Err(IssuesGetError::Status301(github_response.to_json()?).into()),
                404 => Err(IssuesGetError::Status404(github_response.to_json()?).into()),
                410 => Err(IssuesGetError::Status410(github_response.to_json()?).into()),
                304 => Err(IssuesGetError::Status304.into()),
                code => Err(IssuesGetError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # Get an issue comment
    ///
    /// You can use the REST API to get comments on issues and pull requests. Every pull request is an issue, but not every issue is a pull request.
    /// 
    /// This endpoint supports the following custom media types. For more information, see "[Media types](https://docs.github.com/rest/using-the-rest-api/getting-started-with-the-rest-api#media-types)."
    /// 
    /// - **`application/vnd.github.raw+json`**: Returns the raw markdown body. Response will include `body`. This is the default if you do not pass any specific media type.
    /// - **`application/vnd.github.text+json`**: Returns a text only representation of the markdown body. Response will include `body_text`.
    /// - **`application/vnd.github.html+json`**: Returns HTML rendered from the body's markdown. Response will include `body_html`.
    /// - **`application/vnd.github.full+json`**: Returns raw, text, and HTML representations. Response will include `body`, `body_text`, and `body_html`.
    ///
    /// [GitHub API docs for get_comment](https://docs.github.com/rest/issues/comments#get-an-issue-comment)
    ///
    /// ---
    pub async fn get_comment_async(&self, owner: &str, repo: &str, comment_id: i64) -> Result<IssueComment, AdapterError> {

        let request_uri = format!("{}/repos/{}/{}/issues/comments/{}", super::GITHUB_BASE_API_URL, owner, repo, comment_id);


        let req = GitHubRequest {
            uri: request_uri,
            body: None::<C::Body>,
            method: "GET",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch_async(request).await?;

        // --

        if github_response.is_success() {
            Ok(github_response.to_json_async().await?)
        } else {
            match github_response.status_code() {
                404 => Err(IssuesGetCommentError::Status404(github_response.to_json_async().await?).into()),
                code => Err(IssuesGetCommentError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # Get an issue comment
    ///
    /// You can use the REST API to get comments on issues and pull requests. Every pull request is an issue, but not every issue is a pull request.
    /// 
    /// This endpoint supports the following custom media types. For more information, see "[Media types](https://docs.github.com/rest/using-the-rest-api/getting-started-with-the-rest-api#media-types)."
    /// 
    /// - **`application/vnd.github.raw+json`**: Returns the raw markdown body. Response will include `body`. This is the default if you do not pass any specific media type.
    /// - **`application/vnd.github.text+json`**: Returns a text only representation of the markdown body. Response will include `body_text`.
    /// - **`application/vnd.github.html+json`**: Returns HTML rendered from the body's markdown. Response will include `body_html`.
    /// - **`application/vnd.github.full+json`**: Returns raw, text, and HTML representations. Response will include `body`, `body_text`, and `body_html`.
    ///
    /// [GitHub API docs for get_comment](https://docs.github.com/rest/issues/comments#get-an-issue-comment)
    ///
    /// ---
    #[cfg(not(target_arch = "wasm32"))]
    pub fn get_comment(&self, owner: &str, repo: &str, comment_id: i64) -> Result<IssueComment, AdapterError> {

        let request_uri = format!("{}/repos/{}/{}/issues/comments/{}", super::GITHUB_BASE_API_URL, owner, repo, comment_id);


        let req = GitHubRequest {
            uri: request_uri,
            body: None,
            method: "GET",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch(request)?;

        // --

        if github_response.is_success() {
            Ok(github_response.to_json()?)
        } else {
            match github_response.status_code() {
                404 => Err(IssuesGetCommentError::Status404(github_response.to_json()?).into()),
                code => Err(IssuesGetCommentError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # Get an issue event
    ///
    /// Gets a single event by the event id.
    ///
    /// [GitHub API docs for get_event](https://docs.github.com/rest/issues/events#get-an-issue-event)
    ///
    /// ---
    pub async fn get_event_async(&self, owner: &str, repo: &str, event_id: i32) -> Result<IssueEvent, AdapterError> {

        let request_uri = format!("{}/repos/{}/{}/issues/events/{}", super::GITHUB_BASE_API_URL, owner, repo, event_id);


        let req = GitHubRequest {
            uri: request_uri,
            body: None::<C::Body>,
            method: "GET",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch_async(request).await?;

        // --

        if github_response.is_success() {
            Ok(github_response.to_json_async().await?)
        } else {
            match github_response.status_code() {
                404 => Err(IssuesGetEventError::Status404(github_response.to_json_async().await?).into()),
                410 => Err(IssuesGetEventError::Status410(github_response.to_json_async().await?).into()),
                403 => Err(IssuesGetEventError::Status403(github_response.to_json_async().await?).into()),
                code => Err(IssuesGetEventError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # Get an issue event
    ///
    /// Gets a single event by the event id.
    ///
    /// [GitHub API docs for get_event](https://docs.github.com/rest/issues/events#get-an-issue-event)
    ///
    /// ---
    #[cfg(not(target_arch = "wasm32"))]
    pub fn get_event(&self, owner: &str, repo: &str, event_id: i32) -> Result<IssueEvent, AdapterError> {

        let request_uri = format!("{}/repos/{}/{}/issues/events/{}", super::GITHUB_BASE_API_URL, owner, repo, event_id);


        let req = GitHubRequest {
            uri: request_uri,
            body: None,
            method: "GET",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch(request)?;

        // --

        if github_response.is_success() {
            Ok(github_response.to_json()?)
        } else {
            match github_response.status_code() {
                404 => Err(IssuesGetEventError::Status404(github_response.to_json()?).into()),
                410 => Err(IssuesGetEventError::Status410(github_response.to_json()?).into()),
                403 => Err(IssuesGetEventError::Status403(github_response.to_json()?).into()),
                code => Err(IssuesGetEventError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # Get a label
    ///
    /// Gets a label using the given name.
    ///
    /// [GitHub API docs for get_label](https://docs.github.com/rest/issues/labels#get-a-label)
    ///
    /// ---
    pub async fn get_label_async(&self, owner: &str, repo: &str, name: &str) -> Result<Label, AdapterError> {

        let request_uri = format!("{}/repos/{}/{}/labels/{}", super::GITHUB_BASE_API_URL, owner, repo, name);


        let req = GitHubRequest {
            uri: request_uri,
            body: None::<C::Body>,
            method: "GET",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch_async(request).await?;

        // --

        if github_response.is_success() {
            Ok(github_response.to_json_async().await?)
        } else {
            match github_response.status_code() {
                404 => Err(IssuesGetLabelError::Status404(github_response.to_json_async().await?).into()),
                code => Err(IssuesGetLabelError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # Get a label
    ///
    /// Gets a label using the given name.
    ///
    /// [GitHub API docs for get_label](https://docs.github.com/rest/issues/labels#get-a-label)
    ///
    /// ---
    #[cfg(not(target_arch = "wasm32"))]
    pub fn get_label(&self, owner: &str, repo: &str, name: &str) -> Result<Label, AdapterError> {

        let request_uri = format!("{}/repos/{}/{}/labels/{}", super::GITHUB_BASE_API_URL, owner, repo, name);


        let req = GitHubRequest {
            uri: request_uri,
            body: None,
            method: "GET",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch(request)?;

        // --

        if github_response.is_success() {
            Ok(github_response.to_json()?)
        } else {
            match github_response.status_code() {
                404 => Err(IssuesGetLabelError::Status404(github_response.to_json()?).into()),
                code => Err(IssuesGetLabelError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # Get a milestone
    ///
    /// Gets a milestone using the given milestone number.
    ///
    /// [GitHub API docs for get_milestone](https://docs.github.com/rest/issues/milestones#get-a-milestone)
    ///
    /// ---
    pub async fn get_milestone_async(&self, owner: &str, repo: &str, milestone_number: i32) -> Result<Milestone, AdapterError> {

        let request_uri = format!("{}/repos/{}/{}/milestones/{}", super::GITHUB_BASE_API_URL, owner, repo, milestone_number);


        let req = GitHubRequest {
            uri: request_uri,
            body: None::<C::Body>,
            method: "GET",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch_async(request).await?;

        // --

        if github_response.is_success() {
            Ok(github_response.to_json_async().await?)
        } else {
            match github_response.status_code() {
                404 => Err(IssuesGetMilestoneError::Status404(github_response.to_json_async().await?).into()),
                code => Err(IssuesGetMilestoneError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # Get a milestone
    ///
    /// Gets a milestone using the given milestone number.
    ///
    /// [GitHub API docs for get_milestone](https://docs.github.com/rest/issues/milestones#get-a-milestone)
    ///
    /// ---
    #[cfg(not(target_arch = "wasm32"))]
    pub fn get_milestone(&self, owner: &str, repo: &str, milestone_number: i32) -> Result<Milestone, AdapterError> {

        let request_uri = format!("{}/repos/{}/{}/milestones/{}", super::GITHUB_BASE_API_URL, owner, repo, milestone_number);


        let req = GitHubRequest {
            uri: request_uri,
            body: None,
            method: "GET",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch(request)?;

        // --

        if github_response.is_success() {
            Ok(github_response.to_json()?)
        } else {
            match github_response.status_code() {
                404 => Err(IssuesGetMilestoneError::Status404(github_response.to_json()?).into()),
                code => Err(IssuesGetMilestoneError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # List issues assigned to the authenticated user
    ///
    /// List issues assigned to the authenticated user across all visible repositories including owned repositories, member
    /// repositories, and organization repositories. You can use the `filter` query parameter to fetch issues that are not
    /// necessarily assigned to you.
    /// 
    /// > [!NOTE]
    /// > GitHub's REST API considers every pull request an issue, but not every issue is a pull request. For this reason, "Issues" endpoints may return both issues and pull requests in the response. You can identify pull requests by the `pull_request` key. Be aware that the `id` of a pull request returned from "Issues" endpoints will be an _issue id_. To find out the pull request id, use the "[List pull requests](https://docs.github.com/rest/pulls/pulls#list-pull-requests)" endpoint.
    /// 
    /// This endpoint supports the following custom media types. For more information, see "[Media types](https://docs.github.com/rest/using-the-rest-api/getting-started-with-the-rest-api#media-types)."
    /// 
    /// - **`application/vnd.github.raw+json`**: Returns the raw markdown body. Response will include `body`. This is the default if you do not pass any specific media type.
    /// - **`application/vnd.github.text+json`**: Returns a text only representation of the markdown body. Response will include `body_text`.
    /// - **`application/vnd.github.html+json`**: Returns HTML rendered from the body's markdown. Response will include `body_html`.
    /// - **`application/vnd.github.full+json`**: Returns raw, text, and HTML representations. Response will include `body`, `body_text`, and `body_html`.
    ///
    /// [GitHub API docs for list](https://docs.github.com/rest/issues/issues#list-issues-assigned-to-the-authenticated-user)
    ///
    /// ---
    pub async fn list_async(&self, query_params: Option<impl Into<IssuesListParams<'api>>>) -> Result<Vec<Issue>, AdapterError> {

        let mut request_uri = format!("{}/issues", super::GITHUB_BASE_API_URL);

        if let Some(params) = query_params {
            request_uri.push_str("?");
            request_uri.push_str(&serde_urlencoded::to_string(params.into())?);
        }

        let req = GitHubRequest {
            uri: request_uri,
            body: None::<C::Body>,
            method: "GET",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch_async(request).await?;

        // --

        if github_response.is_success() {
            Ok(github_response.to_json_async().await?)
        } else {
            match github_response.status_code() {
                422 => Err(IssuesListError::Status422(github_response.to_json_async().await?).into()),
                304 => Err(IssuesListError::Status304.into()),
                404 => Err(IssuesListError::Status404(github_response.to_json_async().await?).into()),
                code => Err(IssuesListError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # List issues assigned to the authenticated user
    ///
    /// List issues assigned to the authenticated user across all visible repositories including owned repositories, member
    /// repositories, and organization repositories. You can use the `filter` query parameter to fetch issues that are not
    /// necessarily assigned to you.
    /// 
    /// > [!NOTE]
    /// > GitHub's REST API considers every pull request an issue, but not every issue is a pull request. For this reason, "Issues" endpoints may return both issues and pull requests in the response. You can identify pull requests by the `pull_request` key. Be aware that the `id` of a pull request returned from "Issues" endpoints will be an _issue id_. To find out the pull request id, use the "[List pull requests](https://docs.github.com/rest/pulls/pulls#list-pull-requests)" endpoint.
    /// 
    /// This endpoint supports the following custom media types. For more information, see "[Media types](https://docs.github.com/rest/using-the-rest-api/getting-started-with-the-rest-api#media-types)."
    /// 
    /// - **`application/vnd.github.raw+json`**: Returns the raw markdown body. Response will include `body`. This is the default if you do not pass any specific media type.
    /// - **`application/vnd.github.text+json`**: Returns a text only representation of the markdown body. Response will include `body_text`.
    /// - **`application/vnd.github.html+json`**: Returns HTML rendered from the body's markdown. Response will include `body_html`.
    /// - **`application/vnd.github.full+json`**: Returns raw, text, and HTML representations. Response will include `body`, `body_text`, and `body_html`.
    ///
    /// [GitHub API docs for list](https://docs.github.com/rest/issues/issues#list-issues-assigned-to-the-authenticated-user)
    ///
    /// ---
    #[cfg(not(target_arch = "wasm32"))]
    pub fn list(&self, query_params: Option<impl Into<IssuesListParams<'api>>>) -> Result<Vec<Issue>, AdapterError> {

        let mut request_uri = format!("{}/issues", super::GITHUB_BASE_API_URL);

        if let Some(params) = query_params {
            request_uri.push_str("?");
            let qp: IssuesListParams = params.into();
            request_uri.push_str(&serde_urlencoded::to_string(qp)?);
        }

        let req = GitHubRequest {
            uri: request_uri,
            body: None,
            method: "GET",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch(request)?;

        // --

        if github_response.is_success() {
            Ok(github_response.to_json()?)
        } else {
            match github_response.status_code() {
                422 => Err(IssuesListError::Status422(github_response.to_json()?).into()),
                304 => Err(IssuesListError::Status304.into()),
                404 => Err(IssuesListError::Status404(github_response.to_json()?).into()),
                code => Err(IssuesListError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # List assignees
    ///
    /// Lists the [available assignees](https://docs.github.com/articles/assigning-issues-and-pull-requests-to-other-github-users/) for issues in a repository.
    ///
    /// [GitHub API docs for list_assignees](https://docs.github.com/rest/issues/assignees#list-assignees)
    ///
    /// ---
    pub async fn list_assignees_async(&self, owner: &str, repo: &str, query_params: Option<impl Into<IssuesListAssigneesParams>>) -> Result<Vec<SimpleUser>, AdapterError> {

        let mut request_uri = format!("{}/repos/{}/{}/assignees", super::GITHUB_BASE_API_URL, owner, repo);

        if let Some(params) = query_params {
            request_uri.push_str("?");
            request_uri.push_str(&serde_urlencoded::to_string(params.into())?);
        }

        let req = GitHubRequest {
            uri: request_uri,
            body: None::<C::Body>,
            method: "GET",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch_async(request).await?;

        // --

        if github_response.is_success() {
            Ok(github_response.to_json_async().await?)
        } else {
            match github_response.status_code() {
                404 => Err(IssuesListAssigneesError::Status404(github_response.to_json_async().await?).into()),
                code => Err(IssuesListAssigneesError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # List assignees
    ///
    /// Lists the [available assignees](https://docs.github.com/articles/assigning-issues-and-pull-requests-to-other-github-users/) for issues in a repository.
    ///
    /// [GitHub API docs for list_assignees](https://docs.github.com/rest/issues/assignees#list-assignees)
    ///
    /// ---
    #[cfg(not(target_arch = "wasm32"))]
    pub fn list_assignees(&self, owner: &str, repo: &str, query_params: Option<impl Into<IssuesListAssigneesParams>>) -> Result<Vec<SimpleUser>, AdapterError> {

        let mut request_uri = format!("{}/repos/{}/{}/assignees", super::GITHUB_BASE_API_URL, owner, repo);

        if let Some(params) = query_params {
            request_uri.push_str("?");
            let qp: IssuesListAssigneesParams = params.into();
            request_uri.push_str(&serde_urlencoded::to_string(qp)?);
        }

        let req = GitHubRequest {
            uri: request_uri,
            body: None,
            method: "GET",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch(request)?;

        // --

        if github_response.is_success() {
            Ok(github_response.to_json()?)
        } else {
            match github_response.status_code() {
                404 => Err(IssuesListAssigneesError::Status404(github_response.to_json()?).into()),
                code => Err(IssuesListAssigneesError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # List issue comments
    ///
    /// You can use the REST API to list comments on issues and pull requests. Every pull request is an issue, but not every issue is a pull request.
    /// 
    /// Issue comments are ordered by ascending ID.
    /// 
    /// This endpoint supports the following custom media types. For more information, see "[Media types](https://docs.github.com/rest/using-the-rest-api/getting-started-with-the-rest-api#media-types)."
    /// 
    /// - **`application/vnd.github.raw+json`**: Returns the raw markdown body. Response will include `body`. This is the default if you do not pass any specific media type.
    /// - **`application/vnd.github.text+json`**: Returns a text only representation of the markdown body. Response will include `body_text`.
    /// - **`application/vnd.github.html+json`**: Returns HTML rendered from the body's markdown. Response will include `body_html`.
    /// - **`application/vnd.github.full+json`**: Returns raw, text, and HTML representations. Response will include `body`, `body_text`, and `body_html`.
    ///
    /// [GitHub API docs for list_comments](https://docs.github.com/rest/issues/comments#list-issue-comments)
    ///
    /// ---
    pub async fn list_comments_async(&self, owner: &str, repo: &str, issue_number: i32, query_params: Option<impl Into<IssuesListCommentsParams>>) -> Result<Vec<IssueComment>, AdapterError> {

        let mut request_uri = format!("{}/repos/{}/{}/issues/{}/comments", super::GITHUB_BASE_API_URL, owner, repo, issue_number);

        if let Some(params) = query_params {
            request_uri.push_str("?");
            request_uri.push_str(&serde_urlencoded::to_string(params.into())?);
        }

        let req = GitHubRequest {
            uri: request_uri,
            body: None::<C::Body>,
            method: "GET",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch_async(request).await?;

        // --

        if github_response.is_success() {
            Ok(github_response.to_json_async().await?)
        } else {
            match github_response.status_code() {
                404 => Err(IssuesListCommentsError::Status404(github_response.to_json_async().await?).into()),
                410 => Err(IssuesListCommentsError::Status410(github_response.to_json_async().await?).into()),
                code => Err(IssuesListCommentsError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # List issue comments
    ///
    /// You can use the REST API to list comments on issues and pull requests. Every pull request is an issue, but not every issue is a pull request.
    /// 
    /// Issue comments are ordered by ascending ID.
    /// 
    /// This endpoint supports the following custom media types. For more information, see "[Media types](https://docs.github.com/rest/using-the-rest-api/getting-started-with-the-rest-api#media-types)."
    /// 
    /// - **`application/vnd.github.raw+json`**: Returns the raw markdown body. Response will include `body`. This is the default if you do not pass any specific media type.
    /// - **`application/vnd.github.text+json`**: Returns a text only representation of the markdown body. Response will include `body_text`.
    /// - **`application/vnd.github.html+json`**: Returns HTML rendered from the body's markdown. Response will include `body_html`.
    /// - **`application/vnd.github.full+json`**: Returns raw, text, and HTML representations. Response will include `body`, `body_text`, and `body_html`.
    ///
    /// [GitHub API docs for list_comments](https://docs.github.com/rest/issues/comments#list-issue-comments)
    ///
    /// ---
    #[cfg(not(target_arch = "wasm32"))]
    pub fn list_comments(&self, owner: &str, repo: &str, issue_number: i32, query_params: Option<impl Into<IssuesListCommentsParams>>) -> Result<Vec<IssueComment>, AdapterError> {

        let mut request_uri = format!("{}/repos/{}/{}/issues/{}/comments", super::GITHUB_BASE_API_URL, owner, repo, issue_number);

        if let Some(params) = query_params {
            request_uri.push_str("?");
            let qp: IssuesListCommentsParams = params.into();
            request_uri.push_str(&serde_urlencoded::to_string(qp)?);
        }

        let req = GitHubRequest {
            uri: request_uri,
            body: None,
            method: "GET",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch(request)?;

        // --

        if github_response.is_success() {
            Ok(github_response.to_json()?)
        } else {
            match github_response.status_code() {
                404 => Err(IssuesListCommentsError::Status404(github_response.to_json()?).into()),
                410 => Err(IssuesListCommentsError::Status410(github_response.to_json()?).into()),
                code => Err(IssuesListCommentsError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # List issue comments for a repository
    ///
    /// You can use the REST API to list comments on issues and pull requests for a repository. Every pull request is an issue, but not every issue is a pull request.
    /// 
    /// By default, issue comments are ordered by ascending ID.
    /// 
    /// This endpoint supports the following custom media types. For more information, see "[Media types](https://docs.github.com/rest/using-the-rest-api/getting-started-with-the-rest-api#media-types)."
    /// 
    /// - **`application/vnd.github.raw+json`**: Returns the raw markdown body. Response will include `body`. This is the default if you do not pass any specific media type.
    /// - **`application/vnd.github.text+json`**: Returns a text only representation of the markdown body. Response will include `body_text`.
    /// - **`application/vnd.github.html+json`**: Returns HTML rendered from the body's markdown. Response will include `body_html`.
    /// - **`application/vnd.github.full+json`**: Returns raw, text, and HTML representations. Response will include `body`, `body_text`, and `body_html`.
    ///
    /// [GitHub API docs for list_comments_for_repo](https://docs.github.com/rest/issues/comments#list-issue-comments-for-a-repository)
    ///
    /// ---
    pub async fn list_comments_for_repo_async(&self, owner: &str, repo: &str, query_params: Option<impl Into<IssuesListCommentsForRepoParams<'api>>>) -> Result<Vec<IssueComment>, AdapterError> {

        let mut request_uri = format!("{}/repos/{}/{}/issues/comments", super::GITHUB_BASE_API_URL, owner, repo);

        if let Some(params) = query_params {
            request_uri.push_str("?");
            request_uri.push_str(&serde_urlencoded::to_string(params.into())?);
        }

        let req = GitHubRequest {
            uri: request_uri,
            body: None::<C::Body>,
            method: "GET",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch_async(request).await?;

        // --

        if github_response.is_success() {
            Ok(github_response.to_json_async().await?)
        } else {
            match github_response.status_code() {
                422 => Err(IssuesListCommentsForRepoError::Status422(github_response.to_json_async().await?).into()),
                404 => Err(IssuesListCommentsForRepoError::Status404(github_response.to_json_async().await?).into()),
                code => Err(IssuesListCommentsForRepoError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # List issue comments for a repository
    ///
    /// You can use the REST API to list comments on issues and pull requests for a repository. Every pull request is an issue, but not every issue is a pull request.
    /// 
    /// By default, issue comments are ordered by ascending ID.
    /// 
    /// This endpoint supports the following custom media types. For more information, see "[Media types](https://docs.github.com/rest/using-the-rest-api/getting-started-with-the-rest-api#media-types)."
    /// 
    /// - **`application/vnd.github.raw+json`**: Returns the raw markdown body. Response will include `body`. This is the default if you do not pass any specific media type.
    /// - **`application/vnd.github.text+json`**: Returns a text only representation of the markdown body. Response will include `body_text`.
    /// - **`application/vnd.github.html+json`**: Returns HTML rendered from the body's markdown. Response will include `body_html`.
    /// - **`application/vnd.github.full+json`**: Returns raw, text, and HTML representations. Response will include `body`, `body_text`, and `body_html`.
    ///
    /// [GitHub API docs for list_comments_for_repo](https://docs.github.com/rest/issues/comments#list-issue-comments-for-a-repository)
    ///
    /// ---
    #[cfg(not(target_arch = "wasm32"))]
    pub fn list_comments_for_repo(&self, owner: &str, repo: &str, query_params: Option<impl Into<IssuesListCommentsForRepoParams<'api>>>) -> Result<Vec<IssueComment>, AdapterError> {

        let mut request_uri = format!("{}/repos/{}/{}/issues/comments", super::GITHUB_BASE_API_URL, owner, repo);

        if let Some(params) = query_params {
            request_uri.push_str("?");
            let qp: IssuesListCommentsForRepoParams = params.into();
            request_uri.push_str(&serde_urlencoded::to_string(qp)?);
        }

        let req = GitHubRequest {
            uri: request_uri,
            body: None,
            method: "GET",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch(request)?;

        // --

        if github_response.is_success() {
            Ok(github_response.to_json()?)
        } else {
            match github_response.status_code() {
                422 => Err(IssuesListCommentsForRepoError::Status422(github_response.to_json()?).into()),
                404 => Err(IssuesListCommentsForRepoError::Status404(github_response.to_json()?).into()),
                code => Err(IssuesListCommentsForRepoError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # List issue events
    ///
    /// Lists all events for an issue.
    ///
    /// [GitHub API docs for list_events](https://docs.github.com/rest/issues/events#list-issue-events)
    ///
    /// ---
    pub async fn list_events_async(&self, owner: &str, repo: &str, issue_number: i32, query_params: Option<impl Into<IssuesListEventsParams>>) -> Result<Vec<IssueEventForIssue>, AdapterError> {

        let mut request_uri = format!("{}/repos/{}/{}/issues/{}/events", super::GITHUB_BASE_API_URL, owner, repo, issue_number);

        if let Some(params) = query_params {
            request_uri.push_str("?");
            request_uri.push_str(&serde_urlencoded::to_string(params.into())?);
        }

        let req = GitHubRequest {
            uri: request_uri,
            body: None::<C::Body>,
            method: "GET",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch_async(request).await?;

        // --

        if github_response.is_success() {
            Ok(github_response.to_json_async().await?)
        } else {
            match github_response.status_code() {
                410 => Err(IssuesListEventsError::Status410(github_response.to_json_async().await?).into()),
                code => Err(IssuesListEventsError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # List issue events
    ///
    /// Lists all events for an issue.
    ///
    /// [GitHub API docs for list_events](https://docs.github.com/rest/issues/events#list-issue-events)
    ///
    /// ---
    #[cfg(not(target_arch = "wasm32"))]
    pub fn list_events(&self, owner: &str, repo: &str, issue_number: i32, query_params: Option<impl Into<IssuesListEventsParams>>) -> Result<Vec<IssueEventForIssue>, AdapterError> {

        let mut request_uri = format!("{}/repos/{}/{}/issues/{}/events", super::GITHUB_BASE_API_URL, owner, repo, issue_number);

        if let Some(params) = query_params {
            request_uri.push_str("?");
            let qp: IssuesListEventsParams = params.into();
            request_uri.push_str(&serde_urlencoded::to_string(qp)?);
        }

        let req = GitHubRequest {
            uri: request_uri,
            body: None,
            method: "GET",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch(request)?;

        // --

        if github_response.is_success() {
            Ok(github_response.to_json()?)
        } else {
            match github_response.status_code() {
                410 => Err(IssuesListEventsError::Status410(github_response.to_json()?).into()),
                code => Err(IssuesListEventsError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # List issue events for a repository
    ///
    /// Lists events for a repository.
    ///
    /// [GitHub API docs for list_events_for_repo](https://docs.github.com/rest/issues/events#list-issue-events-for-a-repository)
    ///
    /// ---
    pub async fn list_events_for_repo_async(&self, owner: &str, repo: &str, query_params: Option<impl Into<IssuesListEventsForRepoParams>>) -> Result<Vec<IssueEvent>, AdapterError> {

        let mut request_uri = format!("{}/repos/{}/{}/issues/events", super::GITHUB_BASE_API_URL, owner, repo);

        if let Some(params) = query_params {
            request_uri.push_str("?");
            request_uri.push_str(&serde_urlencoded::to_string(params.into())?);
        }

        let req = GitHubRequest {
            uri: request_uri,
            body: None::<C::Body>,
            method: "GET",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch_async(request).await?;

        // --

        if github_response.is_success() {
            Ok(github_response.to_json_async().await?)
        } else {
            match github_response.status_code() {
                422 => Err(IssuesListEventsForRepoError::Status422(github_response.to_json_async().await?).into()),
                code => Err(IssuesListEventsForRepoError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # List issue events for a repository
    ///
    /// Lists events for a repository.
    ///
    /// [GitHub API docs for list_events_for_repo](https://docs.github.com/rest/issues/events#list-issue-events-for-a-repository)
    ///
    /// ---
    #[cfg(not(target_arch = "wasm32"))]
    pub fn list_events_for_repo(&self, owner: &str, repo: &str, query_params: Option<impl Into<IssuesListEventsForRepoParams>>) -> Result<Vec<IssueEvent>, AdapterError> {

        let mut request_uri = format!("{}/repos/{}/{}/issues/events", super::GITHUB_BASE_API_URL, owner, repo);

        if let Some(params) = query_params {
            request_uri.push_str("?");
            let qp: IssuesListEventsForRepoParams = params.into();
            request_uri.push_str(&serde_urlencoded::to_string(qp)?);
        }

        let req = GitHubRequest {
            uri: request_uri,
            body: None,
            method: "GET",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch(request)?;

        // --

        if github_response.is_success() {
            Ok(github_response.to_json()?)
        } else {
            match github_response.status_code() {
                422 => Err(IssuesListEventsForRepoError::Status422(github_response.to_json()?).into()),
                code => Err(IssuesListEventsForRepoError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # List timeline events for an issue
    ///
    /// List all timeline events for an issue.
    ///
    /// [GitHub API docs for list_events_for_timeline](https://docs.github.com/rest/issues/timeline#list-timeline-events-for-an-issue)
    ///
    /// ---
    pub async fn list_events_for_timeline_async(&self, owner: &str, repo: &str, issue_number: i32, query_params: Option<impl Into<IssuesListEventsForTimelineParams>>) -> Result<Vec<TimelineIssueEvents>, AdapterError> {

        let mut request_uri = format!("{}/repos/{}/{}/issues/{}/timeline", super::GITHUB_BASE_API_URL, owner, repo, issue_number);

        if let Some(params) = query_params {
            request_uri.push_str("?");
            request_uri.push_str(&serde_urlencoded::to_string(params.into())?);
        }

        let req = GitHubRequest {
            uri: request_uri,
            body: None::<C::Body>,
            method: "GET",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch_async(request).await?;

        // --

        if github_response.is_success() {
            Ok(github_response.to_json_async().await?)
        } else {
            match github_response.status_code() {
                404 => Err(IssuesListEventsForTimelineError::Status404(github_response.to_json_async().await?).into()),
                410 => Err(IssuesListEventsForTimelineError::Status410(github_response.to_json_async().await?).into()),
                code => Err(IssuesListEventsForTimelineError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # List timeline events for an issue
    ///
    /// List all timeline events for an issue.
    ///
    /// [GitHub API docs for list_events_for_timeline](https://docs.github.com/rest/issues/timeline#list-timeline-events-for-an-issue)
    ///
    /// ---
    #[cfg(not(target_arch = "wasm32"))]
    pub fn list_events_for_timeline(&self, owner: &str, repo: &str, issue_number: i32, query_params: Option<impl Into<IssuesListEventsForTimelineParams>>) -> Result<Vec<TimelineIssueEvents>, AdapterError> {

        let mut request_uri = format!("{}/repos/{}/{}/issues/{}/timeline", super::GITHUB_BASE_API_URL, owner, repo, issue_number);

        if let Some(params) = query_params {
            request_uri.push_str("?");
            let qp: IssuesListEventsForTimelineParams = params.into();
            request_uri.push_str(&serde_urlencoded::to_string(qp)?);
        }

        let req = GitHubRequest {
            uri: request_uri,
            body: None,
            method: "GET",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch(request)?;

        // --

        if github_response.is_success() {
            Ok(github_response.to_json()?)
        } else {
            match github_response.status_code() {
                404 => Err(IssuesListEventsForTimelineError::Status404(github_response.to_json()?).into()),
                410 => Err(IssuesListEventsForTimelineError::Status410(github_response.to_json()?).into()),
                code => Err(IssuesListEventsForTimelineError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # List user account issues assigned to the authenticated user
    ///
    /// List issues across owned and member repositories assigned to the authenticated user.
    /// 
    /// > [!NOTE]
    /// > GitHub's REST API considers every pull request an issue, but not every issue is a pull request. For this reason, "Issues" endpoints may return both issues and pull requests in the response. You can identify pull requests by the `pull_request` key. Be aware that the `id` of a pull request returned from "Issues" endpoints will be an _issue id_. To find out the pull request id, use the "[List pull requests](https://docs.github.com/rest/pulls/pulls#list-pull-requests)" endpoint.
    /// 
    /// This endpoint supports the following custom media types. For more information, see "[Media types](https://docs.github.com/rest/using-the-rest-api/getting-started-with-the-rest-api#media-types)."
    /// 
    /// - **`application/vnd.github.raw+json`**: Returns the raw markdown body. Response will include `body`. This is the default if you do not pass any specific media type.
    /// - **`application/vnd.github.text+json`**: Returns a text only representation of the markdown body. Response will include `body_text`.
    /// - **`application/vnd.github.html+json`**: Returns HTML rendered from the body's markdown. Response will include `body_html`.
    /// - **`application/vnd.github.full+json`**: Returns raw, text, and HTML representations. Response will include `body`, `body_text`, and `body_html`.
    ///
    /// [GitHub API docs for list_for_authenticated_user](https://docs.github.com/rest/issues/issues#list-user-account-issues-assigned-to-the-authenticated-user)
    ///
    /// ---
    pub async fn list_for_authenticated_user_async(&self, query_params: Option<impl Into<IssuesListForAuthenticatedUserParams<'api>>>) -> Result<Vec<Issue>, AdapterError> {

        let mut request_uri = format!("{}/user/issues", super::GITHUB_BASE_API_URL);

        if let Some(params) = query_params {
            request_uri.push_str("?");
            request_uri.push_str(&serde_urlencoded::to_string(params.into())?);
        }

        let req = GitHubRequest {
            uri: request_uri,
            body: None::<C::Body>,
            method: "GET",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch_async(request).await?;

        // --

        if github_response.is_success() {
            Ok(github_response.to_json_async().await?)
        } else {
            match github_response.status_code() {
                404 => Err(IssuesListForAuthenticatedUserError::Status404(github_response.to_json_async().await?).into()),
                304 => Err(IssuesListForAuthenticatedUserError::Status304.into()),
                code => Err(IssuesListForAuthenticatedUserError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # List user account issues assigned to the authenticated user
    ///
    /// List issues across owned and member repositories assigned to the authenticated user.
    /// 
    /// > [!NOTE]
    /// > GitHub's REST API considers every pull request an issue, but not every issue is a pull request. For this reason, "Issues" endpoints may return both issues and pull requests in the response. You can identify pull requests by the `pull_request` key. Be aware that the `id` of a pull request returned from "Issues" endpoints will be an _issue id_. To find out the pull request id, use the "[List pull requests](https://docs.github.com/rest/pulls/pulls#list-pull-requests)" endpoint.
    /// 
    /// This endpoint supports the following custom media types. For more information, see "[Media types](https://docs.github.com/rest/using-the-rest-api/getting-started-with-the-rest-api#media-types)."
    /// 
    /// - **`application/vnd.github.raw+json`**: Returns the raw markdown body. Response will include `body`. This is the default if you do not pass any specific media type.
    /// - **`application/vnd.github.text+json`**: Returns a text only representation of the markdown body. Response will include `body_text`.
    /// - **`application/vnd.github.html+json`**: Returns HTML rendered from the body's markdown. Response will include `body_html`.
    /// - **`application/vnd.github.full+json`**: Returns raw, text, and HTML representations. Response will include `body`, `body_text`, and `body_html`.
    ///
    /// [GitHub API docs for list_for_authenticated_user](https://docs.github.com/rest/issues/issues#list-user-account-issues-assigned-to-the-authenticated-user)
    ///
    /// ---
    #[cfg(not(target_arch = "wasm32"))]
    pub fn list_for_authenticated_user(&self, query_params: Option<impl Into<IssuesListForAuthenticatedUserParams<'api>>>) -> Result<Vec<Issue>, AdapterError> {

        let mut request_uri = format!("{}/user/issues", super::GITHUB_BASE_API_URL);

        if let Some(params) = query_params {
            request_uri.push_str("?");
            let qp: IssuesListForAuthenticatedUserParams = params.into();
            request_uri.push_str(&serde_urlencoded::to_string(qp)?);
        }

        let req = GitHubRequest {
            uri: request_uri,
            body: None,
            method: "GET",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch(request)?;

        // --

        if github_response.is_success() {
            Ok(github_response.to_json()?)
        } else {
            match github_response.status_code() {
                404 => Err(IssuesListForAuthenticatedUserError::Status404(github_response.to_json()?).into()),
                304 => Err(IssuesListForAuthenticatedUserError::Status304.into()),
                code => Err(IssuesListForAuthenticatedUserError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # List organization issues assigned to the authenticated user
    ///
    /// List issues in an organization assigned to the authenticated user.
    /// 
    /// > [!NOTE]
    /// > GitHub's REST API considers every pull request an issue, but not every issue is a pull request. For this reason, "Issues" endpoints may return both issues and pull requests in the response. You can identify pull requests by the `pull_request` key. Be aware that the `id` of a pull request returned from "Issues" endpoints will be an _issue id_. To find out the pull request id, use the "[List pull requests](https://docs.github.com/rest/pulls/pulls#list-pull-requests)" endpoint.
    /// 
    /// This endpoint supports the following custom media types. For more information, see "[Media types](https://docs.github.com/rest/using-the-rest-api/getting-started-with-the-rest-api#media-types)."
    /// 
    /// - **`application/vnd.github.raw+json`**: Returns the raw markdown body. Response will include `body`. This is the default if you do not pass any specific media type.
    /// - **`application/vnd.github.text+json`**: Returns a text only representation of the markdown body. Response will include `body_text`.
    /// - **`application/vnd.github.html+json`**: Returns HTML rendered from the body's markdown. Response will include `body_html`.
    /// - **`application/vnd.github.full+json`**: Returns raw, text, and HTML representations. Response will include `body`, `body_text`, and `body_html`.
    ///
    /// [GitHub API docs for list_for_org](https://docs.github.com/rest/issues/issues#list-organization-issues-assigned-to-the-authenticated-user)
    ///
    /// ---
    pub async fn list_for_org_async(&self, org: &str, query_params: Option<impl Into<IssuesListForOrgParams<'api>>>) -> Result<Vec<Issue>, AdapterError> {

        let mut request_uri = format!("{}/orgs/{}/issues", super::GITHUB_BASE_API_URL, org);

        if let Some(params) = query_params {
            request_uri.push_str("?");
            request_uri.push_str(&serde_urlencoded::to_string(params.into())?);
        }

        let req = GitHubRequest {
            uri: request_uri,
            body: None::<C::Body>,
            method: "GET",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch_async(request).await?;

        // --

        if github_response.is_success() {
            Ok(github_response.to_json_async().await?)
        } else {
            match github_response.status_code() {
                404 => Err(IssuesListForOrgError::Status404(github_response.to_json_async().await?).into()),
                code => Err(IssuesListForOrgError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # List organization issues assigned to the authenticated user
    ///
    /// List issues in an organization assigned to the authenticated user.
    /// 
    /// > [!NOTE]
    /// > GitHub's REST API considers every pull request an issue, but not every issue is a pull request. For this reason, "Issues" endpoints may return both issues and pull requests in the response. You can identify pull requests by the `pull_request` key. Be aware that the `id` of a pull request returned from "Issues" endpoints will be an _issue id_. To find out the pull request id, use the "[List pull requests](https://docs.github.com/rest/pulls/pulls#list-pull-requests)" endpoint.
    /// 
    /// This endpoint supports the following custom media types. For more information, see "[Media types](https://docs.github.com/rest/using-the-rest-api/getting-started-with-the-rest-api#media-types)."
    /// 
    /// - **`application/vnd.github.raw+json`**: Returns the raw markdown body. Response will include `body`. This is the default if you do not pass any specific media type.
    /// - **`application/vnd.github.text+json`**: Returns a text only representation of the markdown body. Response will include `body_text`.
    /// - **`application/vnd.github.html+json`**: Returns HTML rendered from the body's markdown. Response will include `body_html`.
    /// - **`application/vnd.github.full+json`**: Returns raw, text, and HTML representations. Response will include `body`, `body_text`, and `body_html`.
    ///
    /// [GitHub API docs for list_for_org](https://docs.github.com/rest/issues/issues#list-organization-issues-assigned-to-the-authenticated-user)
    ///
    /// ---
    #[cfg(not(target_arch = "wasm32"))]
    pub fn list_for_org(&self, org: &str, query_params: Option<impl Into<IssuesListForOrgParams<'api>>>) -> Result<Vec<Issue>, AdapterError> {

        let mut request_uri = format!("{}/orgs/{}/issues", super::GITHUB_BASE_API_URL, org);

        if let Some(params) = query_params {
            request_uri.push_str("?");
            let qp: IssuesListForOrgParams = params.into();
            request_uri.push_str(&serde_urlencoded::to_string(qp)?);
        }

        let req = GitHubRequest {
            uri: request_uri,
            body: None,
            method: "GET",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch(request)?;

        // --

        if github_response.is_success() {
            Ok(github_response.to_json()?)
        } else {
            match github_response.status_code() {
                404 => Err(IssuesListForOrgError::Status404(github_response.to_json()?).into()),
                code => Err(IssuesListForOrgError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # List repository issues
    ///
    /// List issues in a repository. Only open issues will be listed.
    /// 
    /// > [!NOTE]
    /// > GitHub's REST API considers every pull request an issue, but not every issue is a pull request. For this reason, "Issues" endpoints may return both issues and pull requests in the response. You can identify pull requests by the `pull_request` key. Be aware that the `id` of a pull request returned from "Issues" endpoints will be an _issue id_. To find out the pull request id, use the "[List pull requests](https://docs.github.com/rest/pulls/pulls#list-pull-requests)" endpoint.
    /// 
    /// This endpoint supports the following custom media types. For more information, see "[Media types](https://docs.github.com/rest/using-the-rest-api/getting-started-with-the-rest-api#media-types)."
    /// 
    /// - **`application/vnd.github.raw+json`**: Returns the raw markdown body. Response will include `body`. This is the default if you do not pass any specific media type.
    /// - **`application/vnd.github.text+json`**: Returns a text only representation of the markdown body. Response will include `body_text`.
    /// - **`application/vnd.github.html+json`**: Returns HTML rendered from the body's markdown. Response will include `body_html`.
    /// - **`application/vnd.github.full+json`**: Returns raw, text, and HTML representations. Response will include `body`, `body_text`, and `body_html`.
    ///
    /// [GitHub API docs for list_for_repo](https://docs.github.com/rest/issues/issues#list-repository-issues)
    ///
    /// ---
    pub async fn list_for_repo_async(&self, owner: &str, repo: &str, query_params: Option<impl Into<IssuesListForRepoParams<'api>>>) -> Result<Vec<Issue>, AdapterError> {

        let mut request_uri = format!("{}/repos/{}/{}/issues", super::GITHUB_BASE_API_URL, owner, repo);

        if let Some(params) = query_params {
            request_uri.push_str("?");
            request_uri.push_str(&serde_urlencoded::to_string(params.into())?);
        }

        let req = GitHubRequest {
            uri: request_uri,
            body: None::<C::Body>,
            method: "GET",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch_async(request).await?;

        // --

        if github_response.is_success() {
            Ok(github_response.to_json_async().await?)
        } else {
            match github_response.status_code() {
                301 => Err(IssuesListForRepoError::Status301(github_response.to_json_async().await?).into()),
                422 => Err(IssuesListForRepoError::Status422(github_response.to_json_async().await?).into()),
                404 => Err(IssuesListForRepoError::Status404(github_response.to_json_async().await?).into()),
                code => Err(IssuesListForRepoError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # List repository issues
    ///
    /// List issues in a repository. Only open issues will be listed.
    /// 
    /// > [!NOTE]
    /// > GitHub's REST API considers every pull request an issue, but not every issue is a pull request. For this reason, "Issues" endpoints may return both issues and pull requests in the response. You can identify pull requests by the `pull_request` key. Be aware that the `id` of a pull request returned from "Issues" endpoints will be an _issue id_. To find out the pull request id, use the "[List pull requests](https://docs.github.com/rest/pulls/pulls#list-pull-requests)" endpoint.
    /// 
    /// This endpoint supports the following custom media types. For more information, see "[Media types](https://docs.github.com/rest/using-the-rest-api/getting-started-with-the-rest-api#media-types)."
    /// 
    /// - **`application/vnd.github.raw+json`**: Returns the raw markdown body. Response will include `body`. This is the default if you do not pass any specific media type.
    /// - **`application/vnd.github.text+json`**: Returns a text only representation of the markdown body. Response will include `body_text`.
    /// - **`application/vnd.github.html+json`**: Returns HTML rendered from the body's markdown. Response will include `body_html`.
    /// - **`application/vnd.github.full+json`**: Returns raw, text, and HTML representations. Response will include `body`, `body_text`, and `body_html`.
    ///
    /// [GitHub API docs for list_for_repo](https://docs.github.com/rest/issues/issues#list-repository-issues)
    ///
    /// ---
    #[cfg(not(target_arch = "wasm32"))]
    pub fn list_for_repo(&self, owner: &str, repo: &str, query_params: Option<impl Into<IssuesListForRepoParams<'api>>>) -> Result<Vec<Issue>, AdapterError> {

        let mut request_uri = format!("{}/repos/{}/{}/issues", super::GITHUB_BASE_API_URL, owner, repo);

        if let Some(params) = query_params {
            request_uri.push_str("?");
            let qp: IssuesListForRepoParams = params.into();
            request_uri.push_str(&serde_urlencoded::to_string(qp)?);
        }

        let req = GitHubRequest {
            uri: request_uri,
            body: None,
            method: "GET",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch(request)?;

        // --

        if github_response.is_success() {
            Ok(github_response.to_json()?)
        } else {
            match github_response.status_code() {
                301 => Err(IssuesListForRepoError::Status301(github_response.to_json()?).into()),
                422 => Err(IssuesListForRepoError::Status422(github_response.to_json()?).into()),
                404 => Err(IssuesListForRepoError::Status404(github_response.to_json()?).into()),
                code => Err(IssuesListForRepoError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # List labels for issues in a milestone
    ///
    /// Lists labels for issues in a milestone.
    ///
    /// [GitHub API docs for list_labels_for_milestone](https://docs.github.com/rest/issues/labels#list-labels-for-issues-in-a-milestone)
    ///
    /// ---
    pub async fn list_labels_for_milestone_async(&self, owner: &str, repo: &str, milestone_number: i32, query_params: Option<impl Into<IssuesListLabelsForMilestoneParams>>) -> Result<Vec<Label>, AdapterError> {

        let mut request_uri = format!("{}/repos/{}/{}/milestones/{}/labels", super::GITHUB_BASE_API_URL, owner, repo, milestone_number);

        if let Some(params) = query_params {
            request_uri.push_str("?");
            request_uri.push_str(&serde_urlencoded::to_string(params.into())?);
        }

        let req = GitHubRequest {
            uri: request_uri,
            body: None::<C::Body>,
            method: "GET",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch_async(request).await?;

        // --

        if github_response.is_success() {
            Ok(github_response.to_json_async().await?)
        } else {
            match github_response.status_code() {
                code => Err(IssuesListLabelsForMilestoneError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # List labels for issues in a milestone
    ///
    /// Lists labels for issues in a milestone.
    ///
    /// [GitHub API docs for list_labels_for_milestone](https://docs.github.com/rest/issues/labels#list-labels-for-issues-in-a-milestone)
    ///
    /// ---
    #[cfg(not(target_arch = "wasm32"))]
    pub fn list_labels_for_milestone(&self, owner: &str, repo: &str, milestone_number: i32, query_params: Option<impl Into<IssuesListLabelsForMilestoneParams>>) -> Result<Vec<Label>, AdapterError> {

        let mut request_uri = format!("{}/repos/{}/{}/milestones/{}/labels", super::GITHUB_BASE_API_URL, owner, repo, milestone_number);

        if let Some(params) = query_params {
            request_uri.push_str("?");
            let qp: IssuesListLabelsForMilestoneParams = params.into();
            request_uri.push_str(&serde_urlencoded::to_string(qp)?);
        }

        let req = GitHubRequest {
            uri: request_uri,
            body: None,
            method: "GET",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch(request)?;

        // --

        if github_response.is_success() {
            Ok(github_response.to_json()?)
        } else {
            match github_response.status_code() {
                code => Err(IssuesListLabelsForMilestoneError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # List labels for a repository
    ///
    /// Lists all labels for a repository.
    ///
    /// [GitHub API docs for list_labels_for_repo](https://docs.github.com/rest/issues/labels#list-labels-for-a-repository)
    ///
    /// ---
    pub async fn list_labels_for_repo_async(&self, owner: &str, repo: &str, query_params: Option<impl Into<IssuesListLabelsForRepoParams>>) -> Result<Vec<Label>, AdapterError> {

        let mut request_uri = format!("{}/repos/{}/{}/labels", super::GITHUB_BASE_API_URL, owner, repo);

        if let Some(params) = query_params {
            request_uri.push_str("?");
            request_uri.push_str(&serde_urlencoded::to_string(params.into())?);
        }

        let req = GitHubRequest {
            uri: request_uri,
            body: None::<C::Body>,
            method: "GET",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch_async(request).await?;

        // --

        if github_response.is_success() {
            Ok(github_response.to_json_async().await?)
        } else {
            match github_response.status_code() {
                404 => Err(IssuesListLabelsForRepoError::Status404(github_response.to_json_async().await?).into()),
                code => Err(IssuesListLabelsForRepoError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # List labels for a repository
    ///
    /// Lists all labels for a repository.
    ///
    /// [GitHub API docs for list_labels_for_repo](https://docs.github.com/rest/issues/labels#list-labels-for-a-repository)
    ///
    /// ---
    #[cfg(not(target_arch = "wasm32"))]
    pub fn list_labels_for_repo(&self, owner: &str, repo: &str, query_params: Option<impl Into<IssuesListLabelsForRepoParams>>) -> Result<Vec<Label>, AdapterError> {

        let mut request_uri = format!("{}/repos/{}/{}/labels", super::GITHUB_BASE_API_URL, owner, repo);

        if let Some(params) = query_params {
            request_uri.push_str("?");
            let qp: IssuesListLabelsForRepoParams = params.into();
            request_uri.push_str(&serde_urlencoded::to_string(qp)?);
        }

        let req = GitHubRequest {
            uri: request_uri,
            body: None,
            method: "GET",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch(request)?;

        // --

        if github_response.is_success() {
            Ok(github_response.to_json()?)
        } else {
            match github_response.status_code() {
                404 => Err(IssuesListLabelsForRepoError::Status404(github_response.to_json()?).into()),
                code => Err(IssuesListLabelsForRepoError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # List labels for an issue
    ///
    /// Lists all labels for an issue.
    ///
    /// [GitHub API docs for list_labels_on_issue](https://docs.github.com/rest/issues/labels#list-labels-for-an-issue)
    ///
    /// ---
    pub async fn list_labels_on_issue_async(&self, owner: &str, repo: &str, issue_number: i32, query_params: Option<impl Into<IssuesListLabelsOnIssueParams>>) -> Result<Vec<Label>, AdapterError> {

        let mut request_uri = format!("{}/repos/{}/{}/issues/{}/labels", super::GITHUB_BASE_API_URL, owner, repo, issue_number);

        if let Some(params) = query_params {
            request_uri.push_str("?");
            request_uri.push_str(&serde_urlencoded::to_string(params.into())?);
        }

        let req = GitHubRequest {
            uri: request_uri,
            body: None::<C::Body>,
            method: "GET",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch_async(request).await?;

        // --

        if github_response.is_success() {
            Ok(github_response.to_json_async().await?)
        } else {
            match github_response.status_code() {
                301 => Err(IssuesListLabelsOnIssueError::Status301(github_response.to_json_async().await?).into()),
                404 => Err(IssuesListLabelsOnIssueError::Status404(github_response.to_json_async().await?).into()),
                410 => Err(IssuesListLabelsOnIssueError::Status410(github_response.to_json_async().await?).into()),
                code => Err(IssuesListLabelsOnIssueError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # List labels for an issue
    ///
    /// Lists all labels for an issue.
    ///
    /// [GitHub API docs for list_labels_on_issue](https://docs.github.com/rest/issues/labels#list-labels-for-an-issue)
    ///
    /// ---
    #[cfg(not(target_arch = "wasm32"))]
    pub fn list_labels_on_issue(&self, owner: &str, repo: &str, issue_number: i32, query_params: Option<impl Into<IssuesListLabelsOnIssueParams>>) -> Result<Vec<Label>, AdapterError> {

        let mut request_uri = format!("{}/repos/{}/{}/issues/{}/labels", super::GITHUB_BASE_API_URL, owner, repo, issue_number);

        if let Some(params) = query_params {
            request_uri.push_str("?");
            let qp: IssuesListLabelsOnIssueParams = params.into();
            request_uri.push_str(&serde_urlencoded::to_string(qp)?);
        }

        let req = GitHubRequest {
            uri: request_uri,
            body: None,
            method: "GET",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch(request)?;

        // --

        if github_response.is_success() {
            Ok(github_response.to_json()?)
        } else {
            match github_response.status_code() {
                301 => Err(IssuesListLabelsOnIssueError::Status301(github_response.to_json()?).into()),
                404 => Err(IssuesListLabelsOnIssueError::Status404(github_response.to_json()?).into()),
                410 => Err(IssuesListLabelsOnIssueError::Status410(github_response.to_json()?).into()),
                code => Err(IssuesListLabelsOnIssueError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # List milestones
    ///
    /// Lists milestones for a repository.
    ///
    /// [GitHub API docs for list_milestones](https://docs.github.com/rest/issues/milestones#list-milestones)
    ///
    /// ---
    pub async fn list_milestones_async(&self, owner: &str, repo: &str, query_params: Option<impl Into<IssuesListMilestonesParams<'api>>>) -> Result<Vec<Milestone>, AdapterError> {

        let mut request_uri = format!("{}/repos/{}/{}/milestones", super::GITHUB_BASE_API_URL, owner, repo);

        if let Some(params) = query_params {
            request_uri.push_str("?");
            request_uri.push_str(&serde_urlencoded::to_string(params.into())?);
        }

        let req = GitHubRequest {
            uri: request_uri,
            body: None::<C::Body>,
            method: "GET",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch_async(request).await?;

        // --

        if github_response.is_success() {
            Ok(github_response.to_json_async().await?)
        } else {
            match github_response.status_code() {
                404 => Err(IssuesListMilestonesError::Status404(github_response.to_json_async().await?).into()),
                code => Err(IssuesListMilestonesError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # List milestones
    ///
    /// Lists milestones for a repository.
    ///
    /// [GitHub API docs for list_milestones](https://docs.github.com/rest/issues/milestones#list-milestones)
    ///
    /// ---
    #[cfg(not(target_arch = "wasm32"))]
    pub fn list_milestones(&self, owner: &str, repo: &str, query_params: Option<impl Into<IssuesListMilestonesParams<'api>>>) -> Result<Vec<Milestone>, AdapterError> {

        let mut request_uri = format!("{}/repos/{}/{}/milestones", super::GITHUB_BASE_API_URL, owner, repo);

        if let Some(params) = query_params {
            request_uri.push_str("?");
            let qp: IssuesListMilestonesParams = params.into();
            request_uri.push_str(&serde_urlencoded::to_string(qp)?);
        }

        let req = GitHubRequest {
            uri: request_uri,
            body: None,
            method: "GET",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch(request)?;

        // --

        if github_response.is_success() {
            Ok(github_response.to_json()?)
        } else {
            match github_response.status_code() {
                404 => Err(IssuesListMilestonesError::Status404(github_response.to_json()?).into()),
                code => Err(IssuesListMilestonesError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # Lock an issue
    ///
    /// Users with push access can lock an issue or pull request's conversation.
    /// 
    /// Note that, if you choose not to pass any parameters, you'll need to set `Content-Length` to zero when calling out to this endpoint. For more information, see "[HTTP method](https://docs.github.com/rest/guides/getting-started-with-the-rest-api#http-method)."
    ///
    /// [GitHub API docs for lock](https://docs.github.com/rest/issues/issues#lock-an-issue)
    ///
    /// ---
    pub async fn lock_async(&self, owner: &str, repo: &str, issue_number: i32, body: PutIssuesLock) -> Result<(), AdapterError> {

        let request_uri = format!("{}/repos/{}/{}/issues/{}/lock", super::GITHUB_BASE_API_URL, owner, repo, issue_number);


        let req = GitHubRequest {
            uri: request_uri,
            body: Some(C::from_json::<PutIssuesLock>(body)?),
            method: "PUT",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch_async(request).await?;

        // --

        if github_response.is_success() {
            Ok(())
        } else {
            match github_response.status_code() {
                403 => Err(IssuesLockError::Status403(github_response.to_json_async().await?).into()),
                410 => Err(IssuesLockError::Status410(github_response.to_json_async().await?).into()),
                404 => Err(IssuesLockError::Status404(github_response.to_json_async().await?).into()),
                422 => Err(IssuesLockError::Status422(github_response.to_json_async().await?).into()),
                code => Err(IssuesLockError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # Lock an issue
    ///
    /// Users with push access can lock an issue or pull request's conversation.
    /// 
    /// Note that, if you choose not to pass any parameters, you'll need to set `Content-Length` to zero when calling out to this endpoint. For more information, see "[HTTP method](https://docs.github.com/rest/guides/getting-started-with-the-rest-api#http-method)."
    ///
    /// [GitHub API docs for lock](https://docs.github.com/rest/issues/issues#lock-an-issue)
    ///
    /// ---
    #[cfg(not(target_arch = "wasm32"))]
    pub fn lock(&self, owner: &str, repo: &str, issue_number: i32, body: PutIssuesLock) -> Result<(), AdapterError> {

        let request_uri = format!("{}/repos/{}/{}/issues/{}/lock", super::GITHUB_BASE_API_URL, owner, repo, issue_number);


        let req = GitHubRequest {
            uri: request_uri,
            body: Some(C::from_json::<PutIssuesLock>(body)?),
            method: "PUT",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch(request)?;

        // --

        if github_response.is_success() {
            Ok(())
        } else {
            match github_response.status_code() {
                403 => Err(IssuesLockError::Status403(github_response.to_json()?).into()),
                410 => Err(IssuesLockError::Status410(github_response.to_json()?).into()),
                404 => Err(IssuesLockError::Status404(github_response.to_json()?).into()),
                422 => Err(IssuesLockError::Status422(github_response.to_json()?).into()),
                code => Err(IssuesLockError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # Remove all labels from an issue
    ///
    /// Removes all labels from an issue.
    ///
    /// [GitHub API docs for remove_all_labels](https://docs.github.com/rest/issues/labels#remove-all-labels-from-an-issue)
    ///
    /// ---
    pub async fn remove_all_labels_async(&self, owner: &str, repo: &str, issue_number: i32) -> Result<(), AdapterError> {

        let request_uri = format!("{}/repos/{}/{}/issues/{}/labels", super::GITHUB_BASE_API_URL, owner, repo, issue_number);


        let req = GitHubRequest {
            uri: request_uri,
            body: None::<C::Body>,
            method: "DELETE",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch_async(request).await?;

        // --

        if github_response.is_success() {
            Ok(())
        } else {
            match github_response.status_code() {
                301 => Err(IssuesRemoveAllLabelsError::Status301(github_response.to_json_async().await?).into()),
                404 => Err(IssuesRemoveAllLabelsError::Status404(github_response.to_json_async().await?).into()),
                410 => Err(IssuesRemoveAllLabelsError::Status410(github_response.to_json_async().await?).into()),
                code => Err(IssuesRemoveAllLabelsError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # Remove all labels from an issue
    ///
    /// Removes all labels from an issue.
    ///
    /// [GitHub API docs for remove_all_labels](https://docs.github.com/rest/issues/labels#remove-all-labels-from-an-issue)
    ///
    /// ---
    #[cfg(not(target_arch = "wasm32"))]
    pub fn remove_all_labels(&self, owner: &str, repo: &str, issue_number: i32) -> Result<(), AdapterError> {

        let request_uri = format!("{}/repos/{}/{}/issues/{}/labels", super::GITHUB_BASE_API_URL, owner, repo, issue_number);


        let req = GitHubRequest {
            uri: request_uri,
            body: None,
            method: "DELETE",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch(request)?;

        // --

        if github_response.is_success() {
            Ok(())
        } else {
            match github_response.status_code() {
                301 => Err(IssuesRemoveAllLabelsError::Status301(github_response.to_json()?).into()),
                404 => Err(IssuesRemoveAllLabelsError::Status404(github_response.to_json()?).into()),
                410 => Err(IssuesRemoveAllLabelsError::Status410(github_response.to_json()?).into()),
                code => Err(IssuesRemoveAllLabelsError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # Remove assignees from an issue
    ///
    /// Removes one or more assignees from an issue.
    ///
    /// [GitHub API docs for remove_assignees](https://docs.github.com/rest/issues/assignees#remove-assignees-from-an-issue)
    ///
    /// ---
    pub async fn remove_assignees_async(&self, owner: &str, repo: &str, issue_number: i32, body: DeleteIssuesRemoveAssignees) -> Result<Issue, AdapterError> {

        let request_uri = format!("{}/repos/{}/{}/issues/{}/assignees", super::GITHUB_BASE_API_URL, owner, repo, issue_number);


        let req = GitHubRequest {
            uri: request_uri,
            body: Some(C::from_json::<DeleteIssuesRemoveAssignees>(body)?),
            method: "DELETE",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch_async(request).await?;

        // --

        if github_response.is_success() {
            Ok(github_response.to_json_async().await?)
        } else {
            match github_response.status_code() {
                code => Err(IssuesRemoveAssigneesError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # Remove assignees from an issue
    ///
    /// Removes one or more assignees from an issue.
    ///
    /// [GitHub API docs for remove_assignees](https://docs.github.com/rest/issues/assignees#remove-assignees-from-an-issue)
    ///
    /// ---
    #[cfg(not(target_arch = "wasm32"))]
    pub fn remove_assignees(&self, owner: &str, repo: &str, issue_number: i32, body: DeleteIssuesRemoveAssignees) -> Result<Issue, AdapterError> {

        let request_uri = format!("{}/repos/{}/{}/issues/{}/assignees", super::GITHUB_BASE_API_URL, owner, repo, issue_number);


        let req = GitHubRequest {
            uri: request_uri,
            body: Some(C::from_json::<DeleteIssuesRemoveAssignees>(body)?),
            method: "DELETE",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch(request)?;

        // --

        if github_response.is_success() {
            Ok(github_response.to_json()?)
        } else {
            match github_response.status_code() {
                code => Err(IssuesRemoveAssigneesError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # Remove a label from an issue
    ///
    /// Removes the specified label from the issue, and returns the remaining labels on the issue. This endpoint returns a `404 Not Found` status if the label does not exist.
    ///
    /// [GitHub API docs for remove_label](https://docs.github.com/rest/issues/labels#remove-a-label-from-an-issue)
    ///
    /// ---
    pub async fn remove_label_async(&self, owner: &str, repo: &str, issue_number: i32, name: &str) -> Result<Vec<Label>, AdapterError> {

        let request_uri = format!("{}/repos/{}/{}/issues/{}/labels/{}", super::GITHUB_BASE_API_URL, owner, repo, issue_number, name);


        let req = GitHubRequest {
            uri: request_uri,
            body: None::<C::Body>,
            method: "DELETE",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch_async(request).await?;

        // --

        if github_response.is_success() {
            Ok(github_response.to_json_async().await?)
        } else {
            match github_response.status_code() {
                301 => Err(IssuesRemoveLabelError::Status301(github_response.to_json_async().await?).into()),
                404 => Err(IssuesRemoveLabelError::Status404(github_response.to_json_async().await?).into()),
                410 => Err(IssuesRemoveLabelError::Status410(github_response.to_json_async().await?).into()),
                code => Err(IssuesRemoveLabelError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # Remove a label from an issue
    ///
    /// Removes the specified label from the issue, and returns the remaining labels on the issue. This endpoint returns a `404 Not Found` status if the label does not exist.
    ///
    /// [GitHub API docs for remove_label](https://docs.github.com/rest/issues/labels#remove-a-label-from-an-issue)
    ///
    /// ---
    #[cfg(not(target_arch = "wasm32"))]
    pub fn remove_label(&self, owner: &str, repo: &str, issue_number: i32, name: &str) -> Result<Vec<Label>, AdapterError> {

        let request_uri = format!("{}/repos/{}/{}/issues/{}/labels/{}", super::GITHUB_BASE_API_URL, owner, repo, issue_number, name);


        let req = GitHubRequest {
            uri: request_uri,
            body: None,
            method: "DELETE",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch(request)?;

        // --

        if github_response.is_success() {
            Ok(github_response.to_json()?)
        } else {
            match github_response.status_code() {
                301 => Err(IssuesRemoveLabelError::Status301(github_response.to_json()?).into()),
                404 => Err(IssuesRemoveLabelError::Status404(github_response.to_json()?).into()),
                410 => Err(IssuesRemoveLabelError::Status410(github_response.to_json()?).into()),
                code => Err(IssuesRemoveLabelError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # Set labels for an issue
    ///
    /// Removes any previous labels and sets the new labels for an issue.
    ///
    /// [GitHub API docs for set_labels](https://docs.github.com/rest/issues/labels#set-labels-for-an-issue)
    ///
    /// ---
    pub async fn set_labels_async(&self, owner: &str, repo: &str, issue_number: i32, body: PutIssuesSetLabels) -> Result<Vec<Label>, AdapterError> {

        let request_uri = format!("{}/repos/{}/{}/issues/{}/labels", super::GITHUB_BASE_API_URL, owner, repo, issue_number);


        let req = GitHubRequest {
            uri: request_uri,
            body: Some(C::from_json::<PutIssuesSetLabels>(body)?),
            method: "PUT",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch_async(request).await?;

        // --

        if github_response.is_success() {
            Ok(github_response.to_json_async().await?)
        } else {
            match github_response.status_code() {
                301 => Err(IssuesSetLabelsError::Status301(github_response.to_json_async().await?).into()),
                404 => Err(IssuesSetLabelsError::Status404(github_response.to_json_async().await?).into()),
                410 => Err(IssuesSetLabelsError::Status410(github_response.to_json_async().await?).into()),
                422 => Err(IssuesSetLabelsError::Status422(github_response.to_json_async().await?).into()),
                code => Err(IssuesSetLabelsError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # Set labels for an issue
    ///
    /// Removes any previous labels and sets the new labels for an issue.
    ///
    /// [GitHub API docs for set_labels](https://docs.github.com/rest/issues/labels#set-labels-for-an-issue)
    ///
    /// ---
    #[cfg(not(target_arch = "wasm32"))]
    pub fn set_labels(&self, owner: &str, repo: &str, issue_number: i32, body: PutIssuesSetLabels) -> Result<Vec<Label>, AdapterError> {

        let request_uri = format!("{}/repos/{}/{}/issues/{}/labels", super::GITHUB_BASE_API_URL, owner, repo, issue_number);


        let req = GitHubRequest {
            uri: request_uri,
            body: Some(C::from_json::<PutIssuesSetLabels>(body)?),
            method: "PUT",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch(request)?;

        // --

        if github_response.is_success() {
            Ok(github_response.to_json()?)
        } else {
            match github_response.status_code() {
                301 => Err(IssuesSetLabelsError::Status301(github_response.to_json()?).into()),
                404 => Err(IssuesSetLabelsError::Status404(github_response.to_json()?).into()),
                410 => Err(IssuesSetLabelsError::Status410(github_response.to_json()?).into()),
                422 => Err(IssuesSetLabelsError::Status422(github_response.to_json()?).into()),
                code => Err(IssuesSetLabelsError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # Unlock an issue
    ///
    /// Users with push access can unlock an issue's conversation.
    ///
    /// [GitHub API docs for unlock](https://docs.github.com/rest/issues/issues#unlock-an-issue)
    ///
    /// ---
    pub async fn unlock_async(&self, owner: &str, repo: &str, issue_number: i32) -> Result<(), AdapterError> {

        let request_uri = format!("{}/repos/{}/{}/issues/{}/lock", super::GITHUB_BASE_API_URL, owner, repo, issue_number);


        let req = GitHubRequest {
            uri: request_uri,
            body: None::<C::Body>,
            method: "DELETE",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch_async(request).await?;

        // --

        if github_response.is_success() {
            Ok(())
        } else {
            match github_response.status_code() {
                403 => Err(IssuesUnlockError::Status403(github_response.to_json_async().await?).into()),
                404 => Err(IssuesUnlockError::Status404(github_response.to_json_async().await?).into()),
                code => Err(IssuesUnlockError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # Unlock an issue
    ///
    /// Users with push access can unlock an issue's conversation.
    ///
    /// [GitHub API docs for unlock](https://docs.github.com/rest/issues/issues#unlock-an-issue)
    ///
    /// ---
    #[cfg(not(target_arch = "wasm32"))]
    pub fn unlock(&self, owner: &str, repo: &str, issue_number: i32) -> Result<(), AdapterError> {

        let request_uri = format!("{}/repos/{}/{}/issues/{}/lock", super::GITHUB_BASE_API_URL, owner, repo, issue_number);


        let req = GitHubRequest {
            uri: request_uri,
            body: None,
            method: "DELETE",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch(request)?;

        // --

        if github_response.is_success() {
            Ok(())
        } else {
            match github_response.status_code() {
                403 => Err(IssuesUnlockError::Status403(github_response.to_json()?).into()),
                404 => Err(IssuesUnlockError::Status404(github_response.to_json()?).into()),
                code => Err(IssuesUnlockError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # Update an issue
    ///
    /// Issue owners and users with push access or Triage role can edit an issue.
    /// 
    /// This endpoint supports the following custom media types. For more information, see "[Media types](https://docs.github.com/rest/using-the-rest-api/getting-started-with-the-rest-api#media-types)."
    /// 
    /// - **`application/vnd.github.raw+json`**: Returns the raw markdown body. Response will include `body`. This is the default if you do not pass any specific media type.
    /// - **`application/vnd.github.text+json`**: Returns a text only representation of the markdown body. Response will include `body_text`.
    /// - **`application/vnd.github.html+json`**: Returns HTML rendered from the body's markdown. Response will include `body_html`.
    /// - **`application/vnd.github.full+json`**: Returns raw, text, and HTML representations. Response will include `body`, `body_text`, and `body_html`.
    ///
    /// [GitHub API docs for update](https://docs.github.com/rest/issues/issues#update-an-issue)
    ///
    /// ---
    pub async fn update_async(&self, owner: &str, repo: &str, issue_number: i32, body: PatchIssuesUpdate) -> Result<Issue, AdapterError> {

        let request_uri = format!("{}/repos/{}/{}/issues/{}", super::GITHUB_BASE_API_URL, owner, repo, issue_number);


        let req = GitHubRequest {
            uri: request_uri,
            body: Some(C::from_json::<PatchIssuesUpdate>(body)?),
            method: "PATCH",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch_async(request).await?;

        // --

        if github_response.is_success() {
            Ok(github_response.to_json_async().await?)
        } else {
            match github_response.status_code() {
                422 => Err(IssuesUpdateError::Status422(github_response.to_json_async().await?).into()),
                503 => Err(IssuesUpdateError::Status503(github_response.to_json_async().await?).into()),
                403 => Err(IssuesUpdateError::Status403(github_response.to_json_async().await?).into()),
                301 => Err(IssuesUpdateError::Status301(github_response.to_json_async().await?).into()),
                404 => Err(IssuesUpdateError::Status404(github_response.to_json_async().await?).into()),
                410 => Err(IssuesUpdateError::Status410(github_response.to_json_async().await?).into()),
                code => Err(IssuesUpdateError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # Update an issue
    ///
    /// Issue owners and users with push access or Triage role can edit an issue.
    /// 
    /// This endpoint supports the following custom media types. For more information, see "[Media types](https://docs.github.com/rest/using-the-rest-api/getting-started-with-the-rest-api#media-types)."
    /// 
    /// - **`application/vnd.github.raw+json`**: Returns the raw markdown body. Response will include `body`. This is the default if you do not pass any specific media type.
    /// - **`application/vnd.github.text+json`**: Returns a text only representation of the markdown body. Response will include `body_text`.
    /// - **`application/vnd.github.html+json`**: Returns HTML rendered from the body's markdown. Response will include `body_html`.
    /// - **`application/vnd.github.full+json`**: Returns raw, text, and HTML representations. Response will include `body`, `body_text`, and `body_html`.
    ///
    /// [GitHub API docs for update](https://docs.github.com/rest/issues/issues#update-an-issue)
    ///
    /// ---
    #[cfg(not(target_arch = "wasm32"))]
    pub fn update(&self, owner: &str, repo: &str, issue_number: i32, body: PatchIssuesUpdate) -> Result<Issue, AdapterError> {

        let request_uri = format!("{}/repos/{}/{}/issues/{}", super::GITHUB_BASE_API_URL, owner, repo, issue_number);


        let req = GitHubRequest {
            uri: request_uri,
            body: Some(C::from_json::<PatchIssuesUpdate>(body)?),
            method: "PATCH",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch(request)?;

        // --

        if github_response.is_success() {
            Ok(github_response.to_json()?)
        } else {
            match github_response.status_code() {
                422 => Err(IssuesUpdateError::Status422(github_response.to_json()?).into()),
                503 => Err(IssuesUpdateError::Status503(github_response.to_json()?).into()),
                403 => Err(IssuesUpdateError::Status403(github_response.to_json()?).into()),
                301 => Err(IssuesUpdateError::Status301(github_response.to_json()?).into()),
                404 => Err(IssuesUpdateError::Status404(github_response.to_json()?).into()),
                410 => Err(IssuesUpdateError::Status410(github_response.to_json()?).into()),
                code => Err(IssuesUpdateError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # Update an issue comment
    ///
    /// You can use the REST API to update comments on issues and pull requests. Every pull request is an issue, but not every issue is a pull request.
    /// 
    /// This endpoint supports the following custom media types. For more information, see "[Media types](https://docs.github.com/rest/using-the-rest-api/getting-started-with-the-rest-api#media-types)."
    /// 
    /// - **`application/vnd.github.raw+json`**: Returns the raw markdown body. Response will include `body`. This is the default if you do not pass any specific media type.
    /// - **`application/vnd.github.text+json`**: Returns a text only representation of the markdown body. Response will include `body_text`.
    /// - **`application/vnd.github.html+json`**: Returns HTML rendered from the body's markdown. Response will include `body_html`.
    /// - **`application/vnd.github.full+json`**: Returns raw, text, and HTML representations. Response will include `body`, `body_text`, and `body_html`.
    ///
    /// [GitHub API docs for update_comment](https://docs.github.com/rest/issues/comments#update-an-issue-comment)
    ///
    /// ---
    pub async fn update_comment_async(&self, owner: &str, repo: &str, comment_id: i64, body: PatchIssuesUpdateComment) -> Result<IssueComment, AdapterError> {

        let request_uri = format!("{}/repos/{}/{}/issues/comments/{}", super::GITHUB_BASE_API_URL, owner, repo, comment_id);


        let req = GitHubRequest {
            uri: request_uri,
            body: Some(C::from_json::<PatchIssuesUpdateComment>(body)?),
            method: "PATCH",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch_async(request).await?;

        // --

        if github_response.is_success() {
            Ok(github_response.to_json_async().await?)
        } else {
            match github_response.status_code() {
                422 => Err(IssuesUpdateCommentError::Status422(github_response.to_json_async().await?).into()),
                code => Err(IssuesUpdateCommentError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # Update an issue comment
    ///
    /// You can use the REST API to update comments on issues and pull requests. Every pull request is an issue, but not every issue is a pull request.
    /// 
    /// This endpoint supports the following custom media types. For more information, see "[Media types](https://docs.github.com/rest/using-the-rest-api/getting-started-with-the-rest-api#media-types)."
    /// 
    /// - **`application/vnd.github.raw+json`**: Returns the raw markdown body. Response will include `body`. This is the default if you do not pass any specific media type.
    /// - **`application/vnd.github.text+json`**: Returns a text only representation of the markdown body. Response will include `body_text`.
    /// - **`application/vnd.github.html+json`**: Returns HTML rendered from the body's markdown. Response will include `body_html`.
    /// - **`application/vnd.github.full+json`**: Returns raw, text, and HTML representations. Response will include `body`, `body_text`, and `body_html`.
    ///
    /// [GitHub API docs for update_comment](https://docs.github.com/rest/issues/comments#update-an-issue-comment)
    ///
    /// ---
    #[cfg(not(target_arch = "wasm32"))]
    pub fn update_comment(&self, owner: &str, repo: &str, comment_id: i64, body: PatchIssuesUpdateComment) -> Result<IssueComment, AdapterError> {

        let request_uri = format!("{}/repos/{}/{}/issues/comments/{}", super::GITHUB_BASE_API_URL, owner, repo, comment_id);


        let req = GitHubRequest {
            uri: request_uri,
            body: Some(C::from_json::<PatchIssuesUpdateComment>(body)?),
            method: "PATCH",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch(request)?;

        // --

        if github_response.is_success() {
            Ok(github_response.to_json()?)
        } else {
            match github_response.status_code() {
                422 => Err(IssuesUpdateCommentError::Status422(github_response.to_json()?).into()),
                code => Err(IssuesUpdateCommentError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # Update a label
    ///
    /// Updates a label using the given label name.
    ///
    /// [GitHub API docs for update_label](https://docs.github.com/rest/issues/labels#update-a-label)
    ///
    /// ---
    pub async fn update_label_async(&self, owner: &str, repo: &str, name: &str, body: PatchIssuesUpdateLabel) -> Result<Label, AdapterError> {

        let request_uri = format!("{}/repos/{}/{}/labels/{}", super::GITHUB_BASE_API_URL, owner, repo, name);


        let req = GitHubRequest {
            uri: request_uri,
            body: Some(C::from_json::<PatchIssuesUpdateLabel>(body)?),
            method: "PATCH",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch_async(request).await?;

        // --

        if github_response.is_success() {
            Ok(github_response.to_json_async().await?)
        } else {
            match github_response.status_code() {
                code => Err(IssuesUpdateLabelError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # Update a label
    ///
    /// Updates a label using the given label name.
    ///
    /// [GitHub API docs for update_label](https://docs.github.com/rest/issues/labels#update-a-label)
    ///
    /// ---
    #[cfg(not(target_arch = "wasm32"))]
    pub fn update_label(&self, owner: &str, repo: &str, name: &str, body: PatchIssuesUpdateLabel) -> Result<Label, AdapterError> {

        let request_uri = format!("{}/repos/{}/{}/labels/{}", super::GITHUB_BASE_API_URL, owner, repo, name);


        let req = GitHubRequest {
            uri: request_uri,
            body: Some(C::from_json::<PatchIssuesUpdateLabel>(body)?),
            method: "PATCH",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch(request)?;

        // --

        if github_response.is_success() {
            Ok(github_response.to_json()?)
        } else {
            match github_response.status_code() {
                code => Err(IssuesUpdateLabelError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # Update a milestone
    ///
    /// [GitHub API docs for update_milestone](https://docs.github.com/rest/issues/milestones#update-a-milestone)
    ///
    /// ---
    pub async fn update_milestone_async(&self, owner: &str, repo: &str, milestone_number: i32, body: PatchIssuesUpdateMilestone) -> Result<Milestone, AdapterError> {

        let request_uri = format!("{}/repos/{}/{}/milestones/{}", super::GITHUB_BASE_API_URL, owner, repo, milestone_number);


        let req = GitHubRequest {
            uri: request_uri,
            body: Some(C::from_json::<PatchIssuesUpdateMilestone>(body)?),
            method: "PATCH",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch_async(request).await?;

        // --

        if github_response.is_success() {
            Ok(github_response.to_json_async().await?)
        } else {
            match github_response.status_code() {
                code => Err(IssuesUpdateMilestoneError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # Update a milestone
    ///
    /// [GitHub API docs for update_milestone](https://docs.github.com/rest/issues/milestones#update-a-milestone)
    ///
    /// ---
    #[cfg(not(target_arch = "wasm32"))]
    pub fn update_milestone(&self, owner: &str, repo: &str, milestone_number: i32, body: PatchIssuesUpdateMilestone) -> Result<Milestone, AdapterError> {

        let request_uri = format!("{}/repos/{}/{}/milestones/{}", super::GITHUB_BASE_API_URL, owner, repo, milestone_number);


        let req = GitHubRequest {
            uri: request_uri,
            body: Some(C::from_json::<PatchIssuesUpdateMilestone>(body)?),
            method: "PATCH",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch(request)?;

        // --

        if github_response.is_success() {
            Ok(github_response.to_json()?)
        } else {
            match github_response.status_code() {
                code => Err(IssuesUpdateMilestoneError::Generic { code }.into()),
            }
        }
    }

}
