//! Method, error and parameter types for the SecretScanning endpoint.
#![allow(
    clippy::all
)]
/* 
 * GitHub v3 REST API
 *
 * GitHub's v3 REST API.
 *
 * OpenAPI spec version: 1.1.4
 * 
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 */

use serde::Deserialize;

use crate::adapters::{AdapterError, Client, GitHubRequest, GitHubResponseExt};
use crate::models::*;

use super::PerPage;

use std::collections::HashMap;
use serde_json::value::Value;

pub struct SecretScanning<'api, C: Client> where AdapterError: From<<C as Client>::Err> {
    client: &'api C
}

pub fn new<C: Client>(client: &C) -> SecretScanning<C> where AdapterError: From<<C as Client>::Err> {
    SecretScanning { client }
}

/// Errors for the [Create a push protection bypass](SecretScanning::create_push_protection_bypass_async()) endpoint.
#[derive(Debug, thiserror::Error)]
pub enum SecretScanningCreatePushProtectionBypassError {
    #[error("User does not have enough permissions to perform this action.")]
    Status403,
    #[error("Placeholder ID not found, or push protection is disabled on this repository.")]
    Status404,
    #[error("Bad request, input data missing or incorrect.")]
    Status422,
    #[error("Service unavailable")]
    Status503(PostCodespacesCreateForAuthenticatedUserResponse503),
    #[error("Status code: {}", code)]
    Generic { code: u16 },
}

impl From<SecretScanningCreatePushProtectionBypassError> for AdapterError {
    fn from(err: SecretScanningCreatePushProtectionBypassError) -> Self {
        let (description, status_code) = match err {
            SecretScanningCreatePushProtectionBypassError::Status403 => (String::from("User does not have enough permissions to perform this action."), 403),
            SecretScanningCreatePushProtectionBypassError::Status404 => (String::from("Placeholder ID not found, or push protection is disabled on this repository."), 404),
            SecretScanningCreatePushProtectionBypassError::Status422 => (String::from("Bad request, input data missing or incorrect."), 422),
            SecretScanningCreatePushProtectionBypassError::Status503(_) => (String::from("Service unavailable"), 503),
            SecretScanningCreatePushProtectionBypassError::Generic { code } => (String::from("Generic"), code)
        };

        Self::Endpoint {
            description,
            status_code,
            source: Some(Box::new(err))
        }
    }
}

/// Errors for the [Get a secret scanning alert](SecretScanning::get_alert_async()) endpoint.
#[derive(Debug, thiserror::Error)]
pub enum SecretScanningGetAlertError {
    #[error("Not modified")]
    Status304,
    #[error("Repository is public, or secret scanning is disabled for the repository, or the resource is not found")]
    Status404,
    #[error("Service unavailable")]
    Status503(PostCodespacesCreateForAuthenticatedUserResponse503),
    #[error("Status code: {}", code)]
    Generic { code: u16 },
}

impl From<SecretScanningGetAlertError> for AdapterError {
    fn from(err: SecretScanningGetAlertError) -> Self {
        let (description, status_code) = match err {
            SecretScanningGetAlertError::Status304 => (String::from("Not modified"), 304),
            SecretScanningGetAlertError::Status404 => (String::from("Repository is public, or secret scanning is disabled for the repository, or the resource is not found"), 404),
            SecretScanningGetAlertError::Status503(_) => (String::from("Service unavailable"), 503),
            SecretScanningGetAlertError::Generic { code } => (String::from("Generic"), code)
        };

        Self::Endpoint {
            description,
            status_code,
            source: Some(Box::new(err))
        }
    }
}

/// Errors for the [List secret scanning alerts for an enterprise](SecretScanning::list_alerts_for_enterprise_async()) endpoint.
#[derive(Debug, thiserror::Error)]
pub enum SecretScanningListAlertsForEnterpriseError {
    #[error("Resource not found")]
    Status404(BasicError),
    #[error("Service unavailable")]
    Status503(PostCodespacesCreateForAuthenticatedUserResponse503),
    #[error("Status code: {}", code)]
    Generic { code: u16 },
}

impl From<SecretScanningListAlertsForEnterpriseError> for AdapterError {
    fn from(err: SecretScanningListAlertsForEnterpriseError) -> Self {
        let (description, status_code) = match err {
            SecretScanningListAlertsForEnterpriseError::Status404(_) => (String::from("Resource not found"), 404),
            SecretScanningListAlertsForEnterpriseError::Status503(_) => (String::from("Service unavailable"), 503),
            SecretScanningListAlertsForEnterpriseError::Generic { code } => (String::from("Generic"), code)
        };

        Self::Endpoint {
            description,
            status_code,
            source: Some(Box::new(err))
        }
    }
}

/// Errors for the [List secret scanning alerts for an organization](SecretScanning::list_alerts_for_org_async()) endpoint.
#[derive(Debug, thiserror::Error)]
pub enum SecretScanningListAlertsForOrgError {
    #[error("Resource not found")]
    Status404(BasicError),
    #[error("Service unavailable")]
    Status503(PostCodespacesCreateForAuthenticatedUserResponse503),
    #[error("Status code: {}", code)]
    Generic { code: u16 },
}

impl From<SecretScanningListAlertsForOrgError> for AdapterError {
    fn from(err: SecretScanningListAlertsForOrgError) -> Self {
        let (description, status_code) = match err {
            SecretScanningListAlertsForOrgError::Status404(_) => (String::from("Resource not found"), 404),
            SecretScanningListAlertsForOrgError::Status503(_) => (String::from("Service unavailable"), 503),
            SecretScanningListAlertsForOrgError::Generic { code } => (String::from("Generic"), code)
        };

        Self::Endpoint {
            description,
            status_code,
            source: Some(Box::new(err))
        }
    }
}

/// Errors for the [List secret scanning alerts for a repository](SecretScanning::list_alerts_for_repo_async()) endpoint.
#[derive(Debug, thiserror::Error)]
pub enum SecretScanningListAlertsForRepoError {
    #[error("Repository is public or secret scanning is disabled for the repository")]
    Status404,
    #[error("Service unavailable")]
    Status503(PostCodespacesCreateForAuthenticatedUserResponse503),
    #[error("Status code: {}", code)]
    Generic { code: u16 },
}

impl From<SecretScanningListAlertsForRepoError> for AdapterError {
    fn from(err: SecretScanningListAlertsForRepoError) -> Self {
        let (description, status_code) = match err {
            SecretScanningListAlertsForRepoError::Status404 => (String::from("Repository is public or secret scanning is disabled for the repository"), 404),
            SecretScanningListAlertsForRepoError::Status503(_) => (String::from("Service unavailable"), 503),
            SecretScanningListAlertsForRepoError::Generic { code } => (String::from("Generic"), code)
        };

        Self::Endpoint {
            description,
            status_code,
            source: Some(Box::new(err))
        }
    }
}

/// Errors for the [List locations for a secret scanning alert](SecretScanning::list_locations_for_alert_async()) endpoint.
#[derive(Debug, thiserror::Error)]
pub enum SecretScanningListLocationsForAlertError {
    #[error("Repository is public, or secret scanning is disabled for the repository, or the resource is not found")]
    Status404,
    #[error("Service unavailable")]
    Status503(PostCodespacesCreateForAuthenticatedUserResponse503),
    #[error("Status code: {}", code)]
    Generic { code: u16 },
}

impl From<SecretScanningListLocationsForAlertError> for AdapterError {
    fn from(err: SecretScanningListLocationsForAlertError) -> Self {
        let (description, status_code) = match err {
            SecretScanningListLocationsForAlertError::Status404 => (String::from("Repository is public, or secret scanning is disabled for the repository, or the resource is not found"), 404),
            SecretScanningListLocationsForAlertError::Status503(_) => (String::from("Service unavailable"), 503),
            SecretScanningListLocationsForAlertError::Generic { code } => (String::from("Generic"), code)
        };

        Self::Endpoint {
            description,
            status_code,
            source: Some(Box::new(err))
        }
    }
}

/// Errors for the [Update a secret scanning alert](SecretScanning::update_alert_async()) endpoint.
#[derive(Debug, thiserror::Error)]
pub enum SecretScanningUpdateAlertError {
    #[error("Bad request, resolution comment is invalid or the resolution was not changed.")]
    Status400,
    #[error("Repository is public, or secret scanning is disabled for the repository, or the resource is not found")]
    Status404,
    #[error("State does not match the resolution or resolution comment")]
    Status422,
    #[error("Service unavailable")]
    Status503(PostCodespacesCreateForAuthenticatedUserResponse503),
    #[error("Status code: {}", code)]
    Generic { code: u16 },
}

impl From<SecretScanningUpdateAlertError> for AdapterError {
    fn from(err: SecretScanningUpdateAlertError) -> Self {
        let (description, status_code) = match err {
            SecretScanningUpdateAlertError::Status400 => (String::from("Bad request, resolution comment is invalid or the resolution was not changed."), 400),
            SecretScanningUpdateAlertError::Status404 => (String::from("Repository is public, or secret scanning is disabled for the repository, or the resource is not found"), 404),
            SecretScanningUpdateAlertError::Status422 => (String::from("State does not match the resolution or resolution comment"), 422),
            SecretScanningUpdateAlertError::Status503(_) => (String::from("Service unavailable"), 503),
            SecretScanningUpdateAlertError::Generic { code } => (String::from("Generic"), code)
        };

        Self::Endpoint {
            description,
            status_code,
            source: Some(Box::new(err))
        }
    }
}


/// Query parameters for the [List secret scanning alerts for an enterprise](SecretScanning::list_alerts_for_enterprise_async()) endpoint.
#[derive(Default, Serialize)]
pub struct SecretScanningListAlertsForEnterpriseParams<'req> {
    /// Set to `open` or `resolved` to only list secret scanning alerts in a specific state.
    state: Option<&'req str>, 
    /// A comma-separated list of secret types to return. By default all secret types are returned. See \"[Supported secret scanning patterns](https://docs.github.com/code-security/secret-scanning/introduction/supported-secret-scanning-patterns#supported-secrets)\" for a complete list of secret types.
    secret_type: Option<&'req str>, 
    /// A comma-separated list of resolutions. Only secret scanning alerts with one of these resolutions are listed. Valid resolutions are `false_positive`, `wont_fix`, `revoked`, `pattern_edited`, `pattern_deleted` or `used_in_tests`.
    resolution: Option<&'req str>, 
    /// The property to sort the results by. `created` means when the alert was created. `updated` means when the alert was updated or resolved.
    sort: Option<&'req str>, 
    /// The direction to sort the results by.
    direction: Option<&'req str>, 
    /// The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    per_page: Option<u16>, 
    /// A cursor, as given in the [Link header](https://docs.github.com/rest/guides/using-pagination-in-the-rest-api#using-link-headers). If specified, the query only searches for results before this cursor. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    before: Option<&'req str>, 
    /// A cursor, as given in the [Link header](https://docs.github.com/rest/guides/using-pagination-in-the-rest-api#using-link-headers). If specified, the query only searches for results after this cursor. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    after: Option<&'req str>, 
    /// A comma-separated list of validities that, when present, will return alerts that match the validities in this list. Valid options are `active`, `inactive`, and `unknown`.
    validity: Option<&'req str>
}

impl<'req> SecretScanningListAlertsForEnterpriseParams<'req> {
    pub fn new() -> Self {
        Self::default()
    }

    /// Set to `open` or `resolved` to only list secret scanning alerts in a specific state.
    pub fn state(self, state: &'req str) -> Self {
        Self {
            state: Some(state),
            secret_type: self.secret_type, 
            resolution: self.resolution, 
            sort: self.sort, 
            direction: self.direction, 
            per_page: self.per_page, 
            before: self.before, 
            after: self.after, 
            validity: self.validity, 
        }
    }

    /// A comma-separated list of secret types to return. By default all secret types are returned. See \"[Supported secret scanning patterns](https://docs.github.com/code-security/secret-scanning/introduction/supported-secret-scanning-patterns#supported-secrets)\" for a complete list of secret types.
    pub fn secret_type(self, secret_type: &'req str) -> Self {
        Self {
            state: self.state, 
            secret_type: Some(secret_type),
            resolution: self.resolution, 
            sort: self.sort, 
            direction: self.direction, 
            per_page: self.per_page, 
            before: self.before, 
            after: self.after, 
            validity: self.validity, 
        }
    }

    /// A comma-separated list of resolutions. Only secret scanning alerts with one of these resolutions are listed. Valid resolutions are `false_positive`, `wont_fix`, `revoked`, `pattern_edited`, `pattern_deleted` or `used_in_tests`.
    pub fn resolution(self, resolution: &'req str) -> Self {
        Self {
            state: self.state, 
            secret_type: self.secret_type, 
            resolution: Some(resolution),
            sort: self.sort, 
            direction: self.direction, 
            per_page: self.per_page, 
            before: self.before, 
            after: self.after, 
            validity: self.validity, 
        }
    }

    /// The property to sort the results by. `created` means when the alert was created. `updated` means when the alert was updated or resolved.
    pub fn sort(self, sort: &'req str) -> Self {
        Self {
            state: self.state, 
            secret_type: self.secret_type, 
            resolution: self.resolution, 
            sort: Some(sort),
            direction: self.direction, 
            per_page: self.per_page, 
            before: self.before, 
            after: self.after, 
            validity: self.validity, 
        }
    }

    /// The direction to sort the results by.
    pub fn direction(self, direction: &'req str) -> Self {
        Self {
            state: self.state, 
            secret_type: self.secret_type, 
            resolution: self.resolution, 
            sort: self.sort, 
            direction: Some(direction),
            per_page: self.per_page, 
            before: self.before, 
            after: self.after, 
            validity: self.validity, 
        }
    }

    /// The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    pub fn per_page(self, per_page: u16) -> Self {
        Self {
            state: self.state, 
            secret_type: self.secret_type, 
            resolution: self.resolution, 
            sort: self.sort, 
            direction: self.direction, 
            per_page: Some(per_page),
            before: self.before, 
            after: self.after, 
            validity: self.validity, 
        }
    }

    /// A cursor, as given in the [Link header](https://docs.github.com/rest/guides/using-pagination-in-the-rest-api#using-link-headers). If specified, the query only searches for results before this cursor. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    pub fn before(self, before: &'req str) -> Self {
        Self {
            state: self.state, 
            secret_type: self.secret_type, 
            resolution: self.resolution, 
            sort: self.sort, 
            direction: self.direction, 
            per_page: self.per_page, 
            before: Some(before),
            after: self.after, 
            validity: self.validity, 
        }
    }

    /// A cursor, as given in the [Link header](https://docs.github.com/rest/guides/using-pagination-in-the-rest-api#using-link-headers). If specified, the query only searches for results after this cursor. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    pub fn after(self, after: &'req str) -> Self {
        Self {
            state: self.state, 
            secret_type: self.secret_type, 
            resolution: self.resolution, 
            sort: self.sort, 
            direction: self.direction, 
            per_page: self.per_page, 
            before: self.before, 
            after: Some(after),
            validity: self.validity, 
        }
    }

    /// A comma-separated list of validities that, when present, will return alerts that match the validities in this list. Valid options are `active`, `inactive`, and `unknown`.
    pub fn validity(self, validity: &'req str) -> Self {
        Self {
            state: self.state, 
            secret_type: self.secret_type, 
            resolution: self.resolution, 
            sort: self.sort, 
            direction: self.direction, 
            per_page: self.per_page, 
            before: self.before, 
            after: self.after, 
            validity: Some(validity),
        }
    }
}

/// Query parameters for the [List secret scanning alerts for an organization](SecretScanning::list_alerts_for_org_async()) endpoint.
#[derive(Default, Serialize)]
pub struct SecretScanningListAlertsForOrgParams<'req> {
    /// Set to `open` or `resolved` to only list secret scanning alerts in a specific state.
    state: Option<&'req str>, 
    /// A comma-separated list of secret types to return. By default all secret types are returned. See \"[Supported secret scanning patterns](https://docs.github.com/code-security/secret-scanning/introduction/supported-secret-scanning-patterns#supported-secrets)\" for a complete list of secret types.
    secret_type: Option<&'req str>, 
    /// A comma-separated list of resolutions. Only secret scanning alerts with one of these resolutions are listed. Valid resolutions are `false_positive`, `wont_fix`, `revoked`, `pattern_edited`, `pattern_deleted` or `used_in_tests`.
    resolution: Option<&'req str>, 
    /// The property to sort the results by. `created` means when the alert was created. `updated` means when the alert was updated or resolved.
    sort: Option<&'req str>, 
    /// The direction to sort the results by.
    direction: Option<&'req str>, 
    /// The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    page: Option<u16>, 
    /// The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    per_page: Option<u16>, 
    /// A cursor, as given in the [Link header](https://docs.github.com/rest/guides/using-pagination-in-the-rest-api#using-link-headers). If specified, the query only searches for events before this cursor. To receive an initial cursor on your first request, include an empty \"before\" query string.
    before: Option<&'req str>, 
    /// A cursor, as given in the [Link header](https://docs.github.com/rest/guides/using-pagination-in-the-rest-api#using-link-headers). If specified, the query only searches for events after this cursor.  To receive an initial cursor on your first request, include an empty \"after\" query string.
    after: Option<&'req str>, 
    /// A comma-separated list of validities that, when present, will return alerts that match the validities in this list. Valid options are `active`, `inactive`, and `unknown`.
    validity: Option<&'req str>
}

impl<'req> SecretScanningListAlertsForOrgParams<'req> {
    pub fn new() -> Self {
        Self::default()
    }

    /// Set to `open` or `resolved` to only list secret scanning alerts in a specific state.
    pub fn state(self, state: &'req str) -> Self {
        Self {
            state: Some(state),
            secret_type: self.secret_type, 
            resolution: self.resolution, 
            sort: self.sort, 
            direction: self.direction, 
            page: self.page, 
            per_page: self.per_page, 
            before: self.before, 
            after: self.after, 
            validity: self.validity, 
        }
    }

    /// A comma-separated list of secret types to return. By default all secret types are returned. See \"[Supported secret scanning patterns](https://docs.github.com/code-security/secret-scanning/introduction/supported-secret-scanning-patterns#supported-secrets)\" for a complete list of secret types.
    pub fn secret_type(self, secret_type: &'req str) -> Self {
        Self {
            state: self.state, 
            secret_type: Some(secret_type),
            resolution: self.resolution, 
            sort: self.sort, 
            direction: self.direction, 
            page: self.page, 
            per_page: self.per_page, 
            before: self.before, 
            after: self.after, 
            validity: self.validity, 
        }
    }

    /// A comma-separated list of resolutions. Only secret scanning alerts with one of these resolutions are listed. Valid resolutions are `false_positive`, `wont_fix`, `revoked`, `pattern_edited`, `pattern_deleted` or `used_in_tests`.
    pub fn resolution(self, resolution: &'req str) -> Self {
        Self {
            state: self.state, 
            secret_type: self.secret_type, 
            resolution: Some(resolution),
            sort: self.sort, 
            direction: self.direction, 
            page: self.page, 
            per_page: self.per_page, 
            before: self.before, 
            after: self.after, 
            validity: self.validity, 
        }
    }

    /// The property to sort the results by. `created` means when the alert was created. `updated` means when the alert was updated or resolved.
    pub fn sort(self, sort: &'req str) -> Self {
        Self {
            state: self.state, 
            secret_type: self.secret_type, 
            resolution: self.resolution, 
            sort: Some(sort),
            direction: self.direction, 
            page: self.page, 
            per_page: self.per_page, 
            before: self.before, 
            after: self.after, 
            validity: self.validity, 
        }
    }

    /// The direction to sort the results by.
    pub fn direction(self, direction: &'req str) -> Self {
        Self {
            state: self.state, 
            secret_type: self.secret_type, 
            resolution: self.resolution, 
            sort: self.sort, 
            direction: Some(direction),
            page: self.page, 
            per_page: self.per_page, 
            before: self.before, 
            after: self.after, 
            validity: self.validity, 
        }
    }

    /// The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    pub fn page(self, page: u16) -> Self {
        Self {
            state: self.state, 
            secret_type: self.secret_type, 
            resolution: self.resolution, 
            sort: self.sort, 
            direction: self.direction, 
            page: Some(page),
            per_page: self.per_page, 
            before: self.before, 
            after: self.after, 
            validity: self.validity, 
        }
    }

    /// The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    pub fn per_page(self, per_page: u16) -> Self {
        Self {
            state: self.state, 
            secret_type: self.secret_type, 
            resolution: self.resolution, 
            sort: self.sort, 
            direction: self.direction, 
            page: self.page, 
            per_page: Some(per_page),
            before: self.before, 
            after: self.after, 
            validity: self.validity, 
        }
    }

    /// A cursor, as given in the [Link header](https://docs.github.com/rest/guides/using-pagination-in-the-rest-api#using-link-headers). If specified, the query only searches for events before this cursor. To receive an initial cursor on your first request, include an empty \"before\" query string.
    pub fn before(self, before: &'req str) -> Self {
        Self {
            state: self.state, 
            secret_type: self.secret_type, 
            resolution: self.resolution, 
            sort: self.sort, 
            direction: self.direction, 
            page: self.page, 
            per_page: self.per_page, 
            before: Some(before),
            after: self.after, 
            validity: self.validity, 
        }
    }

    /// A cursor, as given in the [Link header](https://docs.github.com/rest/guides/using-pagination-in-the-rest-api#using-link-headers). If specified, the query only searches for events after this cursor.  To receive an initial cursor on your first request, include an empty \"after\" query string.
    pub fn after(self, after: &'req str) -> Self {
        Self {
            state: self.state, 
            secret_type: self.secret_type, 
            resolution: self.resolution, 
            sort: self.sort, 
            direction: self.direction, 
            page: self.page, 
            per_page: self.per_page, 
            before: self.before, 
            after: Some(after),
            validity: self.validity, 
        }
    }

    /// A comma-separated list of validities that, when present, will return alerts that match the validities in this list. Valid options are `active`, `inactive`, and `unknown`.
    pub fn validity(self, validity: &'req str) -> Self {
        Self {
            state: self.state, 
            secret_type: self.secret_type, 
            resolution: self.resolution, 
            sort: self.sort, 
            direction: self.direction, 
            page: self.page, 
            per_page: self.per_page, 
            before: self.before, 
            after: self.after, 
            validity: Some(validity),
        }
    }
}

impl<'enc> From<&'enc PerPage> for SecretScanningListAlertsForOrgParams<'enc> {
    fn from(per_page: &'enc PerPage) -> Self {
        Self {
            per_page: Some(per_page.per_page),
            page: Some(per_page.page),
            ..Default::default()
        }
    }
}
/// Query parameters for the [List secret scanning alerts for a repository](SecretScanning::list_alerts_for_repo_async()) endpoint.
#[derive(Default, Serialize)]
pub struct SecretScanningListAlertsForRepoParams<'req> {
    /// Set to `open` or `resolved` to only list secret scanning alerts in a specific state.
    state: Option<&'req str>, 
    /// A comma-separated list of secret types to return. By default all secret types are returned. See \"[Supported secret scanning patterns](https://docs.github.com/code-security/secret-scanning/introduction/supported-secret-scanning-patterns#supported-secrets)\" for a complete list of secret types.
    secret_type: Option<&'req str>, 
    /// A comma-separated list of resolutions. Only secret scanning alerts with one of these resolutions are listed. Valid resolutions are `false_positive`, `wont_fix`, `revoked`, `pattern_edited`, `pattern_deleted` or `used_in_tests`.
    resolution: Option<&'req str>, 
    /// The property to sort the results by. `created` means when the alert was created. `updated` means when the alert was updated or resolved.
    sort: Option<&'req str>, 
    /// The direction to sort the results by.
    direction: Option<&'req str>, 
    /// The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    page: Option<u16>, 
    /// The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    per_page: Option<u16>, 
    /// A cursor, as given in the [Link header](https://docs.github.com/rest/guides/using-pagination-in-the-rest-api#using-link-headers). If specified, the query only searches for events before this cursor. To receive an initial cursor on your first request, include an empty \"before\" query string.
    before: Option<&'req str>, 
    /// A cursor, as given in the [Link header](https://docs.github.com/rest/guides/using-pagination-in-the-rest-api#using-link-headers). If specified, the query only searches for events after this cursor.  To receive an initial cursor on your first request, include an empty \"after\" query string.
    after: Option<&'req str>, 
    /// A comma-separated list of validities that, when present, will return alerts that match the validities in this list. Valid options are `active`, `inactive`, and `unknown`.
    validity: Option<&'req str>
}

impl<'req> SecretScanningListAlertsForRepoParams<'req> {
    pub fn new() -> Self {
        Self::default()
    }

    /// Set to `open` or `resolved` to only list secret scanning alerts in a specific state.
    pub fn state(self, state: &'req str) -> Self {
        Self {
            state: Some(state),
            secret_type: self.secret_type, 
            resolution: self.resolution, 
            sort: self.sort, 
            direction: self.direction, 
            page: self.page, 
            per_page: self.per_page, 
            before: self.before, 
            after: self.after, 
            validity: self.validity, 
        }
    }

    /// A comma-separated list of secret types to return. By default all secret types are returned. See \"[Supported secret scanning patterns](https://docs.github.com/code-security/secret-scanning/introduction/supported-secret-scanning-patterns#supported-secrets)\" for a complete list of secret types.
    pub fn secret_type(self, secret_type: &'req str) -> Self {
        Self {
            state: self.state, 
            secret_type: Some(secret_type),
            resolution: self.resolution, 
            sort: self.sort, 
            direction: self.direction, 
            page: self.page, 
            per_page: self.per_page, 
            before: self.before, 
            after: self.after, 
            validity: self.validity, 
        }
    }

    /// A comma-separated list of resolutions. Only secret scanning alerts with one of these resolutions are listed. Valid resolutions are `false_positive`, `wont_fix`, `revoked`, `pattern_edited`, `pattern_deleted` or `used_in_tests`.
    pub fn resolution(self, resolution: &'req str) -> Self {
        Self {
            state: self.state, 
            secret_type: self.secret_type, 
            resolution: Some(resolution),
            sort: self.sort, 
            direction: self.direction, 
            page: self.page, 
            per_page: self.per_page, 
            before: self.before, 
            after: self.after, 
            validity: self.validity, 
        }
    }

    /// The property to sort the results by. `created` means when the alert was created. `updated` means when the alert was updated or resolved.
    pub fn sort(self, sort: &'req str) -> Self {
        Self {
            state: self.state, 
            secret_type: self.secret_type, 
            resolution: self.resolution, 
            sort: Some(sort),
            direction: self.direction, 
            page: self.page, 
            per_page: self.per_page, 
            before: self.before, 
            after: self.after, 
            validity: self.validity, 
        }
    }

    /// The direction to sort the results by.
    pub fn direction(self, direction: &'req str) -> Self {
        Self {
            state: self.state, 
            secret_type: self.secret_type, 
            resolution: self.resolution, 
            sort: self.sort, 
            direction: Some(direction),
            page: self.page, 
            per_page: self.per_page, 
            before: self.before, 
            after: self.after, 
            validity: self.validity, 
        }
    }

    /// The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    pub fn page(self, page: u16) -> Self {
        Self {
            state: self.state, 
            secret_type: self.secret_type, 
            resolution: self.resolution, 
            sort: self.sort, 
            direction: self.direction, 
            page: Some(page),
            per_page: self.per_page, 
            before: self.before, 
            after: self.after, 
            validity: self.validity, 
        }
    }

    /// The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    pub fn per_page(self, per_page: u16) -> Self {
        Self {
            state: self.state, 
            secret_type: self.secret_type, 
            resolution: self.resolution, 
            sort: self.sort, 
            direction: self.direction, 
            page: self.page, 
            per_page: Some(per_page),
            before: self.before, 
            after: self.after, 
            validity: self.validity, 
        }
    }

    /// A cursor, as given in the [Link header](https://docs.github.com/rest/guides/using-pagination-in-the-rest-api#using-link-headers). If specified, the query only searches for events before this cursor. To receive an initial cursor on your first request, include an empty \"before\" query string.
    pub fn before(self, before: &'req str) -> Self {
        Self {
            state: self.state, 
            secret_type: self.secret_type, 
            resolution: self.resolution, 
            sort: self.sort, 
            direction: self.direction, 
            page: self.page, 
            per_page: self.per_page, 
            before: Some(before),
            after: self.after, 
            validity: self.validity, 
        }
    }

    /// A cursor, as given in the [Link header](https://docs.github.com/rest/guides/using-pagination-in-the-rest-api#using-link-headers). If specified, the query only searches for events after this cursor.  To receive an initial cursor on your first request, include an empty \"after\" query string.
    pub fn after(self, after: &'req str) -> Self {
        Self {
            state: self.state, 
            secret_type: self.secret_type, 
            resolution: self.resolution, 
            sort: self.sort, 
            direction: self.direction, 
            page: self.page, 
            per_page: self.per_page, 
            before: self.before, 
            after: Some(after),
            validity: self.validity, 
        }
    }

    /// A comma-separated list of validities that, when present, will return alerts that match the validities in this list. Valid options are `active`, `inactive`, and `unknown`.
    pub fn validity(self, validity: &'req str) -> Self {
        Self {
            state: self.state, 
            secret_type: self.secret_type, 
            resolution: self.resolution, 
            sort: self.sort, 
            direction: self.direction, 
            page: self.page, 
            per_page: self.per_page, 
            before: self.before, 
            after: self.after, 
            validity: Some(validity),
        }
    }
}

impl<'enc> From<&'enc PerPage> for SecretScanningListAlertsForRepoParams<'enc> {
    fn from(per_page: &'enc PerPage) -> Self {
        Self {
            per_page: Some(per_page.per_page),
            page: Some(per_page.page),
            ..Default::default()
        }
    }
}
/// Query parameters for the [List locations for a secret scanning alert](SecretScanning::list_locations_for_alert_async()) endpoint.
#[derive(Default, Serialize)]
pub struct SecretScanningListLocationsForAlertParams {
    /// The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    page: Option<u16>, 
    /// The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    per_page: Option<u16>
}

impl SecretScanningListLocationsForAlertParams {
    pub fn new() -> Self {
        Self::default()
    }

    /// The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    pub fn page(self, page: u16) -> Self {
        Self {
            page: Some(page),
            per_page: self.per_page, 
        }
    }

    /// The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    pub fn per_page(self, per_page: u16) -> Self {
        Self {
            page: self.page, 
            per_page: Some(per_page),
        }
    }
}

impl<'enc> From<&'enc PerPage> for SecretScanningListLocationsForAlertParams {
    fn from(per_page: &'enc PerPage) -> Self {
        Self {
            per_page: Some(per_page.per_page),
            page: Some(per_page.page),
            ..Default::default()
        }
    }
}

impl<'api, C: Client> SecretScanning<'api, C> where AdapterError: From<<C as Client>::Err> {
    /// ---
    ///
    /// # Create a push protection bypass
    ///
    /// Creates a bypass for a previously push protected secret.
    /// 
    /// The authenticated user must be the original author of the committed secret.
    /// 
    /// OAuth app tokens and personal access tokens (classic) need the `repo` scope to use this endpoint.
    ///
    /// [GitHub API docs for create_push_protection_bypass](https://docs.github.com/rest/secret-scanning/secret-scanning#create-a-push-protection-bypass)
    ///
    /// ---
    pub async fn create_push_protection_bypass_async(&self, owner: &str, repo: &str, body: PostSecretScanningCreatePushProtectionBypass) -> Result<SecretScanningPushProtectionBypass, AdapterError> {

        let request_uri = format!("{}/repos/{}/{}/secret-scanning/push-protection-bypasses", super::GITHUB_BASE_API_URL, owner, repo);


        let req = GitHubRequest {
            uri: request_uri,
            body: Some(C::from_json::<PostSecretScanningCreatePushProtectionBypass>(body)?),
            method: "POST",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch_async(request).await?;

        // --

        if github_response.is_success() {
            Ok(github_response.to_json_async().await?)
        } else {
            match github_response.status_code() {
                403 => Err(SecretScanningCreatePushProtectionBypassError::Status403.into()),
                404 => Err(SecretScanningCreatePushProtectionBypassError::Status404.into()),
                422 => Err(SecretScanningCreatePushProtectionBypassError::Status422.into()),
                503 => Err(SecretScanningCreatePushProtectionBypassError::Status503(github_response.to_json_async().await?).into()),
                code => Err(SecretScanningCreatePushProtectionBypassError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # Create a push protection bypass
    ///
    /// Creates a bypass for a previously push protected secret.
    /// 
    /// The authenticated user must be the original author of the committed secret.
    /// 
    /// OAuth app tokens and personal access tokens (classic) need the `repo` scope to use this endpoint.
    ///
    /// [GitHub API docs for create_push_protection_bypass](https://docs.github.com/rest/secret-scanning/secret-scanning#create-a-push-protection-bypass)
    ///
    /// ---
    #[cfg(not(target_arch = "wasm32"))]
    pub fn create_push_protection_bypass(&self, owner: &str, repo: &str, body: PostSecretScanningCreatePushProtectionBypass) -> Result<SecretScanningPushProtectionBypass, AdapterError> {

        let request_uri = format!("{}/repos/{}/{}/secret-scanning/push-protection-bypasses", super::GITHUB_BASE_API_URL, owner, repo);


        let req = GitHubRequest {
            uri: request_uri,
            body: Some(C::from_json::<PostSecretScanningCreatePushProtectionBypass>(body)?),
            method: "POST",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch(request)?;

        // --

        if github_response.is_success() {
            Ok(github_response.to_json()?)
        } else {
            match github_response.status_code() {
                403 => Err(SecretScanningCreatePushProtectionBypassError::Status403.into()),
                404 => Err(SecretScanningCreatePushProtectionBypassError::Status404.into()),
                422 => Err(SecretScanningCreatePushProtectionBypassError::Status422.into()),
                503 => Err(SecretScanningCreatePushProtectionBypassError::Status503(github_response.to_json()?).into()),
                code => Err(SecretScanningCreatePushProtectionBypassError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # Get a secret scanning alert
    ///
    /// Gets a single secret scanning alert detected in an eligible repository.
    /// 
    /// The authenticated user must be an administrator for the repository or for the organization that owns the repository to use this endpoint.
    /// 
    /// OAuth app tokens and personal access tokens (classic) need the `repo` or `security_events` scope to use this endpoint. If this endpoint is only used with public repositories, the token can use the `public_repo` scope instead.
    ///
    /// [GitHub API docs for get_alert](https://docs.github.com/rest/secret-scanning/secret-scanning#get-a-secret-scanning-alert)
    ///
    /// ---
    pub async fn get_alert_async(&self, owner: &str, repo: &str, alert_number: AlertNumber) -> Result<SecretScanningAlert, AdapterError> {

        let request_uri = format!("{}/repos/{}/{}/secret-scanning/alerts/{}", super::GITHUB_BASE_API_URL, owner, repo, alert_number);


        let req = GitHubRequest {
            uri: request_uri,
            body: None::<C::Body>,
            method: "GET",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch_async(request).await?;

        // --

        if github_response.is_success() {
            Ok(github_response.to_json_async().await?)
        } else {
            match github_response.status_code() {
                304 => Err(SecretScanningGetAlertError::Status304.into()),
                404 => Err(SecretScanningGetAlertError::Status404.into()),
                503 => Err(SecretScanningGetAlertError::Status503(github_response.to_json_async().await?).into()),
                code => Err(SecretScanningGetAlertError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # Get a secret scanning alert
    ///
    /// Gets a single secret scanning alert detected in an eligible repository.
    /// 
    /// The authenticated user must be an administrator for the repository or for the organization that owns the repository to use this endpoint.
    /// 
    /// OAuth app tokens and personal access tokens (classic) need the `repo` or `security_events` scope to use this endpoint. If this endpoint is only used with public repositories, the token can use the `public_repo` scope instead.
    ///
    /// [GitHub API docs for get_alert](https://docs.github.com/rest/secret-scanning/secret-scanning#get-a-secret-scanning-alert)
    ///
    /// ---
    #[cfg(not(target_arch = "wasm32"))]
    pub fn get_alert(&self, owner: &str, repo: &str, alert_number: AlertNumber) -> Result<SecretScanningAlert, AdapterError> {

        let request_uri = format!("{}/repos/{}/{}/secret-scanning/alerts/{}", super::GITHUB_BASE_API_URL, owner, repo, alert_number);


        let req = GitHubRequest {
            uri: request_uri,
            body: None,
            method: "GET",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch(request)?;

        // --

        if github_response.is_success() {
            Ok(github_response.to_json()?)
        } else {
            match github_response.status_code() {
                304 => Err(SecretScanningGetAlertError::Status304.into()),
                404 => Err(SecretScanningGetAlertError::Status404.into()),
                503 => Err(SecretScanningGetAlertError::Status503(github_response.to_json()?).into()),
                code => Err(SecretScanningGetAlertError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # List secret scanning alerts for an enterprise
    ///
    /// Lists secret scanning alerts for eligible repositories in an enterprise, from newest to oldest.
    /// 
    /// Alerts are only returned for organizations in the enterprise for which the authenticated user is an organization owner or a [security manager](https://docs.github.com/organizations/managing-peoples-access-to-your-organization-with-roles/managing-security-managers-in-your-organization).
    /// 
    /// The authenticated user must be a member of the enterprise in order to use this endpoint.
    /// 
    /// OAuth app tokens and personal access tokens (classic) need the `repo` scope or `security_events` scope to use this endpoint.
    ///
    /// [GitHub API docs for list_alerts_for_enterprise](https://docs.github.com/rest/secret-scanning/secret-scanning#list-secret-scanning-alerts-for-an-enterprise)
    ///
    /// ---
    pub async fn list_alerts_for_enterprise_async(&self, enterprise: &str, query_params: Option<impl Into<SecretScanningListAlertsForEnterpriseParams<'api>>>) -> Result<Vec<OrganizationSecretScanningAlert>, AdapterError> {

        let mut request_uri = format!("{}/enterprises/{}/secret-scanning/alerts", super::GITHUB_BASE_API_URL, enterprise);

        if let Some(params) = query_params {
            request_uri.push_str("?");
            request_uri.push_str(&serde_urlencoded::to_string(params.into())?);
        }

        let req = GitHubRequest {
            uri: request_uri,
            body: None::<C::Body>,
            method: "GET",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch_async(request).await?;

        // --

        if github_response.is_success() {
            Ok(github_response.to_json_async().await?)
        } else {
            match github_response.status_code() {
                404 => Err(SecretScanningListAlertsForEnterpriseError::Status404(github_response.to_json_async().await?).into()),
                503 => Err(SecretScanningListAlertsForEnterpriseError::Status503(github_response.to_json_async().await?).into()),
                code => Err(SecretScanningListAlertsForEnterpriseError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # List secret scanning alerts for an enterprise
    ///
    /// Lists secret scanning alerts for eligible repositories in an enterprise, from newest to oldest.
    /// 
    /// Alerts are only returned for organizations in the enterprise for which the authenticated user is an organization owner or a [security manager](https://docs.github.com/organizations/managing-peoples-access-to-your-organization-with-roles/managing-security-managers-in-your-organization).
    /// 
    /// The authenticated user must be a member of the enterprise in order to use this endpoint.
    /// 
    /// OAuth app tokens and personal access tokens (classic) need the `repo` scope or `security_events` scope to use this endpoint.
    ///
    /// [GitHub API docs for list_alerts_for_enterprise](https://docs.github.com/rest/secret-scanning/secret-scanning#list-secret-scanning-alerts-for-an-enterprise)
    ///
    /// ---
    #[cfg(not(target_arch = "wasm32"))]
    pub fn list_alerts_for_enterprise(&self, enterprise: &str, query_params: Option<impl Into<SecretScanningListAlertsForEnterpriseParams<'api>>>) -> Result<Vec<OrganizationSecretScanningAlert>, AdapterError> {

        let mut request_uri = format!("{}/enterprises/{}/secret-scanning/alerts", super::GITHUB_BASE_API_URL, enterprise);

        if let Some(params) = query_params {
            request_uri.push_str("?");
            let qp: SecretScanningListAlertsForEnterpriseParams = params.into();
            request_uri.push_str(&serde_urlencoded::to_string(qp)?);
        }

        let req = GitHubRequest {
            uri: request_uri,
            body: None,
            method: "GET",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch(request)?;

        // --

        if github_response.is_success() {
            Ok(github_response.to_json()?)
        } else {
            match github_response.status_code() {
                404 => Err(SecretScanningListAlertsForEnterpriseError::Status404(github_response.to_json()?).into()),
                503 => Err(SecretScanningListAlertsForEnterpriseError::Status503(github_response.to_json()?).into()),
                code => Err(SecretScanningListAlertsForEnterpriseError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # List secret scanning alerts for an organization
    ///
    /// Lists secret scanning alerts for eligible repositories in an organization, from newest to oldest.
    /// 
    /// The authenticated user must be an administrator or security manager for the organization to use this endpoint.
    /// 
    /// OAuth app tokens and personal access tokens (classic) need the `repo` or `security_events` scope to use this endpoint. If this endpoint is only used with public repositories, the token can use the `public_repo` scope instead.
    ///
    /// [GitHub API docs for list_alerts_for_org](https://docs.github.com/rest/secret-scanning/secret-scanning#list-secret-scanning-alerts-for-an-organization)
    ///
    /// ---
    pub async fn list_alerts_for_org_async(&self, org: &str, query_params: Option<impl Into<SecretScanningListAlertsForOrgParams<'api>>>) -> Result<Vec<OrganizationSecretScanningAlert>, AdapterError> {

        let mut request_uri = format!("{}/orgs/{}/secret-scanning/alerts", super::GITHUB_BASE_API_URL, org);

        if let Some(params) = query_params {
            request_uri.push_str("?");
            request_uri.push_str(&serde_urlencoded::to_string(params.into())?);
        }

        let req = GitHubRequest {
            uri: request_uri,
            body: None::<C::Body>,
            method: "GET",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch_async(request).await?;

        // --

        if github_response.is_success() {
            Ok(github_response.to_json_async().await?)
        } else {
            match github_response.status_code() {
                404 => Err(SecretScanningListAlertsForOrgError::Status404(github_response.to_json_async().await?).into()),
                503 => Err(SecretScanningListAlertsForOrgError::Status503(github_response.to_json_async().await?).into()),
                code => Err(SecretScanningListAlertsForOrgError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # List secret scanning alerts for an organization
    ///
    /// Lists secret scanning alerts for eligible repositories in an organization, from newest to oldest.
    /// 
    /// The authenticated user must be an administrator or security manager for the organization to use this endpoint.
    /// 
    /// OAuth app tokens and personal access tokens (classic) need the `repo` or `security_events` scope to use this endpoint. If this endpoint is only used with public repositories, the token can use the `public_repo` scope instead.
    ///
    /// [GitHub API docs for list_alerts_for_org](https://docs.github.com/rest/secret-scanning/secret-scanning#list-secret-scanning-alerts-for-an-organization)
    ///
    /// ---
    #[cfg(not(target_arch = "wasm32"))]
    pub fn list_alerts_for_org(&self, org: &str, query_params: Option<impl Into<SecretScanningListAlertsForOrgParams<'api>>>) -> Result<Vec<OrganizationSecretScanningAlert>, AdapterError> {

        let mut request_uri = format!("{}/orgs/{}/secret-scanning/alerts", super::GITHUB_BASE_API_URL, org);

        if let Some(params) = query_params {
            request_uri.push_str("?");
            let qp: SecretScanningListAlertsForOrgParams = params.into();
            request_uri.push_str(&serde_urlencoded::to_string(qp)?);
        }

        let req = GitHubRequest {
            uri: request_uri,
            body: None,
            method: "GET",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch(request)?;

        // --

        if github_response.is_success() {
            Ok(github_response.to_json()?)
        } else {
            match github_response.status_code() {
                404 => Err(SecretScanningListAlertsForOrgError::Status404(github_response.to_json()?).into()),
                503 => Err(SecretScanningListAlertsForOrgError::Status503(github_response.to_json()?).into()),
                code => Err(SecretScanningListAlertsForOrgError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # List secret scanning alerts for a repository
    ///
    /// Lists secret scanning alerts for an eligible repository, from newest to oldest.
    /// 
    /// The authenticated user must be an administrator for the repository or for the organization that owns the repository to use this endpoint.
    /// 
    /// OAuth app tokens and personal access tokens (classic) need the `repo` or `security_events` scope to use this endpoint. If this endpoint is only used with public repositories, the token can use the `public_repo` scope instead.
    ///
    /// [GitHub API docs for list_alerts_for_repo](https://docs.github.com/rest/secret-scanning/secret-scanning#list-secret-scanning-alerts-for-a-repository)
    ///
    /// ---
    pub async fn list_alerts_for_repo_async(&self, owner: &str, repo: &str, query_params: Option<impl Into<SecretScanningListAlertsForRepoParams<'api>>>) -> Result<Vec<SecretScanningAlert>, AdapterError> {

        let mut request_uri = format!("{}/repos/{}/{}/secret-scanning/alerts", super::GITHUB_BASE_API_URL, owner, repo);

        if let Some(params) = query_params {
            request_uri.push_str("?");
            request_uri.push_str(&serde_urlencoded::to_string(params.into())?);
        }

        let req = GitHubRequest {
            uri: request_uri,
            body: None::<C::Body>,
            method: "GET",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch_async(request).await?;

        // --

        if github_response.is_success() {
            Ok(github_response.to_json_async().await?)
        } else {
            match github_response.status_code() {
                404 => Err(SecretScanningListAlertsForRepoError::Status404.into()),
                503 => Err(SecretScanningListAlertsForRepoError::Status503(github_response.to_json_async().await?).into()),
                code => Err(SecretScanningListAlertsForRepoError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # List secret scanning alerts for a repository
    ///
    /// Lists secret scanning alerts for an eligible repository, from newest to oldest.
    /// 
    /// The authenticated user must be an administrator for the repository or for the organization that owns the repository to use this endpoint.
    /// 
    /// OAuth app tokens and personal access tokens (classic) need the `repo` or `security_events` scope to use this endpoint. If this endpoint is only used with public repositories, the token can use the `public_repo` scope instead.
    ///
    /// [GitHub API docs for list_alerts_for_repo](https://docs.github.com/rest/secret-scanning/secret-scanning#list-secret-scanning-alerts-for-a-repository)
    ///
    /// ---
    #[cfg(not(target_arch = "wasm32"))]
    pub fn list_alerts_for_repo(&self, owner: &str, repo: &str, query_params: Option<impl Into<SecretScanningListAlertsForRepoParams<'api>>>) -> Result<Vec<SecretScanningAlert>, AdapterError> {

        let mut request_uri = format!("{}/repos/{}/{}/secret-scanning/alerts", super::GITHUB_BASE_API_URL, owner, repo);

        if let Some(params) = query_params {
            request_uri.push_str("?");
            let qp: SecretScanningListAlertsForRepoParams = params.into();
            request_uri.push_str(&serde_urlencoded::to_string(qp)?);
        }

        let req = GitHubRequest {
            uri: request_uri,
            body: None,
            method: "GET",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch(request)?;

        // --

        if github_response.is_success() {
            Ok(github_response.to_json()?)
        } else {
            match github_response.status_code() {
                404 => Err(SecretScanningListAlertsForRepoError::Status404.into()),
                503 => Err(SecretScanningListAlertsForRepoError::Status503(github_response.to_json()?).into()),
                code => Err(SecretScanningListAlertsForRepoError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # List locations for a secret scanning alert
    ///
    /// Lists all locations for a given secret scanning alert for an eligible repository.
    /// 
    /// The authenticated user must be an administrator for the repository or for the organization that owns the repository to use this endpoint.
    /// 
    /// OAuth app tokens and personal access tokens (classic) need the `repo` or `security_events` scope to use this endpoint. If this endpoint is only used with public repositories, the token can use the `public_repo` scope instead.
    ///
    /// [GitHub API docs for list_locations_for_alert](https://docs.github.com/rest/secret-scanning/secret-scanning#list-locations-for-a-secret-scanning-alert)
    ///
    /// ---
    pub async fn list_locations_for_alert_async(&self, owner: &str, repo: &str, alert_number: AlertNumber, query_params: Option<impl Into<SecretScanningListLocationsForAlertParams>>) -> Result<Vec<SecretScanningLocation>, AdapterError> {

        let mut request_uri = format!("{}/repos/{}/{}/secret-scanning/alerts/{}/locations", super::GITHUB_BASE_API_URL, owner, repo, alert_number);

        if let Some(params) = query_params {
            request_uri.push_str("?");
            request_uri.push_str(&serde_urlencoded::to_string(params.into())?);
        }

        let req = GitHubRequest {
            uri: request_uri,
            body: None::<C::Body>,
            method: "GET",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch_async(request).await?;

        // --

        if github_response.is_success() {
            Ok(github_response.to_json_async().await?)
        } else {
            match github_response.status_code() {
                404 => Err(SecretScanningListLocationsForAlertError::Status404.into()),
                503 => Err(SecretScanningListLocationsForAlertError::Status503(github_response.to_json_async().await?).into()),
                code => Err(SecretScanningListLocationsForAlertError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # List locations for a secret scanning alert
    ///
    /// Lists all locations for a given secret scanning alert for an eligible repository.
    /// 
    /// The authenticated user must be an administrator for the repository or for the organization that owns the repository to use this endpoint.
    /// 
    /// OAuth app tokens and personal access tokens (classic) need the `repo` or `security_events` scope to use this endpoint. If this endpoint is only used with public repositories, the token can use the `public_repo` scope instead.
    ///
    /// [GitHub API docs for list_locations_for_alert](https://docs.github.com/rest/secret-scanning/secret-scanning#list-locations-for-a-secret-scanning-alert)
    ///
    /// ---
    #[cfg(not(target_arch = "wasm32"))]
    pub fn list_locations_for_alert(&self, owner: &str, repo: &str, alert_number: AlertNumber, query_params: Option<impl Into<SecretScanningListLocationsForAlertParams>>) -> Result<Vec<SecretScanningLocation>, AdapterError> {

        let mut request_uri = format!("{}/repos/{}/{}/secret-scanning/alerts/{}/locations", super::GITHUB_BASE_API_URL, owner, repo, alert_number);

        if let Some(params) = query_params {
            request_uri.push_str("?");
            let qp: SecretScanningListLocationsForAlertParams = params.into();
            request_uri.push_str(&serde_urlencoded::to_string(qp)?);
        }

        let req = GitHubRequest {
            uri: request_uri,
            body: None,
            method: "GET",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch(request)?;

        // --

        if github_response.is_success() {
            Ok(github_response.to_json()?)
        } else {
            match github_response.status_code() {
                404 => Err(SecretScanningListLocationsForAlertError::Status404.into()),
                503 => Err(SecretScanningListLocationsForAlertError::Status503(github_response.to_json()?).into()),
                code => Err(SecretScanningListLocationsForAlertError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # Update a secret scanning alert
    ///
    /// Updates the status of a secret scanning alert in an eligible repository.
    /// 
    /// The authenticated user must be an administrator for the repository or for the organization that owns the repository to use this endpoint.
    /// 
    /// OAuth app tokens and personal access tokens (classic) need the `repo` or `security_events` scope to use this endpoint. If this endpoint is only used with public repositories, the token can use the `public_repo` scope instead.
    ///
    /// [GitHub API docs for update_alert](https://docs.github.com/rest/secret-scanning/secret-scanning#update-a-secret-scanning-alert)
    ///
    /// ---
    pub async fn update_alert_async(&self, owner: &str, repo: &str, alert_number: AlertNumber, body: PatchSecretScanningUpdateAlert) -> Result<SecretScanningAlert, AdapterError> {

        let request_uri = format!("{}/repos/{}/{}/secret-scanning/alerts/{}", super::GITHUB_BASE_API_URL, owner, repo, alert_number);


        let req = GitHubRequest {
            uri: request_uri,
            body: Some(C::from_json::<PatchSecretScanningUpdateAlert>(body)?),
            method: "PATCH",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch_async(request).await?;

        // --

        if github_response.is_success() {
            Ok(github_response.to_json_async().await?)
        } else {
            match github_response.status_code() {
                400 => Err(SecretScanningUpdateAlertError::Status400.into()),
                404 => Err(SecretScanningUpdateAlertError::Status404.into()),
                422 => Err(SecretScanningUpdateAlertError::Status422.into()),
                503 => Err(SecretScanningUpdateAlertError::Status503(github_response.to_json_async().await?).into()),
                code => Err(SecretScanningUpdateAlertError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # Update a secret scanning alert
    ///
    /// Updates the status of a secret scanning alert in an eligible repository.
    /// 
    /// The authenticated user must be an administrator for the repository or for the organization that owns the repository to use this endpoint.
    /// 
    /// OAuth app tokens and personal access tokens (classic) need the `repo` or `security_events` scope to use this endpoint. If this endpoint is only used with public repositories, the token can use the `public_repo` scope instead.
    ///
    /// [GitHub API docs for update_alert](https://docs.github.com/rest/secret-scanning/secret-scanning#update-a-secret-scanning-alert)
    ///
    /// ---
    #[cfg(not(target_arch = "wasm32"))]
    pub fn update_alert(&self, owner: &str, repo: &str, alert_number: AlertNumber, body: PatchSecretScanningUpdateAlert) -> Result<SecretScanningAlert, AdapterError> {

        let request_uri = format!("{}/repos/{}/{}/secret-scanning/alerts/{}", super::GITHUB_BASE_API_URL, owner, repo, alert_number);


        let req = GitHubRequest {
            uri: request_uri,
            body: Some(C::from_json::<PatchSecretScanningUpdateAlert>(body)?),
            method: "PATCH",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch(request)?;

        // --

        if github_response.is_success() {
            Ok(github_response.to_json()?)
        } else {
            match github_response.status_code() {
                400 => Err(SecretScanningUpdateAlertError::Status400.into()),
                404 => Err(SecretScanningUpdateAlertError::Status404.into()),
                422 => Err(SecretScanningUpdateAlertError::Status422.into()),
                503 => Err(SecretScanningUpdateAlertError::Status503(github_response.to_json()?).into()),
                code => Err(SecretScanningUpdateAlertError::Generic { code }.into()),
            }
        }
    }

}
