//! Method, error and parameter types for the Projects endpoint.
#![allow(
    clippy::all
)]
/* 
 * GitHub v3 REST API
 *
 * GitHub's v3 REST API.
 *
 * OpenAPI spec version: 1.1.4
 * 
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 */

use serde::Deserialize;

use crate::adapters::{AdapterError, Client, GitHubRequest, GitHubResponseExt};
use crate::models::*;

use super::PerPage;

use std::collections::HashMap;
use serde_json::value::Value;

pub struct Projects<'api, C: Client> where AdapterError: From<<C as Client>::Err> {
    client: &'api C
}

pub fn new<C: Client>(client: &C) -> Projects<C> where AdapterError: From<<C as Client>::Err> {
    Projects { client }
}

/// Errors for the [Add project collaborator](Projects::add_collaborator_async()) endpoint.
#[derive(Debug, thiserror::Error)]
pub enum ProjectsAddCollaboratorError {
    #[error("Resource not found")]
    Status404(BasicError),
    #[error("Validation failed, or the endpoint has been spammed.")]
    Status422(ValidationError),
    #[error("Not modified")]
    Status304,
    #[error("Forbidden")]
    Status403(BasicError),
    #[error("Requires authentication")]
    Status401(BasicError),
    #[error("Status code: {}", code)]
    Generic { code: u16 },
}

impl From<ProjectsAddCollaboratorError> for AdapterError {
    fn from(err: ProjectsAddCollaboratorError) -> Self {
        let (description, status_code) = match err {
            ProjectsAddCollaboratorError::Status404(_) => (String::from("Resource not found"), 404),
            ProjectsAddCollaboratorError::Status422(_) => (String::from("Validation failed, or the endpoint has been spammed."), 422),
            ProjectsAddCollaboratorError::Status304 => (String::from("Not modified"), 304),
            ProjectsAddCollaboratorError::Status403(_) => (String::from("Forbidden"), 403),
            ProjectsAddCollaboratorError::Status401(_) => (String::from("Requires authentication"), 401),
            ProjectsAddCollaboratorError::Generic { code } => (String::from("Generic"), code)
        };

        Self::Endpoint {
            description,
            status_code,
            source: Some(Box::new(err))
        }
    }
}

/// Errors for the [Create a project card](Projects::create_card_async()) endpoint.
#[derive(Debug, thiserror::Error)]
pub enum ProjectsCreateCardError {
    #[error("Not modified")]
    Status304,
    #[error("Forbidden")]
    Status403(BasicError),
    #[error("Requires authentication")]
    Status401(BasicError),
    #[error("Validation failed")]
    Status422(PostProjectsCreateCardResponse422),
    #[error("Response")]
    Status503(PostProjectsCreateCardResponse503),
    #[error("Status code: {}", code)]
    Generic { code: u16 },
}

impl From<ProjectsCreateCardError> for AdapterError {
    fn from(err: ProjectsCreateCardError) -> Self {
        let (description, status_code) = match err {
            ProjectsCreateCardError::Status304 => (String::from("Not modified"), 304),
            ProjectsCreateCardError::Status403(_) => (String::from("Forbidden"), 403),
            ProjectsCreateCardError::Status401(_) => (String::from("Requires authentication"), 401),
            ProjectsCreateCardError::Status422(_) => (String::from("Validation failed"), 422),
            ProjectsCreateCardError::Status503(_) => (String::from("Response"), 503),
            ProjectsCreateCardError::Generic { code } => (String::from("Generic"), code)
        };

        Self::Endpoint {
            description,
            status_code,
            source: Some(Box::new(err))
        }
    }
}

/// Errors for the [Create a project column](Projects::create_column_async()) endpoint.
#[derive(Debug, thiserror::Error)]
pub enum ProjectsCreateColumnError {
    #[error("Not modified")]
    Status304,
    #[error("Forbidden")]
    Status403(BasicError),
    #[error("Validation failed, or the endpoint has been spammed.")]
    Status422(ValidationErrorSimple),
    #[error("Requires authentication")]
    Status401(BasicError),
    #[error("Status code: {}", code)]
    Generic { code: u16 },
}

impl From<ProjectsCreateColumnError> for AdapterError {
    fn from(err: ProjectsCreateColumnError) -> Self {
        let (description, status_code) = match err {
            ProjectsCreateColumnError::Status304 => (String::from("Not modified"), 304),
            ProjectsCreateColumnError::Status403(_) => (String::from("Forbidden"), 403),
            ProjectsCreateColumnError::Status422(_) => (String::from("Validation failed, or the endpoint has been spammed."), 422),
            ProjectsCreateColumnError::Status401(_) => (String::from("Requires authentication"), 401),
            ProjectsCreateColumnError::Generic { code } => (String::from("Generic"), code)
        };

        Self::Endpoint {
            description,
            status_code,
            source: Some(Box::new(err))
        }
    }
}

/// Errors for the [Create a user project](Projects::create_for_authenticated_user_async()) endpoint.
#[derive(Debug, thiserror::Error)]
pub enum ProjectsCreateForAuthenticatedUserError {
    #[error("Not modified")]
    Status304,
    #[error("Forbidden")]
    Status403(BasicError),
    #[error("Requires authentication")]
    Status401(BasicError),
    #[error("Validation failed, or the endpoint has been spammed.")]
    Status422(ValidationErrorSimple),
    #[error("Status code: {}", code)]
    Generic { code: u16 },
}

impl From<ProjectsCreateForAuthenticatedUserError> for AdapterError {
    fn from(err: ProjectsCreateForAuthenticatedUserError) -> Self {
        let (description, status_code) = match err {
            ProjectsCreateForAuthenticatedUserError::Status304 => (String::from("Not modified"), 304),
            ProjectsCreateForAuthenticatedUserError::Status403(_) => (String::from("Forbidden"), 403),
            ProjectsCreateForAuthenticatedUserError::Status401(_) => (String::from("Requires authentication"), 401),
            ProjectsCreateForAuthenticatedUserError::Status422(_) => (String::from("Validation failed, or the endpoint has been spammed."), 422),
            ProjectsCreateForAuthenticatedUserError::Generic { code } => (String::from("Generic"), code)
        };

        Self::Endpoint {
            description,
            status_code,
            source: Some(Box::new(err))
        }
    }
}

/// Errors for the [Create an organization project](Projects::create_for_org_async()) endpoint.
#[derive(Debug, thiserror::Error)]
pub enum ProjectsCreateForOrgError {
    #[error("Requires authentication")]
    Status401(BasicError),
    #[error("Forbidden")]
    Status403(BasicError),
    #[error("Resource not found")]
    Status404(BasicError),
    #[error("Gone")]
    Status410(BasicError),
    #[error("Validation failed, or the endpoint has been spammed.")]
    Status422(ValidationErrorSimple),
    #[error("Status code: {}", code)]
    Generic { code: u16 },
}

impl From<ProjectsCreateForOrgError> for AdapterError {
    fn from(err: ProjectsCreateForOrgError) -> Self {
        let (description, status_code) = match err {
            ProjectsCreateForOrgError::Status401(_) => (String::from("Requires authentication"), 401),
            ProjectsCreateForOrgError::Status403(_) => (String::from("Forbidden"), 403),
            ProjectsCreateForOrgError::Status404(_) => (String::from("Resource not found"), 404),
            ProjectsCreateForOrgError::Status410(_) => (String::from("Gone"), 410),
            ProjectsCreateForOrgError::Status422(_) => (String::from("Validation failed, or the endpoint has been spammed."), 422),
            ProjectsCreateForOrgError::Generic { code } => (String::from("Generic"), code)
        };

        Self::Endpoint {
            description,
            status_code,
            source: Some(Box::new(err))
        }
    }
}

/// Errors for the [Create a repository project](Projects::create_for_repo_async()) endpoint.
#[derive(Debug, thiserror::Error)]
pub enum ProjectsCreateForRepoError {
    #[error("Requires authentication")]
    Status401(BasicError),
    #[error("Forbidden")]
    Status403(BasicError),
    #[error("Resource not found")]
    Status404(BasicError),
    #[error("Gone")]
    Status410(BasicError),
    #[error("Validation failed, or the endpoint has been spammed.")]
    Status422(ValidationErrorSimple),
    #[error("Status code: {}", code)]
    Generic { code: u16 },
}

impl From<ProjectsCreateForRepoError> for AdapterError {
    fn from(err: ProjectsCreateForRepoError) -> Self {
        let (description, status_code) = match err {
            ProjectsCreateForRepoError::Status401(_) => (String::from("Requires authentication"), 401),
            ProjectsCreateForRepoError::Status403(_) => (String::from("Forbidden"), 403),
            ProjectsCreateForRepoError::Status404(_) => (String::from("Resource not found"), 404),
            ProjectsCreateForRepoError::Status410(_) => (String::from("Gone"), 410),
            ProjectsCreateForRepoError::Status422(_) => (String::from("Validation failed, or the endpoint has been spammed."), 422),
            ProjectsCreateForRepoError::Generic { code } => (String::from("Generic"), code)
        };

        Self::Endpoint {
            description,
            status_code,
            source: Some(Box::new(err))
        }
    }
}

/// Errors for the [Delete a project](Projects::delete_async()) endpoint.
#[derive(Debug, thiserror::Error)]
pub enum ProjectsDeleteError {
    #[error("Not modified")]
    Status304,
    #[error("Forbidden")]
    Status403(PatchProjectsUpdateResponse403),
    #[error("Requires authentication")]
    Status401(BasicError),
    #[error("Gone")]
    Status410(BasicError),
    #[error("Resource not found")]
    Status404(BasicError),
    #[error("Status code: {}", code)]
    Generic { code: u16 },
}

impl From<ProjectsDeleteError> for AdapterError {
    fn from(err: ProjectsDeleteError) -> Self {
        let (description, status_code) = match err {
            ProjectsDeleteError::Status304 => (String::from("Not modified"), 304),
            ProjectsDeleteError::Status403(_) => (String::from("Forbidden"), 403),
            ProjectsDeleteError::Status401(_) => (String::from("Requires authentication"), 401),
            ProjectsDeleteError::Status410(_) => (String::from("Gone"), 410),
            ProjectsDeleteError::Status404(_) => (String::from("Resource not found"), 404),
            ProjectsDeleteError::Generic { code } => (String::from("Generic"), code)
        };

        Self::Endpoint {
            description,
            status_code,
            source: Some(Box::new(err))
        }
    }
}

/// Errors for the [Delete a project card](Projects::delete_card_async()) endpoint.
#[derive(Debug, thiserror::Error)]
pub enum ProjectsDeleteCardError {
    #[error("Not modified")]
    Status304,
    #[error("Forbidden")]
    Status403(PatchProjectsUpdateResponse403),
    #[error("Requires authentication")]
    Status401(BasicError),
    #[error("Resource not found")]
    Status404(BasicError),
    #[error("Status code: {}", code)]
    Generic { code: u16 },
}

impl From<ProjectsDeleteCardError> for AdapterError {
    fn from(err: ProjectsDeleteCardError) -> Self {
        let (description, status_code) = match err {
            ProjectsDeleteCardError::Status304 => (String::from("Not modified"), 304),
            ProjectsDeleteCardError::Status403(_) => (String::from("Forbidden"), 403),
            ProjectsDeleteCardError::Status401(_) => (String::from("Requires authentication"), 401),
            ProjectsDeleteCardError::Status404(_) => (String::from("Resource not found"), 404),
            ProjectsDeleteCardError::Generic { code } => (String::from("Generic"), code)
        };

        Self::Endpoint {
            description,
            status_code,
            source: Some(Box::new(err))
        }
    }
}

/// Errors for the [Delete a project column](Projects::delete_column_async()) endpoint.
#[derive(Debug, thiserror::Error)]
pub enum ProjectsDeleteColumnError {
    #[error("Not modified")]
    Status304,
    #[error("Forbidden")]
    Status403(BasicError),
    #[error("Requires authentication")]
    Status401(BasicError),
    #[error("Status code: {}", code)]
    Generic { code: u16 },
}

impl From<ProjectsDeleteColumnError> for AdapterError {
    fn from(err: ProjectsDeleteColumnError) -> Self {
        let (description, status_code) = match err {
            ProjectsDeleteColumnError::Status304 => (String::from("Not modified"), 304),
            ProjectsDeleteColumnError::Status403(_) => (String::from("Forbidden"), 403),
            ProjectsDeleteColumnError::Status401(_) => (String::from("Requires authentication"), 401),
            ProjectsDeleteColumnError::Generic { code } => (String::from("Generic"), code)
        };

        Self::Endpoint {
            description,
            status_code,
            source: Some(Box::new(err))
        }
    }
}

/// Errors for the [Get a project](Projects::get_async()) endpoint.
#[derive(Debug, thiserror::Error)]
pub enum ProjectsGetError {
    #[error("Not modified")]
    Status304,
    #[error("Forbidden")]
    Status403(BasicError),
    #[error("Requires authentication")]
    Status401(BasicError),
    #[error("Status code: {}", code)]
    Generic { code: u16 },
}

impl From<ProjectsGetError> for AdapterError {
    fn from(err: ProjectsGetError) -> Self {
        let (description, status_code) = match err {
            ProjectsGetError::Status304 => (String::from("Not modified"), 304),
            ProjectsGetError::Status403(_) => (String::from("Forbidden"), 403),
            ProjectsGetError::Status401(_) => (String::from("Requires authentication"), 401),
            ProjectsGetError::Generic { code } => (String::from("Generic"), code)
        };

        Self::Endpoint {
            description,
            status_code,
            source: Some(Box::new(err))
        }
    }
}

/// Errors for the [Get a project card](Projects::get_card_async()) endpoint.
#[derive(Debug, thiserror::Error)]
pub enum ProjectsGetCardError {
    #[error("Not modified")]
    Status304,
    #[error("Forbidden")]
    Status403(BasicError),
    #[error("Requires authentication")]
    Status401(BasicError),
    #[error("Resource not found")]
    Status404(BasicError),
    #[error("Status code: {}", code)]
    Generic { code: u16 },
}

impl From<ProjectsGetCardError> for AdapterError {
    fn from(err: ProjectsGetCardError) -> Self {
        let (description, status_code) = match err {
            ProjectsGetCardError::Status304 => (String::from("Not modified"), 304),
            ProjectsGetCardError::Status403(_) => (String::from("Forbidden"), 403),
            ProjectsGetCardError::Status401(_) => (String::from("Requires authentication"), 401),
            ProjectsGetCardError::Status404(_) => (String::from("Resource not found"), 404),
            ProjectsGetCardError::Generic { code } => (String::from("Generic"), code)
        };

        Self::Endpoint {
            description,
            status_code,
            source: Some(Box::new(err))
        }
    }
}

/// Errors for the [Get a project column](Projects::get_column_async()) endpoint.
#[derive(Debug, thiserror::Error)]
pub enum ProjectsGetColumnError {
    #[error("Not modified")]
    Status304,
    #[error("Forbidden")]
    Status403(BasicError),
    #[error("Resource not found")]
    Status404(BasicError),
    #[error("Requires authentication")]
    Status401(BasicError),
    #[error("Status code: {}", code)]
    Generic { code: u16 },
}

impl From<ProjectsGetColumnError> for AdapterError {
    fn from(err: ProjectsGetColumnError) -> Self {
        let (description, status_code) = match err {
            ProjectsGetColumnError::Status304 => (String::from("Not modified"), 304),
            ProjectsGetColumnError::Status403(_) => (String::from("Forbidden"), 403),
            ProjectsGetColumnError::Status404(_) => (String::from("Resource not found"), 404),
            ProjectsGetColumnError::Status401(_) => (String::from("Requires authentication"), 401),
            ProjectsGetColumnError::Generic { code } => (String::from("Generic"), code)
        };

        Self::Endpoint {
            description,
            status_code,
            source: Some(Box::new(err))
        }
    }
}

/// Errors for the [Get project permission for a user](Projects::get_permission_for_user_async()) endpoint.
#[derive(Debug, thiserror::Error)]
pub enum ProjectsGetPermissionForUserError {
    #[error("Resource not found")]
    Status404(BasicError),
    #[error("Validation failed, or the endpoint has been spammed.")]
    Status422(ValidationError),
    #[error("Not modified")]
    Status304,
    #[error("Forbidden")]
    Status403(BasicError),
    #[error("Requires authentication")]
    Status401(BasicError),
    #[error("Status code: {}", code)]
    Generic { code: u16 },
}

impl From<ProjectsGetPermissionForUserError> for AdapterError {
    fn from(err: ProjectsGetPermissionForUserError) -> Self {
        let (description, status_code) = match err {
            ProjectsGetPermissionForUserError::Status404(_) => (String::from("Resource not found"), 404),
            ProjectsGetPermissionForUserError::Status422(_) => (String::from("Validation failed, or the endpoint has been spammed."), 422),
            ProjectsGetPermissionForUserError::Status304 => (String::from("Not modified"), 304),
            ProjectsGetPermissionForUserError::Status403(_) => (String::from("Forbidden"), 403),
            ProjectsGetPermissionForUserError::Status401(_) => (String::from("Requires authentication"), 401),
            ProjectsGetPermissionForUserError::Generic { code } => (String::from("Generic"), code)
        };

        Self::Endpoint {
            description,
            status_code,
            source: Some(Box::new(err))
        }
    }
}

/// Errors for the [List project cards](Projects::list_cards_async()) endpoint.
#[derive(Debug, thiserror::Error)]
pub enum ProjectsListCardsError {
    #[error("Not modified")]
    Status304,
    #[error("Forbidden")]
    Status403(BasicError),
    #[error("Requires authentication")]
    Status401(BasicError),
    #[error("Status code: {}", code)]
    Generic { code: u16 },
}

impl From<ProjectsListCardsError> for AdapterError {
    fn from(err: ProjectsListCardsError) -> Self {
        let (description, status_code) = match err {
            ProjectsListCardsError::Status304 => (String::from("Not modified"), 304),
            ProjectsListCardsError::Status403(_) => (String::from("Forbidden"), 403),
            ProjectsListCardsError::Status401(_) => (String::from("Requires authentication"), 401),
            ProjectsListCardsError::Generic { code } => (String::from("Generic"), code)
        };

        Self::Endpoint {
            description,
            status_code,
            source: Some(Box::new(err))
        }
    }
}

/// Errors for the [List project collaborators](Projects::list_collaborators_async()) endpoint.
#[derive(Debug, thiserror::Error)]
pub enum ProjectsListCollaboratorsError {
    #[error("Resource not found")]
    Status404(BasicError),
    #[error("Validation failed, or the endpoint has been spammed.")]
    Status422(ValidationError),
    #[error("Not modified")]
    Status304,
    #[error("Forbidden")]
    Status403(BasicError),
    #[error("Requires authentication")]
    Status401(BasicError),
    #[error("Status code: {}", code)]
    Generic { code: u16 },
}

impl From<ProjectsListCollaboratorsError> for AdapterError {
    fn from(err: ProjectsListCollaboratorsError) -> Self {
        let (description, status_code) = match err {
            ProjectsListCollaboratorsError::Status404(_) => (String::from("Resource not found"), 404),
            ProjectsListCollaboratorsError::Status422(_) => (String::from("Validation failed, or the endpoint has been spammed."), 422),
            ProjectsListCollaboratorsError::Status304 => (String::from("Not modified"), 304),
            ProjectsListCollaboratorsError::Status403(_) => (String::from("Forbidden"), 403),
            ProjectsListCollaboratorsError::Status401(_) => (String::from("Requires authentication"), 401),
            ProjectsListCollaboratorsError::Generic { code } => (String::from("Generic"), code)
        };

        Self::Endpoint {
            description,
            status_code,
            source: Some(Box::new(err))
        }
    }
}

/// Errors for the [List project columns](Projects::list_columns_async()) endpoint.
#[derive(Debug, thiserror::Error)]
pub enum ProjectsListColumnsError {
    #[error("Not modified")]
    Status304,
    #[error("Forbidden")]
    Status403(BasicError),
    #[error("Requires authentication")]
    Status401(BasicError),
    #[error("Status code: {}", code)]
    Generic { code: u16 },
}

impl From<ProjectsListColumnsError> for AdapterError {
    fn from(err: ProjectsListColumnsError) -> Self {
        let (description, status_code) = match err {
            ProjectsListColumnsError::Status304 => (String::from("Not modified"), 304),
            ProjectsListColumnsError::Status403(_) => (String::from("Forbidden"), 403),
            ProjectsListColumnsError::Status401(_) => (String::from("Requires authentication"), 401),
            ProjectsListColumnsError::Generic { code } => (String::from("Generic"), code)
        };

        Self::Endpoint {
            description,
            status_code,
            source: Some(Box::new(err))
        }
    }
}

/// Errors for the [List organization projects](Projects::list_for_org_async()) endpoint.
#[derive(Debug, thiserror::Error)]
pub enum ProjectsListForOrgError {
    #[error("Validation failed, or the endpoint has been spammed.")]
    Status422(ValidationErrorSimple),
    #[error("Status code: {}", code)]
    Generic { code: u16 },
}

impl From<ProjectsListForOrgError> for AdapterError {
    fn from(err: ProjectsListForOrgError) -> Self {
        let (description, status_code) = match err {
            ProjectsListForOrgError::Status422(_) => (String::from("Validation failed, or the endpoint has been spammed."), 422),
            ProjectsListForOrgError::Generic { code } => (String::from("Generic"), code)
        };

        Self::Endpoint {
            description,
            status_code,
            source: Some(Box::new(err))
        }
    }
}

/// Errors for the [List repository projects](Projects::list_for_repo_async()) endpoint.
#[derive(Debug, thiserror::Error)]
pub enum ProjectsListForRepoError {
    #[error("Requires authentication")]
    Status401(BasicError),
    #[error("Forbidden")]
    Status403(BasicError),
    #[error("Resource not found")]
    Status404(BasicError),
    #[error("Gone")]
    Status410(BasicError),
    #[error("Validation failed, or the endpoint has been spammed.")]
    Status422(ValidationErrorSimple),
    #[error("Status code: {}", code)]
    Generic { code: u16 },
}

impl From<ProjectsListForRepoError> for AdapterError {
    fn from(err: ProjectsListForRepoError) -> Self {
        let (description, status_code) = match err {
            ProjectsListForRepoError::Status401(_) => (String::from("Requires authentication"), 401),
            ProjectsListForRepoError::Status403(_) => (String::from("Forbidden"), 403),
            ProjectsListForRepoError::Status404(_) => (String::from("Resource not found"), 404),
            ProjectsListForRepoError::Status410(_) => (String::from("Gone"), 410),
            ProjectsListForRepoError::Status422(_) => (String::from("Validation failed, or the endpoint has been spammed."), 422),
            ProjectsListForRepoError::Generic { code } => (String::from("Generic"), code)
        };

        Self::Endpoint {
            description,
            status_code,
            source: Some(Box::new(err))
        }
    }
}

/// Errors for the [List user projects](Projects::list_for_user_async()) endpoint.
#[derive(Debug, thiserror::Error)]
pub enum ProjectsListForUserError {
    #[error("Validation failed, or the endpoint has been spammed.")]
    Status422(ValidationError),
    #[error("Status code: {}", code)]
    Generic { code: u16 },
}

impl From<ProjectsListForUserError> for AdapterError {
    fn from(err: ProjectsListForUserError) -> Self {
        let (description, status_code) = match err {
            ProjectsListForUserError::Status422(_) => (String::from("Validation failed, or the endpoint has been spammed."), 422),
            ProjectsListForUserError::Generic { code } => (String::from("Generic"), code)
        };

        Self::Endpoint {
            description,
            status_code,
            source: Some(Box::new(err))
        }
    }
}

/// Errors for the [Move a project card](Projects::move_card_async()) endpoint.
#[derive(Debug, thiserror::Error)]
pub enum ProjectsMoveCardError {
    #[error("Not modified")]
    Status304,
    #[error("Forbidden")]
    Status403(PostProjectsMoveCardResponse403),
    #[error("Requires authentication")]
    Status401(BasicError),
    #[error("Response")]
    Status503(PostProjectsCreateCardResponse503),
    #[error("Validation failed, or the endpoint has been spammed.")]
    Status422(ValidationError),
    #[error("Status code: {}", code)]
    Generic { code: u16 },
}

impl From<ProjectsMoveCardError> for AdapterError {
    fn from(err: ProjectsMoveCardError) -> Self {
        let (description, status_code) = match err {
            ProjectsMoveCardError::Status304 => (String::from("Not modified"), 304),
            ProjectsMoveCardError::Status403(_) => (String::from("Forbidden"), 403),
            ProjectsMoveCardError::Status401(_) => (String::from("Requires authentication"), 401),
            ProjectsMoveCardError::Status503(_) => (String::from("Response"), 503),
            ProjectsMoveCardError::Status422(_) => (String::from("Validation failed, or the endpoint has been spammed."), 422),
            ProjectsMoveCardError::Generic { code } => (String::from("Generic"), code)
        };

        Self::Endpoint {
            description,
            status_code,
            source: Some(Box::new(err))
        }
    }
}

/// Errors for the [Move a project column](Projects::move_column_async()) endpoint.
#[derive(Debug, thiserror::Error)]
pub enum ProjectsMoveColumnError {
    #[error("Not modified")]
    Status304,
    #[error("Forbidden")]
    Status403(BasicError),
    #[error("Validation failed, or the endpoint has been spammed.")]
    Status422(ValidationErrorSimple),
    #[error("Requires authentication")]
    Status401(BasicError),
    #[error("Status code: {}", code)]
    Generic { code: u16 },
}

impl From<ProjectsMoveColumnError> for AdapterError {
    fn from(err: ProjectsMoveColumnError) -> Self {
        let (description, status_code) = match err {
            ProjectsMoveColumnError::Status304 => (String::from("Not modified"), 304),
            ProjectsMoveColumnError::Status403(_) => (String::from("Forbidden"), 403),
            ProjectsMoveColumnError::Status422(_) => (String::from("Validation failed, or the endpoint has been spammed."), 422),
            ProjectsMoveColumnError::Status401(_) => (String::from("Requires authentication"), 401),
            ProjectsMoveColumnError::Generic { code } => (String::from("Generic"), code)
        };

        Self::Endpoint {
            description,
            status_code,
            source: Some(Box::new(err))
        }
    }
}

/// Errors for the [Remove user as a collaborator](Projects::remove_collaborator_async()) endpoint.
#[derive(Debug, thiserror::Error)]
pub enum ProjectsRemoveCollaboratorError {
    #[error("Not modified")]
    Status304,
    #[error("Resource not found")]
    Status404(BasicError),
    #[error("Forbidden")]
    Status403(BasicError),
    #[error("Validation failed, or the endpoint has been spammed.")]
    Status422(ValidationError),
    #[error("Requires authentication")]
    Status401(BasicError),
    #[error("Status code: {}", code)]
    Generic { code: u16 },
}

impl From<ProjectsRemoveCollaboratorError> for AdapterError {
    fn from(err: ProjectsRemoveCollaboratorError) -> Self {
        let (description, status_code) = match err {
            ProjectsRemoveCollaboratorError::Status304 => (String::from("Not modified"), 304),
            ProjectsRemoveCollaboratorError::Status404(_) => (String::from("Resource not found"), 404),
            ProjectsRemoveCollaboratorError::Status403(_) => (String::from("Forbidden"), 403),
            ProjectsRemoveCollaboratorError::Status422(_) => (String::from("Validation failed, or the endpoint has been spammed."), 422),
            ProjectsRemoveCollaboratorError::Status401(_) => (String::from("Requires authentication"), 401),
            ProjectsRemoveCollaboratorError::Generic { code } => (String::from("Generic"), code)
        };

        Self::Endpoint {
            description,
            status_code,
            source: Some(Box::new(err))
        }
    }
}

/// Errors for the [Update a project](Projects::update_async()) endpoint.
#[derive(Debug, thiserror::Error)]
pub enum ProjectsUpdateError {
    #[error("Not Found if the authenticated user does not have access to the project")]
    Status404,
    #[error("Not modified")]
    Status304,
    #[error("Forbidden")]
    Status403(PatchProjectsUpdateResponse403),
    #[error("Requires authentication")]
    Status401(BasicError),
    #[error("Gone")]
    Status410(BasicError),
    #[error("Validation failed, or the endpoint has been spammed.")]
    Status422(ValidationErrorSimple),
    #[error("Status code: {}", code)]
    Generic { code: u16 },
}

impl From<ProjectsUpdateError> for AdapterError {
    fn from(err: ProjectsUpdateError) -> Self {
        let (description, status_code) = match err {
            ProjectsUpdateError::Status404 => (String::from("Not Found if the authenticated user does not have access to the project"), 404),
            ProjectsUpdateError::Status304 => (String::from("Not modified"), 304),
            ProjectsUpdateError::Status403(_) => (String::from("Forbidden"), 403),
            ProjectsUpdateError::Status401(_) => (String::from("Requires authentication"), 401),
            ProjectsUpdateError::Status410(_) => (String::from("Gone"), 410),
            ProjectsUpdateError::Status422(_) => (String::from("Validation failed, or the endpoint has been spammed."), 422),
            ProjectsUpdateError::Generic { code } => (String::from("Generic"), code)
        };

        Self::Endpoint {
            description,
            status_code,
            source: Some(Box::new(err))
        }
    }
}

/// Errors for the [Update an existing project card](Projects::update_card_async()) endpoint.
#[derive(Debug, thiserror::Error)]
pub enum ProjectsUpdateCardError {
    #[error("Not modified")]
    Status304,
    #[error("Forbidden")]
    Status403(BasicError),
    #[error("Requires authentication")]
    Status401(BasicError),
    #[error("Resource not found")]
    Status404(BasicError),
    #[error("Validation failed, or the endpoint has been spammed.")]
    Status422(ValidationErrorSimple),
    #[error("Status code: {}", code)]
    Generic { code: u16 },
}

impl From<ProjectsUpdateCardError> for AdapterError {
    fn from(err: ProjectsUpdateCardError) -> Self {
        let (description, status_code) = match err {
            ProjectsUpdateCardError::Status304 => (String::from("Not modified"), 304),
            ProjectsUpdateCardError::Status403(_) => (String::from("Forbidden"), 403),
            ProjectsUpdateCardError::Status401(_) => (String::from("Requires authentication"), 401),
            ProjectsUpdateCardError::Status404(_) => (String::from("Resource not found"), 404),
            ProjectsUpdateCardError::Status422(_) => (String::from("Validation failed, or the endpoint has been spammed."), 422),
            ProjectsUpdateCardError::Generic { code } => (String::from("Generic"), code)
        };

        Self::Endpoint {
            description,
            status_code,
            source: Some(Box::new(err))
        }
    }
}

/// Errors for the [Update an existing project column](Projects::update_column_async()) endpoint.
#[derive(Debug, thiserror::Error)]
pub enum ProjectsUpdateColumnError {
    #[error("Not modified")]
    Status304,
    #[error("Forbidden")]
    Status403(BasicError),
    #[error("Requires authentication")]
    Status401(BasicError),
    #[error("Status code: {}", code)]
    Generic { code: u16 },
}

impl From<ProjectsUpdateColumnError> for AdapterError {
    fn from(err: ProjectsUpdateColumnError) -> Self {
        let (description, status_code) = match err {
            ProjectsUpdateColumnError::Status304 => (String::from("Not modified"), 304),
            ProjectsUpdateColumnError::Status403(_) => (String::from("Forbidden"), 403),
            ProjectsUpdateColumnError::Status401(_) => (String::from("Requires authentication"), 401),
            ProjectsUpdateColumnError::Generic { code } => (String::from("Generic"), code)
        };

        Self::Endpoint {
            description,
            status_code,
            source: Some(Box::new(err))
        }
    }
}


/// Query parameters for the [List project cards](Projects::list_cards_async()) endpoint.
#[derive(Default, Serialize)]
pub struct ProjectsListCardsParams<'req> {
    /// Filters the project cards that are returned by the card's state.
    archived_state: Option<&'req str>, 
    /// The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    per_page: Option<u16>, 
    /// The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    page: Option<u16>
}

impl<'req> ProjectsListCardsParams<'req> {
    pub fn new() -> Self {
        Self::default()
    }

    /// Filters the project cards that are returned by the card's state.
    pub fn archived_state(self, archived_state: &'req str) -> Self {
        Self {
            archived_state: Some(archived_state),
            per_page: self.per_page, 
            page: self.page, 
        }
    }

    /// The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    pub fn per_page(self, per_page: u16) -> Self {
        Self {
            archived_state: self.archived_state, 
            per_page: Some(per_page),
            page: self.page, 
        }
    }

    /// The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    pub fn page(self, page: u16) -> Self {
        Self {
            archived_state: self.archived_state, 
            per_page: self.per_page, 
            page: Some(page),
        }
    }
}

impl<'enc> From<&'enc PerPage> for ProjectsListCardsParams<'enc> {
    fn from(per_page: &'enc PerPage) -> Self {
        Self {
            per_page: Some(per_page.per_page),
            page: Some(per_page.page),
            ..Default::default()
        }
    }
}
/// Query parameters for the [List project collaborators](Projects::list_collaborators_async()) endpoint.
#[derive(Default, Serialize)]
pub struct ProjectsListCollaboratorsParams<'req> {
    /// Filters the collaborators by their affiliation. `outside` means outside collaborators of a project that are not a member of the project's organization. `direct` means collaborators with permissions to a project, regardless of organization membership status. `all` means all collaborators the authenticated user can see.
    affiliation: Option<&'req str>, 
    /// The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    per_page: Option<u16>, 
    /// The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    page: Option<u16>
}

impl<'req> ProjectsListCollaboratorsParams<'req> {
    pub fn new() -> Self {
        Self::default()
    }

    /// Filters the collaborators by their affiliation. `outside` means outside collaborators of a project that are not a member of the project's organization. `direct` means collaborators with permissions to a project, regardless of organization membership status. `all` means all collaborators the authenticated user can see.
    pub fn affiliation(self, affiliation: &'req str) -> Self {
        Self {
            affiliation: Some(affiliation),
            per_page: self.per_page, 
            page: self.page, 
        }
    }

    /// The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    pub fn per_page(self, per_page: u16) -> Self {
        Self {
            affiliation: self.affiliation, 
            per_page: Some(per_page),
            page: self.page, 
        }
    }

    /// The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    pub fn page(self, page: u16) -> Self {
        Self {
            affiliation: self.affiliation, 
            per_page: self.per_page, 
            page: Some(page),
        }
    }
}

impl<'enc> From<&'enc PerPage> for ProjectsListCollaboratorsParams<'enc> {
    fn from(per_page: &'enc PerPage) -> Self {
        Self {
            per_page: Some(per_page.per_page),
            page: Some(per_page.page),
            ..Default::default()
        }
    }
}
/// Query parameters for the [List project columns](Projects::list_columns_async()) endpoint.
#[derive(Default, Serialize)]
pub struct ProjectsListColumnsParams {
    /// The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    per_page: Option<u16>, 
    /// The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    page: Option<u16>
}

impl ProjectsListColumnsParams {
    pub fn new() -> Self {
        Self::default()
    }

    /// The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    pub fn per_page(self, per_page: u16) -> Self {
        Self {
            per_page: Some(per_page),
            page: self.page, 
        }
    }

    /// The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    pub fn page(self, page: u16) -> Self {
        Self {
            per_page: self.per_page, 
            page: Some(page),
        }
    }
}

impl<'enc> From<&'enc PerPage> for ProjectsListColumnsParams {
    fn from(per_page: &'enc PerPage) -> Self {
        Self {
            per_page: Some(per_page.per_page),
            page: Some(per_page.page),
            ..Default::default()
        }
    }
}
/// Query parameters for the [List organization projects](Projects::list_for_org_async()) endpoint.
#[derive(Default, Serialize)]
pub struct ProjectsListForOrgParams<'req> {
    /// Indicates the state of the projects to return.
    state: Option<&'req str>, 
    /// The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    per_page: Option<u16>, 
    /// The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    page: Option<u16>
}

impl<'req> ProjectsListForOrgParams<'req> {
    pub fn new() -> Self {
        Self::default()
    }

    /// Indicates the state of the projects to return.
    pub fn state(self, state: &'req str) -> Self {
        Self {
            state: Some(state),
            per_page: self.per_page, 
            page: self.page, 
        }
    }

    /// The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    pub fn per_page(self, per_page: u16) -> Self {
        Self {
            state: self.state, 
            per_page: Some(per_page),
            page: self.page, 
        }
    }

    /// The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    pub fn page(self, page: u16) -> Self {
        Self {
            state: self.state, 
            per_page: self.per_page, 
            page: Some(page),
        }
    }
}

impl<'enc> From<&'enc PerPage> for ProjectsListForOrgParams<'enc> {
    fn from(per_page: &'enc PerPage) -> Self {
        Self {
            per_page: Some(per_page.per_page),
            page: Some(per_page.page),
            ..Default::default()
        }
    }
}
/// Query parameters for the [List repository projects](Projects::list_for_repo_async()) endpoint.
#[derive(Default, Serialize)]
pub struct ProjectsListForRepoParams<'req> {
    /// Indicates the state of the projects to return.
    state: Option<&'req str>, 
    /// The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    per_page: Option<u16>, 
    /// The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    page: Option<u16>
}

impl<'req> ProjectsListForRepoParams<'req> {
    pub fn new() -> Self {
        Self::default()
    }

    /// Indicates the state of the projects to return.
    pub fn state(self, state: &'req str) -> Self {
        Self {
            state: Some(state),
            per_page: self.per_page, 
            page: self.page, 
        }
    }

    /// The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    pub fn per_page(self, per_page: u16) -> Self {
        Self {
            state: self.state, 
            per_page: Some(per_page),
            page: self.page, 
        }
    }

    /// The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    pub fn page(self, page: u16) -> Self {
        Self {
            state: self.state, 
            per_page: self.per_page, 
            page: Some(page),
        }
    }
}

impl<'enc> From<&'enc PerPage> for ProjectsListForRepoParams<'enc> {
    fn from(per_page: &'enc PerPage) -> Self {
        Self {
            per_page: Some(per_page.per_page),
            page: Some(per_page.page),
            ..Default::default()
        }
    }
}
/// Query parameters for the [List user projects](Projects::list_for_user_async()) endpoint.
#[derive(Default, Serialize)]
pub struct ProjectsListForUserParams<'req> {
    /// Indicates the state of the projects to return.
    state: Option<&'req str>, 
    /// The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    per_page: Option<u16>, 
    /// The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    page: Option<u16>
}

impl<'req> ProjectsListForUserParams<'req> {
    pub fn new() -> Self {
        Self::default()
    }

    /// Indicates the state of the projects to return.
    pub fn state(self, state: &'req str) -> Self {
        Self {
            state: Some(state),
            per_page: self.per_page, 
            page: self.page, 
        }
    }

    /// The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    pub fn per_page(self, per_page: u16) -> Self {
        Self {
            state: self.state, 
            per_page: Some(per_page),
            page: self.page, 
        }
    }

    /// The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    pub fn page(self, page: u16) -> Self {
        Self {
            state: self.state, 
            per_page: self.per_page, 
            page: Some(page),
        }
    }
}

impl<'enc> From<&'enc PerPage> for ProjectsListForUserParams<'enc> {
    fn from(per_page: &'enc PerPage) -> Self {
        Self {
            per_page: Some(per_page.per_page),
            page: Some(per_page.page),
            ..Default::default()
        }
    }
}

impl<'api, C: Client> Projects<'api, C> where AdapterError: From<<C as Client>::Err> {
    /// ---
    ///
    /// # Add project collaborator
    ///
    /// Adds a collaborator to an organization project and sets their permission level. You must be an organization owner or a project `admin` to add a collaborator.
    ///
    /// [GitHub API docs for add_collaborator](https://docs.github.com/rest/projects/collaborators#add-project-collaborator)
    ///
    /// ---
    pub async fn add_collaborator_async(&self, project_id: i32, username: &str, body: PutProjectsAddCollaborator) -> Result<(), AdapterError> {

        let request_uri = format!("{}/projects/{}/collaborators/{}", super::GITHUB_BASE_API_URL, project_id, username);


        let req = GitHubRequest {
            uri: request_uri,
            body: Some(C::from_json::<PutProjectsAddCollaborator>(body)?),
            method: "PUT",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch_async(request).await?;

        // --

        if github_response.is_success() {
            Ok(())
        } else {
            match github_response.status_code() {
                404 => Err(ProjectsAddCollaboratorError::Status404(github_response.to_json_async().await?).into()),
                422 => Err(ProjectsAddCollaboratorError::Status422(github_response.to_json_async().await?).into()),
                304 => Err(ProjectsAddCollaboratorError::Status304.into()),
                403 => Err(ProjectsAddCollaboratorError::Status403(github_response.to_json_async().await?).into()),
                401 => Err(ProjectsAddCollaboratorError::Status401(github_response.to_json_async().await?).into()),
                code => Err(ProjectsAddCollaboratorError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # Add project collaborator
    ///
    /// Adds a collaborator to an organization project and sets their permission level. You must be an organization owner or a project `admin` to add a collaborator.
    ///
    /// [GitHub API docs for add_collaborator](https://docs.github.com/rest/projects/collaborators#add-project-collaborator)
    ///
    /// ---
    #[cfg(not(target_arch = "wasm32"))]
    pub fn add_collaborator(&self, project_id: i32, username: &str, body: PutProjectsAddCollaborator) -> Result<(), AdapterError> {

        let request_uri = format!("{}/projects/{}/collaborators/{}", super::GITHUB_BASE_API_URL, project_id, username);


        let req = GitHubRequest {
            uri: request_uri,
            body: Some(C::from_json::<PutProjectsAddCollaborator>(body)?),
            method: "PUT",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch(request)?;

        // --

        if github_response.is_success() {
            Ok(())
        } else {
            match github_response.status_code() {
                404 => Err(ProjectsAddCollaboratorError::Status404(github_response.to_json()?).into()),
                422 => Err(ProjectsAddCollaboratorError::Status422(github_response.to_json()?).into()),
                304 => Err(ProjectsAddCollaboratorError::Status304.into()),
                403 => Err(ProjectsAddCollaboratorError::Status403(github_response.to_json()?).into()),
                401 => Err(ProjectsAddCollaboratorError::Status401(github_response.to_json()?).into()),
                code => Err(ProjectsAddCollaboratorError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # Create a project card
    ///
    /// [GitHub API docs for create_card](https://docs.github.com/rest/projects/cards#create-a-project-card)
    ///
    /// ---
    pub async fn create_card_async(&self, column_id: i32, body: PostProjectsCreateCard) -> Result<ProjectCard, AdapterError> {

        let request_uri = format!("{}/projects/columns/{}/cards", super::GITHUB_BASE_API_URL, column_id);


        let req = GitHubRequest {
            uri: request_uri,
            body: Some(C::from_json::<PostProjectsCreateCard>(body)?),
            method: "POST",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch_async(request).await?;

        // --

        if github_response.is_success() {
            Ok(github_response.to_json_async().await?)
        } else {
            match github_response.status_code() {
                304 => Err(ProjectsCreateCardError::Status304.into()),
                403 => Err(ProjectsCreateCardError::Status403(github_response.to_json_async().await?).into()),
                401 => Err(ProjectsCreateCardError::Status401(github_response.to_json_async().await?).into()),
                422 => Err(ProjectsCreateCardError::Status422(github_response.to_json_async().await?).into()),
                503 => Err(ProjectsCreateCardError::Status503(github_response.to_json_async().await?).into()),
                code => Err(ProjectsCreateCardError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # Create a project card
    ///
    /// [GitHub API docs for create_card](https://docs.github.com/rest/projects/cards#create-a-project-card)
    ///
    /// ---
    #[cfg(not(target_arch = "wasm32"))]
    pub fn create_card(&self, column_id: i32, body: PostProjectsCreateCard) -> Result<ProjectCard, AdapterError> {

        let request_uri = format!("{}/projects/columns/{}/cards", super::GITHUB_BASE_API_URL, column_id);


        let req = GitHubRequest {
            uri: request_uri,
            body: Some(C::from_json::<PostProjectsCreateCard>(body)?),
            method: "POST",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch(request)?;

        // --

        if github_response.is_success() {
            Ok(github_response.to_json()?)
        } else {
            match github_response.status_code() {
                304 => Err(ProjectsCreateCardError::Status304.into()),
                403 => Err(ProjectsCreateCardError::Status403(github_response.to_json()?).into()),
                401 => Err(ProjectsCreateCardError::Status401(github_response.to_json()?).into()),
                422 => Err(ProjectsCreateCardError::Status422(github_response.to_json()?).into()),
                503 => Err(ProjectsCreateCardError::Status503(github_response.to_json()?).into()),
                code => Err(ProjectsCreateCardError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # Create a project column
    ///
    /// Creates a new project column.
    ///
    /// [GitHub API docs for create_column](https://docs.github.com/rest/projects/columns#create-a-project-column)
    ///
    /// ---
    pub async fn create_column_async(&self, project_id: i32, body: PostProjectsCreateColumn) -> Result<ProjectColumn, AdapterError> {

        let request_uri = format!("{}/projects/{}/columns", super::GITHUB_BASE_API_URL, project_id);


        let req = GitHubRequest {
            uri: request_uri,
            body: Some(C::from_json::<PostProjectsCreateColumn>(body)?),
            method: "POST",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch_async(request).await?;

        // --

        if github_response.is_success() {
            Ok(github_response.to_json_async().await?)
        } else {
            match github_response.status_code() {
                304 => Err(ProjectsCreateColumnError::Status304.into()),
                403 => Err(ProjectsCreateColumnError::Status403(github_response.to_json_async().await?).into()),
                422 => Err(ProjectsCreateColumnError::Status422(github_response.to_json_async().await?).into()),
                401 => Err(ProjectsCreateColumnError::Status401(github_response.to_json_async().await?).into()),
                code => Err(ProjectsCreateColumnError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # Create a project column
    ///
    /// Creates a new project column.
    ///
    /// [GitHub API docs for create_column](https://docs.github.com/rest/projects/columns#create-a-project-column)
    ///
    /// ---
    #[cfg(not(target_arch = "wasm32"))]
    pub fn create_column(&self, project_id: i32, body: PostProjectsCreateColumn) -> Result<ProjectColumn, AdapterError> {

        let request_uri = format!("{}/projects/{}/columns", super::GITHUB_BASE_API_URL, project_id);


        let req = GitHubRequest {
            uri: request_uri,
            body: Some(C::from_json::<PostProjectsCreateColumn>(body)?),
            method: "POST",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch(request)?;

        // --

        if github_response.is_success() {
            Ok(github_response.to_json()?)
        } else {
            match github_response.status_code() {
                304 => Err(ProjectsCreateColumnError::Status304.into()),
                403 => Err(ProjectsCreateColumnError::Status403(github_response.to_json()?).into()),
                422 => Err(ProjectsCreateColumnError::Status422(github_response.to_json()?).into()),
                401 => Err(ProjectsCreateColumnError::Status401(github_response.to_json()?).into()),
                code => Err(ProjectsCreateColumnError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # Create a user project
    ///
    /// Creates a user project board. Returns a `410 Gone` status if the user does not have existing classic projects. If you do not have sufficient privileges to perform this action, a `401 Unauthorized` or `410 Gone` status is returned.
    ///
    /// [GitHub API docs for create_for_authenticated_user](https://docs.github.com/rest/projects/projects#create-a-user-project)
    ///
    /// ---
    pub async fn create_for_authenticated_user_async(&self, body: PostProjectsCreateForAuthenticatedUser) -> Result<Project, AdapterError> {

        let request_uri = format!("{}/user/projects", super::GITHUB_BASE_API_URL);


        let req = GitHubRequest {
            uri: request_uri,
            body: Some(C::from_json::<PostProjectsCreateForAuthenticatedUser>(body)?),
            method: "POST",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch_async(request).await?;

        // --

        if github_response.is_success() {
            Ok(github_response.to_json_async().await?)
        } else {
            match github_response.status_code() {
                304 => Err(ProjectsCreateForAuthenticatedUserError::Status304.into()),
                403 => Err(ProjectsCreateForAuthenticatedUserError::Status403(github_response.to_json_async().await?).into()),
                401 => Err(ProjectsCreateForAuthenticatedUserError::Status401(github_response.to_json_async().await?).into()),
                422 => Err(ProjectsCreateForAuthenticatedUserError::Status422(github_response.to_json_async().await?).into()),
                code => Err(ProjectsCreateForAuthenticatedUserError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # Create a user project
    ///
    /// Creates a user project board. Returns a `410 Gone` status if the user does not have existing classic projects. If you do not have sufficient privileges to perform this action, a `401 Unauthorized` or `410 Gone` status is returned.
    ///
    /// [GitHub API docs for create_for_authenticated_user](https://docs.github.com/rest/projects/projects#create-a-user-project)
    ///
    /// ---
    #[cfg(not(target_arch = "wasm32"))]
    pub fn create_for_authenticated_user(&self, body: PostProjectsCreateForAuthenticatedUser) -> Result<Project, AdapterError> {

        let request_uri = format!("{}/user/projects", super::GITHUB_BASE_API_URL);


        let req = GitHubRequest {
            uri: request_uri,
            body: Some(C::from_json::<PostProjectsCreateForAuthenticatedUser>(body)?),
            method: "POST",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch(request)?;

        // --

        if github_response.is_success() {
            Ok(github_response.to_json()?)
        } else {
            match github_response.status_code() {
                304 => Err(ProjectsCreateForAuthenticatedUserError::Status304.into()),
                403 => Err(ProjectsCreateForAuthenticatedUserError::Status403(github_response.to_json()?).into()),
                401 => Err(ProjectsCreateForAuthenticatedUserError::Status401(github_response.to_json()?).into()),
                422 => Err(ProjectsCreateForAuthenticatedUserError::Status422(github_response.to_json()?).into()),
                code => Err(ProjectsCreateForAuthenticatedUserError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # Create an organization project
    ///
    /// Creates an organization project board. Returns a `410 Gone` status if projects are disabled in the organization or if the organization does not have existing classic projects. If you do not have sufficient privileges to perform this action, a `401 Unauthorized` or `410 Gone` status is returned.
    ///
    /// [GitHub API docs for create_for_org](https://docs.github.com/rest/projects/projects#create-an-organization-project)
    ///
    /// ---
    pub async fn create_for_org_async(&self, org: &str, body: PostProjectsCreateForOrg) -> Result<Project, AdapterError> {

        let request_uri = format!("{}/orgs/{}/projects", super::GITHUB_BASE_API_URL, org);


        let req = GitHubRequest {
            uri: request_uri,
            body: Some(C::from_json::<PostProjectsCreateForOrg>(body)?),
            method: "POST",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch_async(request).await?;

        // --

        if github_response.is_success() {
            Ok(github_response.to_json_async().await?)
        } else {
            match github_response.status_code() {
                401 => Err(ProjectsCreateForOrgError::Status401(github_response.to_json_async().await?).into()),
                403 => Err(ProjectsCreateForOrgError::Status403(github_response.to_json_async().await?).into()),
                404 => Err(ProjectsCreateForOrgError::Status404(github_response.to_json_async().await?).into()),
                410 => Err(ProjectsCreateForOrgError::Status410(github_response.to_json_async().await?).into()),
                422 => Err(ProjectsCreateForOrgError::Status422(github_response.to_json_async().await?).into()),
                code => Err(ProjectsCreateForOrgError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # Create an organization project
    ///
    /// Creates an organization project board. Returns a `410 Gone` status if projects are disabled in the organization or if the organization does not have existing classic projects. If you do not have sufficient privileges to perform this action, a `401 Unauthorized` or `410 Gone` status is returned.
    ///
    /// [GitHub API docs for create_for_org](https://docs.github.com/rest/projects/projects#create-an-organization-project)
    ///
    /// ---
    #[cfg(not(target_arch = "wasm32"))]
    pub fn create_for_org(&self, org: &str, body: PostProjectsCreateForOrg) -> Result<Project, AdapterError> {

        let request_uri = format!("{}/orgs/{}/projects", super::GITHUB_BASE_API_URL, org);


        let req = GitHubRequest {
            uri: request_uri,
            body: Some(C::from_json::<PostProjectsCreateForOrg>(body)?),
            method: "POST",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch(request)?;

        // --

        if github_response.is_success() {
            Ok(github_response.to_json()?)
        } else {
            match github_response.status_code() {
                401 => Err(ProjectsCreateForOrgError::Status401(github_response.to_json()?).into()),
                403 => Err(ProjectsCreateForOrgError::Status403(github_response.to_json()?).into()),
                404 => Err(ProjectsCreateForOrgError::Status404(github_response.to_json()?).into()),
                410 => Err(ProjectsCreateForOrgError::Status410(github_response.to_json()?).into()),
                422 => Err(ProjectsCreateForOrgError::Status422(github_response.to_json()?).into()),
                code => Err(ProjectsCreateForOrgError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # Create a repository project
    ///
    /// Creates a repository project board. Returns a `410 Gone` status if projects are disabled in the repository or if the repository does not have existing classic projects. If you do not have sufficient privileges to perform this action, a `401 Unauthorized` or `410 Gone` status is returned.
    ///
    /// [GitHub API docs for create_for_repo](https://docs.github.com/rest/projects/projects#create-a-repository-project)
    ///
    /// ---
    pub async fn create_for_repo_async(&self, owner: &str, repo: &str, body: PostProjectsCreateForRepo) -> Result<Project, AdapterError> {

        let request_uri = format!("{}/repos/{}/{}/projects", super::GITHUB_BASE_API_URL, owner, repo);


        let req = GitHubRequest {
            uri: request_uri,
            body: Some(C::from_json::<PostProjectsCreateForRepo>(body)?),
            method: "POST",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch_async(request).await?;

        // --

        if github_response.is_success() {
            Ok(github_response.to_json_async().await?)
        } else {
            match github_response.status_code() {
                401 => Err(ProjectsCreateForRepoError::Status401(github_response.to_json_async().await?).into()),
                403 => Err(ProjectsCreateForRepoError::Status403(github_response.to_json_async().await?).into()),
                404 => Err(ProjectsCreateForRepoError::Status404(github_response.to_json_async().await?).into()),
                410 => Err(ProjectsCreateForRepoError::Status410(github_response.to_json_async().await?).into()),
                422 => Err(ProjectsCreateForRepoError::Status422(github_response.to_json_async().await?).into()),
                code => Err(ProjectsCreateForRepoError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # Create a repository project
    ///
    /// Creates a repository project board. Returns a `410 Gone` status if projects are disabled in the repository or if the repository does not have existing classic projects. If you do not have sufficient privileges to perform this action, a `401 Unauthorized` or `410 Gone` status is returned.
    ///
    /// [GitHub API docs for create_for_repo](https://docs.github.com/rest/projects/projects#create-a-repository-project)
    ///
    /// ---
    #[cfg(not(target_arch = "wasm32"))]
    pub fn create_for_repo(&self, owner: &str, repo: &str, body: PostProjectsCreateForRepo) -> Result<Project, AdapterError> {

        let request_uri = format!("{}/repos/{}/{}/projects", super::GITHUB_BASE_API_URL, owner, repo);


        let req = GitHubRequest {
            uri: request_uri,
            body: Some(C::from_json::<PostProjectsCreateForRepo>(body)?),
            method: "POST",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch(request)?;

        // --

        if github_response.is_success() {
            Ok(github_response.to_json()?)
        } else {
            match github_response.status_code() {
                401 => Err(ProjectsCreateForRepoError::Status401(github_response.to_json()?).into()),
                403 => Err(ProjectsCreateForRepoError::Status403(github_response.to_json()?).into()),
                404 => Err(ProjectsCreateForRepoError::Status404(github_response.to_json()?).into()),
                410 => Err(ProjectsCreateForRepoError::Status410(github_response.to_json()?).into()),
                422 => Err(ProjectsCreateForRepoError::Status422(github_response.to_json()?).into()),
                code => Err(ProjectsCreateForRepoError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # Delete a project
    ///
    /// Deletes a project board. Returns a `404 Not Found` status if projects are disabled.
    ///
    /// [GitHub API docs for delete](https://docs.github.com/rest/projects/projects#delete-a-project)
    ///
    /// ---
    pub async fn delete_async(&self, project_id: i32) -> Result<(), AdapterError> {

        let request_uri = format!("{}/projects/{}", super::GITHUB_BASE_API_URL, project_id);


        let req = GitHubRequest {
            uri: request_uri,
            body: None::<C::Body>,
            method: "DELETE",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch_async(request).await?;

        // --

        if github_response.is_success() {
            Ok(())
        } else {
            match github_response.status_code() {
                304 => Err(ProjectsDeleteError::Status304.into()),
                403 => Err(ProjectsDeleteError::Status403(github_response.to_json_async().await?).into()),
                401 => Err(ProjectsDeleteError::Status401(github_response.to_json_async().await?).into()),
                410 => Err(ProjectsDeleteError::Status410(github_response.to_json_async().await?).into()),
                404 => Err(ProjectsDeleteError::Status404(github_response.to_json_async().await?).into()),
                code => Err(ProjectsDeleteError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # Delete a project
    ///
    /// Deletes a project board. Returns a `404 Not Found` status if projects are disabled.
    ///
    /// [GitHub API docs for delete](https://docs.github.com/rest/projects/projects#delete-a-project)
    ///
    /// ---
    #[cfg(not(target_arch = "wasm32"))]
    pub fn delete(&self, project_id: i32) -> Result<(), AdapterError> {

        let request_uri = format!("{}/projects/{}", super::GITHUB_BASE_API_URL, project_id);


        let req = GitHubRequest {
            uri: request_uri,
            body: None,
            method: "DELETE",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch(request)?;

        // --

        if github_response.is_success() {
            Ok(())
        } else {
            match github_response.status_code() {
                304 => Err(ProjectsDeleteError::Status304.into()),
                403 => Err(ProjectsDeleteError::Status403(github_response.to_json()?).into()),
                401 => Err(ProjectsDeleteError::Status401(github_response.to_json()?).into()),
                410 => Err(ProjectsDeleteError::Status410(github_response.to_json()?).into()),
                404 => Err(ProjectsDeleteError::Status404(github_response.to_json()?).into()),
                code => Err(ProjectsDeleteError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # Delete a project card
    ///
    /// Deletes a project card
    ///
    /// [GitHub API docs for delete_card](https://docs.github.com/rest/projects/cards#delete-a-project-card)
    ///
    /// ---
    pub async fn delete_card_async(&self, card_id: i32) -> Result<(), AdapterError> {

        let request_uri = format!("{}/projects/columns/cards/{}", super::GITHUB_BASE_API_URL, card_id);


        let req = GitHubRequest {
            uri: request_uri,
            body: None::<C::Body>,
            method: "DELETE",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch_async(request).await?;

        // --

        if github_response.is_success() {
            Ok(())
        } else {
            match github_response.status_code() {
                304 => Err(ProjectsDeleteCardError::Status304.into()),
                403 => Err(ProjectsDeleteCardError::Status403(github_response.to_json_async().await?).into()),
                401 => Err(ProjectsDeleteCardError::Status401(github_response.to_json_async().await?).into()),
                404 => Err(ProjectsDeleteCardError::Status404(github_response.to_json_async().await?).into()),
                code => Err(ProjectsDeleteCardError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # Delete a project card
    ///
    /// Deletes a project card
    ///
    /// [GitHub API docs for delete_card](https://docs.github.com/rest/projects/cards#delete-a-project-card)
    ///
    /// ---
    #[cfg(not(target_arch = "wasm32"))]
    pub fn delete_card(&self, card_id: i32) -> Result<(), AdapterError> {

        let request_uri = format!("{}/projects/columns/cards/{}", super::GITHUB_BASE_API_URL, card_id);


        let req = GitHubRequest {
            uri: request_uri,
            body: None,
            method: "DELETE",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch(request)?;

        // --

        if github_response.is_success() {
            Ok(())
        } else {
            match github_response.status_code() {
                304 => Err(ProjectsDeleteCardError::Status304.into()),
                403 => Err(ProjectsDeleteCardError::Status403(github_response.to_json()?).into()),
                401 => Err(ProjectsDeleteCardError::Status401(github_response.to_json()?).into()),
                404 => Err(ProjectsDeleteCardError::Status404(github_response.to_json()?).into()),
                code => Err(ProjectsDeleteCardError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # Delete a project column
    ///
    /// Deletes a project column.
    ///
    /// [GitHub API docs for delete_column](https://docs.github.com/rest/projects/columns#delete-a-project-column)
    ///
    /// ---
    pub async fn delete_column_async(&self, column_id: i32) -> Result<(), AdapterError> {

        let request_uri = format!("{}/projects/columns/{}", super::GITHUB_BASE_API_URL, column_id);


        let req = GitHubRequest {
            uri: request_uri,
            body: None::<C::Body>,
            method: "DELETE",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch_async(request).await?;

        // --

        if github_response.is_success() {
            Ok(())
        } else {
            match github_response.status_code() {
                304 => Err(ProjectsDeleteColumnError::Status304.into()),
                403 => Err(ProjectsDeleteColumnError::Status403(github_response.to_json_async().await?).into()),
                401 => Err(ProjectsDeleteColumnError::Status401(github_response.to_json_async().await?).into()),
                code => Err(ProjectsDeleteColumnError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # Delete a project column
    ///
    /// Deletes a project column.
    ///
    /// [GitHub API docs for delete_column](https://docs.github.com/rest/projects/columns#delete-a-project-column)
    ///
    /// ---
    #[cfg(not(target_arch = "wasm32"))]
    pub fn delete_column(&self, column_id: i32) -> Result<(), AdapterError> {

        let request_uri = format!("{}/projects/columns/{}", super::GITHUB_BASE_API_URL, column_id);


        let req = GitHubRequest {
            uri: request_uri,
            body: None,
            method: "DELETE",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch(request)?;

        // --

        if github_response.is_success() {
            Ok(())
        } else {
            match github_response.status_code() {
                304 => Err(ProjectsDeleteColumnError::Status304.into()),
                403 => Err(ProjectsDeleteColumnError::Status403(github_response.to_json()?).into()),
                401 => Err(ProjectsDeleteColumnError::Status401(github_response.to_json()?).into()),
                code => Err(ProjectsDeleteColumnError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # Get a project
    ///
    /// Gets a project by its `id`. Returns a `404 Not Found` status if projects are disabled. If you do not have sufficient privileges to perform this action, a `401 Unauthorized` or `410 Gone` status is returned.
    ///
    /// [GitHub API docs for get](https://docs.github.com/rest/projects/projects#get-a-project)
    ///
    /// ---
    pub async fn get_async(&self, project_id: i32) -> Result<Project, AdapterError> {

        let request_uri = format!("{}/projects/{}", super::GITHUB_BASE_API_URL, project_id);


        let req = GitHubRequest {
            uri: request_uri,
            body: None::<C::Body>,
            method: "GET",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch_async(request).await?;

        // --

        if github_response.is_success() {
            Ok(github_response.to_json_async().await?)
        } else {
            match github_response.status_code() {
                304 => Err(ProjectsGetError::Status304.into()),
                403 => Err(ProjectsGetError::Status403(github_response.to_json_async().await?).into()),
                401 => Err(ProjectsGetError::Status401(github_response.to_json_async().await?).into()),
                code => Err(ProjectsGetError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # Get a project
    ///
    /// Gets a project by its `id`. Returns a `404 Not Found` status if projects are disabled. If you do not have sufficient privileges to perform this action, a `401 Unauthorized` or `410 Gone` status is returned.
    ///
    /// [GitHub API docs for get](https://docs.github.com/rest/projects/projects#get-a-project)
    ///
    /// ---
    #[cfg(not(target_arch = "wasm32"))]
    pub fn get(&self, project_id: i32) -> Result<Project, AdapterError> {

        let request_uri = format!("{}/projects/{}", super::GITHUB_BASE_API_URL, project_id);


        let req = GitHubRequest {
            uri: request_uri,
            body: None,
            method: "GET",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch(request)?;

        // --

        if github_response.is_success() {
            Ok(github_response.to_json()?)
        } else {
            match github_response.status_code() {
                304 => Err(ProjectsGetError::Status304.into()),
                403 => Err(ProjectsGetError::Status403(github_response.to_json()?).into()),
                401 => Err(ProjectsGetError::Status401(github_response.to_json()?).into()),
                code => Err(ProjectsGetError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # Get a project card
    ///
    /// Gets information about a project card.
    ///
    /// [GitHub API docs for get_card](https://docs.github.com/rest/projects/cards#get-a-project-card)
    ///
    /// ---
    pub async fn get_card_async(&self, card_id: i32) -> Result<ProjectCard, AdapterError> {

        let request_uri = format!("{}/projects/columns/cards/{}", super::GITHUB_BASE_API_URL, card_id);


        let req = GitHubRequest {
            uri: request_uri,
            body: None::<C::Body>,
            method: "GET",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch_async(request).await?;

        // --

        if github_response.is_success() {
            Ok(github_response.to_json_async().await?)
        } else {
            match github_response.status_code() {
                304 => Err(ProjectsGetCardError::Status304.into()),
                403 => Err(ProjectsGetCardError::Status403(github_response.to_json_async().await?).into()),
                401 => Err(ProjectsGetCardError::Status401(github_response.to_json_async().await?).into()),
                404 => Err(ProjectsGetCardError::Status404(github_response.to_json_async().await?).into()),
                code => Err(ProjectsGetCardError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # Get a project card
    ///
    /// Gets information about a project card.
    ///
    /// [GitHub API docs for get_card](https://docs.github.com/rest/projects/cards#get-a-project-card)
    ///
    /// ---
    #[cfg(not(target_arch = "wasm32"))]
    pub fn get_card(&self, card_id: i32) -> Result<ProjectCard, AdapterError> {

        let request_uri = format!("{}/projects/columns/cards/{}", super::GITHUB_BASE_API_URL, card_id);


        let req = GitHubRequest {
            uri: request_uri,
            body: None,
            method: "GET",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch(request)?;

        // --

        if github_response.is_success() {
            Ok(github_response.to_json()?)
        } else {
            match github_response.status_code() {
                304 => Err(ProjectsGetCardError::Status304.into()),
                403 => Err(ProjectsGetCardError::Status403(github_response.to_json()?).into()),
                401 => Err(ProjectsGetCardError::Status401(github_response.to_json()?).into()),
                404 => Err(ProjectsGetCardError::Status404(github_response.to_json()?).into()),
                code => Err(ProjectsGetCardError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # Get a project column
    ///
    /// Gets information about a project column.
    ///
    /// [GitHub API docs for get_column](https://docs.github.com/rest/projects/columns#get-a-project-column)
    ///
    /// ---
    pub async fn get_column_async(&self, column_id: i32) -> Result<ProjectColumn, AdapterError> {

        let request_uri = format!("{}/projects/columns/{}", super::GITHUB_BASE_API_URL, column_id);


        let req = GitHubRequest {
            uri: request_uri,
            body: None::<C::Body>,
            method: "GET",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch_async(request).await?;

        // --

        if github_response.is_success() {
            Ok(github_response.to_json_async().await?)
        } else {
            match github_response.status_code() {
                304 => Err(ProjectsGetColumnError::Status304.into()),
                403 => Err(ProjectsGetColumnError::Status403(github_response.to_json_async().await?).into()),
                404 => Err(ProjectsGetColumnError::Status404(github_response.to_json_async().await?).into()),
                401 => Err(ProjectsGetColumnError::Status401(github_response.to_json_async().await?).into()),
                code => Err(ProjectsGetColumnError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # Get a project column
    ///
    /// Gets information about a project column.
    ///
    /// [GitHub API docs for get_column](https://docs.github.com/rest/projects/columns#get-a-project-column)
    ///
    /// ---
    #[cfg(not(target_arch = "wasm32"))]
    pub fn get_column(&self, column_id: i32) -> Result<ProjectColumn, AdapterError> {

        let request_uri = format!("{}/projects/columns/{}", super::GITHUB_BASE_API_URL, column_id);


        let req = GitHubRequest {
            uri: request_uri,
            body: None,
            method: "GET",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch(request)?;

        // --

        if github_response.is_success() {
            Ok(github_response.to_json()?)
        } else {
            match github_response.status_code() {
                304 => Err(ProjectsGetColumnError::Status304.into()),
                403 => Err(ProjectsGetColumnError::Status403(github_response.to_json()?).into()),
                404 => Err(ProjectsGetColumnError::Status404(github_response.to_json()?).into()),
                401 => Err(ProjectsGetColumnError::Status401(github_response.to_json()?).into()),
                code => Err(ProjectsGetColumnError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # Get project permission for a user
    ///
    /// Returns the collaborator's permission level for an organization project. Possible values for the `permission` key: `admin`, `write`, `read`, `none`. You must be an organization owner or a project `admin` to review a user's permission level.
    ///
    /// [GitHub API docs for get_permission_for_user](https://docs.github.com/rest/projects/collaborators#get-project-permission-for-a-user)
    ///
    /// ---
    pub async fn get_permission_for_user_async(&self, project_id: i32, username: &str) -> Result<ProjectCollaboratorPermission, AdapterError> {

        let request_uri = format!("{}/projects/{}/collaborators/{}/permission", super::GITHUB_BASE_API_URL, project_id, username);


        let req = GitHubRequest {
            uri: request_uri,
            body: None::<C::Body>,
            method: "GET",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch_async(request).await?;

        // --

        if github_response.is_success() {
            Ok(github_response.to_json_async().await?)
        } else {
            match github_response.status_code() {
                404 => Err(ProjectsGetPermissionForUserError::Status404(github_response.to_json_async().await?).into()),
                422 => Err(ProjectsGetPermissionForUserError::Status422(github_response.to_json_async().await?).into()),
                304 => Err(ProjectsGetPermissionForUserError::Status304.into()),
                403 => Err(ProjectsGetPermissionForUserError::Status403(github_response.to_json_async().await?).into()),
                401 => Err(ProjectsGetPermissionForUserError::Status401(github_response.to_json_async().await?).into()),
                code => Err(ProjectsGetPermissionForUserError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # Get project permission for a user
    ///
    /// Returns the collaborator's permission level for an organization project. Possible values for the `permission` key: `admin`, `write`, `read`, `none`. You must be an organization owner or a project `admin` to review a user's permission level.
    ///
    /// [GitHub API docs for get_permission_for_user](https://docs.github.com/rest/projects/collaborators#get-project-permission-for-a-user)
    ///
    /// ---
    #[cfg(not(target_arch = "wasm32"))]
    pub fn get_permission_for_user(&self, project_id: i32, username: &str) -> Result<ProjectCollaboratorPermission, AdapterError> {

        let request_uri = format!("{}/projects/{}/collaborators/{}/permission", super::GITHUB_BASE_API_URL, project_id, username);


        let req = GitHubRequest {
            uri: request_uri,
            body: None,
            method: "GET",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch(request)?;

        // --

        if github_response.is_success() {
            Ok(github_response.to_json()?)
        } else {
            match github_response.status_code() {
                404 => Err(ProjectsGetPermissionForUserError::Status404(github_response.to_json()?).into()),
                422 => Err(ProjectsGetPermissionForUserError::Status422(github_response.to_json()?).into()),
                304 => Err(ProjectsGetPermissionForUserError::Status304.into()),
                403 => Err(ProjectsGetPermissionForUserError::Status403(github_response.to_json()?).into()),
                401 => Err(ProjectsGetPermissionForUserError::Status401(github_response.to_json()?).into()),
                code => Err(ProjectsGetPermissionForUserError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # List project cards
    ///
    /// Lists the project cards in a project.
    ///
    /// [GitHub API docs for list_cards](https://docs.github.com/rest/projects/cards#list-project-cards)
    ///
    /// ---
    pub async fn list_cards_async(&self, column_id: i32, query_params: Option<impl Into<ProjectsListCardsParams<'api>>>) -> Result<Vec<ProjectCard>, AdapterError> {

        let mut request_uri = format!("{}/projects/columns/{}/cards", super::GITHUB_BASE_API_URL, column_id);

        if let Some(params) = query_params {
            request_uri.push_str("?");
            request_uri.push_str(&serde_urlencoded::to_string(params.into())?);
        }

        let req = GitHubRequest {
            uri: request_uri,
            body: None::<C::Body>,
            method: "GET",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch_async(request).await?;

        // --

        if github_response.is_success() {
            Ok(github_response.to_json_async().await?)
        } else {
            match github_response.status_code() {
                304 => Err(ProjectsListCardsError::Status304.into()),
                403 => Err(ProjectsListCardsError::Status403(github_response.to_json_async().await?).into()),
                401 => Err(ProjectsListCardsError::Status401(github_response.to_json_async().await?).into()),
                code => Err(ProjectsListCardsError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # List project cards
    ///
    /// Lists the project cards in a project.
    ///
    /// [GitHub API docs for list_cards](https://docs.github.com/rest/projects/cards#list-project-cards)
    ///
    /// ---
    #[cfg(not(target_arch = "wasm32"))]
    pub fn list_cards(&self, column_id: i32, query_params: Option<impl Into<ProjectsListCardsParams<'api>>>) -> Result<Vec<ProjectCard>, AdapterError> {

        let mut request_uri = format!("{}/projects/columns/{}/cards", super::GITHUB_BASE_API_URL, column_id);

        if let Some(params) = query_params {
            request_uri.push_str("?");
            let qp: ProjectsListCardsParams = params.into();
            request_uri.push_str(&serde_urlencoded::to_string(qp)?);
        }

        let req = GitHubRequest {
            uri: request_uri,
            body: None,
            method: "GET",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch(request)?;

        // --

        if github_response.is_success() {
            Ok(github_response.to_json()?)
        } else {
            match github_response.status_code() {
                304 => Err(ProjectsListCardsError::Status304.into()),
                403 => Err(ProjectsListCardsError::Status403(github_response.to_json()?).into()),
                401 => Err(ProjectsListCardsError::Status401(github_response.to_json()?).into()),
                code => Err(ProjectsListCardsError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # List project collaborators
    ///
    /// Lists the collaborators for an organization project. For a project, the list of collaborators includes outside collaborators, organization members that are direct collaborators, organization members with access through team memberships, organization members with access through default organization permissions, and organization owners. You must be an organization owner or a project `admin` to list collaborators.
    ///
    /// [GitHub API docs for list_collaborators](https://docs.github.com/rest/projects/collaborators#list-project-collaborators)
    ///
    /// ---
    pub async fn list_collaborators_async(&self, project_id: i32, query_params: Option<impl Into<ProjectsListCollaboratorsParams<'api>>>) -> Result<Vec<SimpleUser>, AdapterError> {

        let mut request_uri = format!("{}/projects/{}/collaborators", super::GITHUB_BASE_API_URL, project_id);

        if let Some(params) = query_params {
            request_uri.push_str("?");
            request_uri.push_str(&serde_urlencoded::to_string(params.into())?);
        }

        let req = GitHubRequest {
            uri: request_uri,
            body: None::<C::Body>,
            method: "GET",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch_async(request).await?;

        // --

        if github_response.is_success() {
            Ok(github_response.to_json_async().await?)
        } else {
            match github_response.status_code() {
                404 => Err(ProjectsListCollaboratorsError::Status404(github_response.to_json_async().await?).into()),
                422 => Err(ProjectsListCollaboratorsError::Status422(github_response.to_json_async().await?).into()),
                304 => Err(ProjectsListCollaboratorsError::Status304.into()),
                403 => Err(ProjectsListCollaboratorsError::Status403(github_response.to_json_async().await?).into()),
                401 => Err(ProjectsListCollaboratorsError::Status401(github_response.to_json_async().await?).into()),
                code => Err(ProjectsListCollaboratorsError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # List project collaborators
    ///
    /// Lists the collaborators for an organization project. For a project, the list of collaborators includes outside collaborators, organization members that are direct collaborators, organization members with access through team memberships, organization members with access through default organization permissions, and organization owners. You must be an organization owner or a project `admin` to list collaborators.
    ///
    /// [GitHub API docs for list_collaborators](https://docs.github.com/rest/projects/collaborators#list-project-collaborators)
    ///
    /// ---
    #[cfg(not(target_arch = "wasm32"))]
    pub fn list_collaborators(&self, project_id: i32, query_params: Option<impl Into<ProjectsListCollaboratorsParams<'api>>>) -> Result<Vec<SimpleUser>, AdapterError> {

        let mut request_uri = format!("{}/projects/{}/collaborators", super::GITHUB_BASE_API_URL, project_id);

        if let Some(params) = query_params {
            request_uri.push_str("?");
            let qp: ProjectsListCollaboratorsParams = params.into();
            request_uri.push_str(&serde_urlencoded::to_string(qp)?);
        }

        let req = GitHubRequest {
            uri: request_uri,
            body: None,
            method: "GET",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch(request)?;

        // --

        if github_response.is_success() {
            Ok(github_response.to_json()?)
        } else {
            match github_response.status_code() {
                404 => Err(ProjectsListCollaboratorsError::Status404(github_response.to_json()?).into()),
                422 => Err(ProjectsListCollaboratorsError::Status422(github_response.to_json()?).into()),
                304 => Err(ProjectsListCollaboratorsError::Status304.into()),
                403 => Err(ProjectsListCollaboratorsError::Status403(github_response.to_json()?).into()),
                401 => Err(ProjectsListCollaboratorsError::Status401(github_response.to_json()?).into()),
                code => Err(ProjectsListCollaboratorsError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # List project columns
    ///
    /// Lists the project columns in a project.
    ///
    /// [GitHub API docs for list_columns](https://docs.github.com/rest/projects/columns#list-project-columns)
    ///
    /// ---
    pub async fn list_columns_async(&self, project_id: i32, query_params: Option<impl Into<ProjectsListColumnsParams>>) -> Result<Vec<ProjectColumn>, AdapterError> {

        let mut request_uri = format!("{}/projects/{}/columns", super::GITHUB_BASE_API_URL, project_id);

        if let Some(params) = query_params {
            request_uri.push_str("?");
            request_uri.push_str(&serde_urlencoded::to_string(params.into())?);
        }

        let req = GitHubRequest {
            uri: request_uri,
            body: None::<C::Body>,
            method: "GET",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch_async(request).await?;

        // --

        if github_response.is_success() {
            Ok(github_response.to_json_async().await?)
        } else {
            match github_response.status_code() {
                304 => Err(ProjectsListColumnsError::Status304.into()),
                403 => Err(ProjectsListColumnsError::Status403(github_response.to_json_async().await?).into()),
                401 => Err(ProjectsListColumnsError::Status401(github_response.to_json_async().await?).into()),
                code => Err(ProjectsListColumnsError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # List project columns
    ///
    /// Lists the project columns in a project.
    ///
    /// [GitHub API docs for list_columns](https://docs.github.com/rest/projects/columns#list-project-columns)
    ///
    /// ---
    #[cfg(not(target_arch = "wasm32"))]
    pub fn list_columns(&self, project_id: i32, query_params: Option<impl Into<ProjectsListColumnsParams>>) -> Result<Vec<ProjectColumn>, AdapterError> {

        let mut request_uri = format!("{}/projects/{}/columns", super::GITHUB_BASE_API_URL, project_id);

        if let Some(params) = query_params {
            request_uri.push_str("?");
            let qp: ProjectsListColumnsParams = params.into();
            request_uri.push_str(&serde_urlencoded::to_string(qp)?);
        }

        let req = GitHubRequest {
            uri: request_uri,
            body: None,
            method: "GET",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch(request)?;

        // --

        if github_response.is_success() {
            Ok(github_response.to_json()?)
        } else {
            match github_response.status_code() {
                304 => Err(ProjectsListColumnsError::Status304.into()),
                403 => Err(ProjectsListColumnsError::Status403(github_response.to_json()?).into()),
                401 => Err(ProjectsListColumnsError::Status401(github_response.to_json()?).into()),
                code => Err(ProjectsListColumnsError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # List organization projects
    ///
    /// Lists the projects in an organization. Returns a `404 Not Found` status if projects are disabled in the organization. If you do not have sufficient privileges to perform this action, a `401 Unauthorized` or `410 Gone` status is returned.
    ///
    /// [GitHub API docs for list_for_org](https://docs.github.com/rest/projects/projects#list-organization-projects)
    ///
    /// ---
    pub async fn list_for_org_async(&self, org: &str, query_params: Option<impl Into<ProjectsListForOrgParams<'api>>>) -> Result<Vec<Project>, AdapterError> {

        let mut request_uri = format!("{}/orgs/{}/projects", super::GITHUB_BASE_API_URL, org);

        if let Some(params) = query_params {
            request_uri.push_str("?");
            request_uri.push_str(&serde_urlencoded::to_string(params.into())?);
        }

        let req = GitHubRequest {
            uri: request_uri,
            body: None::<C::Body>,
            method: "GET",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch_async(request).await?;

        // --

        if github_response.is_success() {
            Ok(github_response.to_json_async().await?)
        } else {
            match github_response.status_code() {
                422 => Err(ProjectsListForOrgError::Status422(github_response.to_json_async().await?).into()),
                code => Err(ProjectsListForOrgError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # List organization projects
    ///
    /// Lists the projects in an organization. Returns a `404 Not Found` status if projects are disabled in the organization. If you do not have sufficient privileges to perform this action, a `401 Unauthorized` or `410 Gone` status is returned.
    ///
    /// [GitHub API docs for list_for_org](https://docs.github.com/rest/projects/projects#list-organization-projects)
    ///
    /// ---
    #[cfg(not(target_arch = "wasm32"))]
    pub fn list_for_org(&self, org: &str, query_params: Option<impl Into<ProjectsListForOrgParams<'api>>>) -> Result<Vec<Project>, AdapterError> {

        let mut request_uri = format!("{}/orgs/{}/projects", super::GITHUB_BASE_API_URL, org);

        if let Some(params) = query_params {
            request_uri.push_str("?");
            let qp: ProjectsListForOrgParams = params.into();
            request_uri.push_str(&serde_urlencoded::to_string(qp)?);
        }

        let req = GitHubRequest {
            uri: request_uri,
            body: None,
            method: "GET",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch(request)?;

        // --

        if github_response.is_success() {
            Ok(github_response.to_json()?)
        } else {
            match github_response.status_code() {
                422 => Err(ProjectsListForOrgError::Status422(github_response.to_json()?).into()),
                code => Err(ProjectsListForOrgError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # List repository projects
    ///
    /// Lists the projects in a repository. Returns a `404 Not Found` status if projects are disabled in the repository. If you do not have sufficient privileges to perform this action, a `401 Unauthorized` or `410 Gone` status is returned.
    ///
    /// [GitHub API docs for list_for_repo](https://docs.github.com/rest/projects/projects#list-repository-projects)
    ///
    /// ---
    pub async fn list_for_repo_async(&self, owner: &str, repo: &str, query_params: Option<impl Into<ProjectsListForRepoParams<'api>>>) -> Result<Vec<Project>, AdapterError> {

        let mut request_uri = format!("{}/repos/{}/{}/projects", super::GITHUB_BASE_API_URL, owner, repo);

        if let Some(params) = query_params {
            request_uri.push_str("?");
            request_uri.push_str(&serde_urlencoded::to_string(params.into())?);
        }

        let req = GitHubRequest {
            uri: request_uri,
            body: None::<C::Body>,
            method: "GET",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch_async(request).await?;

        // --

        if github_response.is_success() {
            Ok(github_response.to_json_async().await?)
        } else {
            match github_response.status_code() {
                401 => Err(ProjectsListForRepoError::Status401(github_response.to_json_async().await?).into()),
                403 => Err(ProjectsListForRepoError::Status403(github_response.to_json_async().await?).into()),
                404 => Err(ProjectsListForRepoError::Status404(github_response.to_json_async().await?).into()),
                410 => Err(ProjectsListForRepoError::Status410(github_response.to_json_async().await?).into()),
                422 => Err(ProjectsListForRepoError::Status422(github_response.to_json_async().await?).into()),
                code => Err(ProjectsListForRepoError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # List repository projects
    ///
    /// Lists the projects in a repository. Returns a `404 Not Found` status if projects are disabled in the repository. If you do not have sufficient privileges to perform this action, a `401 Unauthorized` or `410 Gone` status is returned.
    ///
    /// [GitHub API docs for list_for_repo](https://docs.github.com/rest/projects/projects#list-repository-projects)
    ///
    /// ---
    #[cfg(not(target_arch = "wasm32"))]
    pub fn list_for_repo(&self, owner: &str, repo: &str, query_params: Option<impl Into<ProjectsListForRepoParams<'api>>>) -> Result<Vec<Project>, AdapterError> {

        let mut request_uri = format!("{}/repos/{}/{}/projects", super::GITHUB_BASE_API_URL, owner, repo);

        if let Some(params) = query_params {
            request_uri.push_str("?");
            let qp: ProjectsListForRepoParams = params.into();
            request_uri.push_str(&serde_urlencoded::to_string(qp)?);
        }

        let req = GitHubRequest {
            uri: request_uri,
            body: None,
            method: "GET",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch(request)?;

        // --

        if github_response.is_success() {
            Ok(github_response.to_json()?)
        } else {
            match github_response.status_code() {
                401 => Err(ProjectsListForRepoError::Status401(github_response.to_json()?).into()),
                403 => Err(ProjectsListForRepoError::Status403(github_response.to_json()?).into()),
                404 => Err(ProjectsListForRepoError::Status404(github_response.to_json()?).into()),
                410 => Err(ProjectsListForRepoError::Status410(github_response.to_json()?).into()),
                422 => Err(ProjectsListForRepoError::Status422(github_response.to_json()?).into()),
                code => Err(ProjectsListForRepoError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # List user projects
    ///
    /// Lists projects for a user.
    ///
    /// [GitHub API docs for list_for_user](https://docs.github.com/rest/projects/projects#list-user-projects)
    ///
    /// ---
    pub async fn list_for_user_async(&self, username: &str, query_params: Option<impl Into<ProjectsListForUserParams<'api>>>) -> Result<Vec<Project>, AdapterError> {

        let mut request_uri = format!("{}/users/{}/projects", super::GITHUB_BASE_API_URL, username);

        if let Some(params) = query_params {
            request_uri.push_str("?");
            request_uri.push_str(&serde_urlencoded::to_string(params.into())?);
        }

        let req = GitHubRequest {
            uri: request_uri,
            body: None::<C::Body>,
            method: "GET",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch_async(request).await?;

        // --

        if github_response.is_success() {
            Ok(github_response.to_json_async().await?)
        } else {
            match github_response.status_code() {
                422 => Err(ProjectsListForUserError::Status422(github_response.to_json_async().await?).into()),
                code => Err(ProjectsListForUserError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # List user projects
    ///
    /// Lists projects for a user.
    ///
    /// [GitHub API docs for list_for_user](https://docs.github.com/rest/projects/projects#list-user-projects)
    ///
    /// ---
    #[cfg(not(target_arch = "wasm32"))]
    pub fn list_for_user(&self, username: &str, query_params: Option<impl Into<ProjectsListForUserParams<'api>>>) -> Result<Vec<Project>, AdapterError> {

        let mut request_uri = format!("{}/users/{}/projects", super::GITHUB_BASE_API_URL, username);

        if let Some(params) = query_params {
            request_uri.push_str("?");
            let qp: ProjectsListForUserParams = params.into();
            request_uri.push_str(&serde_urlencoded::to_string(qp)?);
        }

        let req = GitHubRequest {
            uri: request_uri,
            body: None,
            method: "GET",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch(request)?;

        // --

        if github_response.is_success() {
            Ok(github_response.to_json()?)
        } else {
            match github_response.status_code() {
                422 => Err(ProjectsListForUserError::Status422(github_response.to_json()?).into()),
                code => Err(ProjectsListForUserError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # Move a project card
    ///
    /// [GitHub API docs for move_card](https://docs.github.com/rest/projects/cards#move-a-project-card)
    ///
    /// ---
    pub async fn move_card_async(&self, card_id: i32, body: PostProjectsMoveCard) -> Result<HashMap<String, Value>, AdapterError> {

        let request_uri = format!("{}/projects/columns/cards/{}/moves", super::GITHUB_BASE_API_URL, card_id);


        let req = GitHubRequest {
            uri: request_uri,
            body: Some(C::from_json::<PostProjectsMoveCard>(body)?),
            method: "POST",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch_async(request).await?;

        // --

        if github_response.is_success() {
            Ok(github_response.to_json_async().await?)
        } else {
            match github_response.status_code() {
                304 => Err(ProjectsMoveCardError::Status304.into()),
                403 => Err(ProjectsMoveCardError::Status403(github_response.to_json_async().await?).into()),
                401 => Err(ProjectsMoveCardError::Status401(github_response.to_json_async().await?).into()),
                503 => Err(ProjectsMoveCardError::Status503(github_response.to_json_async().await?).into()),
                422 => Err(ProjectsMoveCardError::Status422(github_response.to_json_async().await?).into()),
                code => Err(ProjectsMoveCardError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # Move a project card
    ///
    /// [GitHub API docs for move_card](https://docs.github.com/rest/projects/cards#move-a-project-card)
    ///
    /// ---
    #[cfg(not(target_arch = "wasm32"))]
    pub fn move_card(&self, card_id: i32, body: PostProjectsMoveCard) -> Result<HashMap<String, Value>, AdapterError> {

        let request_uri = format!("{}/projects/columns/cards/{}/moves", super::GITHUB_BASE_API_URL, card_id);


        let req = GitHubRequest {
            uri: request_uri,
            body: Some(C::from_json::<PostProjectsMoveCard>(body)?),
            method: "POST",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch(request)?;

        // --

        if github_response.is_success() {
            Ok(github_response.to_json()?)
        } else {
            match github_response.status_code() {
                304 => Err(ProjectsMoveCardError::Status304.into()),
                403 => Err(ProjectsMoveCardError::Status403(github_response.to_json()?).into()),
                401 => Err(ProjectsMoveCardError::Status401(github_response.to_json()?).into()),
                503 => Err(ProjectsMoveCardError::Status503(github_response.to_json()?).into()),
                422 => Err(ProjectsMoveCardError::Status422(github_response.to_json()?).into()),
                code => Err(ProjectsMoveCardError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # Move a project column
    ///
    /// [GitHub API docs for move_column](https://docs.github.com/rest/projects/columns#move-a-project-column)
    ///
    /// ---
    pub async fn move_column_async(&self, column_id: i32, body: PostProjectsMoveColumn) -> Result<HashMap<String, Value>, AdapterError> {

        let request_uri = format!("{}/projects/columns/{}/moves", super::GITHUB_BASE_API_URL, column_id);


        let req = GitHubRequest {
            uri: request_uri,
            body: Some(C::from_json::<PostProjectsMoveColumn>(body)?),
            method: "POST",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch_async(request).await?;

        // --

        if github_response.is_success() {
            Ok(github_response.to_json_async().await?)
        } else {
            match github_response.status_code() {
                304 => Err(ProjectsMoveColumnError::Status304.into()),
                403 => Err(ProjectsMoveColumnError::Status403(github_response.to_json_async().await?).into()),
                422 => Err(ProjectsMoveColumnError::Status422(github_response.to_json_async().await?).into()),
                401 => Err(ProjectsMoveColumnError::Status401(github_response.to_json_async().await?).into()),
                code => Err(ProjectsMoveColumnError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # Move a project column
    ///
    /// [GitHub API docs for move_column](https://docs.github.com/rest/projects/columns#move-a-project-column)
    ///
    /// ---
    #[cfg(not(target_arch = "wasm32"))]
    pub fn move_column(&self, column_id: i32, body: PostProjectsMoveColumn) -> Result<HashMap<String, Value>, AdapterError> {

        let request_uri = format!("{}/projects/columns/{}/moves", super::GITHUB_BASE_API_URL, column_id);


        let req = GitHubRequest {
            uri: request_uri,
            body: Some(C::from_json::<PostProjectsMoveColumn>(body)?),
            method: "POST",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch(request)?;

        // --

        if github_response.is_success() {
            Ok(github_response.to_json()?)
        } else {
            match github_response.status_code() {
                304 => Err(ProjectsMoveColumnError::Status304.into()),
                403 => Err(ProjectsMoveColumnError::Status403(github_response.to_json()?).into()),
                422 => Err(ProjectsMoveColumnError::Status422(github_response.to_json()?).into()),
                401 => Err(ProjectsMoveColumnError::Status401(github_response.to_json()?).into()),
                code => Err(ProjectsMoveColumnError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # Remove user as a collaborator
    ///
    /// Removes a collaborator from an organization project. You must be an organization owner or a project `admin` to remove a collaborator.
    ///
    /// [GitHub API docs for remove_collaborator](https://docs.github.com/rest/projects/collaborators#remove-user-as-a-collaborator)
    ///
    /// ---
    pub async fn remove_collaborator_async(&self, project_id: i32, username: &str) -> Result<(), AdapterError> {

        let request_uri = format!("{}/projects/{}/collaborators/{}", super::GITHUB_BASE_API_URL, project_id, username);


        let req = GitHubRequest {
            uri: request_uri,
            body: None::<C::Body>,
            method: "DELETE",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch_async(request).await?;

        // --

        if github_response.is_success() {
            Ok(())
        } else {
            match github_response.status_code() {
                304 => Err(ProjectsRemoveCollaboratorError::Status304.into()),
                404 => Err(ProjectsRemoveCollaboratorError::Status404(github_response.to_json_async().await?).into()),
                403 => Err(ProjectsRemoveCollaboratorError::Status403(github_response.to_json_async().await?).into()),
                422 => Err(ProjectsRemoveCollaboratorError::Status422(github_response.to_json_async().await?).into()),
                401 => Err(ProjectsRemoveCollaboratorError::Status401(github_response.to_json_async().await?).into()),
                code => Err(ProjectsRemoveCollaboratorError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # Remove user as a collaborator
    ///
    /// Removes a collaborator from an organization project. You must be an organization owner or a project `admin` to remove a collaborator.
    ///
    /// [GitHub API docs for remove_collaborator](https://docs.github.com/rest/projects/collaborators#remove-user-as-a-collaborator)
    ///
    /// ---
    #[cfg(not(target_arch = "wasm32"))]
    pub fn remove_collaborator(&self, project_id: i32, username: &str) -> Result<(), AdapterError> {

        let request_uri = format!("{}/projects/{}/collaborators/{}", super::GITHUB_BASE_API_URL, project_id, username);


        let req = GitHubRequest {
            uri: request_uri,
            body: None,
            method: "DELETE",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch(request)?;

        // --

        if github_response.is_success() {
            Ok(())
        } else {
            match github_response.status_code() {
                304 => Err(ProjectsRemoveCollaboratorError::Status304.into()),
                404 => Err(ProjectsRemoveCollaboratorError::Status404(github_response.to_json()?).into()),
                403 => Err(ProjectsRemoveCollaboratorError::Status403(github_response.to_json()?).into()),
                422 => Err(ProjectsRemoveCollaboratorError::Status422(github_response.to_json()?).into()),
                401 => Err(ProjectsRemoveCollaboratorError::Status401(github_response.to_json()?).into()),
                code => Err(ProjectsRemoveCollaboratorError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # Update a project
    ///
    /// Updates a project board's information. Returns a `404 Not Found` status if projects are disabled. If you do not have sufficient privileges to perform this action, a `401 Unauthorized` or `410 Gone` status is returned.
    ///
    /// [GitHub API docs for update](https://docs.github.com/rest/projects/projects#update-a-project)
    ///
    /// ---
    pub async fn update_async(&self, project_id: i32, body: PatchProjectsUpdate) -> Result<Project, AdapterError> {

        let request_uri = format!("{}/projects/{}", super::GITHUB_BASE_API_URL, project_id);


        let req = GitHubRequest {
            uri: request_uri,
            body: Some(C::from_json::<PatchProjectsUpdate>(body)?),
            method: "PATCH",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch_async(request).await?;

        // --

        if github_response.is_success() {
            Ok(github_response.to_json_async().await?)
        } else {
            match github_response.status_code() {
                404 => Err(ProjectsUpdateError::Status404.into()),
                304 => Err(ProjectsUpdateError::Status304.into()),
                403 => Err(ProjectsUpdateError::Status403(github_response.to_json_async().await?).into()),
                401 => Err(ProjectsUpdateError::Status401(github_response.to_json_async().await?).into()),
                410 => Err(ProjectsUpdateError::Status410(github_response.to_json_async().await?).into()),
                422 => Err(ProjectsUpdateError::Status422(github_response.to_json_async().await?).into()),
                code => Err(ProjectsUpdateError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # Update a project
    ///
    /// Updates a project board's information. Returns a `404 Not Found` status if projects are disabled. If you do not have sufficient privileges to perform this action, a `401 Unauthorized` or `410 Gone` status is returned.
    ///
    /// [GitHub API docs for update](https://docs.github.com/rest/projects/projects#update-a-project)
    ///
    /// ---
    #[cfg(not(target_arch = "wasm32"))]
    pub fn update(&self, project_id: i32, body: PatchProjectsUpdate) -> Result<Project, AdapterError> {

        let request_uri = format!("{}/projects/{}", super::GITHUB_BASE_API_URL, project_id);


        let req = GitHubRequest {
            uri: request_uri,
            body: Some(C::from_json::<PatchProjectsUpdate>(body)?),
            method: "PATCH",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch(request)?;

        // --

        if github_response.is_success() {
            Ok(github_response.to_json()?)
        } else {
            match github_response.status_code() {
                404 => Err(ProjectsUpdateError::Status404.into()),
                304 => Err(ProjectsUpdateError::Status304.into()),
                403 => Err(ProjectsUpdateError::Status403(github_response.to_json()?).into()),
                401 => Err(ProjectsUpdateError::Status401(github_response.to_json()?).into()),
                410 => Err(ProjectsUpdateError::Status410(github_response.to_json()?).into()),
                422 => Err(ProjectsUpdateError::Status422(github_response.to_json()?).into()),
                code => Err(ProjectsUpdateError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # Update an existing project card
    ///
    /// [GitHub API docs for update_card](https://docs.github.com/rest/projects/cards#update-an-existing-project-card)
    ///
    /// ---
    pub async fn update_card_async(&self, card_id: i32, body: PatchProjectsUpdateCard) -> Result<ProjectCard, AdapterError> {

        let request_uri = format!("{}/projects/columns/cards/{}", super::GITHUB_BASE_API_URL, card_id);


        let req = GitHubRequest {
            uri: request_uri,
            body: Some(C::from_json::<PatchProjectsUpdateCard>(body)?),
            method: "PATCH",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch_async(request).await?;

        // --

        if github_response.is_success() {
            Ok(github_response.to_json_async().await?)
        } else {
            match github_response.status_code() {
                304 => Err(ProjectsUpdateCardError::Status304.into()),
                403 => Err(ProjectsUpdateCardError::Status403(github_response.to_json_async().await?).into()),
                401 => Err(ProjectsUpdateCardError::Status401(github_response.to_json_async().await?).into()),
                404 => Err(ProjectsUpdateCardError::Status404(github_response.to_json_async().await?).into()),
                422 => Err(ProjectsUpdateCardError::Status422(github_response.to_json_async().await?).into()),
                code => Err(ProjectsUpdateCardError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # Update an existing project card
    ///
    /// [GitHub API docs for update_card](https://docs.github.com/rest/projects/cards#update-an-existing-project-card)
    ///
    /// ---
    #[cfg(not(target_arch = "wasm32"))]
    pub fn update_card(&self, card_id: i32, body: PatchProjectsUpdateCard) -> Result<ProjectCard, AdapterError> {

        let request_uri = format!("{}/projects/columns/cards/{}", super::GITHUB_BASE_API_URL, card_id);


        let req = GitHubRequest {
            uri: request_uri,
            body: Some(C::from_json::<PatchProjectsUpdateCard>(body)?),
            method: "PATCH",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch(request)?;

        // --

        if github_response.is_success() {
            Ok(github_response.to_json()?)
        } else {
            match github_response.status_code() {
                304 => Err(ProjectsUpdateCardError::Status304.into()),
                403 => Err(ProjectsUpdateCardError::Status403(github_response.to_json()?).into()),
                401 => Err(ProjectsUpdateCardError::Status401(github_response.to_json()?).into()),
                404 => Err(ProjectsUpdateCardError::Status404(github_response.to_json()?).into()),
                422 => Err(ProjectsUpdateCardError::Status422(github_response.to_json()?).into()),
                code => Err(ProjectsUpdateCardError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # Update an existing project column
    ///
    /// [GitHub API docs for update_column](https://docs.github.com/rest/projects/columns#update-an-existing-project-column)
    ///
    /// ---
    pub async fn update_column_async(&self, column_id: i32, body: PatchProjectsUpdateColumn) -> Result<ProjectColumn, AdapterError> {

        let request_uri = format!("{}/projects/columns/{}", super::GITHUB_BASE_API_URL, column_id);


        let req = GitHubRequest {
            uri: request_uri,
            body: Some(C::from_json::<PatchProjectsUpdateColumn>(body)?),
            method: "PATCH",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch_async(request).await?;

        // --

        if github_response.is_success() {
            Ok(github_response.to_json_async().await?)
        } else {
            match github_response.status_code() {
                304 => Err(ProjectsUpdateColumnError::Status304.into()),
                403 => Err(ProjectsUpdateColumnError::Status403(github_response.to_json_async().await?).into()),
                401 => Err(ProjectsUpdateColumnError::Status401(github_response.to_json_async().await?).into()),
                code => Err(ProjectsUpdateColumnError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # Update an existing project column
    ///
    /// [GitHub API docs for update_column](https://docs.github.com/rest/projects/columns#update-an-existing-project-column)
    ///
    /// ---
    #[cfg(not(target_arch = "wasm32"))]
    pub fn update_column(&self, column_id: i32, body: PatchProjectsUpdateColumn) -> Result<ProjectColumn, AdapterError> {

        let request_uri = format!("{}/projects/columns/{}", super::GITHUB_BASE_API_URL, column_id);


        let req = GitHubRequest {
            uri: request_uri,
            body: Some(C::from_json::<PatchProjectsUpdateColumn>(body)?),
            method: "PATCH",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch(request)?;

        // --

        if github_response.is_success() {
            Ok(github_response.to_json()?)
        } else {
            match github_response.status_code() {
                304 => Err(ProjectsUpdateColumnError::Status304.into()),
                403 => Err(ProjectsUpdateColumnError::Status403(github_response.to_json()?).into()),
                401 => Err(ProjectsUpdateColumnError::Status401(github_response.to_json()?).into()),
                code => Err(ProjectsUpdateColumnError::Generic { code }.into()),
            }
        }
    }

}
