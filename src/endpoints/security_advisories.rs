//! Method, error and parameter types for the SecurityAdvisories endpoint.
#![allow(
    unused_imports,
)]
/* 
 * GitHub v3 REST API
 *
 * GitHub's v3 REST API.
 *
 * OpenAPI spec version: 1.1.4
 * 
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 */

use serde::Deserialize;

use crate::adapters::{AdapterError, FromJson, GitHubRequest, GitHubRequestBuilder, GitHubResponseExt};
use crate::auth::Auth;
use crate::models::*;

use super::PerPage;

use std::collections::HashMap;
use serde_json::value::Value;

pub struct SecurityAdvisories<'api> {
    auth: &'api Auth
}

pub fn new(auth: &Auth) -> SecurityAdvisories {
    SecurityAdvisories { auth }
}

/// Errors for the [Create a temporary private fork](SecurityAdvisories::create_fork_async()) endpoint.
#[derive(Debug, thiserror::Error)]
pub enum SecurityAdvisoriesCreateForkError {
    #[error(transparent)]
    AdapterError(#[from] AdapterError),
    #[error(transparent)]
    SerdeJson(#[from] serde_json::Error),
    #[error(transparent)]
    SerdeUrl(#[from] serde_urlencoded::ser::Error),


    // -- endpoint errors

    #[error("Bad Request")]
    Status400(BasicError),
    #[error("Validation failed, or the endpoint has been spammed.")]
    Status422(ValidationError),
    #[error("Forbidden")]
    Status403(BasicError),
    #[error("Resource not found")]
    Status404(BasicError),
    #[error("Status code: {}", code)]
    Generic { code: u16 },
}

/// Errors for the [Privately report a security vulnerability](SecurityAdvisories::create_private_vulnerability_report_async()) endpoint.
#[derive(Debug, thiserror::Error)]
pub enum SecurityAdvisoriesCreatePrivateVulnerabilityReportError {
    #[error(transparent)]
    AdapterError(#[from] AdapterError),
    #[error(transparent)]
    SerdeJson(#[from] serde_json::Error),
    #[error(transparent)]
    SerdeUrl(#[from] serde_urlencoded::ser::Error),


    // -- endpoint errors

    #[error("Forbidden")]
    Status403(BasicError),
    #[error("Resource not found")]
    Status404(BasicError),
    #[error("Validation failed, or the endpoint has been spammed.")]
    Status422(ValidationError),
    #[error("Status code: {}", code)]
    Generic { code: u16 },
}

/// Errors for the [Create a repository security advisory](SecurityAdvisories::create_repository_advisory_async()) endpoint.
#[derive(Debug, thiserror::Error)]
pub enum SecurityAdvisoriesCreateRepositoryAdvisoryError {
    #[error(transparent)]
    AdapterError(#[from] AdapterError),
    #[error(transparent)]
    SerdeJson(#[from] serde_json::Error),
    #[error(transparent)]
    SerdeUrl(#[from] serde_urlencoded::ser::Error),


    // -- endpoint errors

    #[error("Forbidden")]
    Status403(BasicError),
    #[error("Resource not found")]
    Status404(BasicError),
    #[error("Validation failed, or the endpoint has been spammed.")]
    Status422(ValidationError),
    #[error("Status code: {}", code)]
    Generic { code: u16 },
}

/// Errors for the [Request a CVE for a repository security advisory](SecurityAdvisories::create_repository_advisory_cve_request_async()) endpoint.
#[derive(Debug, thiserror::Error)]
pub enum SecurityAdvisoriesCreateRepositoryAdvisoryCveRequestError {
    #[error(transparent)]
    AdapterError(#[from] AdapterError),
    #[error(transparent)]
    SerdeJson(#[from] serde_json::Error),
    #[error(transparent)]
    SerdeUrl(#[from] serde_urlencoded::ser::Error),


    // -- endpoint errors

    #[error("Bad Request")]
    Status400(BasicError),
    #[error("Forbidden")]
    Status403(BasicError),
    #[error("Resource not found")]
    Status404(BasicError),
    #[error("Validation failed, or the endpoint has been spammed.")]
    Status422(ValidationError),
    #[error("Status code: {}", code)]
    Generic { code: u16 },
}

/// Errors for the [Get a global security advisory](SecurityAdvisories::get_global_advisory_async()) endpoint.
#[derive(Debug, thiserror::Error)]
pub enum SecurityAdvisoriesGetGlobalAdvisoryError {
    #[error(transparent)]
    AdapterError(#[from] AdapterError),
    #[error(transparent)]
    SerdeJson(#[from] serde_json::Error),
    #[error(transparent)]
    SerdeUrl(#[from] serde_urlencoded::ser::Error),


    // -- endpoint errors

    #[error("Resource not found")]
    Status404(BasicError),
    #[error("Status code: {}", code)]
    Generic { code: u16 },
}

/// Errors for the [Get a repository security advisory](SecurityAdvisories::get_repository_advisory_async()) endpoint.
#[derive(Debug, thiserror::Error)]
pub enum SecurityAdvisoriesGetRepositoryAdvisoryError {
    #[error(transparent)]
    AdapterError(#[from] AdapterError),
    #[error(transparent)]
    SerdeJson(#[from] serde_json::Error),
    #[error(transparent)]
    SerdeUrl(#[from] serde_urlencoded::ser::Error),


    // -- endpoint errors

    #[error("Forbidden")]
    Status403(BasicError),
    #[error("Resource not found")]
    Status404(BasicError),
    #[error("Status code: {}", code)]
    Generic { code: u16 },
}

/// Errors for the [List global security advisories](SecurityAdvisories::list_global_advisories_async()) endpoint.
#[derive(Debug, thiserror::Error)]
pub enum SecurityAdvisoriesListGlobalAdvisoriesError {
    #[error(transparent)]
    AdapterError(#[from] AdapterError),
    #[error(transparent)]
    SerdeJson(#[from] serde_json::Error),
    #[error(transparent)]
    SerdeUrl(#[from] serde_urlencoded::ser::Error),


    // -- endpoint errors

    #[error("Too many requests")]
    Status429(BasicError),
    #[error("Validation failed, or the endpoint has been spammed.")]
    Status422(ValidationErrorSimple),
    #[error("Status code: {}", code)]
    Generic { code: u16 },
}

/// Errors for the [List repository security advisories for an organization](SecurityAdvisories::list_org_repository_advisories_async()) endpoint.
#[derive(Debug, thiserror::Error)]
pub enum SecurityAdvisoriesListOrgRepositoryAdvisoriesError {
    #[error(transparent)]
    AdapterError(#[from] AdapterError),
    #[error(transparent)]
    SerdeJson(#[from] serde_json::Error),
    #[error(transparent)]
    SerdeUrl(#[from] serde_urlencoded::ser::Error),


    // -- endpoint errors

    #[error("Bad Request")]
    Status400(BasicError),
    #[error("Resource not found")]
    Status404(BasicError),
    #[error("Status code: {}", code)]
    Generic { code: u16 },
}

/// Errors for the [List repository security advisories](SecurityAdvisories::list_repository_advisories_async()) endpoint.
#[derive(Debug, thiserror::Error)]
pub enum SecurityAdvisoriesListRepositoryAdvisoriesError {
    #[error(transparent)]
    AdapterError(#[from] AdapterError),
    #[error(transparent)]
    SerdeJson(#[from] serde_json::Error),
    #[error(transparent)]
    SerdeUrl(#[from] serde_urlencoded::ser::Error),


    // -- endpoint errors

    #[error("Bad Request")]
    Status400(BasicError),
    #[error("Resource not found")]
    Status404(BasicError),
    #[error("Status code: {}", code)]
    Generic { code: u16 },
}

/// Errors for the [Update a repository security advisory](SecurityAdvisories::update_repository_advisory_async()) endpoint.
#[derive(Debug, thiserror::Error)]
pub enum SecurityAdvisoriesUpdateRepositoryAdvisoryError {
    #[error(transparent)]
    AdapterError(#[from] AdapterError),
    #[error(transparent)]
    SerdeJson(#[from] serde_json::Error),
    #[error(transparent)]
    SerdeUrl(#[from] serde_urlencoded::ser::Error),


    // -- endpoint errors

    #[error("Forbidden")]
    Status403(BasicError),
    #[error("Resource not found")]
    Status404(BasicError),
    #[error("Validation failed, or the endpoint has been spammed.")]
    Status422(ValidationError),
    #[error("Status code: {}", code)]
    Generic { code: u16 },
}


/// Query parameters for the [List global security advisories](SecurityAdvisories::list_global_advisories_async()) endpoint.
#[derive(Default, Serialize)]
pub struct SecurityAdvisoriesListGlobalAdvisoriesParams<'req> {
    /// If specified, only advisories with this GHSA (GitHub Security Advisory) identifier will be returned.
    ghsa_id: Option<&'req str>, 
    /// If specified, only advisories of this type will be returned. By default, a request with no other parameters defined will only return reviewed advisories that are not malware.
    _type: Option<&'req str>, 
    /// If specified, only advisories with this CVE (Common Vulnerabilities and Exposures) identifier will be returned.
    cve_id: Option<&'req str>, 
    /// If specified, only advisories for these ecosystems will be returned.
    ecosystem: Option<SecurityAdvisoryEcosystems>, 
    /// If specified, only advisories with these severities will be returned.
    severity: Option<&'req str>, 
    /// If specified, only advisories with these Common Weakness Enumerations (CWEs) will be returned.  Example: `cwes=79,284,22` or `cwes[]=79&cwes[]=284&cwes[]=22`
    cwes: Option<Cwes>, 
    /// Whether to only return advisories that have been withdrawn.
    is_withdrawn: Option<bool>, 
    /// If specified, only return advisories that affect any of `package` or `package@version`. A maximum of 1000 packages can be specified. If the query parameter causes the URL to exceed the maximum URL length supported by your client, you must specify fewer packages.  Example: `affects=package1,package2@1.0.0,package3@^2.0.0` or `affects[]=package1&affects[]=package2@1.0.0`
    affects: Option<Affects>, 
    /// If specified, only return advisories that were published on a date or date range.  For more information on the syntax of the date range, see \"[Understanding the search syntax](https://docs.github.com/search-github/getting-started-with-searching-on-github/understanding-the-search-syntax#query-for-dates).\"
    published: Option<&'req str>, 
    /// If specified, only return advisories that were updated on a date or date range.  For more information on the syntax of the date range, see \"[Understanding the search syntax](https://docs.github.com/search-github/getting-started-with-searching-on-github/understanding-the-search-syntax#query-for-dates).\"
    updated: Option<&'req str>, 
    /// If specified, only show advisories that were updated or published on a date or date range.  For more information on the syntax of the date range, see \"[Understanding the search syntax](https://docs.github.com/search-github/getting-started-with-searching-on-github/understanding-the-search-syntax#query-for-dates).\"
    modified: Option<&'req str>, 
    /// If specified, only return advisories that have an EPSS percentage score that matches the provided value. The EPSS percentage represents the likelihood of a CVE being exploited.
    epss_percentage: Option<&'req str>, 
    /// If specified, only return advisories that have an EPSS percentile score that matches the provided value. The EPSS percentile represents the relative rank of the CVE's likelihood of being exploited compared to other CVEs.
    epss_percentile: Option<&'req str>, 
    /// A cursor, as given in the [Link header](https://docs.github.com/rest/guides/using-pagination-in-the-rest-api#using-link-headers). If specified, the query only searches for results before this cursor. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    before: Option<&'req str>, 
    /// A cursor, as given in the [Link header](https://docs.github.com/rest/guides/using-pagination-in-the-rest-api#using-link-headers). If specified, the query only searches for results after this cursor. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    after: Option<&'req str>, 
    /// The direction to sort the results by.
    direction: Option<&'req str>, 
    /// The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    per_page: Option<u16>, 
    /// The property to sort the results by.
    sort: Option<&'req str>
}

impl<'req> SecurityAdvisoriesListGlobalAdvisoriesParams<'req> {
    pub fn new() -> Self {
        Self::default()
    }

    /// If specified, only advisories with this GHSA (GitHub Security Advisory) identifier will be returned.
    pub fn ghsa_id(self, ghsa_id: &'req str) -> Self {
        Self { 
            ghsa_id: Some(ghsa_id),
            _type: self._type, 
            cve_id: self.cve_id, 
            ecosystem: self.ecosystem, 
            severity: self.severity, 
            cwes: self.cwes, 
            is_withdrawn: self.is_withdrawn, 
            affects: self.affects, 
            published: self.published, 
            updated: self.updated, 
            modified: self.modified, 
            epss_percentage: self.epss_percentage, 
            epss_percentile: self.epss_percentile, 
            before: self.before, 
            after: self.after, 
            direction: self.direction, 
            per_page: self.per_page, 
            sort: self.sort, 
        }
    }

    /// If specified, only advisories of this type will be returned. By default, a request with no other parameters defined will only return reviewed advisories that are not malware.
    pub fn _type(self, _type: &'req str) -> Self {
        Self { 
            ghsa_id: self.ghsa_id, 
            _type: Some(_type),
            cve_id: self.cve_id, 
            ecosystem: self.ecosystem, 
            severity: self.severity, 
            cwes: self.cwes, 
            is_withdrawn: self.is_withdrawn, 
            affects: self.affects, 
            published: self.published, 
            updated: self.updated, 
            modified: self.modified, 
            epss_percentage: self.epss_percentage, 
            epss_percentile: self.epss_percentile, 
            before: self.before, 
            after: self.after, 
            direction: self.direction, 
            per_page: self.per_page, 
            sort: self.sort, 
        }
    }

    /// If specified, only advisories with this CVE (Common Vulnerabilities and Exposures) identifier will be returned.
    pub fn cve_id(self, cve_id: &'req str) -> Self {
        Self { 
            ghsa_id: self.ghsa_id, 
            _type: self._type, 
            cve_id: Some(cve_id),
            ecosystem: self.ecosystem, 
            severity: self.severity, 
            cwes: self.cwes, 
            is_withdrawn: self.is_withdrawn, 
            affects: self.affects, 
            published: self.published, 
            updated: self.updated, 
            modified: self.modified, 
            epss_percentage: self.epss_percentage, 
            epss_percentile: self.epss_percentile, 
            before: self.before, 
            after: self.after, 
            direction: self.direction, 
            per_page: self.per_page, 
            sort: self.sort, 
        }
    }

    /// If specified, only advisories for these ecosystems will be returned.
    pub fn ecosystem(self, ecosystem: SecurityAdvisoryEcosystems) -> Self {
        Self { 
            ghsa_id: self.ghsa_id, 
            _type: self._type, 
            cve_id: self.cve_id, 
            ecosystem: Some(ecosystem),
            severity: self.severity, 
            cwes: self.cwes, 
            is_withdrawn: self.is_withdrawn, 
            affects: self.affects, 
            published: self.published, 
            updated: self.updated, 
            modified: self.modified, 
            epss_percentage: self.epss_percentage, 
            epss_percentile: self.epss_percentile, 
            before: self.before, 
            after: self.after, 
            direction: self.direction, 
            per_page: self.per_page, 
            sort: self.sort, 
        }
    }

    /// If specified, only advisories with these severities will be returned.
    pub fn severity(self, severity: &'req str) -> Self {
        Self { 
            ghsa_id: self.ghsa_id, 
            _type: self._type, 
            cve_id: self.cve_id, 
            ecosystem: self.ecosystem, 
            severity: Some(severity),
            cwes: self.cwes, 
            is_withdrawn: self.is_withdrawn, 
            affects: self.affects, 
            published: self.published, 
            updated: self.updated, 
            modified: self.modified, 
            epss_percentage: self.epss_percentage, 
            epss_percentile: self.epss_percentile, 
            before: self.before, 
            after: self.after, 
            direction: self.direction, 
            per_page: self.per_page, 
            sort: self.sort, 
        }
    }

    /// If specified, only advisories with these Common Weakness Enumerations (CWEs) will be returned.  Example: `cwes=79,284,22` or `cwes[]=79&cwes[]=284&cwes[]=22`
    pub fn cwes(self, cwes: Cwes) -> Self {
        Self { 
            ghsa_id: self.ghsa_id, 
            _type: self._type, 
            cve_id: self.cve_id, 
            ecosystem: self.ecosystem, 
            severity: self.severity, 
            cwes: Some(cwes),
            is_withdrawn: self.is_withdrawn, 
            affects: self.affects, 
            published: self.published, 
            updated: self.updated, 
            modified: self.modified, 
            epss_percentage: self.epss_percentage, 
            epss_percentile: self.epss_percentile, 
            before: self.before, 
            after: self.after, 
            direction: self.direction, 
            per_page: self.per_page, 
            sort: self.sort, 
        }
    }

    /// Whether to only return advisories that have been withdrawn.
    pub fn is_withdrawn(self, is_withdrawn: bool) -> Self {
        Self { 
            ghsa_id: self.ghsa_id, 
            _type: self._type, 
            cve_id: self.cve_id, 
            ecosystem: self.ecosystem, 
            severity: self.severity, 
            cwes: self.cwes, 
            is_withdrawn: Some(is_withdrawn),
            affects: self.affects, 
            published: self.published, 
            updated: self.updated, 
            modified: self.modified, 
            epss_percentage: self.epss_percentage, 
            epss_percentile: self.epss_percentile, 
            before: self.before, 
            after: self.after, 
            direction: self.direction, 
            per_page: self.per_page, 
            sort: self.sort, 
        }
    }

    /// If specified, only return advisories that affect any of `package` or `package@version`. A maximum of 1000 packages can be specified. If the query parameter causes the URL to exceed the maximum URL length supported by your client, you must specify fewer packages.  Example: `affects=package1,package2@1.0.0,package3@^2.0.0` or `affects[]=package1&affects[]=package2@1.0.0`
    pub fn affects(self, affects: Affects) -> Self {
        Self { 
            ghsa_id: self.ghsa_id, 
            _type: self._type, 
            cve_id: self.cve_id, 
            ecosystem: self.ecosystem, 
            severity: self.severity, 
            cwes: self.cwes, 
            is_withdrawn: self.is_withdrawn, 
            affects: Some(affects),
            published: self.published, 
            updated: self.updated, 
            modified: self.modified, 
            epss_percentage: self.epss_percentage, 
            epss_percentile: self.epss_percentile, 
            before: self.before, 
            after: self.after, 
            direction: self.direction, 
            per_page: self.per_page, 
            sort: self.sort, 
        }
    }

    /// If specified, only return advisories that were published on a date or date range.  For more information on the syntax of the date range, see \"[Understanding the search syntax](https://docs.github.com/search-github/getting-started-with-searching-on-github/understanding-the-search-syntax#query-for-dates).\"
    pub fn published(self, published: &'req str) -> Self {
        Self { 
            ghsa_id: self.ghsa_id, 
            _type: self._type, 
            cve_id: self.cve_id, 
            ecosystem: self.ecosystem, 
            severity: self.severity, 
            cwes: self.cwes, 
            is_withdrawn: self.is_withdrawn, 
            affects: self.affects, 
            published: Some(published),
            updated: self.updated, 
            modified: self.modified, 
            epss_percentage: self.epss_percentage, 
            epss_percentile: self.epss_percentile, 
            before: self.before, 
            after: self.after, 
            direction: self.direction, 
            per_page: self.per_page, 
            sort: self.sort, 
        }
    }

    /// If specified, only return advisories that were updated on a date or date range.  For more information on the syntax of the date range, see \"[Understanding the search syntax](https://docs.github.com/search-github/getting-started-with-searching-on-github/understanding-the-search-syntax#query-for-dates).\"
    pub fn updated(self, updated: &'req str) -> Self {
        Self { 
            ghsa_id: self.ghsa_id, 
            _type: self._type, 
            cve_id: self.cve_id, 
            ecosystem: self.ecosystem, 
            severity: self.severity, 
            cwes: self.cwes, 
            is_withdrawn: self.is_withdrawn, 
            affects: self.affects, 
            published: self.published, 
            updated: Some(updated),
            modified: self.modified, 
            epss_percentage: self.epss_percentage, 
            epss_percentile: self.epss_percentile, 
            before: self.before, 
            after: self.after, 
            direction: self.direction, 
            per_page: self.per_page, 
            sort: self.sort, 
        }
    }

    /// If specified, only show advisories that were updated or published on a date or date range.  For more information on the syntax of the date range, see \"[Understanding the search syntax](https://docs.github.com/search-github/getting-started-with-searching-on-github/understanding-the-search-syntax#query-for-dates).\"
    pub fn modified(self, modified: &'req str) -> Self {
        Self { 
            ghsa_id: self.ghsa_id, 
            _type: self._type, 
            cve_id: self.cve_id, 
            ecosystem: self.ecosystem, 
            severity: self.severity, 
            cwes: self.cwes, 
            is_withdrawn: self.is_withdrawn, 
            affects: self.affects, 
            published: self.published, 
            updated: self.updated, 
            modified: Some(modified),
            epss_percentage: self.epss_percentage, 
            epss_percentile: self.epss_percentile, 
            before: self.before, 
            after: self.after, 
            direction: self.direction, 
            per_page: self.per_page, 
            sort: self.sort, 
        }
    }

    /// If specified, only return advisories that have an EPSS percentage score that matches the provided value. The EPSS percentage represents the likelihood of a CVE being exploited.
    pub fn epss_percentage(self, epss_percentage: &'req str) -> Self {
        Self { 
            ghsa_id: self.ghsa_id, 
            _type: self._type, 
            cve_id: self.cve_id, 
            ecosystem: self.ecosystem, 
            severity: self.severity, 
            cwes: self.cwes, 
            is_withdrawn: self.is_withdrawn, 
            affects: self.affects, 
            published: self.published, 
            updated: self.updated, 
            modified: self.modified, 
            epss_percentage: Some(epss_percentage),
            epss_percentile: self.epss_percentile, 
            before: self.before, 
            after: self.after, 
            direction: self.direction, 
            per_page: self.per_page, 
            sort: self.sort, 
        }
    }

    /// If specified, only return advisories that have an EPSS percentile score that matches the provided value. The EPSS percentile represents the relative rank of the CVE's likelihood of being exploited compared to other CVEs.
    pub fn epss_percentile(self, epss_percentile: &'req str) -> Self {
        Self { 
            ghsa_id: self.ghsa_id, 
            _type: self._type, 
            cve_id: self.cve_id, 
            ecosystem: self.ecosystem, 
            severity: self.severity, 
            cwes: self.cwes, 
            is_withdrawn: self.is_withdrawn, 
            affects: self.affects, 
            published: self.published, 
            updated: self.updated, 
            modified: self.modified, 
            epss_percentage: self.epss_percentage, 
            epss_percentile: Some(epss_percentile),
            before: self.before, 
            after: self.after, 
            direction: self.direction, 
            per_page: self.per_page, 
            sort: self.sort, 
        }
    }

    /// A cursor, as given in the [Link header](https://docs.github.com/rest/guides/using-pagination-in-the-rest-api#using-link-headers). If specified, the query only searches for results before this cursor. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    pub fn before(self, before: &'req str) -> Self {
        Self { 
            ghsa_id: self.ghsa_id, 
            _type: self._type, 
            cve_id: self.cve_id, 
            ecosystem: self.ecosystem, 
            severity: self.severity, 
            cwes: self.cwes, 
            is_withdrawn: self.is_withdrawn, 
            affects: self.affects, 
            published: self.published, 
            updated: self.updated, 
            modified: self.modified, 
            epss_percentage: self.epss_percentage, 
            epss_percentile: self.epss_percentile, 
            before: Some(before),
            after: self.after, 
            direction: self.direction, 
            per_page: self.per_page, 
            sort: self.sort, 
        }
    }

    /// A cursor, as given in the [Link header](https://docs.github.com/rest/guides/using-pagination-in-the-rest-api#using-link-headers). If specified, the query only searches for results after this cursor. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    pub fn after(self, after: &'req str) -> Self {
        Self { 
            ghsa_id: self.ghsa_id, 
            _type: self._type, 
            cve_id: self.cve_id, 
            ecosystem: self.ecosystem, 
            severity: self.severity, 
            cwes: self.cwes, 
            is_withdrawn: self.is_withdrawn, 
            affects: self.affects, 
            published: self.published, 
            updated: self.updated, 
            modified: self.modified, 
            epss_percentage: self.epss_percentage, 
            epss_percentile: self.epss_percentile, 
            before: self.before, 
            after: Some(after),
            direction: self.direction, 
            per_page: self.per_page, 
            sort: self.sort, 
        }
    }

    /// The direction to sort the results by.
    pub fn direction(self, direction: &'req str) -> Self {
        Self { 
            ghsa_id: self.ghsa_id, 
            _type: self._type, 
            cve_id: self.cve_id, 
            ecosystem: self.ecosystem, 
            severity: self.severity, 
            cwes: self.cwes, 
            is_withdrawn: self.is_withdrawn, 
            affects: self.affects, 
            published: self.published, 
            updated: self.updated, 
            modified: self.modified, 
            epss_percentage: self.epss_percentage, 
            epss_percentile: self.epss_percentile, 
            before: self.before, 
            after: self.after, 
            direction: Some(direction),
            per_page: self.per_page, 
            sort: self.sort, 
        }
    }

    /// The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    pub fn per_page(self, per_page: u16) -> Self {
        Self { 
            ghsa_id: self.ghsa_id, 
            _type: self._type, 
            cve_id: self.cve_id, 
            ecosystem: self.ecosystem, 
            severity: self.severity, 
            cwes: self.cwes, 
            is_withdrawn: self.is_withdrawn, 
            affects: self.affects, 
            published: self.published, 
            updated: self.updated, 
            modified: self.modified, 
            epss_percentage: self.epss_percentage, 
            epss_percentile: self.epss_percentile, 
            before: self.before, 
            after: self.after, 
            direction: self.direction, 
            per_page: Some(per_page),
            sort: self.sort, 
        }
    }

    /// The property to sort the results by.
    pub fn sort(self, sort: &'req str) -> Self {
        Self { 
            ghsa_id: self.ghsa_id, 
            _type: self._type, 
            cve_id: self.cve_id, 
            ecosystem: self.ecosystem, 
            severity: self.severity, 
            cwes: self.cwes, 
            is_withdrawn: self.is_withdrawn, 
            affects: self.affects, 
            published: self.published, 
            updated: self.updated, 
            modified: self.modified, 
            epss_percentage: self.epss_percentage, 
            epss_percentile: self.epss_percentile, 
            before: self.before, 
            after: self.after, 
            direction: self.direction, 
            per_page: self.per_page, 
            sort: Some(sort),
        }
    }
}

/// Query parameters for the [List repository security advisories for an organization](SecurityAdvisories::list_org_repository_advisories_async()) endpoint.
#[derive(Default, Serialize)]
pub struct SecurityAdvisoriesListOrgRepositoryAdvisoriesParams<'req> {
    /// The direction to sort the results by.
    direction: Option<&'req str>, 
    /// The property to sort the results by.
    sort: Option<&'req str>, 
    /// A cursor, as given in the [Link header](https://docs.github.com/rest/guides/using-pagination-in-the-rest-api#using-link-headers). If specified, the query only searches for results before this cursor. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    before: Option<&'req str>, 
    /// A cursor, as given in the [Link header](https://docs.github.com/rest/guides/using-pagination-in-the-rest-api#using-link-headers). If specified, the query only searches for results after this cursor. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    after: Option<&'req str>, 
    /// The number of advisories to return per page. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    per_page: Option<u16>, 
    /// Filter by the state of the repository advisories. Only advisories of this state will be returned.
    state: Option<&'req str>
}

impl<'req> SecurityAdvisoriesListOrgRepositoryAdvisoriesParams<'req> {
    pub fn new() -> Self {
        Self::default()
    }

    /// The direction to sort the results by.
    pub fn direction(self, direction: &'req str) -> Self {
        Self { 
            direction: Some(direction),
            sort: self.sort, 
            before: self.before, 
            after: self.after, 
            per_page: self.per_page, 
            state: self.state, 
        }
    }

    /// The property to sort the results by.
    pub fn sort(self, sort: &'req str) -> Self {
        Self { 
            direction: self.direction, 
            sort: Some(sort),
            before: self.before, 
            after: self.after, 
            per_page: self.per_page, 
            state: self.state, 
        }
    }

    /// A cursor, as given in the [Link header](https://docs.github.com/rest/guides/using-pagination-in-the-rest-api#using-link-headers). If specified, the query only searches for results before this cursor. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    pub fn before(self, before: &'req str) -> Self {
        Self { 
            direction: self.direction, 
            sort: self.sort, 
            before: Some(before),
            after: self.after, 
            per_page: self.per_page, 
            state: self.state, 
        }
    }

    /// A cursor, as given in the [Link header](https://docs.github.com/rest/guides/using-pagination-in-the-rest-api#using-link-headers). If specified, the query only searches for results after this cursor. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    pub fn after(self, after: &'req str) -> Self {
        Self { 
            direction: self.direction, 
            sort: self.sort, 
            before: self.before, 
            after: Some(after),
            per_page: self.per_page, 
            state: self.state, 
        }
    }

    /// The number of advisories to return per page. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    pub fn per_page(self, per_page: u16) -> Self {
        Self { 
            direction: self.direction, 
            sort: self.sort, 
            before: self.before, 
            after: self.after, 
            per_page: Some(per_page),
            state: self.state, 
        }
    }

    /// Filter by the state of the repository advisories. Only advisories of this state will be returned.
    pub fn state(self, state: &'req str) -> Self {
        Self { 
            direction: self.direction, 
            sort: self.sort, 
            before: self.before, 
            after: self.after, 
            per_page: self.per_page, 
            state: Some(state),
        }
    }
}

/// Query parameters for the [List repository security advisories](SecurityAdvisories::list_repository_advisories_async()) endpoint.
#[derive(Default, Serialize)]
pub struct SecurityAdvisoriesListRepositoryAdvisoriesParams<'req> {
    /// The direction to sort the results by.
    direction: Option<&'req str>, 
    /// The property to sort the results by.
    sort: Option<&'req str>, 
    /// A cursor, as given in the [Link header](https://docs.github.com/rest/guides/using-pagination-in-the-rest-api#using-link-headers). If specified, the query only searches for results before this cursor. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    before: Option<&'req str>, 
    /// A cursor, as given in the [Link header](https://docs.github.com/rest/guides/using-pagination-in-the-rest-api#using-link-headers). If specified, the query only searches for results after this cursor. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    after: Option<&'req str>, 
    /// The number of advisories to return per page. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    per_page: Option<u16>, 
    /// Filter by state of the repository advisories. Only advisories of this state will be returned.
    state: Option<&'req str>
}

impl<'req> SecurityAdvisoriesListRepositoryAdvisoriesParams<'req> {
    pub fn new() -> Self {
        Self::default()
    }

    /// The direction to sort the results by.
    pub fn direction(self, direction: &'req str) -> Self {
        Self { 
            direction: Some(direction),
            sort: self.sort, 
            before: self.before, 
            after: self.after, 
            per_page: self.per_page, 
            state: self.state, 
        }
    }

    /// The property to sort the results by.
    pub fn sort(self, sort: &'req str) -> Self {
        Self { 
            direction: self.direction, 
            sort: Some(sort),
            before: self.before, 
            after: self.after, 
            per_page: self.per_page, 
            state: self.state, 
        }
    }

    /// A cursor, as given in the [Link header](https://docs.github.com/rest/guides/using-pagination-in-the-rest-api#using-link-headers). If specified, the query only searches for results before this cursor. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    pub fn before(self, before: &'req str) -> Self {
        Self { 
            direction: self.direction, 
            sort: self.sort, 
            before: Some(before),
            after: self.after, 
            per_page: self.per_page, 
            state: self.state, 
        }
    }

    /// A cursor, as given in the [Link header](https://docs.github.com/rest/guides/using-pagination-in-the-rest-api#using-link-headers). If specified, the query only searches for results after this cursor. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    pub fn after(self, after: &'req str) -> Self {
        Self { 
            direction: self.direction, 
            sort: self.sort, 
            before: self.before, 
            after: Some(after),
            per_page: self.per_page, 
            state: self.state, 
        }
    }

    /// The number of advisories to return per page. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    pub fn per_page(self, per_page: u16) -> Self {
        Self { 
            direction: self.direction, 
            sort: self.sort, 
            before: self.before, 
            after: self.after, 
            per_page: Some(per_page),
            state: self.state, 
        }
    }

    /// Filter by state of the repository advisories. Only advisories of this state will be returned.
    pub fn state(self, state: &'req str) -> Self {
        Self { 
            direction: self.direction, 
            sort: self.sort, 
            before: self.before, 
            after: self.after, 
            per_page: self.per_page, 
            state: Some(state),
        }
    }
}


impl<'api> SecurityAdvisories<'api> {
    /// ---
    ///
    /// # Create a temporary private fork
    ///
    /// Create a temporary private fork to collaborate on fixing a security vulnerability in your repository.
    /// 
    /// > [!NOTE]
    /// > Forking a repository happens asynchronously. You may have to wait up to 5 minutes before you can access the fork.
    /// 
    /// [GitHub API docs for create_fork](https://docs.github.com/rest/security-advisories/repository-advisories#create-a-temporary-private-fork)
    ///
    /// ---
    pub async fn create_fork_async(&self, owner: &str, repo: &str, ghsa_id: &str) -> Result<FullRepository, SecurityAdvisoriesCreateForkError> {

        let request_uri = format!("{}/repos/{}/{}/security-advisories/{}/forks", super::GITHUB_BASE_API_URL, owner, repo, ghsa_id);


        let req = GitHubRequest {
            uri: request_uri,
            body: None,
            method: "POST",
            headers: vec![]
        };

        let request = GitHubRequestBuilder::build(req, self.auth)?;

        // --

        let github_response = crate::adapters::fetch_async(request).await?;

        // --

        if github_response.is_success() {
            Ok(crate::adapters::to_json_async(github_response).await?)
        } else {
            match github_response.status_code() {
                400 => Err(SecurityAdvisoriesCreateForkError::Status400(crate::adapters::to_json_async(github_response).await?)),
                422 => Err(SecurityAdvisoriesCreateForkError::Status422(crate::adapters::to_json_async(github_response).await?)),
                403 => Err(SecurityAdvisoriesCreateForkError::Status403(crate::adapters::to_json_async(github_response).await?)),
                404 => Err(SecurityAdvisoriesCreateForkError::Status404(crate::adapters::to_json_async(github_response).await?)),
                code => Err(SecurityAdvisoriesCreateForkError::Generic { code }),
            }
        }
    }

    /// ---
    ///
    /// # Create a temporary private fork
    ///
    /// Create a temporary private fork to collaborate on fixing a security vulnerability in your repository.
    /// 
    /// > [!NOTE]
    /// > Forking a repository happens asynchronously. You may have to wait up to 5 minutes before you can access the fork.
    /// 
    /// [GitHub API docs for create_fork](https://docs.github.com/rest/security-advisories/repository-advisories#create-a-temporary-private-fork)
    ///
    /// ---
    #[cfg(not(target_arch = "wasm32"))]
    pub fn create_fork(&self, owner: &str, repo: &str, ghsa_id: &str) -> Result<FullRepository, SecurityAdvisoriesCreateForkError> {

        let request_uri = format!("{}/repos/{}/{}/security-advisories/{}/forks", super::GITHUB_BASE_API_URL, owner, repo, ghsa_id);


        let req = GitHubRequest {
            uri: request_uri,
            body: None,
            method: "POST",
            headers: vec![]
        };

        let request = GitHubRequestBuilder::build(req, self.auth)?;

        // --

        let github_response = crate::adapters::fetch(request)?;

        // --

        if github_response.is_success() {
            Ok(crate::adapters::to_json(github_response)?)
        } else {
            match github_response.status_code() {
                400 => Err(SecurityAdvisoriesCreateForkError::Status400(crate::adapters::to_json(github_response)?)),
                422 => Err(SecurityAdvisoriesCreateForkError::Status422(crate::adapters::to_json(github_response)?)),
                403 => Err(SecurityAdvisoriesCreateForkError::Status403(crate::adapters::to_json(github_response)?)),
                404 => Err(SecurityAdvisoriesCreateForkError::Status404(crate::adapters::to_json(github_response)?)),
                code => Err(SecurityAdvisoriesCreateForkError::Generic { code }),
            }
        }
    }

    /// ---
    ///
    /// # Privately report a security vulnerability
    ///
    /// Report a security vulnerability to the maintainers of the repository.
    /// See "[Privately reporting a security vulnerability](https://docs.github.com/code-security/security-advisories/guidance-on-reporting-and-writing/privately-reporting-a-security-vulnerability)" for more information about private vulnerability reporting.
    /// 
    /// [GitHub API docs for create_private_vulnerability_report](https://docs.github.com/rest/security-advisories/repository-advisories#privately-report-a-security-vulnerability)
    ///
    /// ---
    pub async fn create_private_vulnerability_report_async(&self, owner: &str, repo: &str, body: PostSecurityAdvisoriesCreatePrivateVulnerabilityReport) -> Result<RepositoryAdvisory, SecurityAdvisoriesCreatePrivateVulnerabilityReportError> {

        let request_uri = format!("{}/repos/{}/{}/security-advisories/reports", super::GITHUB_BASE_API_URL, owner, repo);


        let req = GitHubRequest {
            uri: request_uri,
            body: Some(PostSecurityAdvisoriesCreatePrivateVulnerabilityReport::from_json(body)?),
            method: "POST",
            headers: vec![]
        };

        let request = GitHubRequestBuilder::build(req, self.auth)?;

        // --

        let github_response = crate::adapters::fetch_async(request).await?;

        // --

        if github_response.is_success() {
            Ok(crate::adapters::to_json_async(github_response).await?)
        } else {
            match github_response.status_code() {
                403 => Err(SecurityAdvisoriesCreatePrivateVulnerabilityReportError::Status403(crate::adapters::to_json_async(github_response).await?)),
                404 => Err(SecurityAdvisoriesCreatePrivateVulnerabilityReportError::Status404(crate::adapters::to_json_async(github_response).await?)),
                422 => Err(SecurityAdvisoriesCreatePrivateVulnerabilityReportError::Status422(crate::adapters::to_json_async(github_response).await?)),
                code => Err(SecurityAdvisoriesCreatePrivateVulnerabilityReportError::Generic { code }),
            }
        }
    }

    /// ---
    ///
    /// # Privately report a security vulnerability
    ///
    /// Report a security vulnerability to the maintainers of the repository.
    /// See "[Privately reporting a security vulnerability](https://docs.github.com/code-security/security-advisories/guidance-on-reporting-and-writing/privately-reporting-a-security-vulnerability)" for more information about private vulnerability reporting.
    /// 
    /// [GitHub API docs for create_private_vulnerability_report](https://docs.github.com/rest/security-advisories/repository-advisories#privately-report-a-security-vulnerability)
    ///
    /// ---
    #[cfg(not(target_arch = "wasm32"))]
    pub fn create_private_vulnerability_report(&self, owner: &str, repo: &str, body: PostSecurityAdvisoriesCreatePrivateVulnerabilityReport) -> Result<RepositoryAdvisory, SecurityAdvisoriesCreatePrivateVulnerabilityReportError> {

        let request_uri = format!("{}/repos/{}/{}/security-advisories/reports", super::GITHUB_BASE_API_URL, owner, repo);


        let req = GitHubRequest {
            uri: request_uri,
            body: Some(PostSecurityAdvisoriesCreatePrivateVulnerabilityReport::from_json(body)?),
            method: "POST",
            headers: vec![]
        };

        let request = GitHubRequestBuilder::build(req, self.auth)?;

        // --

        let github_response = crate::adapters::fetch(request)?;

        // --

        if github_response.is_success() {
            Ok(crate::adapters::to_json(github_response)?)
        } else {
            match github_response.status_code() {
                403 => Err(SecurityAdvisoriesCreatePrivateVulnerabilityReportError::Status403(crate::adapters::to_json(github_response)?)),
                404 => Err(SecurityAdvisoriesCreatePrivateVulnerabilityReportError::Status404(crate::adapters::to_json(github_response)?)),
                422 => Err(SecurityAdvisoriesCreatePrivateVulnerabilityReportError::Status422(crate::adapters::to_json(github_response)?)),
                code => Err(SecurityAdvisoriesCreatePrivateVulnerabilityReportError::Generic { code }),
            }
        }
    }

    /// ---
    ///
    /// # Create a repository security advisory
    ///
    /// Creates a new repository security advisory.
    /// 
    /// In order to create a draft repository security advisory, the authenticated user must be a security manager or administrator of that repository.
    /// 
    /// OAuth app tokens and personal access tokens (classic) need the `repo` or `repository_advisories:write` scope to use this endpoint.
    /// 
    /// [GitHub API docs for create_repository_advisory](https://docs.github.com/rest/security-advisories/repository-advisories#create-a-repository-security-advisory)
    ///
    /// ---
    pub async fn create_repository_advisory_async(&self, owner: &str, repo: &str, body: PostSecurityAdvisoriesCreateRepositoryAdvisory) -> Result<RepositoryAdvisory, SecurityAdvisoriesCreateRepositoryAdvisoryError> {

        let request_uri = format!("{}/repos/{}/{}/security-advisories", super::GITHUB_BASE_API_URL, owner, repo);


        let req = GitHubRequest {
            uri: request_uri,
            body: Some(PostSecurityAdvisoriesCreateRepositoryAdvisory::from_json(body)?),
            method: "POST",
            headers: vec![]
        };

        let request = GitHubRequestBuilder::build(req, self.auth)?;

        // --

        let github_response = crate::adapters::fetch_async(request).await?;

        // --

        if github_response.is_success() {
            Ok(crate::adapters::to_json_async(github_response).await?)
        } else {
            match github_response.status_code() {
                403 => Err(SecurityAdvisoriesCreateRepositoryAdvisoryError::Status403(crate::adapters::to_json_async(github_response).await?)),
                404 => Err(SecurityAdvisoriesCreateRepositoryAdvisoryError::Status404(crate::adapters::to_json_async(github_response).await?)),
                422 => Err(SecurityAdvisoriesCreateRepositoryAdvisoryError::Status422(crate::adapters::to_json_async(github_response).await?)),
                code => Err(SecurityAdvisoriesCreateRepositoryAdvisoryError::Generic { code }),
            }
        }
    }

    /// ---
    ///
    /// # Create a repository security advisory
    ///
    /// Creates a new repository security advisory.
    /// 
    /// In order to create a draft repository security advisory, the authenticated user must be a security manager or administrator of that repository.
    /// 
    /// OAuth app tokens and personal access tokens (classic) need the `repo` or `repository_advisories:write` scope to use this endpoint.
    /// 
    /// [GitHub API docs for create_repository_advisory](https://docs.github.com/rest/security-advisories/repository-advisories#create-a-repository-security-advisory)
    ///
    /// ---
    #[cfg(not(target_arch = "wasm32"))]
    pub fn create_repository_advisory(&self, owner: &str, repo: &str, body: PostSecurityAdvisoriesCreateRepositoryAdvisory) -> Result<RepositoryAdvisory, SecurityAdvisoriesCreateRepositoryAdvisoryError> {

        let request_uri = format!("{}/repos/{}/{}/security-advisories", super::GITHUB_BASE_API_URL, owner, repo);


        let req = GitHubRequest {
            uri: request_uri,
            body: Some(PostSecurityAdvisoriesCreateRepositoryAdvisory::from_json(body)?),
            method: "POST",
            headers: vec![]
        };

        let request = GitHubRequestBuilder::build(req, self.auth)?;

        // --

        let github_response = crate::adapters::fetch(request)?;

        // --

        if github_response.is_success() {
            Ok(crate::adapters::to_json(github_response)?)
        } else {
            match github_response.status_code() {
                403 => Err(SecurityAdvisoriesCreateRepositoryAdvisoryError::Status403(crate::adapters::to_json(github_response)?)),
                404 => Err(SecurityAdvisoriesCreateRepositoryAdvisoryError::Status404(crate::adapters::to_json(github_response)?)),
                422 => Err(SecurityAdvisoriesCreateRepositoryAdvisoryError::Status422(crate::adapters::to_json(github_response)?)),
                code => Err(SecurityAdvisoriesCreateRepositoryAdvisoryError::Generic { code }),
            }
        }
    }

    /// ---
    ///
    /// # Request a CVE for a repository security advisory
    ///
    /// If you want a CVE identification number for the security vulnerability in your project, and don't already have one, you can request a CVE identification number from GitHub. For more information see "[Requesting a CVE identification number](https://docs.github.com/code-security/security-advisories/repository-security-advisories/publishing-a-repository-security-advisory#requesting-a-cve-identification-number-optional)."
    /// 
    /// You may request a CVE for public repositories, but cannot do so for private repositories.
    /// 
    /// In order to request a CVE for a repository security advisory, the authenticated user must be a security manager or administrator of that repository.
    /// 
    /// OAuth app tokens and personal access tokens (classic) need the `repo` or `repository_advisories:write` scope to use this endpoint.
    /// 
    /// [GitHub API docs for create_repository_advisory_cve_request](https://docs.github.com/rest/security-advisories/repository-advisories#request-a-cve-for-a-repository-security-advisory)
    ///
    /// ---
    pub async fn create_repository_advisory_cve_request_async(&self, owner: &str, repo: &str, ghsa_id: &str) -> Result<HashMap<String, Value>, SecurityAdvisoriesCreateRepositoryAdvisoryCveRequestError> {

        let request_uri = format!("{}/repos/{}/{}/security-advisories/{}/cve", super::GITHUB_BASE_API_URL, owner, repo, ghsa_id);


        let req = GitHubRequest {
            uri: request_uri,
            body: None,
            method: "POST",
            headers: vec![]
        };

        let request = GitHubRequestBuilder::build(req, self.auth)?;

        // --

        let github_response = crate::adapters::fetch_async(request).await?;

        // --

        if github_response.is_success() {
            Ok(crate::adapters::to_json_async(github_response).await?)
        } else {
            match github_response.status_code() {
                400 => Err(SecurityAdvisoriesCreateRepositoryAdvisoryCveRequestError::Status400(crate::adapters::to_json_async(github_response).await?)),
                403 => Err(SecurityAdvisoriesCreateRepositoryAdvisoryCveRequestError::Status403(crate::adapters::to_json_async(github_response).await?)),
                404 => Err(SecurityAdvisoriesCreateRepositoryAdvisoryCveRequestError::Status404(crate::adapters::to_json_async(github_response).await?)),
                422 => Err(SecurityAdvisoriesCreateRepositoryAdvisoryCveRequestError::Status422(crate::adapters::to_json_async(github_response).await?)),
                code => Err(SecurityAdvisoriesCreateRepositoryAdvisoryCveRequestError::Generic { code }),
            }
        }
    }

    /// ---
    ///
    /// # Request a CVE for a repository security advisory
    ///
    /// If you want a CVE identification number for the security vulnerability in your project, and don't already have one, you can request a CVE identification number from GitHub. For more information see "[Requesting a CVE identification number](https://docs.github.com/code-security/security-advisories/repository-security-advisories/publishing-a-repository-security-advisory#requesting-a-cve-identification-number-optional)."
    /// 
    /// You may request a CVE for public repositories, but cannot do so for private repositories.
    /// 
    /// In order to request a CVE for a repository security advisory, the authenticated user must be a security manager or administrator of that repository.
    /// 
    /// OAuth app tokens and personal access tokens (classic) need the `repo` or `repository_advisories:write` scope to use this endpoint.
    /// 
    /// [GitHub API docs for create_repository_advisory_cve_request](https://docs.github.com/rest/security-advisories/repository-advisories#request-a-cve-for-a-repository-security-advisory)
    ///
    /// ---
    #[cfg(not(target_arch = "wasm32"))]
    pub fn create_repository_advisory_cve_request(&self, owner: &str, repo: &str, ghsa_id: &str) -> Result<HashMap<String, Value>, SecurityAdvisoriesCreateRepositoryAdvisoryCveRequestError> {

        let request_uri = format!("{}/repos/{}/{}/security-advisories/{}/cve", super::GITHUB_BASE_API_URL, owner, repo, ghsa_id);


        let req = GitHubRequest {
            uri: request_uri,
            body: None,
            method: "POST",
            headers: vec![]
        };

        let request = GitHubRequestBuilder::build(req, self.auth)?;

        // --

        let github_response = crate::adapters::fetch(request)?;

        // --

        if github_response.is_success() {
            Ok(crate::adapters::to_json(github_response)?)
        } else {
            match github_response.status_code() {
                400 => Err(SecurityAdvisoriesCreateRepositoryAdvisoryCveRequestError::Status400(crate::adapters::to_json(github_response)?)),
                403 => Err(SecurityAdvisoriesCreateRepositoryAdvisoryCveRequestError::Status403(crate::adapters::to_json(github_response)?)),
                404 => Err(SecurityAdvisoriesCreateRepositoryAdvisoryCveRequestError::Status404(crate::adapters::to_json(github_response)?)),
                422 => Err(SecurityAdvisoriesCreateRepositoryAdvisoryCveRequestError::Status422(crate::adapters::to_json(github_response)?)),
                code => Err(SecurityAdvisoriesCreateRepositoryAdvisoryCveRequestError::Generic { code }),
            }
        }
    }

    /// ---
    ///
    /// # Get a global security advisory
    ///
    /// Gets a global security advisory using its GitHub Security Advisory (GHSA) identifier.
    /// 
    /// [GitHub API docs for get_global_advisory](https://docs.github.com/rest/security-advisories/global-advisories#get-a-global-security-advisory)
    ///
    /// ---
    pub async fn get_global_advisory_async(&self, ghsa_id: &str) -> Result<GlobalAdvisory, SecurityAdvisoriesGetGlobalAdvisoryError> {

        let request_uri = format!("{}/advisories/{}", super::GITHUB_BASE_API_URL, ghsa_id);


        let req = GitHubRequest {
            uri: request_uri,
            body: None,
            method: "GET",
            headers: vec![]
        };

        let request = GitHubRequestBuilder::build(req, self.auth)?;

        // --

        let github_response = crate::adapters::fetch_async(request).await?;

        // --

        if github_response.is_success() {
            Ok(crate::adapters::to_json_async(github_response).await?)
        } else {
            match github_response.status_code() {
                404 => Err(SecurityAdvisoriesGetGlobalAdvisoryError::Status404(crate::adapters::to_json_async(github_response).await?)),
                code => Err(SecurityAdvisoriesGetGlobalAdvisoryError::Generic { code }),
            }
        }
    }

    /// ---
    ///
    /// # Get a global security advisory
    ///
    /// Gets a global security advisory using its GitHub Security Advisory (GHSA) identifier.
    /// 
    /// [GitHub API docs for get_global_advisory](https://docs.github.com/rest/security-advisories/global-advisories#get-a-global-security-advisory)
    ///
    /// ---
    #[cfg(not(target_arch = "wasm32"))]
    pub fn get_global_advisory(&self, ghsa_id: &str) -> Result<GlobalAdvisory, SecurityAdvisoriesGetGlobalAdvisoryError> {

        let request_uri = format!("{}/advisories/{}", super::GITHUB_BASE_API_URL, ghsa_id);


        let req = GitHubRequest {
            uri: request_uri,
            body: None,
            method: "GET",
            headers: vec![]
        };

        let request = GitHubRequestBuilder::build(req, self.auth)?;

        // --

        let github_response = crate::adapters::fetch(request)?;

        // --

        if github_response.is_success() {
            Ok(crate::adapters::to_json(github_response)?)
        } else {
            match github_response.status_code() {
                404 => Err(SecurityAdvisoriesGetGlobalAdvisoryError::Status404(crate::adapters::to_json(github_response)?)),
                code => Err(SecurityAdvisoriesGetGlobalAdvisoryError::Generic { code }),
            }
        }
    }

    /// ---
    ///
    /// # Get a repository security advisory
    ///
    /// Get a repository security advisory using its GitHub Security Advisory (GHSA) identifier.
    /// 
    /// Anyone can access any published security advisory on a public repository.
    /// 
    /// The authenticated user can access an unpublished security advisory from a repository if they are a security manager or administrator of that repository, or if they are a
    /// collaborator on the security advisory.
    /// 
    /// OAuth app tokens and personal access tokens (classic) need the `repo` or `repository_advisories:read` scope to to get a published security advisory in a private repository, or any unpublished security advisory that the authenticated user has access to.
    /// 
    /// [GitHub API docs for get_repository_advisory](https://docs.github.com/rest/security-advisories/repository-advisories#get-a-repository-security-advisory)
    ///
    /// ---
    pub async fn get_repository_advisory_async(&self, owner: &str, repo: &str, ghsa_id: &str) -> Result<RepositoryAdvisory, SecurityAdvisoriesGetRepositoryAdvisoryError> {

        let request_uri = format!("{}/repos/{}/{}/security-advisories/{}", super::GITHUB_BASE_API_URL, owner, repo, ghsa_id);


        let req = GitHubRequest {
            uri: request_uri,
            body: None,
            method: "GET",
            headers: vec![]
        };

        let request = GitHubRequestBuilder::build(req, self.auth)?;

        // --

        let github_response = crate::adapters::fetch_async(request).await?;

        // --

        if github_response.is_success() {
            Ok(crate::adapters::to_json_async(github_response).await?)
        } else {
            match github_response.status_code() {
                403 => Err(SecurityAdvisoriesGetRepositoryAdvisoryError::Status403(crate::adapters::to_json_async(github_response).await?)),
                404 => Err(SecurityAdvisoriesGetRepositoryAdvisoryError::Status404(crate::adapters::to_json_async(github_response).await?)),
                code => Err(SecurityAdvisoriesGetRepositoryAdvisoryError::Generic { code }),
            }
        }
    }

    /// ---
    ///
    /// # Get a repository security advisory
    ///
    /// Get a repository security advisory using its GitHub Security Advisory (GHSA) identifier.
    /// 
    /// Anyone can access any published security advisory on a public repository.
    /// 
    /// The authenticated user can access an unpublished security advisory from a repository if they are a security manager or administrator of that repository, or if they are a
    /// collaborator on the security advisory.
    /// 
    /// OAuth app tokens and personal access tokens (classic) need the `repo` or `repository_advisories:read` scope to to get a published security advisory in a private repository, or any unpublished security advisory that the authenticated user has access to.
    /// 
    /// [GitHub API docs for get_repository_advisory](https://docs.github.com/rest/security-advisories/repository-advisories#get-a-repository-security-advisory)
    ///
    /// ---
    #[cfg(not(target_arch = "wasm32"))]
    pub fn get_repository_advisory(&self, owner: &str, repo: &str, ghsa_id: &str) -> Result<RepositoryAdvisory, SecurityAdvisoriesGetRepositoryAdvisoryError> {

        let request_uri = format!("{}/repos/{}/{}/security-advisories/{}", super::GITHUB_BASE_API_URL, owner, repo, ghsa_id);


        let req = GitHubRequest {
            uri: request_uri,
            body: None,
            method: "GET",
            headers: vec![]
        };

        let request = GitHubRequestBuilder::build(req, self.auth)?;

        // --

        let github_response = crate::adapters::fetch(request)?;

        // --

        if github_response.is_success() {
            Ok(crate::adapters::to_json(github_response)?)
        } else {
            match github_response.status_code() {
                403 => Err(SecurityAdvisoriesGetRepositoryAdvisoryError::Status403(crate::adapters::to_json(github_response)?)),
                404 => Err(SecurityAdvisoriesGetRepositoryAdvisoryError::Status404(crate::adapters::to_json(github_response)?)),
                code => Err(SecurityAdvisoriesGetRepositoryAdvisoryError::Generic { code }),
            }
        }
    }

    /// ---
    ///
    /// # List global security advisories
    ///
    /// Lists all global security advisories that match the specified parameters. If no other parameters are defined, the request will return only GitHub-reviewed advisories that are not malware.
    /// 
    /// By default, all responses will exclude advisories for malware, because malware are not standard vulnerabilities. To list advisories for malware, you must include the `type` parameter in your request, with the value `malware`. For more information about the different types of security advisories, see "[About the GitHub Advisory database](https://docs.github.com/code-security/security-advisories/global-security-advisories/about-the-github-advisory-database#about-types-of-security-advisories)."
    /// 
    /// [GitHub API docs for list_global_advisories](https://docs.github.com/rest/security-advisories/global-advisories#list-global-security-advisories)
    ///
    /// ---
    pub async fn list_global_advisories_async(&self, query_params: Option<impl Into<SecurityAdvisoriesListGlobalAdvisoriesParams<'api>>>) -> Result<Vec<GlobalAdvisory>, SecurityAdvisoriesListGlobalAdvisoriesError> {

        let mut request_uri = format!("{}/advisories", super::GITHUB_BASE_API_URL);

        if let Some(params) = query_params {
            request_uri.push_str("?");
            request_uri.push_str(&serde_urlencoded::to_string(params.into())?);
        }

        let req = GitHubRequest {
            uri: request_uri,
            body: None,
            method: "GET",
            headers: vec![]
        };

        let request = GitHubRequestBuilder::build(req, self.auth)?;

        // --

        let github_response = crate::adapters::fetch_async(request).await?;

        // --

        if github_response.is_success() {
            Ok(crate::adapters::to_json_async(github_response).await?)
        } else {
            match github_response.status_code() {
                429 => Err(SecurityAdvisoriesListGlobalAdvisoriesError::Status429(crate::adapters::to_json_async(github_response).await?)),
                422 => Err(SecurityAdvisoriesListGlobalAdvisoriesError::Status422(crate::adapters::to_json_async(github_response).await?)),
                code => Err(SecurityAdvisoriesListGlobalAdvisoriesError::Generic { code }),
            }
        }
    }

    /// ---
    ///
    /// # List global security advisories
    ///
    /// Lists all global security advisories that match the specified parameters. If no other parameters are defined, the request will return only GitHub-reviewed advisories that are not malware.
    /// 
    /// By default, all responses will exclude advisories for malware, because malware are not standard vulnerabilities. To list advisories for malware, you must include the `type` parameter in your request, with the value `malware`. For more information about the different types of security advisories, see "[About the GitHub Advisory database](https://docs.github.com/code-security/security-advisories/global-security-advisories/about-the-github-advisory-database#about-types-of-security-advisories)."
    /// 
    /// [GitHub API docs for list_global_advisories](https://docs.github.com/rest/security-advisories/global-advisories#list-global-security-advisories)
    ///
    /// ---
    #[cfg(not(target_arch = "wasm32"))]
    pub fn list_global_advisories(&self, query_params: Option<impl Into<SecurityAdvisoriesListGlobalAdvisoriesParams<'api>>>) -> Result<Vec<GlobalAdvisory>, SecurityAdvisoriesListGlobalAdvisoriesError> {

        let mut request_uri = format!("{}/advisories", super::GITHUB_BASE_API_URL);

        if let Some(params) = query_params {
            request_uri.push_str("?");
            let qp: SecurityAdvisoriesListGlobalAdvisoriesParams = params.into();
            request_uri.push_str(&serde_urlencoded::to_string(qp)?);
        }

        let req = GitHubRequest {
            uri: request_uri,
            body: None,
            method: "GET",
            headers: vec![]
        };

        let request = GitHubRequestBuilder::build(req, self.auth)?;

        // --

        let github_response = crate::adapters::fetch(request)?;

        // --

        if github_response.is_success() {
            Ok(crate::adapters::to_json(github_response)?)
        } else {
            match github_response.status_code() {
                429 => Err(SecurityAdvisoriesListGlobalAdvisoriesError::Status429(crate::adapters::to_json(github_response)?)),
                422 => Err(SecurityAdvisoriesListGlobalAdvisoriesError::Status422(crate::adapters::to_json(github_response)?)),
                code => Err(SecurityAdvisoriesListGlobalAdvisoriesError::Generic { code }),
            }
        }
    }

    /// ---
    ///
    /// # List repository security advisories for an organization
    ///
    /// Lists repository security advisories for an organization.
    /// 
    /// The authenticated user must be an owner or security manager for the organization to use this endpoint.
    /// 
    /// OAuth app tokens and personal access tokens (classic) need the `repo` or `repository_advisories:write` scope to use this endpoint.
    /// 
    /// [GitHub API docs for list_org_repository_advisories](https://docs.github.com/rest/security-advisories/repository-advisories#list-repository-security-advisories-for-an-organization)
    ///
    /// ---
    pub async fn list_org_repository_advisories_async(&self, org: &str, query_params: Option<impl Into<SecurityAdvisoriesListOrgRepositoryAdvisoriesParams<'api>>>) -> Result<Vec<RepositoryAdvisory>, SecurityAdvisoriesListOrgRepositoryAdvisoriesError> {

        let mut request_uri = format!("{}/orgs/{}/security-advisories", super::GITHUB_BASE_API_URL, org);

        if let Some(params) = query_params {
            request_uri.push_str("?");
            request_uri.push_str(&serde_urlencoded::to_string(params.into())?);
        }

        let req = GitHubRequest {
            uri: request_uri,
            body: None,
            method: "GET",
            headers: vec![]
        };

        let request = GitHubRequestBuilder::build(req, self.auth)?;

        // --

        let github_response = crate::adapters::fetch_async(request).await?;

        // --

        if github_response.is_success() {
            Ok(crate::adapters::to_json_async(github_response).await?)
        } else {
            match github_response.status_code() {
                400 => Err(SecurityAdvisoriesListOrgRepositoryAdvisoriesError::Status400(crate::adapters::to_json_async(github_response).await?)),
                404 => Err(SecurityAdvisoriesListOrgRepositoryAdvisoriesError::Status404(crate::adapters::to_json_async(github_response).await?)),
                code => Err(SecurityAdvisoriesListOrgRepositoryAdvisoriesError::Generic { code }),
            }
        }
    }

    /// ---
    ///
    /// # List repository security advisories for an organization
    ///
    /// Lists repository security advisories for an organization.
    /// 
    /// The authenticated user must be an owner or security manager for the organization to use this endpoint.
    /// 
    /// OAuth app tokens and personal access tokens (classic) need the `repo` or `repository_advisories:write` scope to use this endpoint.
    /// 
    /// [GitHub API docs for list_org_repository_advisories](https://docs.github.com/rest/security-advisories/repository-advisories#list-repository-security-advisories-for-an-organization)
    ///
    /// ---
    #[cfg(not(target_arch = "wasm32"))]
    pub fn list_org_repository_advisories(&self, org: &str, query_params: Option<impl Into<SecurityAdvisoriesListOrgRepositoryAdvisoriesParams<'api>>>) -> Result<Vec<RepositoryAdvisory>, SecurityAdvisoriesListOrgRepositoryAdvisoriesError> {

        let mut request_uri = format!("{}/orgs/{}/security-advisories", super::GITHUB_BASE_API_URL, org);

        if let Some(params) = query_params {
            request_uri.push_str("?");
            let qp: SecurityAdvisoriesListOrgRepositoryAdvisoriesParams = params.into();
            request_uri.push_str(&serde_urlencoded::to_string(qp)?);
        }

        let req = GitHubRequest {
            uri: request_uri,
            body: None,
            method: "GET",
            headers: vec![]
        };

        let request = GitHubRequestBuilder::build(req, self.auth)?;

        // --

        let github_response = crate::adapters::fetch(request)?;

        // --

        if github_response.is_success() {
            Ok(crate::adapters::to_json(github_response)?)
        } else {
            match github_response.status_code() {
                400 => Err(SecurityAdvisoriesListOrgRepositoryAdvisoriesError::Status400(crate::adapters::to_json(github_response)?)),
                404 => Err(SecurityAdvisoriesListOrgRepositoryAdvisoriesError::Status404(crate::adapters::to_json(github_response)?)),
                code => Err(SecurityAdvisoriesListOrgRepositoryAdvisoriesError::Generic { code }),
            }
        }
    }

    /// ---
    ///
    /// # List repository security advisories
    ///
    /// Lists security advisories in a repository.
    /// 
    /// The authenticated user can access unpublished security advisories from a repository if they are a security manager or administrator of that repository, or if they are a collaborator on any security advisory.
    /// 
    /// OAuth app tokens and personal access tokens (classic) need the `repo` or `repository_advisories:read` scope to to get a published security advisory in a private repository, or any unpublished security advisory that the authenticated user has access to.
    /// 
    /// [GitHub API docs for list_repository_advisories](https://docs.github.com/rest/security-advisories/repository-advisories#list-repository-security-advisories)
    ///
    /// ---
    pub async fn list_repository_advisories_async(&self, owner: &str, repo: &str, query_params: Option<impl Into<SecurityAdvisoriesListRepositoryAdvisoriesParams<'api>>>) -> Result<Vec<RepositoryAdvisory>, SecurityAdvisoriesListRepositoryAdvisoriesError> {

        let mut request_uri = format!("{}/repos/{}/{}/security-advisories", super::GITHUB_BASE_API_URL, owner, repo);

        if let Some(params) = query_params {
            request_uri.push_str("?");
            request_uri.push_str(&serde_urlencoded::to_string(params.into())?);
        }

        let req = GitHubRequest {
            uri: request_uri,
            body: None,
            method: "GET",
            headers: vec![]
        };

        let request = GitHubRequestBuilder::build(req, self.auth)?;

        // --

        let github_response = crate::adapters::fetch_async(request).await?;

        // --

        if github_response.is_success() {
            Ok(crate::adapters::to_json_async(github_response).await?)
        } else {
            match github_response.status_code() {
                400 => Err(SecurityAdvisoriesListRepositoryAdvisoriesError::Status400(crate::adapters::to_json_async(github_response).await?)),
                404 => Err(SecurityAdvisoriesListRepositoryAdvisoriesError::Status404(crate::adapters::to_json_async(github_response).await?)),
                code => Err(SecurityAdvisoriesListRepositoryAdvisoriesError::Generic { code }),
            }
        }
    }

    /// ---
    ///
    /// # List repository security advisories
    ///
    /// Lists security advisories in a repository.
    /// 
    /// The authenticated user can access unpublished security advisories from a repository if they are a security manager or administrator of that repository, or if they are a collaborator on any security advisory.
    /// 
    /// OAuth app tokens and personal access tokens (classic) need the `repo` or `repository_advisories:read` scope to to get a published security advisory in a private repository, or any unpublished security advisory that the authenticated user has access to.
    /// 
    /// [GitHub API docs for list_repository_advisories](https://docs.github.com/rest/security-advisories/repository-advisories#list-repository-security-advisories)
    ///
    /// ---
    #[cfg(not(target_arch = "wasm32"))]
    pub fn list_repository_advisories(&self, owner: &str, repo: &str, query_params: Option<impl Into<SecurityAdvisoriesListRepositoryAdvisoriesParams<'api>>>) -> Result<Vec<RepositoryAdvisory>, SecurityAdvisoriesListRepositoryAdvisoriesError> {

        let mut request_uri = format!("{}/repos/{}/{}/security-advisories", super::GITHUB_BASE_API_URL, owner, repo);

        if let Some(params) = query_params {
            request_uri.push_str("?");
            let qp: SecurityAdvisoriesListRepositoryAdvisoriesParams = params.into();
            request_uri.push_str(&serde_urlencoded::to_string(qp)?);
        }

        let req = GitHubRequest {
            uri: request_uri,
            body: None,
            method: "GET",
            headers: vec![]
        };

        let request = GitHubRequestBuilder::build(req, self.auth)?;

        // --

        let github_response = crate::adapters::fetch(request)?;

        // --

        if github_response.is_success() {
            Ok(crate::adapters::to_json(github_response)?)
        } else {
            match github_response.status_code() {
                400 => Err(SecurityAdvisoriesListRepositoryAdvisoriesError::Status400(crate::adapters::to_json(github_response)?)),
                404 => Err(SecurityAdvisoriesListRepositoryAdvisoriesError::Status404(crate::adapters::to_json(github_response)?)),
                code => Err(SecurityAdvisoriesListRepositoryAdvisoriesError::Generic { code }),
            }
        }
    }

    /// ---
    ///
    /// # Update a repository security advisory
    ///
    /// Update a repository security advisory using its GitHub Security Advisory (GHSA) identifier.
    /// 
    /// In order to update any security advisory, the authenticated user must be a security manager or administrator of that repository,
    /// or a collaborator on the repository security advisory.
    /// 
    /// OAuth app tokens and personal access tokens (classic) need the `repo` or `repository_advisories:write` scope to use this endpoint.
    /// 
    /// [GitHub API docs for update_repository_advisory](https://docs.github.com/rest/security-advisories/repository-advisories#update-a-repository-security-advisory)
    ///
    /// ---
    pub async fn update_repository_advisory_async(&self, owner: &str, repo: &str, ghsa_id: &str, body: PatchSecurityAdvisoriesUpdateRepositoryAdvisory) -> Result<RepositoryAdvisory, SecurityAdvisoriesUpdateRepositoryAdvisoryError> {

        let request_uri = format!("{}/repos/{}/{}/security-advisories/{}", super::GITHUB_BASE_API_URL, owner, repo, ghsa_id);


        let req = GitHubRequest {
            uri: request_uri,
            body: Some(PatchSecurityAdvisoriesUpdateRepositoryAdvisory::from_json(body)?),
            method: "PATCH",
            headers: vec![]
        };

        let request = GitHubRequestBuilder::build(req, self.auth)?;

        // --

        let github_response = crate::adapters::fetch_async(request).await?;

        // --

        if github_response.is_success() {
            Ok(crate::adapters::to_json_async(github_response).await?)
        } else {
            match github_response.status_code() {
                403 => Err(SecurityAdvisoriesUpdateRepositoryAdvisoryError::Status403(crate::adapters::to_json_async(github_response).await?)),
                404 => Err(SecurityAdvisoriesUpdateRepositoryAdvisoryError::Status404(crate::adapters::to_json_async(github_response).await?)),
                422 => Err(SecurityAdvisoriesUpdateRepositoryAdvisoryError::Status422(crate::adapters::to_json_async(github_response).await?)),
                code => Err(SecurityAdvisoriesUpdateRepositoryAdvisoryError::Generic { code }),
            }
        }
    }

    /// ---
    ///
    /// # Update a repository security advisory
    ///
    /// Update a repository security advisory using its GitHub Security Advisory (GHSA) identifier.
    /// 
    /// In order to update any security advisory, the authenticated user must be a security manager or administrator of that repository,
    /// or a collaborator on the repository security advisory.
    /// 
    /// OAuth app tokens and personal access tokens (classic) need the `repo` or `repository_advisories:write` scope to use this endpoint.
    /// 
    /// [GitHub API docs for update_repository_advisory](https://docs.github.com/rest/security-advisories/repository-advisories#update-a-repository-security-advisory)
    ///
    /// ---
    #[cfg(not(target_arch = "wasm32"))]
    pub fn update_repository_advisory(&self, owner: &str, repo: &str, ghsa_id: &str, body: PatchSecurityAdvisoriesUpdateRepositoryAdvisory) -> Result<RepositoryAdvisory, SecurityAdvisoriesUpdateRepositoryAdvisoryError> {

        let request_uri = format!("{}/repos/{}/{}/security-advisories/{}", super::GITHUB_BASE_API_URL, owner, repo, ghsa_id);


        let req = GitHubRequest {
            uri: request_uri,
            body: Some(PatchSecurityAdvisoriesUpdateRepositoryAdvisory::from_json(body)?),
            method: "PATCH",
            headers: vec![]
        };

        let request = GitHubRequestBuilder::build(req, self.auth)?;

        // --

        let github_response = crate::adapters::fetch(request)?;

        // --

        if github_response.is_success() {
            Ok(crate::adapters::to_json(github_response)?)
        } else {
            match github_response.status_code() {
                403 => Err(SecurityAdvisoriesUpdateRepositoryAdvisoryError::Status403(crate::adapters::to_json(github_response)?)),
                404 => Err(SecurityAdvisoriesUpdateRepositoryAdvisoryError::Status404(crate::adapters::to_json(github_response)?)),
                422 => Err(SecurityAdvisoriesUpdateRepositoryAdvisoryError::Status422(crate::adapters::to_json(github_response)?)),
                code => Err(SecurityAdvisoriesUpdateRepositoryAdvisoryError::Generic { code }),
            }
        }
    }

}
