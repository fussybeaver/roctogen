//! Method, error and parameter types for the Reactions endpoint.
#![allow(
    clippy::all
)]
/* 
 * GitHub v3 REST API
 *
 * GitHub's v3 REST API.
 *
 * OpenAPI spec version: 1.1.4
 * 
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 */

use serde::Deserialize;

use crate::adapters::{AdapterError, Client, GitHubRequest, GitHubResponseExt};
use crate::models::*;

use super::PerPage;

use std::collections::HashMap;
use serde_json::value::Value;

pub struct Reactions<'api, C: Client> where AdapterError: From<<C as Client>::Err> {
    client: &'api C
}

pub fn new<C: Client>(client: &C) -> Reactions<C> where AdapterError: From<<C as Client>::Err> {
    Reactions { client }
}

/// Errors for the [Create reaction for a commit comment](Reactions::create_for_commit_comment_async()) endpoint.
#[derive(Debug, thiserror::Error)]
pub enum ReactionsCreateForCommitCommentError {
    #[error("Reaction created")]
    Status201(Reaction),
    #[error("Validation failed, or the endpoint has been spammed.")]
    Status422(ValidationError),
    #[error("Status code: {}", code)]
    Generic { code: u16 },
}

impl From<ReactionsCreateForCommitCommentError> for AdapterError {
    fn from(err: ReactionsCreateForCommitCommentError) -> Self {
        let (description, status_code) = match err {
            ReactionsCreateForCommitCommentError::Status201(_) => (String::from("Reaction created"), 201),
            ReactionsCreateForCommitCommentError::Status422(_) => (String::from("Validation failed, or the endpoint has been spammed."), 422),
            ReactionsCreateForCommitCommentError::Generic { code } => (String::from("Generic"), code)
        };

        Self::Endpoint {
            description,
            status_code,
            source: Some(Box::new(err))
        }
    }
}

/// Errors for the [Create reaction for an issue](Reactions::create_for_issue_async()) endpoint.
#[derive(Debug, thiserror::Error)]
pub enum ReactionsCreateForIssueError {
    #[error("Response")]
    Status201(Reaction),
    #[error("Validation failed, or the endpoint has been spammed.")]
    Status422(ValidationError),
    #[error("Status code: {}", code)]
    Generic { code: u16 },
}

impl From<ReactionsCreateForIssueError> for AdapterError {
    fn from(err: ReactionsCreateForIssueError) -> Self {
        let (description, status_code) = match err {
            ReactionsCreateForIssueError::Status201(_) => (String::from("Response"), 201),
            ReactionsCreateForIssueError::Status422(_) => (String::from("Validation failed, or the endpoint has been spammed."), 422),
            ReactionsCreateForIssueError::Generic { code } => (String::from("Generic"), code)
        };

        Self::Endpoint {
            description,
            status_code,
            source: Some(Box::new(err))
        }
    }
}

/// Errors for the [Create reaction for an issue comment](Reactions::create_for_issue_comment_async()) endpoint.
#[derive(Debug, thiserror::Error)]
pub enum ReactionsCreateForIssueCommentError {
    #[error("Reaction created")]
    Status201(Reaction),
    #[error("Validation failed, or the endpoint has been spammed.")]
    Status422(ValidationError),
    #[error("Status code: {}", code)]
    Generic { code: u16 },
}

impl From<ReactionsCreateForIssueCommentError> for AdapterError {
    fn from(err: ReactionsCreateForIssueCommentError) -> Self {
        let (description, status_code) = match err {
            ReactionsCreateForIssueCommentError::Status201(_) => (String::from("Reaction created"), 201),
            ReactionsCreateForIssueCommentError::Status422(_) => (String::from("Validation failed, or the endpoint has been spammed."), 422),
            ReactionsCreateForIssueCommentError::Generic { code } => (String::from("Generic"), code)
        };

        Self::Endpoint {
            description,
            status_code,
            source: Some(Box::new(err))
        }
    }
}

/// Errors for the [Create reaction for a pull request review comment](Reactions::create_for_pull_request_review_comment_async()) endpoint.
#[derive(Debug, thiserror::Error)]
pub enum ReactionsCreateForPullRequestReviewCommentError {
    #[error("Reaction created")]
    Status201(Reaction),
    #[error("Validation failed, or the endpoint has been spammed.")]
    Status422(ValidationError),
    #[error("Status code: {}", code)]
    Generic { code: u16 },
}

impl From<ReactionsCreateForPullRequestReviewCommentError> for AdapterError {
    fn from(err: ReactionsCreateForPullRequestReviewCommentError) -> Self {
        let (description, status_code) = match err {
            ReactionsCreateForPullRequestReviewCommentError::Status201(_) => (String::from("Reaction created"), 201),
            ReactionsCreateForPullRequestReviewCommentError::Status422(_) => (String::from("Validation failed, or the endpoint has been spammed."), 422),
            ReactionsCreateForPullRequestReviewCommentError::Generic { code } => (String::from("Generic"), code)
        };

        Self::Endpoint {
            description,
            status_code,
            source: Some(Box::new(err))
        }
    }
}

/// Errors for the [Create reaction for a release](Reactions::create_for_release_async()) endpoint.
#[derive(Debug, thiserror::Error)]
pub enum ReactionsCreateForReleaseError {
    #[error("Reaction created")]
    Status201(Reaction),
    #[error("Validation failed, or the endpoint has been spammed.")]
    Status422(ValidationError),
    #[error("Status code: {}", code)]
    Generic { code: u16 },
}

impl From<ReactionsCreateForReleaseError> for AdapterError {
    fn from(err: ReactionsCreateForReleaseError) -> Self {
        let (description, status_code) = match err {
            ReactionsCreateForReleaseError::Status201(_) => (String::from("Reaction created"), 201),
            ReactionsCreateForReleaseError::Status422(_) => (String::from("Validation failed, or the endpoint has been spammed."), 422),
            ReactionsCreateForReleaseError::Generic { code } => (String::from("Generic"), code)
        };

        Self::Endpoint {
            description,
            status_code,
            source: Some(Box::new(err))
        }
    }
}

/// Errors for the [Create reaction for a team discussion comment](Reactions::create_for_team_discussion_comment_in_org_async()) endpoint.
#[derive(Debug, thiserror::Error)]
pub enum ReactionsCreateForTeamDiscussionCommentInOrgError {
    #[error("Response")]
    Status201(Reaction),
    #[error("Status code: {}", code)]
    Generic { code: u16 },
}

impl From<ReactionsCreateForTeamDiscussionCommentInOrgError> for AdapterError {
    fn from(err: ReactionsCreateForTeamDiscussionCommentInOrgError) -> Self {
        let (description, status_code) = match err {
            ReactionsCreateForTeamDiscussionCommentInOrgError::Status201(_) => (String::from("Response"), 201),
            ReactionsCreateForTeamDiscussionCommentInOrgError::Generic { code } => (String::from("Generic"), code)
        };

        Self::Endpoint {
            description,
            status_code,
            source: Some(Box::new(err))
        }
    }
}

/// Errors for the [Create reaction for a team discussion comment (Legacy)](Reactions::create_for_team_discussion_comment_legacy_async()) endpoint.
#[derive(Debug, thiserror::Error)]
pub enum ReactionsCreateForTeamDiscussionCommentLegacyError {
    #[error("Status code: {}", code)]
    Generic { code: u16 },
}

impl From<ReactionsCreateForTeamDiscussionCommentLegacyError> for AdapterError {
    fn from(err: ReactionsCreateForTeamDiscussionCommentLegacyError) -> Self {
        let (description, status_code) = match err {
            ReactionsCreateForTeamDiscussionCommentLegacyError::Generic { code } => (String::from("Generic"), code)
        };

        Self::Endpoint {
            description,
            status_code,
            source: Some(Box::new(err))
        }
    }
}

/// Errors for the [Create reaction for a team discussion](Reactions::create_for_team_discussion_in_org_async()) endpoint.
#[derive(Debug, thiserror::Error)]
pub enum ReactionsCreateForTeamDiscussionInOrgError {
    #[error("Response")]
    Status201(Reaction),
    #[error("Status code: {}", code)]
    Generic { code: u16 },
}

impl From<ReactionsCreateForTeamDiscussionInOrgError> for AdapterError {
    fn from(err: ReactionsCreateForTeamDiscussionInOrgError) -> Self {
        let (description, status_code) = match err {
            ReactionsCreateForTeamDiscussionInOrgError::Status201(_) => (String::from("Response"), 201),
            ReactionsCreateForTeamDiscussionInOrgError::Generic { code } => (String::from("Generic"), code)
        };

        Self::Endpoint {
            description,
            status_code,
            source: Some(Box::new(err))
        }
    }
}

/// Errors for the [Create reaction for a team discussion (Legacy)](Reactions::create_for_team_discussion_legacy_async()) endpoint.
#[derive(Debug, thiserror::Error)]
pub enum ReactionsCreateForTeamDiscussionLegacyError {
    #[error("Status code: {}", code)]
    Generic { code: u16 },
}

impl From<ReactionsCreateForTeamDiscussionLegacyError> for AdapterError {
    fn from(err: ReactionsCreateForTeamDiscussionLegacyError) -> Self {
        let (description, status_code) = match err {
            ReactionsCreateForTeamDiscussionLegacyError::Generic { code } => (String::from("Generic"), code)
        };

        Self::Endpoint {
            description,
            status_code,
            source: Some(Box::new(err))
        }
    }
}

/// Errors for the [Delete a commit comment reaction](Reactions::delete_for_commit_comment_async()) endpoint.
#[derive(Debug, thiserror::Error)]
pub enum ReactionsDeleteForCommitCommentError {
    #[error("Status code: {}", code)]
    Generic { code: u16 },
}

impl From<ReactionsDeleteForCommitCommentError> for AdapterError {
    fn from(err: ReactionsDeleteForCommitCommentError) -> Self {
        let (description, status_code) = match err {
            ReactionsDeleteForCommitCommentError::Generic { code } => (String::from("Generic"), code)
        };

        Self::Endpoint {
            description,
            status_code,
            source: Some(Box::new(err))
        }
    }
}

/// Errors for the [Delete an issue reaction](Reactions::delete_for_issue_async()) endpoint.
#[derive(Debug, thiserror::Error)]
pub enum ReactionsDeleteForIssueError {
    #[error("Status code: {}", code)]
    Generic { code: u16 },
}

impl From<ReactionsDeleteForIssueError> for AdapterError {
    fn from(err: ReactionsDeleteForIssueError) -> Self {
        let (description, status_code) = match err {
            ReactionsDeleteForIssueError::Generic { code } => (String::from("Generic"), code)
        };

        Self::Endpoint {
            description,
            status_code,
            source: Some(Box::new(err))
        }
    }
}

/// Errors for the [Delete an issue comment reaction](Reactions::delete_for_issue_comment_async()) endpoint.
#[derive(Debug, thiserror::Error)]
pub enum ReactionsDeleteForIssueCommentError {
    #[error("Status code: {}", code)]
    Generic { code: u16 },
}

impl From<ReactionsDeleteForIssueCommentError> for AdapterError {
    fn from(err: ReactionsDeleteForIssueCommentError) -> Self {
        let (description, status_code) = match err {
            ReactionsDeleteForIssueCommentError::Generic { code } => (String::from("Generic"), code)
        };

        Self::Endpoint {
            description,
            status_code,
            source: Some(Box::new(err))
        }
    }
}

/// Errors for the [Delete a pull request comment reaction](Reactions::delete_for_pull_request_comment_async()) endpoint.
#[derive(Debug, thiserror::Error)]
pub enum ReactionsDeleteForPullRequestCommentError {
    #[error("Status code: {}", code)]
    Generic { code: u16 },
}

impl From<ReactionsDeleteForPullRequestCommentError> for AdapterError {
    fn from(err: ReactionsDeleteForPullRequestCommentError) -> Self {
        let (description, status_code) = match err {
            ReactionsDeleteForPullRequestCommentError::Generic { code } => (String::from("Generic"), code)
        };

        Self::Endpoint {
            description,
            status_code,
            source: Some(Box::new(err))
        }
    }
}

/// Errors for the [Delete a release reaction](Reactions::delete_for_release_async()) endpoint.
#[derive(Debug, thiserror::Error)]
pub enum ReactionsDeleteForReleaseError {
    #[error("Status code: {}", code)]
    Generic { code: u16 },
}

impl From<ReactionsDeleteForReleaseError> for AdapterError {
    fn from(err: ReactionsDeleteForReleaseError) -> Self {
        let (description, status_code) = match err {
            ReactionsDeleteForReleaseError::Generic { code } => (String::from("Generic"), code)
        };

        Self::Endpoint {
            description,
            status_code,
            source: Some(Box::new(err))
        }
    }
}

/// Errors for the [Delete team discussion reaction](Reactions::delete_for_team_discussion_async()) endpoint.
#[derive(Debug, thiserror::Error)]
pub enum ReactionsDeleteForTeamDiscussionError {
    #[error("Status code: {}", code)]
    Generic { code: u16 },
}

impl From<ReactionsDeleteForTeamDiscussionError> for AdapterError {
    fn from(err: ReactionsDeleteForTeamDiscussionError) -> Self {
        let (description, status_code) = match err {
            ReactionsDeleteForTeamDiscussionError::Generic { code } => (String::from("Generic"), code)
        };

        Self::Endpoint {
            description,
            status_code,
            source: Some(Box::new(err))
        }
    }
}

/// Errors for the [Delete team discussion comment reaction](Reactions::delete_for_team_discussion_comment_async()) endpoint.
#[derive(Debug, thiserror::Error)]
pub enum ReactionsDeleteForTeamDiscussionCommentError {
    #[error("Status code: {}", code)]
    Generic { code: u16 },
}

impl From<ReactionsDeleteForTeamDiscussionCommentError> for AdapterError {
    fn from(err: ReactionsDeleteForTeamDiscussionCommentError) -> Self {
        let (description, status_code) = match err {
            ReactionsDeleteForTeamDiscussionCommentError::Generic { code } => (String::from("Generic"), code)
        };

        Self::Endpoint {
            description,
            status_code,
            source: Some(Box::new(err))
        }
    }
}

/// Errors for the [List reactions for a commit comment](Reactions::list_for_commit_comment_async()) endpoint.
#[derive(Debug, thiserror::Error)]
pub enum ReactionsListForCommitCommentError {
    #[error("Resource not found")]
    Status404(BasicError),
    #[error("Status code: {}", code)]
    Generic { code: u16 },
}

impl From<ReactionsListForCommitCommentError> for AdapterError {
    fn from(err: ReactionsListForCommitCommentError) -> Self {
        let (description, status_code) = match err {
            ReactionsListForCommitCommentError::Status404(_) => (String::from("Resource not found"), 404),
            ReactionsListForCommitCommentError::Generic { code } => (String::from("Generic"), code)
        };

        Self::Endpoint {
            description,
            status_code,
            source: Some(Box::new(err))
        }
    }
}

/// Errors for the [List reactions for an issue](Reactions::list_for_issue_async()) endpoint.
#[derive(Debug, thiserror::Error)]
pub enum ReactionsListForIssueError {
    #[error("Resource not found")]
    Status404(BasicError),
    #[error("Gone")]
    Status410(BasicError),
    #[error("Status code: {}", code)]
    Generic { code: u16 },
}

impl From<ReactionsListForIssueError> for AdapterError {
    fn from(err: ReactionsListForIssueError) -> Self {
        let (description, status_code) = match err {
            ReactionsListForIssueError::Status404(_) => (String::from("Resource not found"), 404),
            ReactionsListForIssueError::Status410(_) => (String::from("Gone"), 410),
            ReactionsListForIssueError::Generic { code } => (String::from("Generic"), code)
        };

        Self::Endpoint {
            description,
            status_code,
            source: Some(Box::new(err))
        }
    }
}

/// Errors for the [List reactions for an issue comment](Reactions::list_for_issue_comment_async()) endpoint.
#[derive(Debug, thiserror::Error)]
pub enum ReactionsListForIssueCommentError {
    #[error("Resource not found")]
    Status404(BasicError),
    #[error("Status code: {}", code)]
    Generic { code: u16 },
}

impl From<ReactionsListForIssueCommentError> for AdapterError {
    fn from(err: ReactionsListForIssueCommentError) -> Self {
        let (description, status_code) = match err {
            ReactionsListForIssueCommentError::Status404(_) => (String::from("Resource not found"), 404),
            ReactionsListForIssueCommentError::Generic { code } => (String::from("Generic"), code)
        };

        Self::Endpoint {
            description,
            status_code,
            source: Some(Box::new(err))
        }
    }
}

/// Errors for the [List reactions for a pull request review comment](Reactions::list_for_pull_request_review_comment_async()) endpoint.
#[derive(Debug, thiserror::Error)]
pub enum ReactionsListForPullRequestReviewCommentError {
    #[error("Resource not found")]
    Status404(BasicError),
    #[error("Status code: {}", code)]
    Generic { code: u16 },
}

impl From<ReactionsListForPullRequestReviewCommentError> for AdapterError {
    fn from(err: ReactionsListForPullRequestReviewCommentError) -> Self {
        let (description, status_code) = match err {
            ReactionsListForPullRequestReviewCommentError::Status404(_) => (String::from("Resource not found"), 404),
            ReactionsListForPullRequestReviewCommentError::Generic { code } => (String::from("Generic"), code)
        };

        Self::Endpoint {
            description,
            status_code,
            source: Some(Box::new(err))
        }
    }
}

/// Errors for the [List reactions for a release](Reactions::list_for_release_async()) endpoint.
#[derive(Debug, thiserror::Error)]
pub enum ReactionsListForReleaseError {
    #[error("Resource not found")]
    Status404(BasicError),
    #[error("Status code: {}", code)]
    Generic { code: u16 },
}

impl From<ReactionsListForReleaseError> for AdapterError {
    fn from(err: ReactionsListForReleaseError) -> Self {
        let (description, status_code) = match err {
            ReactionsListForReleaseError::Status404(_) => (String::from("Resource not found"), 404),
            ReactionsListForReleaseError::Generic { code } => (String::from("Generic"), code)
        };

        Self::Endpoint {
            description,
            status_code,
            source: Some(Box::new(err))
        }
    }
}

/// Errors for the [List reactions for a team discussion comment](Reactions::list_for_team_discussion_comment_in_org_async()) endpoint.
#[derive(Debug, thiserror::Error)]
pub enum ReactionsListForTeamDiscussionCommentInOrgError {
    #[error("Status code: {}", code)]
    Generic { code: u16 },
}

impl From<ReactionsListForTeamDiscussionCommentInOrgError> for AdapterError {
    fn from(err: ReactionsListForTeamDiscussionCommentInOrgError) -> Self {
        let (description, status_code) = match err {
            ReactionsListForTeamDiscussionCommentInOrgError::Generic { code } => (String::from("Generic"), code)
        };

        Self::Endpoint {
            description,
            status_code,
            source: Some(Box::new(err))
        }
    }
}

/// Errors for the [List reactions for a team discussion comment (Legacy)](Reactions::list_for_team_discussion_comment_legacy_async()) endpoint.
#[derive(Debug, thiserror::Error)]
pub enum ReactionsListForTeamDiscussionCommentLegacyError {
    #[error("Status code: {}", code)]
    Generic { code: u16 },
}

impl From<ReactionsListForTeamDiscussionCommentLegacyError> for AdapterError {
    fn from(err: ReactionsListForTeamDiscussionCommentLegacyError) -> Self {
        let (description, status_code) = match err {
            ReactionsListForTeamDiscussionCommentLegacyError::Generic { code } => (String::from("Generic"), code)
        };

        Self::Endpoint {
            description,
            status_code,
            source: Some(Box::new(err))
        }
    }
}

/// Errors for the [List reactions for a team discussion](Reactions::list_for_team_discussion_in_org_async()) endpoint.
#[derive(Debug, thiserror::Error)]
pub enum ReactionsListForTeamDiscussionInOrgError {
    #[error("Status code: {}", code)]
    Generic { code: u16 },
}

impl From<ReactionsListForTeamDiscussionInOrgError> for AdapterError {
    fn from(err: ReactionsListForTeamDiscussionInOrgError) -> Self {
        let (description, status_code) = match err {
            ReactionsListForTeamDiscussionInOrgError::Generic { code } => (String::from("Generic"), code)
        };

        Self::Endpoint {
            description,
            status_code,
            source: Some(Box::new(err))
        }
    }
}

/// Errors for the [List reactions for a team discussion (Legacy)](Reactions::list_for_team_discussion_legacy_async()) endpoint.
#[derive(Debug, thiserror::Error)]
pub enum ReactionsListForTeamDiscussionLegacyError {
    #[error("Status code: {}", code)]
    Generic { code: u16 },
}

impl From<ReactionsListForTeamDiscussionLegacyError> for AdapterError {
    fn from(err: ReactionsListForTeamDiscussionLegacyError) -> Self {
        let (description, status_code) = match err {
            ReactionsListForTeamDiscussionLegacyError::Generic { code } => (String::from("Generic"), code)
        };

        Self::Endpoint {
            description,
            status_code,
            source: Some(Box::new(err))
        }
    }
}


/// Query parameters for the [List reactions for a commit comment](Reactions::list_for_commit_comment_async()) endpoint.
#[derive(Default, Serialize)]
pub struct ReactionsListForCommitCommentParams<'req> {
    /// Returns a single [reaction type](https://docs.github.com/rest/reactions/reactions#about-reactions). Omit this parameter to list all reactions to a commit comment.
    content: Option<&'req str>, 
    /// The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    per_page: Option<u16>, 
    /// The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    page: Option<u16>
}

impl<'req> ReactionsListForCommitCommentParams<'req> {
    pub fn new() -> Self {
        Self::default()
    }

    /// Returns a single [reaction type](https://docs.github.com/rest/reactions/reactions#about-reactions). Omit this parameter to list all reactions to a commit comment.
    pub fn content(self, content: &'req str) -> Self {
        Self {
            content: Some(content),
            per_page: self.per_page, 
            page: self.page, 
        }
    }

    /// The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    pub fn per_page(self, per_page: u16) -> Self {
        Self {
            content: self.content, 
            per_page: Some(per_page),
            page: self.page, 
        }
    }

    /// The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    pub fn page(self, page: u16) -> Self {
        Self {
            content: self.content, 
            per_page: self.per_page, 
            page: Some(page),
        }
    }
}

impl<'enc> From<&'enc PerPage> for ReactionsListForCommitCommentParams<'enc> {
    fn from(per_page: &'enc PerPage) -> Self {
        Self {
            per_page: Some(per_page.per_page),
            page: Some(per_page.page),
            ..Default::default()
        }
    }
}
/// Query parameters for the [List reactions for an issue](Reactions::list_for_issue_async()) endpoint.
#[derive(Default, Serialize)]
pub struct ReactionsListForIssueParams<'req> {
    /// Returns a single [reaction type](https://docs.github.com/rest/reactions/reactions#about-reactions). Omit this parameter to list all reactions to an issue.
    content: Option<&'req str>, 
    /// The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    per_page: Option<u16>, 
    /// The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    page: Option<u16>
}

impl<'req> ReactionsListForIssueParams<'req> {
    pub fn new() -> Self {
        Self::default()
    }

    /// Returns a single [reaction type](https://docs.github.com/rest/reactions/reactions#about-reactions). Omit this parameter to list all reactions to an issue.
    pub fn content(self, content: &'req str) -> Self {
        Self {
            content: Some(content),
            per_page: self.per_page, 
            page: self.page, 
        }
    }

    /// The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    pub fn per_page(self, per_page: u16) -> Self {
        Self {
            content: self.content, 
            per_page: Some(per_page),
            page: self.page, 
        }
    }

    /// The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    pub fn page(self, page: u16) -> Self {
        Self {
            content: self.content, 
            per_page: self.per_page, 
            page: Some(page),
        }
    }
}

impl<'enc> From<&'enc PerPage> for ReactionsListForIssueParams<'enc> {
    fn from(per_page: &'enc PerPage) -> Self {
        Self {
            per_page: Some(per_page.per_page),
            page: Some(per_page.page),
            ..Default::default()
        }
    }
}
/// Query parameters for the [List reactions for an issue comment](Reactions::list_for_issue_comment_async()) endpoint.
#[derive(Default, Serialize)]
pub struct ReactionsListForIssueCommentParams<'req> {
    /// Returns a single [reaction type](https://docs.github.com/rest/reactions/reactions#about-reactions). Omit this parameter to list all reactions to an issue comment.
    content: Option<&'req str>, 
    /// The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    per_page: Option<u16>, 
    /// The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    page: Option<u16>
}

impl<'req> ReactionsListForIssueCommentParams<'req> {
    pub fn new() -> Self {
        Self::default()
    }

    /// Returns a single [reaction type](https://docs.github.com/rest/reactions/reactions#about-reactions). Omit this parameter to list all reactions to an issue comment.
    pub fn content(self, content: &'req str) -> Self {
        Self {
            content: Some(content),
            per_page: self.per_page, 
            page: self.page, 
        }
    }

    /// The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    pub fn per_page(self, per_page: u16) -> Self {
        Self {
            content: self.content, 
            per_page: Some(per_page),
            page: self.page, 
        }
    }

    /// The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    pub fn page(self, page: u16) -> Self {
        Self {
            content: self.content, 
            per_page: self.per_page, 
            page: Some(page),
        }
    }
}

impl<'enc> From<&'enc PerPage> for ReactionsListForIssueCommentParams<'enc> {
    fn from(per_page: &'enc PerPage) -> Self {
        Self {
            per_page: Some(per_page.per_page),
            page: Some(per_page.page),
            ..Default::default()
        }
    }
}
/// Query parameters for the [List reactions for a pull request review comment](Reactions::list_for_pull_request_review_comment_async()) endpoint.
#[derive(Default, Serialize)]
pub struct ReactionsListForPullRequestReviewCommentParams<'req> {
    /// Returns a single [reaction type](https://docs.github.com/rest/reactions/reactions#about-reactions). Omit this parameter to list all reactions to a pull request review comment.
    content: Option<&'req str>, 
    /// The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    per_page: Option<u16>, 
    /// The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    page: Option<u16>
}

impl<'req> ReactionsListForPullRequestReviewCommentParams<'req> {
    pub fn new() -> Self {
        Self::default()
    }

    /// Returns a single [reaction type](https://docs.github.com/rest/reactions/reactions#about-reactions). Omit this parameter to list all reactions to a pull request review comment.
    pub fn content(self, content: &'req str) -> Self {
        Self {
            content: Some(content),
            per_page: self.per_page, 
            page: self.page, 
        }
    }

    /// The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    pub fn per_page(self, per_page: u16) -> Self {
        Self {
            content: self.content, 
            per_page: Some(per_page),
            page: self.page, 
        }
    }

    /// The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    pub fn page(self, page: u16) -> Self {
        Self {
            content: self.content, 
            per_page: self.per_page, 
            page: Some(page),
        }
    }
}

impl<'enc> From<&'enc PerPage> for ReactionsListForPullRequestReviewCommentParams<'enc> {
    fn from(per_page: &'enc PerPage) -> Self {
        Self {
            per_page: Some(per_page.per_page),
            page: Some(per_page.page),
            ..Default::default()
        }
    }
}
/// Query parameters for the [List reactions for a release](Reactions::list_for_release_async()) endpoint.
#[derive(Default, Serialize)]
pub struct ReactionsListForReleaseParams<'req> {
    /// Returns a single [reaction type](https://docs.github.com/rest/reactions/reactions#about-reactions). Omit this parameter to list all reactions to a release.
    content: Option<&'req str>, 
    /// The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    per_page: Option<u16>, 
    /// The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    page: Option<u16>
}

impl<'req> ReactionsListForReleaseParams<'req> {
    pub fn new() -> Self {
        Self::default()
    }

    /// Returns a single [reaction type](https://docs.github.com/rest/reactions/reactions#about-reactions). Omit this parameter to list all reactions to a release.
    pub fn content(self, content: &'req str) -> Self {
        Self {
            content: Some(content),
            per_page: self.per_page, 
            page: self.page, 
        }
    }

    /// The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    pub fn per_page(self, per_page: u16) -> Self {
        Self {
            content: self.content, 
            per_page: Some(per_page),
            page: self.page, 
        }
    }

    /// The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    pub fn page(self, page: u16) -> Self {
        Self {
            content: self.content, 
            per_page: self.per_page, 
            page: Some(page),
        }
    }
}

impl<'enc> From<&'enc PerPage> for ReactionsListForReleaseParams<'enc> {
    fn from(per_page: &'enc PerPage) -> Self {
        Self {
            per_page: Some(per_page.per_page),
            page: Some(per_page.page),
            ..Default::default()
        }
    }
}
/// Query parameters for the [List reactions for a team discussion comment](Reactions::list_for_team_discussion_comment_in_org_async()) endpoint.
#[derive(Default, Serialize)]
pub struct ReactionsListForTeamDiscussionCommentInOrgParams<'req> {
    /// Returns a single [reaction type](https://docs.github.com/rest/reactions/reactions#about-reactions). Omit this parameter to list all reactions to a team discussion comment.
    content: Option<&'req str>, 
    /// The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    per_page: Option<u16>, 
    /// The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    page: Option<u16>
}

impl<'req> ReactionsListForTeamDiscussionCommentInOrgParams<'req> {
    pub fn new() -> Self {
        Self::default()
    }

    /// Returns a single [reaction type](https://docs.github.com/rest/reactions/reactions#about-reactions). Omit this parameter to list all reactions to a team discussion comment.
    pub fn content(self, content: &'req str) -> Self {
        Self {
            content: Some(content),
            per_page: self.per_page, 
            page: self.page, 
        }
    }

    /// The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    pub fn per_page(self, per_page: u16) -> Self {
        Self {
            content: self.content, 
            per_page: Some(per_page),
            page: self.page, 
        }
    }

    /// The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    pub fn page(self, page: u16) -> Self {
        Self {
            content: self.content, 
            per_page: self.per_page, 
            page: Some(page),
        }
    }
}

impl<'enc> From<&'enc PerPage> for ReactionsListForTeamDiscussionCommentInOrgParams<'enc> {
    fn from(per_page: &'enc PerPage) -> Self {
        Self {
            per_page: Some(per_page.per_page),
            page: Some(per_page.page),
            ..Default::default()
        }
    }
}
/// Query parameters for the [List reactions for a team discussion comment (Legacy)](Reactions::list_for_team_discussion_comment_legacy_async()) endpoint.
#[derive(Default, Serialize)]
pub struct ReactionsListForTeamDiscussionCommentLegacyParams<'req> {
    /// Returns a single [reaction type](https://docs.github.com/rest/reactions/reactions#about-reactions). Omit this parameter to list all reactions to a team discussion comment.
    content: Option<&'req str>, 
    /// The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    per_page: Option<u16>, 
    /// The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    page: Option<u16>
}

impl<'req> ReactionsListForTeamDiscussionCommentLegacyParams<'req> {
    pub fn new() -> Self {
        Self::default()
    }

    /// Returns a single [reaction type](https://docs.github.com/rest/reactions/reactions#about-reactions). Omit this parameter to list all reactions to a team discussion comment.
    pub fn content(self, content: &'req str) -> Self {
        Self {
            content: Some(content),
            per_page: self.per_page, 
            page: self.page, 
        }
    }

    /// The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    pub fn per_page(self, per_page: u16) -> Self {
        Self {
            content: self.content, 
            per_page: Some(per_page),
            page: self.page, 
        }
    }

    /// The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    pub fn page(self, page: u16) -> Self {
        Self {
            content: self.content, 
            per_page: self.per_page, 
            page: Some(page),
        }
    }
}

impl<'enc> From<&'enc PerPage> for ReactionsListForTeamDiscussionCommentLegacyParams<'enc> {
    fn from(per_page: &'enc PerPage) -> Self {
        Self {
            per_page: Some(per_page.per_page),
            page: Some(per_page.page),
            ..Default::default()
        }
    }
}
/// Query parameters for the [List reactions for a team discussion](Reactions::list_for_team_discussion_in_org_async()) endpoint.
#[derive(Default, Serialize)]
pub struct ReactionsListForTeamDiscussionInOrgParams<'req> {
    /// Returns a single [reaction type](https://docs.github.com/rest/reactions/reactions#about-reactions). Omit this parameter to list all reactions to a team discussion.
    content: Option<&'req str>, 
    /// The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    per_page: Option<u16>, 
    /// The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    page: Option<u16>
}

impl<'req> ReactionsListForTeamDiscussionInOrgParams<'req> {
    pub fn new() -> Self {
        Self::default()
    }

    /// Returns a single [reaction type](https://docs.github.com/rest/reactions/reactions#about-reactions). Omit this parameter to list all reactions to a team discussion.
    pub fn content(self, content: &'req str) -> Self {
        Self {
            content: Some(content),
            per_page: self.per_page, 
            page: self.page, 
        }
    }

    /// The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    pub fn per_page(self, per_page: u16) -> Self {
        Self {
            content: self.content, 
            per_page: Some(per_page),
            page: self.page, 
        }
    }

    /// The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    pub fn page(self, page: u16) -> Self {
        Self {
            content: self.content, 
            per_page: self.per_page, 
            page: Some(page),
        }
    }
}

impl<'enc> From<&'enc PerPage> for ReactionsListForTeamDiscussionInOrgParams<'enc> {
    fn from(per_page: &'enc PerPage) -> Self {
        Self {
            per_page: Some(per_page.per_page),
            page: Some(per_page.page),
            ..Default::default()
        }
    }
}
/// Query parameters for the [List reactions for a team discussion (Legacy)](Reactions::list_for_team_discussion_legacy_async()) endpoint.
#[derive(Default, Serialize)]
pub struct ReactionsListForTeamDiscussionLegacyParams<'req> {
    /// Returns a single [reaction type](https://docs.github.com/rest/reactions/reactions#about-reactions). Omit this parameter to list all reactions to a team discussion.
    content: Option<&'req str>, 
    /// The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    per_page: Option<u16>, 
    /// The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    page: Option<u16>
}

impl<'req> ReactionsListForTeamDiscussionLegacyParams<'req> {
    pub fn new() -> Self {
        Self::default()
    }

    /// Returns a single [reaction type](https://docs.github.com/rest/reactions/reactions#about-reactions). Omit this parameter to list all reactions to a team discussion.
    pub fn content(self, content: &'req str) -> Self {
        Self {
            content: Some(content),
            per_page: self.per_page, 
            page: self.page, 
        }
    }

    /// The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    pub fn per_page(self, per_page: u16) -> Self {
        Self {
            content: self.content, 
            per_page: Some(per_page),
            page: self.page, 
        }
    }

    /// The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    pub fn page(self, page: u16) -> Self {
        Self {
            content: self.content, 
            per_page: self.per_page, 
            page: Some(page),
        }
    }
}

impl<'enc> From<&'enc PerPage> for ReactionsListForTeamDiscussionLegacyParams<'enc> {
    fn from(per_page: &'enc PerPage) -> Self {
        Self {
            per_page: Some(per_page.per_page),
            page: Some(per_page.page),
            ..Default::default()
        }
    }
}

impl<'api, C: Client> Reactions<'api, C> where AdapterError: From<<C as Client>::Err> {
    /// ---
    ///
    /// # Create reaction for a commit comment
    ///
    /// Create a reaction to a [commit comment](https://docs.github.com/rest/commits/comments#get-a-commit-comment). A response with an HTTP `200` status means that you already added the reaction type to this commit comment.
    ///
    /// [GitHub API docs for create_for_commit_comment](https://docs.github.com/rest/reactions/reactions#create-reaction-for-a-commit-comment)
    ///
    /// ---
    pub async fn create_for_commit_comment_async(&self, owner: &str, repo: &str, comment_id: i64, body: PostReactionsCreateForCommitComment) -> Result<Reaction, AdapterError> {

        let request_uri = format!("{}/repos/{}/{}/comments/{}/reactions", super::GITHUB_BASE_API_URL, owner, repo, comment_id);


        let req = GitHubRequest {
            uri: request_uri,
            body: Some(C::from_json::<PostReactionsCreateForCommitComment>(body)?),
            method: "POST",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch_async(request).await?;

        // --

        if github_response.is_success() {
            Ok(github_response.to_json_async().await?)
        } else {
            match github_response.status_code() {
                201 => Err(ReactionsCreateForCommitCommentError::Status201(github_response.to_json_async().await?).into()),
                422 => Err(ReactionsCreateForCommitCommentError::Status422(github_response.to_json_async().await?).into()),
                code => Err(ReactionsCreateForCommitCommentError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # Create reaction for a commit comment
    ///
    /// Create a reaction to a [commit comment](https://docs.github.com/rest/commits/comments#get-a-commit-comment). A response with an HTTP `200` status means that you already added the reaction type to this commit comment.
    ///
    /// [GitHub API docs for create_for_commit_comment](https://docs.github.com/rest/reactions/reactions#create-reaction-for-a-commit-comment)
    ///
    /// ---
    #[cfg(not(target_arch = "wasm32"))]
    pub fn create_for_commit_comment(&self, owner: &str, repo: &str, comment_id: i64, body: PostReactionsCreateForCommitComment) -> Result<Reaction, AdapterError> {

        let request_uri = format!("{}/repos/{}/{}/comments/{}/reactions", super::GITHUB_BASE_API_URL, owner, repo, comment_id);


        let req = GitHubRequest {
            uri: request_uri,
            body: Some(C::from_json::<PostReactionsCreateForCommitComment>(body)?),
            method: "POST",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch(request)?;

        // --

        if github_response.is_success() {
            Ok(github_response.to_json()?)
        } else {
            match github_response.status_code() {
                201 => Err(ReactionsCreateForCommitCommentError::Status201(github_response.to_json()?).into()),
                422 => Err(ReactionsCreateForCommitCommentError::Status422(github_response.to_json()?).into()),
                code => Err(ReactionsCreateForCommitCommentError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # Create reaction for an issue
    ///
    /// Create a reaction to an [issue](https://docs.github.com/rest/issues/issues#get-an-issue). A response with an HTTP `200` status means that you already added the reaction type to this issue.
    ///
    /// [GitHub API docs for create_for_issue](https://docs.github.com/rest/reactions/reactions#create-reaction-for-an-issue)
    ///
    /// ---
    pub async fn create_for_issue_async(&self, owner: &str, repo: &str, issue_number: i32, body: PostReactionsCreateForIssue) -> Result<Reaction, AdapterError> {

        let request_uri = format!("{}/repos/{}/{}/issues/{}/reactions", super::GITHUB_BASE_API_URL, owner, repo, issue_number);


        let req = GitHubRequest {
            uri: request_uri,
            body: Some(C::from_json::<PostReactionsCreateForIssue>(body)?),
            method: "POST",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch_async(request).await?;

        // --

        if github_response.is_success() {
            Ok(github_response.to_json_async().await?)
        } else {
            match github_response.status_code() {
                201 => Err(ReactionsCreateForIssueError::Status201(github_response.to_json_async().await?).into()),
                422 => Err(ReactionsCreateForIssueError::Status422(github_response.to_json_async().await?).into()),
                code => Err(ReactionsCreateForIssueError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # Create reaction for an issue
    ///
    /// Create a reaction to an [issue](https://docs.github.com/rest/issues/issues#get-an-issue). A response with an HTTP `200` status means that you already added the reaction type to this issue.
    ///
    /// [GitHub API docs for create_for_issue](https://docs.github.com/rest/reactions/reactions#create-reaction-for-an-issue)
    ///
    /// ---
    #[cfg(not(target_arch = "wasm32"))]
    pub fn create_for_issue(&self, owner: &str, repo: &str, issue_number: i32, body: PostReactionsCreateForIssue) -> Result<Reaction, AdapterError> {

        let request_uri = format!("{}/repos/{}/{}/issues/{}/reactions", super::GITHUB_BASE_API_URL, owner, repo, issue_number);


        let req = GitHubRequest {
            uri: request_uri,
            body: Some(C::from_json::<PostReactionsCreateForIssue>(body)?),
            method: "POST",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch(request)?;

        // --

        if github_response.is_success() {
            Ok(github_response.to_json()?)
        } else {
            match github_response.status_code() {
                201 => Err(ReactionsCreateForIssueError::Status201(github_response.to_json()?).into()),
                422 => Err(ReactionsCreateForIssueError::Status422(github_response.to_json()?).into()),
                code => Err(ReactionsCreateForIssueError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # Create reaction for an issue comment
    ///
    /// Create a reaction to an [issue comment](https://docs.github.com/rest/issues/comments#get-an-issue-comment). A response with an HTTP `200` status means that you already added the reaction type to this issue comment.
    ///
    /// [GitHub API docs for create_for_issue_comment](https://docs.github.com/rest/reactions/reactions#create-reaction-for-an-issue-comment)
    ///
    /// ---
    pub async fn create_for_issue_comment_async(&self, owner: &str, repo: &str, comment_id: i64, body: PostReactionsCreateForIssueComment) -> Result<Reaction, AdapterError> {

        let request_uri = format!("{}/repos/{}/{}/issues/comments/{}/reactions", super::GITHUB_BASE_API_URL, owner, repo, comment_id);


        let req = GitHubRequest {
            uri: request_uri,
            body: Some(C::from_json::<PostReactionsCreateForIssueComment>(body)?),
            method: "POST",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch_async(request).await?;

        // --

        if github_response.is_success() {
            Ok(github_response.to_json_async().await?)
        } else {
            match github_response.status_code() {
                201 => Err(ReactionsCreateForIssueCommentError::Status201(github_response.to_json_async().await?).into()),
                422 => Err(ReactionsCreateForIssueCommentError::Status422(github_response.to_json_async().await?).into()),
                code => Err(ReactionsCreateForIssueCommentError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # Create reaction for an issue comment
    ///
    /// Create a reaction to an [issue comment](https://docs.github.com/rest/issues/comments#get-an-issue-comment). A response with an HTTP `200` status means that you already added the reaction type to this issue comment.
    ///
    /// [GitHub API docs for create_for_issue_comment](https://docs.github.com/rest/reactions/reactions#create-reaction-for-an-issue-comment)
    ///
    /// ---
    #[cfg(not(target_arch = "wasm32"))]
    pub fn create_for_issue_comment(&self, owner: &str, repo: &str, comment_id: i64, body: PostReactionsCreateForIssueComment) -> Result<Reaction, AdapterError> {

        let request_uri = format!("{}/repos/{}/{}/issues/comments/{}/reactions", super::GITHUB_BASE_API_URL, owner, repo, comment_id);


        let req = GitHubRequest {
            uri: request_uri,
            body: Some(C::from_json::<PostReactionsCreateForIssueComment>(body)?),
            method: "POST",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch(request)?;

        // --

        if github_response.is_success() {
            Ok(github_response.to_json()?)
        } else {
            match github_response.status_code() {
                201 => Err(ReactionsCreateForIssueCommentError::Status201(github_response.to_json()?).into()),
                422 => Err(ReactionsCreateForIssueCommentError::Status422(github_response.to_json()?).into()),
                code => Err(ReactionsCreateForIssueCommentError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # Create reaction for a pull request review comment
    ///
    /// Create a reaction to a [pull request review comment](https://docs.github.com/rest/pulls/comments#get-a-review-comment-for-a-pull-request). A response with an HTTP `200` status means that you already added the reaction type to this pull request review comment.
    ///
    /// [GitHub API docs for create_for_pull_request_review_comment](https://docs.github.com/rest/reactions/reactions#create-reaction-for-a-pull-request-review-comment)
    ///
    /// ---
    pub async fn create_for_pull_request_review_comment_async(&self, owner: &str, repo: &str, comment_id: i64, body: PostReactionsCreateForPullRequestReviewComment) -> Result<Reaction, AdapterError> {

        let request_uri = format!("{}/repos/{}/{}/pulls/comments/{}/reactions", super::GITHUB_BASE_API_URL, owner, repo, comment_id);


        let req = GitHubRequest {
            uri: request_uri,
            body: Some(C::from_json::<PostReactionsCreateForPullRequestReviewComment>(body)?),
            method: "POST",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch_async(request).await?;

        // --

        if github_response.is_success() {
            Ok(github_response.to_json_async().await?)
        } else {
            match github_response.status_code() {
                201 => Err(ReactionsCreateForPullRequestReviewCommentError::Status201(github_response.to_json_async().await?).into()),
                422 => Err(ReactionsCreateForPullRequestReviewCommentError::Status422(github_response.to_json_async().await?).into()),
                code => Err(ReactionsCreateForPullRequestReviewCommentError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # Create reaction for a pull request review comment
    ///
    /// Create a reaction to a [pull request review comment](https://docs.github.com/rest/pulls/comments#get-a-review-comment-for-a-pull-request). A response with an HTTP `200` status means that you already added the reaction type to this pull request review comment.
    ///
    /// [GitHub API docs for create_for_pull_request_review_comment](https://docs.github.com/rest/reactions/reactions#create-reaction-for-a-pull-request-review-comment)
    ///
    /// ---
    #[cfg(not(target_arch = "wasm32"))]
    pub fn create_for_pull_request_review_comment(&self, owner: &str, repo: &str, comment_id: i64, body: PostReactionsCreateForPullRequestReviewComment) -> Result<Reaction, AdapterError> {

        let request_uri = format!("{}/repos/{}/{}/pulls/comments/{}/reactions", super::GITHUB_BASE_API_URL, owner, repo, comment_id);


        let req = GitHubRequest {
            uri: request_uri,
            body: Some(C::from_json::<PostReactionsCreateForPullRequestReviewComment>(body)?),
            method: "POST",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch(request)?;

        // --

        if github_response.is_success() {
            Ok(github_response.to_json()?)
        } else {
            match github_response.status_code() {
                201 => Err(ReactionsCreateForPullRequestReviewCommentError::Status201(github_response.to_json()?).into()),
                422 => Err(ReactionsCreateForPullRequestReviewCommentError::Status422(github_response.to_json()?).into()),
                code => Err(ReactionsCreateForPullRequestReviewCommentError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # Create reaction for a release
    ///
    /// Create a reaction to a [release](https://docs.github.com/rest/releases/releases#get-a-release). A response with a `Status: 200 OK` means that you already added the reaction type to this release.
    ///
    /// [GitHub API docs for create_for_release](https://docs.github.com/rest/reactions/reactions#create-reaction-for-a-release)
    ///
    /// ---
    pub async fn create_for_release_async(&self, owner: &str, repo: &str, release_id: i32, body: PostReactionsCreateForRelease) -> Result<Reaction, AdapterError> {

        let request_uri = format!("{}/repos/{}/{}/releases/{}/reactions", super::GITHUB_BASE_API_URL, owner, repo, release_id);


        let req = GitHubRequest {
            uri: request_uri,
            body: Some(C::from_json::<PostReactionsCreateForRelease>(body)?),
            method: "POST",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch_async(request).await?;

        // --

        if github_response.is_success() {
            Ok(github_response.to_json_async().await?)
        } else {
            match github_response.status_code() {
                201 => Err(ReactionsCreateForReleaseError::Status201(github_response.to_json_async().await?).into()),
                422 => Err(ReactionsCreateForReleaseError::Status422(github_response.to_json_async().await?).into()),
                code => Err(ReactionsCreateForReleaseError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # Create reaction for a release
    ///
    /// Create a reaction to a [release](https://docs.github.com/rest/releases/releases#get-a-release). A response with a `Status: 200 OK` means that you already added the reaction type to this release.
    ///
    /// [GitHub API docs for create_for_release](https://docs.github.com/rest/reactions/reactions#create-reaction-for-a-release)
    ///
    /// ---
    #[cfg(not(target_arch = "wasm32"))]
    pub fn create_for_release(&self, owner: &str, repo: &str, release_id: i32, body: PostReactionsCreateForRelease) -> Result<Reaction, AdapterError> {

        let request_uri = format!("{}/repos/{}/{}/releases/{}/reactions", super::GITHUB_BASE_API_URL, owner, repo, release_id);


        let req = GitHubRequest {
            uri: request_uri,
            body: Some(C::from_json::<PostReactionsCreateForRelease>(body)?),
            method: "POST",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch(request)?;

        // --

        if github_response.is_success() {
            Ok(github_response.to_json()?)
        } else {
            match github_response.status_code() {
                201 => Err(ReactionsCreateForReleaseError::Status201(github_response.to_json()?).into()),
                422 => Err(ReactionsCreateForReleaseError::Status422(github_response.to_json()?).into()),
                code => Err(ReactionsCreateForReleaseError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # Create reaction for a team discussion comment
    ///
    /// Create a reaction to a [team discussion comment](https://docs.github.com/rest/teams/discussion-comments#get-a-discussion-comment).
    /// 
    /// A response with an HTTP `200` status means that you already added the reaction type to this team discussion comment.
    /// 
    /// > [!NOTE]
    /// > You can also specify a team by `org_id` and `team_id` using the route `POST /organizations/:org_id/team/:team_id/discussions/:discussion_number/comments/:comment_number/reactions`.
    /// 
    /// OAuth app tokens and personal access tokens (classic) need the `write:discussion` scope to use this endpoint.
    ///
    /// [GitHub API docs for create_for_team_discussion_comment_in_org](https://docs.github.com/rest/reactions/reactions#create-reaction-for-a-team-discussion-comment)
    ///
    /// ---
    pub async fn create_for_team_discussion_comment_in_org_async(&self, org: &str, team_slug: &str, discussion_number: i32, comment_number: i32, body: PostReactionsCreateForTeamDiscussionCommentInOrg) -> Result<Reaction, AdapterError> {

        let request_uri = format!("{}/orgs/{}/teams/{}/discussions/{}/comments/{}/reactions", super::GITHUB_BASE_API_URL, org, team_slug, discussion_number, comment_number);


        let req = GitHubRequest {
            uri: request_uri,
            body: Some(C::from_json::<PostReactionsCreateForTeamDiscussionCommentInOrg>(body)?),
            method: "POST",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch_async(request).await?;

        // --

        if github_response.is_success() {
            Ok(github_response.to_json_async().await?)
        } else {
            match github_response.status_code() {
                201 => Err(ReactionsCreateForTeamDiscussionCommentInOrgError::Status201(github_response.to_json_async().await?).into()),
                code => Err(ReactionsCreateForTeamDiscussionCommentInOrgError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # Create reaction for a team discussion comment
    ///
    /// Create a reaction to a [team discussion comment](https://docs.github.com/rest/teams/discussion-comments#get-a-discussion-comment).
    /// 
    /// A response with an HTTP `200` status means that you already added the reaction type to this team discussion comment.
    /// 
    /// > [!NOTE]
    /// > You can also specify a team by `org_id` and `team_id` using the route `POST /organizations/:org_id/team/:team_id/discussions/:discussion_number/comments/:comment_number/reactions`.
    /// 
    /// OAuth app tokens and personal access tokens (classic) need the `write:discussion` scope to use this endpoint.
    ///
    /// [GitHub API docs for create_for_team_discussion_comment_in_org](https://docs.github.com/rest/reactions/reactions#create-reaction-for-a-team-discussion-comment)
    ///
    /// ---
    #[cfg(not(target_arch = "wasm32"))]
    pub fn create_for_team_discussion_comment_in_org(&self, org: &str, team_slug: &str, discussion_number: i32, comment_number: i32, body: PostReactionsCreateForTeamDiscussionCommentInOrg) -> Result<Reaction, AdapterError> {

        let request_uri = format!("{}/orgs/{}/teams/{}/discussions/{}/comments/{}/reactions", super::GITHUB_BASE_API_URL, org, team_slug, discussion_number, comment_number);


        let req = GitHubRequest {
            uri: request_uri,
            body: Some(C::from_json::<PostReactionsCreateForTeamDiscussionCommentInOrg>(body)?),
            method: "POST",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch(request)?;

        // --

        if github_response.is_success() {
            Ok(github_response.to_json()?)
        } else {
            match github_response.status_code() {
                201 => Err(ReactionsCreateForTeamDiscussionCommentInOrgError::Status201(github_response.to_json()?).into()),
                code => Err(ReactionsCreateForTeamDiscussionCommentInOrgError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # Create reaction for a team discussion comment (Legacy)
    ///
    /// > [!WARNING]
    /// > **Endpoint closing down notice:** This endpoint route is closing down and will be removed from the Teams API. We recommend migrating your existing code to use the new "[Create reaction for a team discussion comment](https://docs.github.com/rest/reactions/reactions#create-reaction-for-a-team-discussion-comment)" endpoint.
    /// 
    /// Create a reaction to a [team discussion comment](https://docs.github.com/rest/teams/discussion-comments#get-a-discussion-comment).
    /// 
    /// A response with an HTTP `200` status means that you already added the reaction type to this team discussion comment.
    /// 
    /// OAuth app tokens and personal access tokens (classic) need the `write:discussion` scope to use this endpoint.
    ///
    /// [GitHub API docs for create_for_team_discussion_comment_legacy](https://docs.github.com/rest/reactions/reactions#create-reaction-for-a-team-discussion-comment-legacy)
    ///
    /// ---
    pub async fn create_for_team_discussion_comment_legacy_async(&self, team_id: i32, discussion_number: i32, comment_number: i32, body: PostReactionsCreateForTeamDiscussionCommentLegacy) -> Result<Reaction, AdapterError> {

        let request_uri = format!("{}/teams/{}/discussions/{}/comments/{}/reactions", super::GITHUB_BASE_API_URL, team_id, discussion_number, comment_number);


        let req = GitHubRequest {
            uri: request_uri,
            body: Some(C::from_json::<PostReactionsCreateForTeamDiscussionCommentLegacy>(body)?),
            method: "POST",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch_async(request).await?;

        // --

        if github_response.is_success() {
            Ok(github_response.to_json_async().await?)
        } else {
            match github_response.status_code() {
                code => Err(ReactionsCreateForTeamDiscussionCommentLegacyError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # Create reaction for a team discussion comment (Legacy)
    ///
    /// > [!WARNING]
    /// > **Endpoint closing down notice:** This endpoint route is closing down and will be removed from the Teams API. We recommend migrating your existing code to use the new "[Create reaction for a team discussion comment](https://docs.github.com/rest/reactions/reactions#create-reaction-for-a-team-discussion-comment)" endpoint.
    /// 
    /// Create a reaction to a [team discussion comment](https://docs.github.com/rest/teams/discussion-comments#get-a-discussion-comment).
    /// 
    /// A response with an HTTP `200` status means that you already added the reaction type to this team discussion comment.
    /// 
    /// OAuth app tokens and personal access tokens (classic) need the `write:discussion` scope to use this endpoint.
    ///
    /// [GitHub API docs for create_for_team_discussion_comment_legacy](https://docs.github.com/rest/reactions/reactions#create-reaction-for-a-team-discussion-comment-legacy)
    ///
    /// ---
    #[cfg(not(target_arch = "wasm32"))]
    pub fn create_for_team_discussion_comment_legacy(&self, team_id: i32, discussion_number: i32, comment_number: i32, body: PostReactionsCreateForTeamDiscussionCommentLegacy) -> Result<Reaction, AdapterError> {

        let request_uri = format!("{}/teams/{}/discussions/{}/comments/{}/reactions", super::GITHUB_BASE_API_URL, team_id, discussion_number, comment_number);


        let req = GitHubRequest {
            uri: request_uri,
            body: Some(C::from_json::<PostReactionsCreateForTeamDiscussionCommentLegacy>(body)?),
            method: "POST",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch(request)?;

        // --

        if github_response.is_success() {
            Ok(github_response.to_json()?)
        } else {
            match github_response.status_code() {
                code => Err(ReactionsCreateForTeamDiscussionCommentLegacyError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # Create reaction for a team discussion
    ///
    /// Create a reaction to a [team discussion](https://docs.github.com/rest/teams/discussions#get-a-discussion).
    /// 
    /// A response with an HTTP `200` status means that you already added the reaction type to this team discussion.
    /// 
    /// > [!NOTE]
    /// > You can also specify a team by `org_id` and `team_id` using the route `POST /organizations/:org_id/team/:team_id/discussions/:discussion_number/reactions`.
    /// 
    /// OAuth app tokens and personal access tokens (classic) need the `write:discussion` scope to use this endpoint.
    ///
    /// [GitHub API docs for create_for_team_discussion_in_org](https://docs.github.com/rest/reactions/reactions#create-reaction-for-a-team-discussion)
    ///
    /// ---
    pub async fn create_for_team_discussion_in_org_async(&self, org: &str, team_slug: &str, discussion_number: i32, body: PostReactionsCreateForTeamDiscussionInOrg) -> Result<Reaction, AdapterError> {

        let request_uri = format!("{}/orgs/{}/teams/{}/discussions/{}/reactions", super::GITHUB_BASE_API_URL, org, team_slug, discussion_number);


        let req = GitHubRequest {
            uri: request_uri,
            body: Some(C::from_json::<PostReactionsCreateForTeamDiscussionInOrg>(body)?),
            method: "POST",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch_async(request).await?;

        // --

        if github_response.is_success() {
            Ok(github_response.to_json_async().await?)
        } else {
            match github_response.status_code() {
                201 => Err(ReactionsCreateForTeamDiscussionInOrgError::Status201(github_response.to_json_async().await?).into()),
                code => Err(ReactionsCreateForTeamDiscussionInOrgError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # Create reaction for a team discussion
    ///
    /// Create a reaction to a [team discussion](https://docs.github.com/rest/teams/discussions#get-a-discussion).
    /// 
    /// A response with an HTTP `200` status means that you already added the reaction type to this team discussion.
    /// 
    /// > [!NOTE]
    /// > You can also specify a team by `org_id` and `team_id` using the route `POST /organizations/:org_id/team/:team_id/discussions/:discussion_number/reactions`.
    /// 
    /// OAuth app tokens and personal access tokens (classic) need the `write:discussion` scope to use this endpoint.
    ///
    /// [GitHub API docs for create_for_team_discussion_in_org](https://docs.github.com/rest/reactions/reactions#create-reaction-for-a-team-discussion)
    ///
    /// ---
    #[cfg(not(target_arch = "wasm32"))]
    pub fn create_for_team_discussion_in_org(&self, org: &str, team_slug: &str, discussion_number: i32, body: PostReactionsCreateForTeamDiscussionInOrg) -> Result<Reaction, AdapterError> {

        let request_uri = format!("{}/orgs/{}/teams/{}/discussions/{}/reactions", super::GITHUB_BASE_API_URL, org, team_slug, discussion_number);


        let req = GitHubRequest {
            uri: request_uri,
            body: Some(C::from_json::<PostReactionsCreateForTeamDiscussionInOrg>(body)?),
            method: "POST",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch(request)?;

        // --

        if github_response.is_success() {
            Ok(github_response.to_json()?)
        } else {
            match github_response.status_code() {
                201 => Err(ReactionsCreateForTeamDiscussionInOrgError::Status201(github_response.to_json()?).into()),
                code => Err(ReactionsCreateForTeamDiscussionInOrgError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # Create reaction for a team discussion (Legacy)
    ///
    /// > [!WARNING]
    /// > **Endpoint closing down notice:** This endpoint route is closing down and will be removed from the Teams API. We recommend migrating your existing code to use the new [`Create reaction for a team discussion`](https://docs.github.com/rest/reactions/reactions#create-reaction-for-a-team-discussion) endpoint.
    /// 
    /// Create a reaction to a [team discussion](https://docs.github.com/rest/teams/discussions#get-a-discussion).
    /// 
    /// A response with an HTTP `200` status means that you already added the reaction type to this team discussion.
    /// 
    /// OAuth app tokens and personal access tokens (classic) need the `write:discussion` scope to use this endpoint.
    ///
    /// [GitHub API docs for create_for_team_discussion_legacy](https://docs.github.com/rest/reactions/reactions#create-reaction-for-a-team-discussion-legacy)
    ///
    /// ---
    pub async fn create_for_team_discussion_legacy_async(&self, team_id: i32, discussion_number: i32, body: PostReactionsCreateForTeamDiscussionLegacy) -> Result<Reaction, AdapterError> {

        let request_uri = format!("{}/teams/{}/discussions/{}/reactions", super::GITHUB_BASE_API_URL, team_id, discussion_number);


        let req = GitHubRequest {
            uri: request_uri,
            body: Some(C::from_json::<PostReactionsCreateForTeamDiscussionLegacy>(body)?),
            method: "POST",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch_async(request).await?;

        // --

        if github_response.is_success() {
            Ok(github_response.to_json_async().await?)
        } else {
            match github_response.status_code() {
                code => Err(ReactionsCreateForTeamDiscussionLegacyError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # Create reaction for a team discussion (Legacy)
    ///
    /// > [!WARNING]
    /// > **Endpoint closing down notice:** This endpoint route is closing down and will be removed from the Teams API. We recommend migrating your existing code to use the new [`Create reaction for a team discussion`](https://docs.github.com/rest/reactions/reactions#create-reaction-for-a-team-discussion) endpoint.
    /// 
    /// Create a reaction to a [team discussion](https://docs.github.com/rest/teams/discussions#get-a-discussion).
    /// 
    /// A response with an HTTP `200` status means that you already added the reaction type to this team discussion.
    /// 
    /// OAuth app tokens and personal access tokens (classic) need the `write:discussion` scope to use this endpoint.
    ///
    /// [GitHub API docs for create_for_team_discussion_legacy](https://docs.github.com/rest/reactions/reactions#create-reaction-for-a-team-discussion-legacy)
    ///
    /// ---
    #[cfg(not(target_arch = "wasm32"))]
    pub fn create_for_team_discussion_legacy(&self, team_id: i32, discussion_number: i32, body: PostReactionsCreateForTeamDiscussionLegacy) -> Result<Reaction, AdapterError> {

        let request_uri = format!("{}/teams/{}/discussions/{}/reactions", super::GITHUB_BASE_API_URL, team_id, discussion_number);


        let req = GitHubRequest {
            uri: request_uri,
            body: Some(C::from_json::<PostReactionsCreateForTeamDiscussionLegacy>(body)?),
            method: "POST",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch(request)?;

        // --

        if github_response.is_success() {
            Ok(github_response.to_json()?)
        } else {
            match github_response.status_code() {
                code => Err(ReactionsCreateForTeamDiscussionLegacyError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # Delete a commit comment reaction
    ///
    /// > [!NOTE]
    /// > You can also specify a repository by `repository_id` using the route `DELETE /repositories/:repository_id/comments/:comment_id/reactions/:reaction_id`.
    /// 
    /// Delete a reaction to a [commit comment](https://docs.github.com/rest/commits/comments#get-a-commit-comment).
    ///
    /// [GitHub API docs for delete_for_commit_comment](https://docs.github.com/rest/reactions/reactions#delete-a-commit-comment-reaction)
    ///
    /// ---
    pub async fn delete_for_commit_comment_async(&self, owner: &str, repo: &str, comment_id: i64, reaction_id: i32) -> Result<(), AdapterError> {

        let request_uri = format!("{}/repos/{}/{}/comments/{}/reactions/{}", super::GITHUB_BASE_API_URL, owner, repo, comment_id, reaction_id);


        let req = GitHubRequest {
            uri: request_uri,
            body: None::<C::Body>,
            method: "DELETE",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch_async(request).await?;

        // --

        if github_response.is_success() {
            Ok(())
        } else {
            match github_response.status_code() {
                code => Err(ReactionsDeleteForCommitCommentError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # Delete a commit comment reaction
    ///
    /// > [!NOTE]
    /// > You can also specify a repository by `repository_id` using the route `DELETE /repositories/:repository_id/comments/:comment_id/reactions/:reaction_id`.
    /// 
    /// Delete a reaction to a [commit comment](https://docs.github.com/rest/commits/comments#get-a-commit-comment).
    ///
    /// [GitHub API docs for delete_for_commit_comment](https://docs.github.com/rest/reactions/reactions#delete-a-commit-comment-reaction)
    ///
    /// ---
    #[cfg(not(target_arch = "wasm32"))]
    pub fn delete_for_commit_comment(&self, owner: &str, repo: &str, comment_id: i64, reaction_id: i32) -> Result<(), AdapterError> {

        let request_uri = format!("{}/repos/{}/{}/comments/{}/reactions/{}", super::GITHUB_BASE_API_URL, owner, repo, comment_id, reaction_id);


        let req = GitHubRequest {
            uri: request_uri,
            body: None,
            method: "DELETE",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch(request)?;

        // --

        if github_response.is_success() {
            Ok(())
        } else {
            match github_response.status_code() {
                code => Err(ReactionsDeleteForCommitCommentError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # Delete an issue reaction
    ///
    /// > [!NOTE]
    /// > You can also specify a repository by `repository_id` using the route `DELETE /repositories/:repository_id/issues/:issue_number/reactions/:reaction_id`.
    /// 
    /// Delete a reaction to an [issue](https://docs.github.com/rest/issues/issues#get-an-issue).
    ///
    /// [GitHub API docs for delete_for_issue](https://docs.github.com/rest/reactions/reactions#delete-an-issue-reaction)
    ///
    /// ---
    pub async fn delete_for_issue_async(&self, owner: &str, repo: &str, issue_number: i32, reaction_id: i32) -> Result<(), AdapterError> {

        let request_uri = format!("{}/repos/{}/{}/issues/{}/reactions/{}", super::GITHUB_BASE_API_URL, owner, repo, issue_number, reaction_id);


        let req = GitHubRequest {
            uri: request_uri,
            body: None::<C::Body>,
            method: "DELETE",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch_async(request).await?;

        // --

        if github_response.is_success() {
            Ok(())
        } else {
            match github_response.status_code() {
                code => Err(ReactionsDeleteForIssueError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # Delete an issue reaction
    ///
    /// > [!NOTE]
    /// > You can also specify a repository by `repository_id` using the route `DELETE /repositories/:repository_id/issues/:issue_number/reactions/:reaction_id`.
    /// 
    /// Delete a reaction to an [issue](https://docs.github.com/rest/issues/issues#get-an-issue).
    ///
    /// [GitHub API docs for delete_for_issue](https://docs.github.com/rest/reactions/reactions#delete-an-issue-reaction)
    ///
    /// ---
    #[cfg(not(target_arch = "wasm32"))]
    pub fn delete_for_issue(&self, owner: &str, repo: &str, issue_number: i32, reaction_id: i32) -> Result<(), AdapterError> {

        let request_uri = format!("{}/repos/{}/{}/issues/{}/reactions/{}", super::GITHUB_BASE_API_URL, owner, repo, issue_number, reaction_id);


        let req = GitHubRequest {
            uri: request_uri,
            body: None,
            method: "DELETE",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch(request)?;

        // --

        if github_response.is_success() {
            Ok(())
        } else {
            match github_response.status_code() {
                code => Err(ReactionsDeleteForIssueError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # Delete an issue comment reaction
    ///
    /// > [!NOTE]
    /// > You can also specify a repository by `repository_id` using the route `DELETE delete /repositories/:repository_id/issues/comments/:comment_id/reactions/:reaction_id`.
    /// 
    /// Delete a reaction to an [issue comment](https://docs.github.com/rest/issues/comments#get-an-issue-comment).
    ///
    /// [GitHub API docs for delete_for_issue_comment](https://docs.github.com/rest/reactions/reactions#delete-an-issue-comment-reaction)
    ///
    /// ---
    pub async fn delete_for_issue_comment_async(&self, owner: &str, repo: &str, comment_id: i64, reaction_id: i32) -> Result<(), AdapterError> {

        let request_uri = format!("{}/repos/{}/{}/issues/comments/{}/reactions/{}", super::GITHUB_BASE_API_URL, owner, repo, comment_id, reaction_id);


        let req = GitHubRequest {
            uri: request_uri,
            body: None::<C::Body>,
            method: "DELETE",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch_async(request).await?;

        // --

        if github_response.is_success() {
            Ok(())
        } else {
            match github_response.status_code() {
                code => Err(ReactionsDeleteForIssueCommentError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # Delete an issue comment reaction
    ///
    /// > [!NOTE]
    /// > You can also specify a repository by `repository_id` using the route `DELETE delete /repositories/:repository_id/issues/comments/:comment_id/reactions/:reaction_id`.
    /// 
    /// Delete a reaction to an [issue comment](https://docs.github.com/rest/issues/comments#get-an-issue-comment).
    ///
    /// [GitHub API docs for delete_for_issue_comment](https://docs.github.com/rest/reactions/reactions#delete-an-issue-comment-reaction)
    ///
    /// ---
    #[cfg(not(target_arch = "wasm32"))]
    pub fn delete_for_issue_comment(&self, owner: &str, repo: &str, comment_id: i64, reaction_id: i32) -> Result<(), AdapterError> {

        let request_uri = format!("{}/repos/{}/{}/issues/comments/{}/reactions/{}", super::GITHUB_BASE_API_URL, owner, repo, comment_id, reaction_id);


        let req = GitHubRequest {
            uri: request_uri,
            body: None,
            method: "DELETE",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch(request)?;

        // --

        if github_response.is_success() {
            Ok(())
        } else {
            match github_response.status_code() {
                code => Err(ReactionsDeleteForIssueCommentError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # Delete a pull request comment reaction
    ///
    /// > [!NOTE]
    /// > You can also specify a repository by `repository_id` using the route `DELETE /repositories/:repository_id/pulls/comments/:comment_id/reactions/:reaction_id.`
    /// 
    /// Delete a reaction to a [pull request review comment](https://docs.github.com/rest/pulls/comments#get-a-review-comment-for-a-pull-request).
    ///
    /// [GitHub API docs for delete_for_pull_request_comment](https://docs.github.com/rest/reactions/reactions#delete-a-pull-request-comment-reaction)
    ///
    /// ---
    pub async fn delete_for_pull_request_comment_async(&self, owner: &str, repo: &str, comment_id: i64, reaction_id: i32) -> Result<(), AdapterError> {

        let request_uri = format!("{}/repos/{}/{}/pulls/comments/{}/reactions/{}", super::GITHUB_BASE_API_URL, owner, repo, comment_id, reaction_id);


        let req = GitHubRequest {
            uri: request_uri,
            body: None::<C::Body>,
            method: "DELETE",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch_async(request).await?;

        // --

        if github_response.is_success() {
            Ok(())
        } else {
            match github_response.status_code() {
                code => Err(ReactionsDeleteForPullRequestCommentError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # Delete a pull request comment reaction
    ///
    /// > [!NOTE]
    /// > You can also specify a repository by `repository_id` using the route `DELETE /repositories/:repository_id/pulls/comments/:comment_id/reactions/:reaction_id.`
    /// 
    /// Delete a reaction to a [pull request review comment](https://docs.github.com/rest/pulls/comments#get-a-review-comment-for-a-pull-request).
    ///
    /// [GitHub API docs for delete_for_pull_request_comment](https://docs.github.com/rest/reactions/reactions#delete-a-pull-request-comment-reaction)
    ///
    /// ---
    #[cfg(not(target_arch = "wasm32"))]
    pub fn delete_for_pull_request_comment(&self, owner: &str, repo: &str, comment_id: i64, reaction_id: i32) -> Result<(), AdapterError> {

        let request_uri = format!("{}/repos/{}/{}/pulls/comments/{}/reactions/{}", super::GITHUB_BASE_API_URL, owner, repo, comment_id, reaction_id);


        let req = GitHubRequest {
            uri: request_uri,
            body: None,
            method: "DELETE",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch(request)?;

        // --

        if github_response.is_success() {
            Ok(())
        } else {
            match github_response.status_code() {
                code => Err(ReactionsDeleteForPullRequestCommentError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # Delete a release reaction
    ///
    /// > [!NOTE]
    /// > You can also specify a repository by `repository_id` using the route `DELETE delete /repositories/:repository_id/releases/:release_id/reactions/:reaction_id`.
    /// 
    /// Delete a reaction to a [release](https://docs.github.com/rest/releases/releases#get-a-release).
    ///
    /// [GitHub API docs for delete_for_release](https://docs.github.com/rest/reactions/reactions#delete-a-release-reaction)
    ///
    /// ---
    pub async fn delete_for_release_async(&self, owner: &str, repo: &str, release_id: i32, reaction_id: i32) -> Result<(), AdapterError> {

        let request_uri = format!("{}/repos/{}/{}/releases/{}/reactions/{}", super::GITHUB_BASE_API_URL, owner, repo, release_id, reaction_id);


        let req = GitHubRequest {
            uri: request_uri,
            body: None::<C::Body>,
            method: "DELETE",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch_async(request).await?;

        // --

        if github_response.is_success() {
            Ok(())
        } else {
            match github_response.status_code() {
                code => Err(ReactionsDeleteForReleaseError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # Delete a release reaction
    ///
    /// > [!NOTE]
    /// > You can also specify a repository by `repository_id` using the route `DELETE delete /repositories/:repository_id/releases/:release_id/reactions/:reaction_id`.
    /// 
    /// Delete a reaction to a [release](https://docs.github.com/rest/releases/releases#get-a-release).
    ///
    /// [GitHub API docs for delete_for_release](https://docs.github.com/rest/reactions/reactions#delete-a-release-reaction)
    ///
    /// ---
    #[cfg(not(target_arch = "wasm32"))]
    pub fn delete_for_release(&self, owner: &str, repo: &str, release_id: i32, reaction_id: i32) -> Result<(), AdapterError> {

        let request_uri = format!("{}/repos/{}/{}/releases/{}/reactions/{}", super::GITHUB_BASE_API_URL, owner, repo, release_id, reaction_id);


        let req = GitHubRequest {
            uri: request_uri,
            body: None,
            method: "DELETE",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch(request)?;

        // --

        if github_response.is_success() {
            Ok(())
        } else {
            match github_response.status_code() {
                code => Err(ReactionsDeleteForReleaseError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # Delete team discussion reaction
    ///
    /// > [!NOTE]
    /// > You can also specify a team or organization with `team_id` and `org_id` using the route `DELETE /organizations/:org_id/team/:team_id/discussions/:discussion_number/reactions/:reaction_id`.
    /// 
    /// Delete a reaction to a [team discussion](https://docs.github.com/rest/teams/discussions#get-a-discussion).
    /// 
    /// OAuth app tokens and personal access tokens (classic) need the `write:discussion` scope to use this endpoint.
    ///
    /// [GitHub API docs for delete_for_team_discussion](https://docs.github.com/rest/reactions/reactions#delete-team-discussion-reaction)
    ///
    /// ---
    pub async fn delete_for_team_discussion_async(&self, org: &str, team_slug: &str, discussion_number: i32, reaction_id: i32) -> Result<(), AdapterError> {

        let request_uri = format!("{}/orgs/{}/teams/{}/discussions/{}/reactions/{}", super::GITHUB_BASE_API_URL, org, team_slug, discussion_number, reaction_id);


        let req = GitHubRequest {
            uri: request_uri,
            body: None::<C::Body>,
            method: "DELETE",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch_async(request).await?;

        // --

        if github_response.is_success() {
            Ok(())
        } else {
            match github_response.status_code() {
                code => Err(ReactionsDeleteForTeamDiscussionError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # Delete team discussion reaction
    ///
    /// > [!NOTE]
    /// > You can also specify a team or organization with `team_id` and `org_id` using the route `DELETE /organizations/:org_id/team/:team_id/discussions/:discussion_number/reactions/:reaction_id`.
    /// 
    /// Delete a reaction to a [team discussion](https://docs.github.com/rest/teams/discussions#get-a-discussion).
    /// 
    /// OAuth app tokens and personal access tokens (classic) need the `write:discussion` scope to use this endpoint.
    ///
    /// [GitHub API docs for delete_for_team_discussion](https://docs.github.com/rest/reactions/reactions#delete-team-discussion-reaction)
    ///
    /// ---
    #[cfg(not(target_arch = "wasm32"))]
    pub fn delete_for_team_discussion(&self, org: &str, team_slug: &str, discussion_number: i32, reaction_id: i32) -> Result<(), AdapterError> {

        let request_uri = format!("{}/orgs/{}/teams/{}/discussions/{}/reactions/{}", super::GITHUB_BASE_API_URL, org, team_slug, discussion_number, reaction_id);


        let req = GitHubRequest {
            uri: request_uri,
            body: None,
            method: "DELETE",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch(request)?;

        // --

        if github_response.is_success() {
            Ok(())
        } else {
            match github_response.status_code() {
                code => Err(ReactionsDeleteForTeamDiscussionError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # Delete team discussion comment reaction
    ///
    /// > [!NOTE]
    /// > You can also specify a team or organization with `team_id` and `org_id` using the route `DELETE /organizations/:org_id/team/:team_id/discussions/:discussion_number/comments/:comment_number/reactions/:reaction_id`.
    /// 
    /// Delete a reaction to a [team discussion comment](https://docs.github.com/rest/teams/discussion-comments#get-a-discussion-comment).
    /// 
    /// OAuth app tokens and personal access tokens (classic) need the `write:discussion` scope to use this endpoint.
    ///
    /// [GitHub API docs for delete_for_team_discussion_comment](https://docs.github.com/rest/reactions/reactions#delete-team-discussion-comment-reaction)
    ///
    /// ---
    pub async fn delete_for_team_discussion_comment_async(&self, org: &str, team_slug: &str, discussion_number: i32, comment_number: i32, reaction_id: i32) -> Result<(), AdapterError> {

        let request_uri = format!("{}/orgs/{}/teams/{}/discussions/{}/comments/{}/reactions/{}", super::GITHUB_BASE_API_URL, org, team_slug, discussion_number, comment_number, reaction_id);


        let req = GitHubRequest {
            uri: request_uri,
            body: None::<C::Body>,
            method: "DELETE",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch_async(request).await?;

        // --

        if github_response.is_success() {
            Ok(())
        } else {
            match github_response.status_code() {
                code => Err(ReactionsDeleteForTeamDiscussionCommentError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # Delete team discussion comment reaction
    ///
    /// > [!NOTE]
    /// > You can also specify a team or organization with `team_id` and `org_id` using the route `DELETE /organizations/:org_id/team/:team_id/discussions/:discussion_number/comments/:comment_number/reactions/:reaction_id`.
    /// 
    /// Delete a reaction to a [team discussion comment](https://docs.github.com/rest/teams/discussion-comments#get-a-discussion-comment).
    /// 
    /// OAuth app tokens and personal access tokens (classic) need the `write:discussion` scope to use this endpoint.
    ///
    /// [GitHub API docs for delete_for_team_discussion_comment](https://docs.github.com/rest/reactions/reactions#delete-team-discussion-comment-reaction)
    ///
    /// ---
    #[cfg(not(target_arch = "wasm32"))]
    pub fn delete_for_team_discussion_comment(&self, org: &str, team_slug: &str, discussion_number: i32, comment_number: i32, reaction_id: i32) -> Result<(), AdapterError> {

        let request_uri = format!("{}/orgs/{}/teams/{}/discussions/{}/comments/{}/reactions/{}", super::GITHUB_BASE_API_URL, org, team_slug, discussion_number, comment_number, reaction_id);


        let req = GitHubRequest {
            uri: request_uri,
            body: None,
            method: "DELETE",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch(request)?;

        // --

        if github_response.is_success() {
            Ok(())
        } else {
            match github_response.status_code() {
                code => Err(ReactionsDeleteForTeamDiscussionCommentError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # List reactions for a commit comment
    ///
    /// List the reactions to a [commit comment](https://docs.github.com/rest/commits/comments#get-a-commit-comment).
    ///
    /// [GitHub API docs for list_for_commit_comment](https://docs.github.com/rest/reactions/reactions#list-reactions-for-a-commit-comment)
    ///
    /// ---
    pub async fn list_for_commit_comment_async(&self, owner: &str, repo: &str, comment_id: i64, query_params: Option<impl Into<ReactionsListForCommitCommentParams<'api>>>) -> Result<Vec<Reaction>, AdapterError> {

        let mut request_uri = format!("{}/repos/{}/{}/comments/{}/reactions", super::GITHUB_BASE_API_URL, owner, repo, comment_id);

        if let Some(params) = query_params {
            request_uri.push_str("?");
            request_uri.push_str(&serde_urlencoded::to_string(params.into())?);
        }

        let req = GitHubRequest {
            uri: request_uri,
            body: None::<C::Body>,
            method: "GET",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch_async(request).await?;

        // --

        if github_response.is_success() {
            Ok(github_response.to_json_async().await?)
        } else {
            match github_response.status_code() {
                404 => Err(ReactionsListForCommitCommentError::Status404(github_response.to_json_async().await?).into()),
                code => Err(ReactionsListForCommitCommentError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # List reactions for a commit comment
    ///
    /// List the reactions to a [commit comment](https://docs.github.com/rest/commits/comments#get-a-commit-comment).
    ///
    /// [GitHub API docs for list_for_commit_comment](https://docs.github.com/rest/reactions/reactions#list-reactions-for-a-commit-comment)
    ///
    /// ---
    #[cfg(not(target_arch = "wasm32"))]
    pub fn list_for_commit_comment(&self, owner: &str, repo: &str, comment_id: i64, query_params: Option<impl Into<ReactionsListForCommitCommentParams<'api>>>) -> Result<Vec<Reaction>, AdapterError> {

        let mut request_uri = format!("{}/repos/{}/{}/comments/{}/reactions", super::GITHUB_BASE_API_URL, owner, repo, comment_id);

        if let Some(params) = query_params {
            request_uri.push_str("?");
            let qp: ReactionsListForCommitCommentParams = params.into();
            request_uri.push_str(&serde_urlencoded::to_string(qp)?);
        }

        let req = GitHubRequest {
            uri: request_uri,
            body: None,
            method: "GET",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch(request)?;

        // --

        if github_response.is_success() {
            Ok(github_response.to_json()?)
        } else {
            match github_response.status_code() {
                404 => Err(ReactionsListForCommitCommentError::Status404(github_response.to_json()?).into()),
                code => Err(ReactionsListForCommitCommentError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # List reactions for an issue
    ///
    /// List the reactions to an [issue](https://docs.github.com/rest/issues/issues#get-an-issue).
    ///
    /// [GitHub API docs for list_for_issue](https://docs.github.com/rest/reactions/reactions#list-reactions-for-an-issue)
    ///
    /// ---
    pub async fn list_for_issue_async(&self, owner: &str, repo: &str, issue_number: i32, query_params: Option<impl Into<ReactionsListForIssueParams<'api>>>) -> Result<Vec<Reaction>, AdapterError> {

        let mut request_uri = format!("{}/repos/{}/{}/issues/{}/reactions", super::GITHUB_BASE_API_URL, owner, repo, issue_number);

        if let Some(params) = query_params {
            request_uri.push_str("?");
            request_uri.push_str(&serde_urlencoded::to_string(params.into())?);
        }

        let req = GitHubRequest {
            uri: request_uri,
            body: None::<C::Body>,
            method: "GET",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch_async(request).await?;

        // --

        if github_response.is_success() {
            Ok(github_response.to_json_async().await?)
        } else {
            match github_response.status_code() {
                404 => Err(ReactionsListForIssueError::Status404(github_response.to_json_async().await?).into()),
                410 => Err(ReactionsListForIssueError::Status410(github_response.to_json_async().await?).into()),
                code => Err(ReactionsListForIssueError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # List reactions for an issue
    ///
    /// List the reactions to an [issue](https://docs.github.com/rest/issues/issues#get-an-issue).
    ///
    /// [GitHub API docs for list_for_issue](https://docs.github.com/rest/reactions/reactions#list-reactions-for-an-issue)
    ///
    /// ---
    #[cfg(not(target_arch = "wasm32"))]
    pub fn list_for_issue(&self, owner: &str, repo: &str, issue_number: i32, query_params: Option<impl Into<ReactionsListForIssueParams<'api>>>) -> Result<Vec<Reaction>, AdapterError> {

        let mut request_uri = format!("{}/repos/{}/{}/issues/{}/reactions", super::GITHUB_BASE_API_URL, owner, repo, issue_number);

        if let Some(params) = query_params {
            request_uri.push_str("?");
            let qp: ReactionsListForIssueParams = params.into();
            request_uri.push_str(&serde_urlencoded::to_string(qp)?);
        }

        let req = GitHubRequest {
            uri: request_uri,
            body: None,
            method: "GET",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch(request)?;

        // --

        if github_response.is_success() {
            Ok(github_response.to_json()?)
        } else {
            match github_response.status_code() {
                404 => Err(ReactionsListForIssueError::Status404(github_response.to_json()?).into()),
                410 => Err(ReactionsListForIssueError::Status410(github_response.to_json()?).into()),
                code => Err(ReactionsListForIssueError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # List reactions for an issue comment
    ///
    /// List the reactions to an [issue comment](https://docs.github.com/rest/issues/comments#get-an-issue-comment).
    ///
    /// [GitHub API docs for list_for_issue_comment](https://docs.github.com/rest/reactions/reactions#list-reactions-for-an-issue-comment)
    ///
    /// ---
    pub async fn list_for_issue_comment_async(&self, owner: &str, repo: &str, comment_id: i64, query_params: Option<impl Into<ReactionsListForIssueCommentParams<'api>>>) -> Result<Vec<Reaction>, AdapterError> {

        let mut request_uri = format!("{}/repos/{}/{}/issues/comments/{}/reactions", super::GITHUB_BASE_API_URL, owner, repo, comment_id);

        if let Some(params) = query_params {
            request_uri.push_str("?");
            request_uri.push_str(&serde_urlencoded::to_string(params.into())?);
        }

        let req = GitHubRequest {
            uri: request_uri,
            body: None::<C::Body>,
            method: "GET",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch_async(request).await?;

        // --

        if github_response.is_success() {
            Ok(github_response.to_json_async().await?)
        } else {
            match github_response.status_code() {
                404 => Err(ReactionsListForIssueCommentError::Status404(github_response.to_json_async().await?).into()),
                code => Err(ReactionsListForIssueCommentError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # List reactions for an issue comment
    ///
    /// List the reactions to an [issue comment](https://docs.github.com/rest/issues/comments#get-an-issue-comment).
    ///
    /// [GitHub API docs for list_for_issue_comment](https://docs.github.com/rest/reactions/reactions#list-reactions-for-an-issue-comment)
    ///
    /// ---
    #[cfg(not(target_arch = "wasm32"))]
    pub fn list_for_issue_comment(&self, owner: &str, repo: &str, comment_id: i64, query_params: Option<impl Into<ReactionsListForIssueCommentParams<'api>>>) -> Result<Vec<Reaction>, AdapterError> {

        let mut request_uri = format!("{}/repos/{}/{}/issues/comments/{}/reactions", super::GITHUB_BASE_API_URL, owner, repo, comment_id);

        if let Some(params) = query_params {
            request_uri.push_str("?");
            let qp: ReactionsListForIssueCommentParams = params.into();
            request_uri.push_str(&serde_urlencoded::to_string(qp)?);
        }

        let req = GitHubRequest {
            uri: request_uri,
            body: None,
            method: "GET",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch(request)?;

        // --

        if github_response.is_success() {
            Ok(github_response.to_json()?)
        } else {
            match github_response.status_code() {
                404 => Err(ReactionsListForIssueCommentError::Status404(github_response.to_json()?).into()),
                code => Err(ReactionsListForIssueCommentError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # List reactions for a pull request review comment
    ///
    /// List the reactions to a [pull request review comment](https://docs.github.com/rest/pulls/comments#get-a-review-comment-for-a-pull-request).
    ///
    /// [GitHub API docs for list_for_pull_request_review_comment](https://docs.github.com/rest/reactions/reactions#list-reactions-for-a-pull-request-review-comment)
    ///
    /// ---
    pub async fn list_for_pull_request_review_comment_async(&self, owner: &str, repo: &str, comment_id: i64, query_params: Option<impl Into<ReactionsListForPullRequestReviewCommentParams<'api>>>) -> Result<Vec<Reaction>, AdapterError> {

        let mut request_uri = format!("{}/repos/{}/{}/pulls/comments/{}/reactions", super::GITHUB_BASE_API_URL, owner, repo, comment_id);

        if let Some(params) = query_params {
            request_uri.push_str("?");
            request_uri.push_str(&serde_urlencoded::to_string(params.into())?);
        }

        let req = GitHubRequest {
            uri: request_uri,
            body: None::<C::Body>,
            method: "GET",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch_async(request).await?;

        // --

        if github_response.is_success() {
            Ok(github_response.to_json_async().await?)
        } else {
            match github_response.status_code() {
                404 => Err(ReactionsListForPullRequestReviewCommentError::Status404(github_response.to_json_async().await?).into()),
                code => Err(ReactionsListForPullRequestReviewCommentError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # List reactions for a pull request review comment
    ///
    /// List the reactions to a [pull request review comment](https://docs.github.com/rest/pulls/comments#get-a-review-comment-for-a-pull-request).
    ///
    /// [GitHub API docs for list_for_pull_request_review_comment](https://docs.github.com/rest/reactions/reactions#list-reactions-for-a-pull-request-review-comment)
    ///
    /// ---
    #[cfg(not(target_arch = "wasm32"))]
    pub fn list_for_pull_request_review_comment(&self, owner: &str, repo: &str, comment_id: i64, query_params: Option<impl Into<ReactionsListForPullRequestReviewCommentParams<'api>>>) -> Result<Vec<Reaction>, AdapterError> {

        let mut request_uri = format!("{}/repos/{}/{}/pulls/comments/{}/reactions", super::GITHUB_BASE_API_URL, owner, repo, comment_id);

        if let Some(params) = query_params {
            request_uri.push_str("?");
            let qp: ReactionsListForPullRequestReviewCommentParams = params.into();
            request_uri.push_str(&serde_urlencoded::to_string(qp)?);
        }

        let req = GitHubRequest {
            uri: request_uri,
            body: None,
            method: "GET",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch(request)?;

        // --

        if github_response.is_success() {
            Ok(github_response.to_json()?)
        } else {
            match github_response.status_code() {
                404 => Err(ReactionsListForPullRequestReviewCommentError::Status404(github_response.to_json()?).into()),
                code => Err(ReactionsListForPullRequestReviewCommentError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # List reactions for a release
    ///
    /// List the reactions to a [release](https://docs.github.com/rest/releases/releases#get-a-release).
    ///
    /// [GitHub API docs for list_for_release](https://docs.github.com/rest/reactions/reactions#list-reactions-for-a-release)
    ///
    /// ---
    pub async fn list_for_release_async(&self, owner: &str, repo: &str, release_id: i32, query_params: Option<impl Into<ReactionsListForReleaseParams<'api>>>) -> Result<Vec<Reaction>, AdapterError> {

        let mut request_uri = format!("{}/repos/{}/{}/releases/{}/reactions", super::GITHUB_BASE_API_URL, owner, repo, release_id);

        if let Some(params) = query_params {
            request_uri.push_str("?");
            request_uri.push_str(&serde_urlencoded::to_string(params.into())?);
        }

        let req = GitHubRequest {
            uri: request_uri,
            body: None::<C::Body>,
            method: "GET",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch_async(request).await?;

        // --

        if github_response.is_success() {
            Ok(github_response.to_json_async().await?)
        } else {
            match github_response.status_code() {
                404 => Err(ReactionsListForReleaseError::Status404(github_response.to_json_async().await?).into()),
                code => Err(ReactionsListForReleaseError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # List reactions for a release
    ///
    /// List the reactions to a [release](https://docs.github.com/rest/releases/releases#get-a-release).
    ///
    /// [GitHub API docs for list_for_release](https://docs.github.com/rest/reactions/reactions#list-reactions-for-a-release)
    ///
    /// ---
    #[cfg(not(target_arch = "wasm32"))]
    pub fn list_for_release(&self, owner: &str, repo: &str, release_id: i32, query_params: Option<impl Into<ReactionsListForReleaseParams<'api>>>) -> Result<Vec<Reaction>, AdapterError> {

        let mut request_uri = format!("{}/repos/{}/{}/releases/{}/reactions", super::GITHUB_BASE_API_URL, owner, repo, release_id);

        if let Some(params) = query_params {
            request_uri.push_str("?");
            let qp: ReactionsListForReleaseParams = params.into();
            request_uri.push_str(&serde_urlencoded::to_string(qp)?);
        }

        let req = GitHubRequest {
            uri: request_uri,
            body: None,
            method: "GET",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch(request)?;

        // --

        if github_response.is_success() {
            Ok(github_response.to_json()?)
        } else {
            match github_response.status_code() {
                404 => Err(ReactionsListForReleaseError::Status404(github_response.to_json()?).into()),
                code => Err(ReactionsListForReleaseError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # List reactions for a team discussion comment
    ///
    /// List the reactions to a [team discussion comment](https://docs.github.com/rest/teams/discussion-comments#get-a-discussion-comment).
    /// 
    /// > [!NOTE]
    /// > You can also specify a team by `org_id` and `team_id` using the route `GET /organizations/:org_id/team/:team_id/discussions/:discussion_number/comments/:comment_number/reactions`.
    /// 
    /// OAuth app tokens and personal access tokens (classic) need the `read:discussion` scope to use this endpoint.
    ///
    /// [GitHub API docs for list_for_team_discussion_comment_in_org](https://docs.github.com/rest/reactions/reactions#list-reactions-for-a-team-discussion-comment)
    ///
    /// ---
    pub async fn list_for_team_discussion_comment_in_org_async(&self, org: &str, team_slug: &str, discussion_number: i32, comment_number: i32, query_params: Option<impl Into<ReactionsListForTeamDiscussionCommentInOrgParams<'api>>>) -> Result<Vec<Reaction>, AdapterError> {

        let mut request_uri = format!("{}/orgs/{}/teams/{}/discussions/{}/comments/{}/reactions", super::GITHUB_BASE_API_URL, org, team_slug, discussion_number, comment_number);

        if let Some(params) = query_params {
            request_uri.push_str("?");
            request_uri.push_str(&serde_urlencoded::to_string(params.into())?);
        }

        let req = GitHubRequest {
            uri: request_uri,
            body: None::<C::Body>,
            method: "GET",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch_async(request).await?;

        // --

        if github_response.is_success() {
            Ok(github_response.to_json_async().await?)
        } else {
            match github_response.status_code() {
                code => Err(ReactionsListForTeamDiscussionCommentInOrgError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # List reactions for a team discussion comment
    ///
    /// List the reactions to a [team discussion comment](https://docs.github.com/rest/teams/discussion-comments#get-a-discussion-comment).
    /// 
    /// > [!NOTE]
    /// > You can also specify a team by `org_id` and `team_id` using the route `GET /organizations/:org_id/team/:team_id/discussions/:discussion_number/comments/:comment_number/reactions`.
    /// 
    /// OAuth app tokens and personal access tokens (classic) need the `read:discussion` scope to use this endpoint.
    ///
    /// [GitHub API docs for list_for_team_discussion_comment_in_org](https://docs.github.com/rest/reactions/reactions#list-reactions-for-a-team-discussion-comment)
    ///
    /// ---
    #[cfg(not(target_arch = "wasm32"))]
    pub fn list_for_team_discussion_comment_in_org(&self, org: &str, team_slug: &str, discussion_number: i32, comment_number: i32, query_params: Option<impl Into<ReactionsListForTeamDiscussionCommentInOrgParams<'api>>>) -> Result<Vec<Reaction>, AdapterError> {

        let mut request_uri = format!("{}/orgs/{}/teams/{}/discussions/{}/comments/{}/reactions", super::GITHUB_BASE_API_URL, org, team_slug, discussion_number, comment_number);

        if let Some(params) = query_params {
            request_uri.push_str("?");
            let qp: ReactionsListForTeamDiscussionCommentInOrgParams = params.into();
            request_uri.push_str(&serde_urlencoded::to_string(qp)?);
        }

        let req = GitHubRequest {
            uri: request_uri,
            body: None,
            method: "GET",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch(request)?;

        // --

        if github_response.is_success() {
            Ok(github_response.to_json()?)
        } else {
            match github_response.status_code() {
                code => Err(ReactionsListForTeamDiscussionCommentInOrgError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # List reactions for a team discussion comment (Legacy)
    ///
    /// > [!WARNING]
    /// > **Endpoint closing down notice:** This endpoint route is closing down and will be removed from the Teams API. We recommend migrating your existing code to use the new [`List reactions for a team discussion comment`](https://docs.github.com/rest/reactions/reactions#list-reactions-for-a-team-discussion-comment) endpoint.
    /// 
    /// List the reactions to a [team discussion comment](https://docs.github.com/rest/teams/discussion-comments#get-a-discussion-comment).
    /// 
    /// OAuth app tokens and personal access tokens (classic) need the `read:discussion` scope to use this endpoint.
    ///
    /// [GitHub API docs for list_for_team_discussion_comment_legacy](https://docs.github.com/rest/reactions/reactions#list-reactions-for-a-team-discussion-comment-legacy)
    ///
    /// ---
    pub async fn list_for_team_discussion_comment_legacy_async(&self, team_id: i32, discussion_number: i32, comment_number: i32, query_params: Option<impl Into<ReactionsListForTeamDiscussionCommentLegacyParams<'api>>>) -> Result<Vec<Reaction>, AdapterError> {

        let mut request_uri = format!("{}/teams/{}/discussions/{}/comments/{}/reactions", super::GITHUB_BASE_API_URL, team_id, discussion_number, comment_number);

        if let Some(params) = query_params {
            request_uri.push_str("?");
            request_uri.push_str(&serde_urlencoded::to_string(params.into())?);
        }

        let req = GitHubRequest {
            uri: request_uri,
            body: None::<C::Body>,
            method: "GET",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch_async(request).await?;

        // --

        if github_response.is_success() {
            Ok(github_response.to_json_async().await?)
        } else {
            match github_response.status_code() {
                code => Err(ReactionsListForTeamDiscussionCommentLegacyError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # List reactions for a team discussion comment (Legacy)
    ///
    /// > [!WARNING]
    /// > **Endpoint closing down notice:** This endpoint route is closing down and will be removed from the Teams API. We recommend migrating your existing code to use the new [`List reactions for a team discussion comment`](https://docs.github.com/rest/reactions/reactions#list-reactions-for-a-team-discussion-comment) endpoint.
    /// 
    /// List the reactions to a [team discussion comment](https://docs.github.com/rest/teams/discussion-comments#get-a-discussion-comment).
    /// 
    /// OAuth app tokens and personal access tokens (classic) need the `read:discussion` scope to use this endpoint.
    ///
    /// [GitHub API docs for list_for_team_discussion_comment_legacy](https://docs.github.com/rest/reactions/reactions#list-reactions-for-a-team-discussion-comment-legacy)
    ///
    /// ---
    #[cfg(not(target_arch = "wasm32"))]
    pub fn list_for_team_discussion_comment_legacy(&self, team_id: i32, discussion_number: i32, comment_number: i32, query_params: Option<impl Into<ReactionsListForTeamDiscussionCommentLegacyParams<'api>>>) -> Result<Vec<Reaction>, AdapterError> {

        let mut request_uri = format!("{}/teams/{}/discussions/{}/comments/{}/reactions", super::GITHUB_BASE_API_URL, team_id, discussion_number, comment_number);

        if let Some(params) = query_params {
            request_uri.push_str("?");
            let qp: ReactionsListForTeamDiscussionCommentLegacyParams = params.into();
            request_uri.push_str(&serde_urlencoded::to_string(qp)?);
        }

        let req = GitHubRequest {
            uri: request_uri,
            body: None,
            method: "GET",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch(request)?;

        // --

        if github_response.is_success() {
            Ok(github_response.to_json()?)
        } else {
            match github_response.status_code() {
                code => Err(ReactionsListForTeamDiscussionCommentLegacyError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # List reactions for a team discussion
    ///
    /// List the reactions to a [team discussion](https://docs.github.com/rest/teams/discussions#get-a-discussion).
    /// 
    /// > [!NOTE]
    /// > You can also specify a team by `org_id` and `team_id` using the route `GET /organizations/:org_id/team/:team_id/discussions/:discussion_number/reactions`.
    /// 
    /// OAuth app tokens and personal access tokens (classic) need the `read:discussion` scope to use this endpoint.
    ///
    /// [GitHub API docs for list_for_team_discussion_in_org](https://docs.github.com/rest/reactions/reactions#list-reactions-for-a-team-discussion)
    ///
    /// ---
    pub async fn list_for_team_discussion_in_org_async(&self, org: &str, team_slug: &str, discussion_number: i32, query_params: Option<impl Into<ReactionsListForTeamDiscussionInOrgParams<'api>>>) -> Result<Vec<Reaction>, AdapterError> {

        let mut request_uri = format!("{}/orgs/{}/teams/{}/discussions/{}/reactions", super::GITHUB_BASE_API_URL, org, team_slug, discussion_number);

        if let Some(params) = query_params {
            request_uri.push_str("?");
            request_uri.push_str(&serde_urlencoded::to_string(params.into())?);
        }

        let req = GitHubRequest {
            uri: request_uri,
            body: None::<C::Body>,
            method: "GET",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch_async(request).await?;

        // --

        if github_response.is_success() {
            Ok(github_response.to_json_async().await?)
        } else {
            match github_response.status_code() {
                code => Err(ReactionsListForTeamDiscussionInOrgError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # List reactions for a team discussion
    ///
    /// List the reactions to a [team discussion](https://docs.github.com/rest/teams/discussions#get-a-discussion).
    /// 
    /// > [!NOTE]
    /// > You can also specify a team by `org_id` and `team_id` using the route `GET /organizations/:org_id/team/:team_id/discussions/:discussion_number/reactions`.
    /// 
    /// OAuth app tokens and personal access tokens (classic) need the `read:discussion` scope to use this endpoint.
    ///
    /// [GitHub API docs for list_for_team_discussion_in_org](https://docs.github.com/rest/reactions/reactions#list-reactions-for-a-team-discussion)
    ///
    /// ---
    #[cfg(not(target_arch = "wasm32"))]
    pub fn list_for_team_discussion_in_org(&self, org: &str, team_slug: &str, discussion_number: i32, query_params: Option<impl Into<ReactionsListForTeamDiscussionInOrgParams<'api>>>) -> Result<Vec<Reaction>, AdapterError> {

        let mut request_uri = format!("{}/orgs/{}/teams/{}/discussions/{}/reactions", super::GITHUB_BASE_API_URL, org, team_slug, discussion_number);

        if let Some(params) = query_params {
            request_uri.push_str("?");
            let qp: ReactionsListForTeamDiscussionInOrgParams = params.into();
            request_uri.push_str(&serde_urlencoded::to_string(qp)?);
        }

        let req = GitHubRequest {
            uri: request_uri,
            body: None,
            method: "GET",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch(request)?;

        // --

        if github_response.is_success() {
            Ok(github_response.to_json()?)
        } else {
            match github_response.status_code() {
                code => Err(ReactionsListForTeamDiscussionInOrgError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # List reactions for a team discussion (Legacy)
    ///
    /// > [!WARNING]
    /// > **Endpoint closing down notice:** This endpoint route is closing down and will be removed from the Teams API. We recommend migrating your existing code to use the new [`List reactions for a team discussion`](https://docs.github.com/rest/reactions/reactions#list-reactions-for-a-team-discussion) endpoint.
    /// 
    /// List the reactions to a [team discussion](https://docs.github.com/rest/teams/discussions#get-a-discussion).
    /// 
    /// OAuth app tokens and personal access tokens (classic) need the `read:discussion` scope to use this endpoint.
    ///
    /// [GitHub API docs for list_for_team_discussion_legacy](https://docs.github.com/rest/reactions/reactions#list-reactions-for-a-team-discussion-legacy)
    ///
    /// ---
    pub async fn list_for_team_discussion_legacy_async(&self, team_id: i32, discussion_number: i32, query_params: Option<impl Into<ReactionsListForTeamDiscussionLegacyParams<'api>>>) -> Result<Vec<Reaction>, AdapterError> {

        let mut request_uri = format!("{}/teams/{}/discussions/{}/reactions", super::GITHUB_BASE_API_URL, team_id, discussion_number);

        if let Some(params) = query_params {
            request_uri.push_str("?");
            request_uri.push_str(&serde_urlencoded::to_string(params.into())?);
        }

        let req = GitHubRequest {
            uri: request_uri,
            body: None::<C::Body>,
            method: "GET",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch_async(request).await?;

        // --

        if github_response.is_success() {
            Ok(github_response.to_json_async().await?)
        } else {
            match github_response.status_code() {
                code => Err(ReactionsListForTeamDiscussionLegacyError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # List reactions for a team discussion (Legacy)
    ///
    /// > [!WARNING]
    /// > **Endpoint closing down notice:** This endpoint route is closing down and will be removed from the Teams API. We recommend migrating your existing code to use the new [`List reactions for a team discussion`](https://docs.github.com/rest/reactions/reactions#list-reactions-for-a-team-discussion) endpoint.
    /// 
    /// List the reactions to a [team discussion](https://docs.github.com/rest/teams/discussions#get-a-discussion).
    /// 
    /// OAuth app tokens and personal access tokens (classic) need the `read:discussion` scope to use this endpoint.
    ///
    /// [GitHub API docs for list_for_team_discussion_legacy](https://docs.github.com/rest/reactions/reactions#list-reactions-for-a-team-discussion-legacy)
    ///
    /// ---
    #[cfg(not(target_arch = "wasm32"))]
    pub fn list_for_team_discussion_legacy(&self, team_id: i32, discussion_number: i32, query_params: Option<impl Into<ReactionsListForTeamDiscussionLegacyParams<'api>>>) -> Result<Vec<Reaction>, AdapterError> {

        let mut request_uri = format!("{}/teams/{}/discussions/{}/reactions", super::GITHUB_BASE_API_URL, team_id, discussion_number);

        if let Some(params) = query_params {
            request_uri.push_str("?");
            let qp: ReactionsListForTeamDiscussionLegacyParams = params.into();
            request_uri.push_str(&serde_urlencoded::to_string(qp)?);
        }

        let req = GitHubRequest {
            uri: request_uri,
            body: None,
            method: "GET",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch(request)?;

        // --

        if github_response.is_success() {
            Ok(github_response.to_json()?)
        } else {
            match github_response.status_code() {
                code => Err(ReactionsListForTeamDiscussionLegacyError::Generic { code }.into()),
            }
        }
    }

}
