//! Method, error and parameter types for the Dependabot endpoint.
#![allow(
    clippy::all
)]
/* 
 * GitHub v3 REST API
 *
 * GitHub's v3 REST API.
 *
 * OpenAPI spec version: 1.1.4
 * 
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 */

use serde::Deserialize;

use crate::adapters::{AdapterError, Client, GitHubRequest, GitHubResponseExt};
use crate::models::*;

use super::PerPage;

use std::collections::HashMap;
use serde_json::value::Value;

pub struct Dependabot<'api, C: Client> where AdapterError: From<<C as Client>::Err> {
    client: &'api C
}

pub fn new<C: Client>(client: &C) -> Dependabot<C> where AdapterError: From<<C as Client>::Err> {
    Dependabot { client }
}

/// Errors for the [Add selected repository to an organization secret](Dependabot::add_selected_repo_to_org_secret_async()) endpoint.
#[derive(Debug, thiserror::Error)]
pub enum DependabotAddSelectedRepoToOrgSecretError {
    #[error("Conflict when visibility type is not set to selected")]
    Status409,
    #[error("Status code: {}", code)]
    Generic { code: u16 },
}

impl From<DependabotAddSelectedRepoToOrgSecretError> for AdapterError {
    fn from(err: DependabotAddSelectedRepoToOrgSecretError) -> Self {
        let (description, status_code) = match err {
            DependabotAddSelectedRepoToOrgSecretError::Status409 => (String::from("Conflict when visibility type is not set to selected"), 409),
            DependabotAddSelectedRepoToOrgSecretError::Generic { code } => (String::from("Generic"), code)
        };

        Self::Endpoint {
            description,
            status_code,
            source: Some(Box::new(err))
        }
    }
}

/// Errors for the [Create or update an organization secret](Dependabot::create_or_update_org_secret_async()) endpoint.
#[derive(Debug, thiserror::Error)]
pub enum DependabotCreateOrUpdateOrgSecretError {
    #[error("Response when updating a secret")]
    Status204,
    #[error("Status code: {}", code)]
    Generic { code: u16 },
}

impl From<DependabotCreateOrUpdateOrgSecretError> for AdapterError {
    fn from(err: DependabotCreateOrUpdateOrgSecretError) -> Self {
        let (description, status_code) = match err {
            DependabotCreateOrUpdateOrgSecretError::Status204 => (String::from("Response when updating a secret"), 204),
            DependabotCreateOrUpdateOrgSecretError::Generic { code } => (String::from("Generic"), code)
        };

        Self::Endpoint {
            description,
            status_code,
            source: Some(Box::new(err))
        }
    }
}

/// Errors for the [Create or update a repository secret](Dependabot::create_or_update_repo_secret_async()) endpoint.
#[derive(Debug, thiserror::Error)]
pub enum DependabotCreateOrUpdateRepoSecretError {
    #[error("Response when updating a secret")]
    Status204,
    #[error("Status code: {}", code)]
    Generic { code: u16 },
}

impl From<DependabotCreateOrUpdateRepoSecretError> for AdapterError {
    fn from(err: DependabotCreateOrUpdateRepoSecretError) -> Self {
        let (description, status_code) = match err {
            DependabotCreateOrUpdateRepoSecretError::Status204 => (String::from("Response when updating a secret"), 204),
            DependabotCreateOrUpdateRepoSecretError::Generic { code } => (String::from("Generic"), code)
        };

        Self::Endpoint {
            description,
            status_code,
            source: Some(Box::new(err))
        }
    }
}

/// Errors for the [Delete an organization secret](Dependabot::delete_org_secret_async()) endpoint.
#[derive(Debug, thiserror::Error)]
pub enum DependabotDeleteOrgSecretError {
    #[error("Status code: {}", code)]
    Generic { code: u16 },
}

impl From<DependabotDeleteOrgSecretError> for AdapterError {
    fn from(err: DependabotDeleteOrgSecretError) -> Self {
        let (description, status_code) = match err {
            DependabotDeleteOrgSecretError::Generic { code } => (String::from("Generic"), code)
        };

        Self::Endpoint {
            description,
            status_code,
            source: Some(Box::new(err))
        }
    }
}

/// Errors for the [Delete a repository secret](Dependabot::delete_repo_secret_async()) endpoint.
#[derive(Debug, thiserror::Error)]
pub enum DependabotDeleteRepoSecretError {
    #[error("Status code: {}", code)]
    Generic { code: u16 },
}

impl From<DependabotDeleteRepoSecretError> for AdapterError {
    fn from(err: DependabotDeleteRepoSecretError) -> Self {
        let (description, status_code) = match err {
            DependabotDeleteRepoSecretError::Generic { code } => (String::from("Generic"), code)
        };

        Self::Endpoint {
            description,
            status_code,
            source: Some(Box::new(err))
        }
    }
}

/// Errors for the [Get a Dependabot alert](Dependabot::get_alert_async()) endpoint.
#[derive(Debug, thiserror::Error)]
pub enum DependabotGetAlertError {
    #[error("Not modified")]
    Status304,
    #[error("Forbidden")]
    Status403(BasicError),
    #[error("Resource not found")]
    Status404(BasicError),
    #[error("Status code: {}", code)]
    Generic { code: u16 },
}

impl From<DependabotGetAlertError> for AdapterError {
    fn from(err: DependabotGetAlertError) -> Self {
        let (description, status_code) = match err {
            DependabotGetAlertError::Status304 => (String::from("Not modified"), 304),
            DependabotGetAlertError::Status403(_) => (String::from("Forbidden"), 403),
            DependabotGetAlertError::Status404(_) => (String::from("Resource not found"), 404),
            DependabotGetAlertError::Generic { code } => (String::from("Generic"), code)
        };

        Self::Endpoint {
            description,
            status_code,
            source: Some(Box::new(err))
        }
    }
}

/// Errors for the [Get an organization public key](Dependabot::get_org_public_key_async()) endpoint.
#[derive(Debug, thiserror::Error)]
pub enum DependabotGetOrgPublicKeyError {
    #[error("Status code: {}", code)]
    Generic { code: u16 },
}

impl From<DependabotGetOrgPublicKeyError> for AdapterError {
    fn from(err: DependabotGetOrgPublicKeyError) -> Self {
        let (description, status_code) = match err {
            DependabotGetOrgPublicKeyError::Generic { code } => (String::from("Generic"), code)
        };

        Self::Endpoint {
            description,
            status_code,
            source: Some(Box::new(err))
        }
    }
}

/// Errors for the [Get an organization secret](Dependabot::get_org_secret_async()) endpoint.
#[derive(Debug, thiserror::Error)]
pub enum DependabotGetOrgSecretError {
    #[error("Status code: {}", code)]
    Generic { code: u16 },
}

impl From<DependabotGetOrgSecretError> for AdapterError {
    fn from(err: DependabotGetOrgSecretError) -> Self {
        let (description, status_code) = match err {
            DependabotGetOrgSecretError::Generic { code } => (String::from("Generic"), code)
        };

        Self::Endpoint {
            description,
            status_code,
            source: Some(Box::new(err))
        }
    }
}

/// Errors for the [Get a repository public key](Dependabot::get_repo_public_key_async()) endpoint.
#[derive(Debug, thiserror::Error)]
pub enum DependabotGetRepoPublicKeyError {
    #[error("Status code: {}", code)]
    Generic { code: u16 },
}

impl From<DependabotGetRepoPublicKeyError> for AdapterError {
    fn from(err: DependabotGetRepoPublicKeyError) -> Self {
        let (description, status_code) = match err {
            DependabotGetRepoPublicKeyError::Generic { code } => (String::from("Generic"), code)
        };

        Self::Endpoint {
            description,
            status_code,
            source: Some(Box::new(err))
        }
    }
}

/// Errors for the [Get a repository secret](Dependabot::get_repo_secret_async()) endpoint.
#[derive(Debug, thiserror::Error)]
pub enum DependabotGetRepoSecretError {
    #[error("Status code: {}", code)]
    Generic { code: u16 },
}

impl From<DependabotGetRepoSecretError> for AdapterError {
    fn from(err: DependabotGetRepoSecretError) -> Self {
        let (description, status_code) = match err {
            DependabotGetRepoSecretError::Generic { code } => (String::from("Generic"), code)
        };

        Self::Endpoint {
            description,
            status_code,
            source: Some(Box::new(err))
        }
    }
}

/// Errors for the [List Dependabot alerts for an enterprise](Dependabot::list_alerts_for_enterprise_async()) endpoint.
#[derive(Debug, thiserror::Error)]
pub enum DependabotListAlertsForEnterpriseError {
    #[error("Not modified")]
    Status304,
    #[error("Forbidden")]
    Status403(BasicError),
    #[error("Resource not found")]
    Status404(BasicError),
    #[error("Validation failed, or the endpoint has been spammed.")]
    Status422(ValidationErrorSimple),
    #[error("Status code: {}", code)]
    Generic { code: u16 },
}

impl From<DependabotListAlertsForEnterpriseError> for AdapterError {
    fn from(err: DependabotListAlertsForEnterpriseError) -> Self {
        let (description, status_code) = match err {
            DependabotListAlertsForEnterpriseError::Status304 => (String::from("Not modified"), 304),
            DependabotListAlertsForEnterpriseError::Status403(_) => (String::from("Forbidden"), 403),
            DependabotListAlertsForEnterpriseError::Status404(_) => (String::from("Resource not found"), 404),
            DependabotListAlertsForEnterpriseError::Status422(_) => (String::from("Validation failed, or the endpoint has been spammed."), 422),
            DependabotListAlertsForEnterpriseError::Generic { code } => (String::from("Generic"), code)
        };

        Self::Endpoint {
            description,
            status_code,
            source: Some(Box::new(err))
        }
    }
}

/// Errors for the [List Dependabot alerts for an organization](Dependabot::list_alerts_for_org_async()) endpoint.
#[derive(Debug, thiserror::Error)]
pub enum DependabotListAlertsForOrgError {
    #[error("Not modified")]
    Status304,
    #[error("Bad Request")]
    Status400(BasicError),
    #[error("Forbidden")]
    Status403(BasicError),
    #[error("Resource not found")]
    Status404(BasicError),
    #[error("Validation failed, or the endpoint has been spammed.")]
    Status422(ValidationErrorSimple),
    #[error("Status code: {}", code)]
    Generic { code: u16 },
}

impl From<DependabotListAlertsForOrgError> for AdapterError {
    fn from(err: DependabotListAlertsForOrgError) -> Self {
        let (description, status_code) = match err {
            DependabotListAlertsForOrgError::Status304 => (String::from("Not modified"), 304),
            DependabotListAlertsForOrgError::Status400(_) => (String::from("Bad Request"), 400),
            DependabotListAlertsForOrgError::Status403(_) => (String::from("Forbidden"), 403),
            DependabotListAlertsForOrgError::Status404(_) => (String::from("Resource not found"), 404),
            DependabotListAlertsForOrgError::Status422(_) => (String::from("Validation failed, or the endpoint has been spammed."), 422),
            DependabotListAlertsForOrgError::Generic { code } => (String::from("Generic"), code)
        };

        Self::Endpoint {
            description,
            status_code,
            source: Some(Box::new(err))
        }
    }
}

/// Errors for the [List Dependabot alerts for a repository](Dependabot::list_alerts_for_repo_async()) endpoint.
#[derive(Debug, thiserror::Error)]
pub enum DependabotListAlertsForRepoError {
    #[error("Not modified")]
    Status304,
    #[error("Bad Request")]
    Status400(BasicError),
    #[error("Forbidden")]
    Status403(BasicError),
    #[error("Resource not found")]
    Status404(BasicError),
    #[error("Validation failed, or the endpoint has been spammed.")]
    Status422(ValidationErrorSimple),
    #[error("Status code: {}", code)]
    Generic { code: u16 },
}

impl From<DependabotListAlertsForRepoError> for AdapterError {
    fn from(err: DependabotListAlertsForRepoError) -> Self {
        let (description, status_code) = match err {
            DependabotListAlertsForRepoError::Status304 => (String::from("Not modified"), 304),
            DependabotListAlertsForRepoError::Status400(_) => (String::from("Bad Request"), 400),
            DependabotListAlertsForRepoError::Status403(_) => (String::from("Forbidden"), 403),
            DependabotListAlertsForRepoError::Status404(_) => (String::from("Resource not found"), 404),
            DependabotListAlertsForRepoError::Status422(_) => (String::from("Validation failed, or the endpoint has been spammed."), 422),
            DependabotListAlertsForRepoError::Generic { code } => (String::from("Generic"), code)
        };

        Self::Endpoint {
            description,
            status_code,
            source: Some(Box::new(err))
        }
    }
}

/// Errors for the [List organization secrets](Dependabot::list_org_secrets_async()) endpoint.
#[derive(Debug, thiserror::Error)]
pub enum DependabotListOrgSecretsError {
    #[error("Status code: {}", code)]
    Generic { code: u16 },
}

impl From<DependabotListOrgSecretsError> for AdapterError {
    fn from(err: DependabotListOrgSecretsError) -> Self {
        let (description, status_code) = match err {
            DependabotListOrgSecretsError::Generic { code } => (String::from("Generic"), code)
        };

        Self::Endpoint {
            description,
            status_code,
            source: Some(Box::new(err))
        }
    }
}

/// Errors for the [List repository secrets](Dependabot::list_repo_secrets_async()) endpoint.
#[derive(Debug, thiserror::Error)]
pub enum DependabotListRepoSecretsError {
    #[error("Status code: {}", code)]
    Generic { code: u16 },
}

impl From<DependabotListRepoSecretsError> for AdapterError {
    fn from(err: DependabotListRepoSecretsError) -> Self {
        let (description, status_code) = match err {
            DependabotListRepoSecretsError::Generic { code } => (String::from("Generic"), code)
        };

        Self::Endpoint {
            description,
            status_code,
            source: Some(Box::new(err))
        }
    }
}

/// Errors for the [List selected repositories for an organization secret](Dependabot::list_selected_repos_for_org_secret_async()) endpoint.
#[derive(Debug, thiserror::Error)]
pub enum DependabotListSelectedReposForOrgSecretError {
    #[error("Status code: {}", code)]
    Generic { code: u16 },
}

impl From<DependabotListSelectedReposForOrgSecretError> for AdapterError {
    fn from(err: DependabotListSelectedReposForOrgSecretError) -> Self {
        let (description, status_code) = match err {
            DependabotListSelectedReposForOrgSecretError::Generic { code } => (String::from("Generic"), code)
        };

        Self::Endpoint {
            description,
            status_code,
            source: Some(Box::new(err))
        }
    }
}

/// Errors for the [Remove selected repository from an organization secret](Dependabot::remove_selected_repo_from_org_secret_async()) endpoint.
#[derive(Debug, thiserror::Error)]
pub enum DependabotRemoveSelectedRepoFromOrgSecretError {
    #[error("Conflict when visibility type not set to selected")]
    Status409,
    #[error("Status code: {}", code)]
    Generic { code: u16 },
}

impl From<DependabotRemoveSelectedRepoFromOrgSecretError> for AdapterError {
    fn from(err: DependabotRemoveSelectedRepoFromOrgSecretError) -> Self {
        let (description, status_code) = match err {
            DependabotRemoveSelectedRepoFromOrgSecretError::Status409 => (String::from("Conflict when visibility type not set to selected"), 409),
            DependabotRemoveSelectedRepoFromOrgSecretError::Generic { code } => (String::from("Generic"), code)
        };

        Self::Endpoint {
            description,
            status_code,
            source: Some(Box::new(err))
        }
    }
}

/// Errors for the [Set selected repositories for an organization secret](Dependabot::set_selected_repos_for_org_secret_async()) endpoint.
#[derive(Debug, thiserror::Error)]
pub enum DependabotSetSelectedReposForOrgSecretError {
    #[error("Status code: {}", code)]
    Generic { code: u16 },
}

impl From<DependabotSetSelectedReposForOrgSecretError> for AdapterError {
    fn from(err: DependabotSetSelectedReposForOrgSecretError) -> Self {
        let (description, status_code) = match err {
            DependabotSetSelectedReposForOrgSecretError::Generic { code } => (String::from("Generic"), code)
        };

        Self::Endpoint {
            description,
            status_code,
            source: Some(Box::new(err))
        }
    }
}

/// Errors for the [Update a Dependabot alert](Dependabot::update_alert_async()) endpoint.
#[derive(Debug, thiserror::Error)]
pub enum DependabotUpdateAlertError {
    #[error("Bad Request")]
    Status400(BasicError),
    #[error("Forbidden")]
    Status403(BasicError),
    #[error("Resource not found")]
    Status404(BasicError),
    #[error("Conflict")]
    Status409(BasicError),
    #[error("Validation failed, or the endpoint has been spammed.")]
    Status422(ValidationErrorSimple),
    #[error("Status code: {}", code)]
    Generic { code: u16 },
}

impl From<DependabotUpdateAlertError> for AdapterError {
    fn from(err: DependabotUpdateAlertError) -> Self {
        let (description, status_code) = match err {
            DependabotUpdateAlertError::Status400(_) => (String::from("Bad Request"), 400),
            DependabotUpdateAlertError::Status403(_) => (String::from("Forbidden"), 403),
            DependabotUpdateAlertError::Status404(_) => (String::from("Resource not found"), 404),
            DependabotUpdateAlertError::Status409(_) => (String::from("Conflict"), 409),
            DependabotUpdateAlertError::Status422(_) => (String::from("Validation failed, or the endpoint has been spammed."), 422),
            DependabotUpdateAlertError::Generic { code } => (String::from("Generic"), code)
        };

        Self::Endpoint {
            description,
            status_code,
            source: Some(Box::new(err))
        }
    }
}


/// Query parameters for the [List Dependabot alerts for an enterprise](Dependabot::list_alerts_for_enterprise_async()) endpoint.
#[derive(Default, Serialize)]
pub struct DependabotListAlertsForEnterpriseParams<'req> {
    /// A comma-separated list of states. If specified, only alerts with these states will be returned.  Can be: `auto_dismissed`, `dismissed`, `fixed`, `open`
    state: Option<&'req str>, 
    /// A comma-separated list of severities. If specified, only alerts with these severities will be returned.  Can be: `low`, `medium`, `high`, `critical`
    severity: Option<&'req str>, 
    /// A comma-separated list of ecosystems. If specified, only alerts for these ecosystems will be returned.  Can be: `composer`, `go`, `maven`, `npm`, `nuget`, `pip`, `pub`, `rubygems`, `rust`
    ecosystem: Option<&'req str>, 
    /// A comma-separated list of package names. If specified, only alerts for these packages will be returned.
    package: Option<&'req str>, 
    /// The scope of the vulnerable dependency. If specified, only alerts with this scope will be returned.
    scope: Option<&'req str>, 
    /// The property by which to sort the results. `created` means when the alert was created. `updated` means when the alert's state last changed.
    sort: Option<&'req str>, 
    /// The direction to sort the results by.
    direction: Option<&'req str>, 
    /// A cursor, as given in the [Link header](https://docs.github.com/rest/guides/using-pagination-in-the-rest-api#using-link-headers). If specified, the query only searches for results before this cursor. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    before: Option<&'req str>, 
    /// A cursor, as given in the [Link header](https://docs.github.com/rest/guides/using-pagination-in-the-rest-api#using-link-headers). If specified, the query only searches for results after this cursor. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    after: Option<&'req str>, 
    /// **Deprecated**. The number of results per page (max 100), starting from the first matching result. This parameter must not be used in combination with `last`. Instead, use `per_page` in combination with `after` to fetch the first page of results.
    first: Option<i32>, 
    /// **Deprecated**. The number of results per page (max 100), starting from the last matching result. This parameter must not be used in combination with `first`. Instead, use `per_page` in combination with `before` to fetch the last page of results.
    last: Option<i32>, 
    /// The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    per_page: Option<u16>
}

impl<'req> DependabotListAlertsForEnterpriseParams<'req> {
    pub fn new() -> Self {
        Self::default()
    }

    /// A comma-separated list of states. If specified, only alerts with these states will be returned.  Can be: `auto_dismissed`, `dismissed`, `fixed`, `open`
    pub fn state(self, state: &'req str) -> Self {
        Self {
            state: Some(state),
            severity: self.severity, 
            ecosystem: self.ecosystem, 
            package: self.package, 
            scope: self.scope, 
            sort: self.sort, 
            direction: self.direction, 
            before: self.before, 
            after: self.after, 
            first: self.first, 
            last: self.last, 
            per_page: self.per_page, 
        }
    }

    /// A comma-separated list of severities. If specified, only alerts with these severities will be returned.  Can be: `low`, `medium`, `high`, `critical`
    pub fn severity(self, severity: &'req str) -> Self {
        Self {
            state: self.state, 
            severity: Some(severity),
            ecosystem: self.ecosystem, 
            package: self.package, 
            scope: self.scope, 
            sort: self.sort, 
            direction: self.direction, 
            before: self.before, 
            after: self.after, 
            first: self.first, 
            last: self.last, 
            per_page: self.per_page, 
        }
    }

    /// A comma-separated list of ecosystems. If specified, only alerts for these ecosystems will be returned.  Can be: `composer`, `go`, `maven`, `npm`, `nuget`, `pip`, `pub`, `rubygems`, `rust`
    pub fn ecosystem(self, ecosystem: &'req str) -> Self {
        Self {
            state: self.state, 
            severity: self.severity, 
            ecosystem: Some(ecosystem),
            package: self.package, 
            scope: self.scope, 
            sort: self.sort, 
            direction: self.direction, 
            before: self.before, 
            after: self.after, 
            first: self.first, 
            last: self.last, 
            per_page: self.per_page, 
        }
    }

    /// A comma-separated list of package names. If specified, only alerts for these packages will be returned.
    pub fn package(self, package: &'req str) -> Self {
        Self {
            state: self.state, 
            severity: self.severity, 
            ecosystem: self.ecosystem, 
            package: Some(package),
            scope: self.scope, 
            sort: self.sort, 
            direction: self.direction, 
            before: self.before, 
            after: self.after, 
            first: self.first, 
            last: self.last, 
            per_page: self.per_page, 
        }
    }

    /// The scope of the vulnerable dependency. If specified, only alerts with this scope will be returned.
    pub fn scope(self, scope: &'req str) -> Self {
        Self {
            state: self.state, 
            severity: self.severity, 
            ecosystem: self.ecosystem, 
            package: self.package, 
            scope: Some(scope),
            sort: self.sort, 
            direction: self.direction, 
            before: self.before, 
            after: self.after, 
            first: self.first, 
            last: self.last, 
            per_page: self.per_page, 
        }
    }

    /// The property by which to sort the results. `created` means when the alert was created. `updated` means when the alert's state last changed.
    pub fn sort(self, sort: &'req str) -> Self {
        Self {
            state: self.state, 
            severity: self.severity, 
            ecosystem: self.ecosystem, 
            package: self.package, 
            scope: self.scope, 
            sort: Some(sort),
            direction: self.direction, 
            before: self.before, 
            after: self.after, 
            first: self.first, 
            last: self.last, 
            per_page: self.per_page, 
        }
    }

    /// The direction to sort the results by.
    pub fn direction(self, direction: &'req str) -> Self {
        Self {
            state: self.state, 
            severity: self.severity, 
            ecosystem: self.ecosystem, 
            package: self.package, 
            scope: self.scope, 
            sort: self.sort, 
            direction: Some(direction),
            before: self.before, 
            after: self.after, 
            first: self.first, 
            last: self.last, 
            per_page: self.per_page, 
        }
    }

    /// A cursor, as given in the [Link header](https://docs.github.com/rest/guides/using-pagination-in-the-rest-api#using-link-headers). If specified, the query only searches for results before this cursor. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    pub fn before(self, before: &'req str) -> Self {
        Self {
            state: self.state, 
            severity: self.severity, 
            ecosystem: self.ecosystem, 
            package: self.package, 
            scope: self.scope, 
            sort: self.sort, 
            direction: self.direction, 
            before: Some(before),
            after: self.after, 
            first: self.first, 
            last: self.last, 
            per_page: self.per_page, 
        }
    }

    /// A cursor, as given in the [Link header](https://docs.github.com/rest/guides/using-pagination-in-the-rest-api#using-link-headers). If specified, the query only searches for results after this cursor. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    pub fn after(self, after: &'req str) -> Self {
        Self {
            state: self.state, 
            severity: self.severity, 
            ecosystem: self.ecosystem, 
            package: self.package, 
            scope: self.scope, 
            sort: self.sort, 
            direction: self.direction, 
            before: self.before, 
            after: Some(after),
            first: self.first, 
            last: self.last, 
            per_page: self.per_page, 
        }
    }

    /// **Deprecated**. The number of results per page (max 100), starting from the first matching result. This parameter must not be used in combination with `last`. Instead, use `per_page` in combination with `after` to fetch the first page of results.
    pub fn first(self, first: i32) -> Self {
        Self {
            state: self.state, 
            severity: self.severity, 
            ecosystem: self.ecosystem, 
            package: self.package, 
            scope: self.scope, 
            sort: self.sort, 
            direction: self.direction, 
            before: self.before, 
            after: self.after, 
            first: Some(first),
            last: self.last, 
            per_page: self.per_page, 
        }
    }

    /// **Deprecated**. The number of results per page (max 100), starting from the last matching result. This parameter must not be used in combination with `first`. Instead, use `per_page` in combination with `before` to fetch the last page of results.
    pub fn last(self, last: i32) -> Self {
        Self {
            state: self.state, 
            severity: self.severity, 
            ecosystem: self.ecosystem, 
            package: self.package, 
            scope: self.scope, 
            sort: self.sort, 
            direction: self.direction, 
            before: self.before, 
            after: self.after, 
            first: self.first, 
            last: Some(last),
            per_page: self.per_page, 
        }
    }

    /// The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    pub fn per_page(self, per_page: u16) -> Self {
        Self {
            state: self.state, 
            severity: self.severity, 
            ecosystem: self.ecosystem, 
            package: self.package, 
            scope: self.scope, 
            sort: self.sort, 
            direction: self.direction, 
            before: self.before, 
            after: self.after, 
            first: self.first, 
            last: self.last, 
            per_page: Some(per_page),
        }
    }
}

/// Query parameters for the [List Dependabot alerts for an organization](Dependabot::list_alerts_for_org_async()) endpoint.
#[derive(Default, Serialize)]
pub struct DependabotListAlertsForOrgParams<'req> {
    /// A comma-separated list of states. If specified, only alerts with these states will be returned.  Can be: `auto_dismissed`, `dismissed`, `fixed`, `open`
    state: Option<&'req str>, 
    /// A comma-separated list of severities. If specified, only alerts with these severities will be returned.  Can be: `low`, `medium`, `high`, `critical`
    severity: Option<&'req str>, 
    /// A comma-separated list of ecosystems. If specified, only alerts for these ecosystems will be returned.  Can be: `composer`, `go`, `maven`, `npm`, `nuget`, `pip`, `pub`, `rubygems`, `rust`
    ecosystem: Option<&'req str>, 
    /// A comma-separated list of package names. If specified, only alerts for these packages will be returned.
    package: Option<&'req str>, 
    /// The scope of the vulnerable dependency. If specified, only alerts with this scope will be returned.
    scope: Option<&'req str>, 
    /// The property by which to sort the results. `created` means when the alert was created. `updated` means when the alert's state last changed.
    sort: Option<&'req str>, 
    /// The direction to sort the results by.
    direction: Option<&'req str>, 
    /// A cursor, as given in the [Link header](https://docs.github.com/rest/guides/using-pagination-in-the-rest-api#using-link-headers). If specified, the query only searches for results before this cursor. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    before: Option<&'req str>, 
    /// A cursor, as given in the [Link header](https://docs.github.com/rest/guides/using-pagination-in-the-rest-api#using-link-headers). If specified, the query only searches for results after this cursor. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    after: Option<&'req str>, 
    /// **Deprecated**. The number of results per page (max 100), starting from the first matching result. This parameter must not be used in combination with `last`. Instead, use `per_page` in combination with `after` to fetch the first page of results.
    first: Option<i32>, 
    /// **Deprecated**. The number of results per page (max 100), starting from the last matching result. This parameter must not be used in combination with `first`. Instead, use `per_page` in combination with `before` to fetch the last page of results.
    last: Option<i32>, 
    /// The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    per_page: Option<u16>
}

impl<'req> DependabotListAlertsForOrgParams<'req> {
    pub fn new() -> Self {
        Self::default()
    }

    /// A comma-separated list of states. If specified, only alerts with these states will be returned.  Can be: `auto_dismissed`, `dismissed`, `fixed`, `open`
    pub fn state(self, state: &'req str) -> Self {
        Self {
            state: Some(state),
            severity: self.severity, 
            ecosystem: self.ecosystem, 
            package: self.package, 
            scope: self.scope, 
            sort: self.sort, 
            direction: self.direction, 
            before: self.before, 
            after: self.after, 
            first: self.first, 
            last: self.last, 
            per_page: self.per_page, 
        }
    }

    /// A comma-separated list of severities. If specified, only alerts with these severities will be returned.  Can be: `low`, `medium`, `high`, `critical`
    pub fn severity(self, severity: &'req str) -> Self {
        Self {
            state: self.state, 
            severity: Some(severity),
            ecosystem: self.ecosystem, 
            package: self.package, 
            scope: self.scope, 
            sort: self.sort, 
            direction: self.direction, 
            before: self.before, 
            after: self.after, 
            first: self.first, 
            last: self.last, 
            per_page: self.per_page, 
        }
    }

    /// A comma-separated list of ecosystems. If specified, only alerts for these ecosystems will be returned.  Can be: `composer`, `go`, `maven`, `npm`, `nuget`, `pip`, `pub`, `rubygems`, `rust`
    pub fn ecosystem(self, ecosystem: &'req str) -> Self {
        Self {
            state: self.state, 
            severity: self.severity, 
            ecosystem: Some(ecosystem),
            package: self.package, 
            scope: self.scope, 
            sort: self.sort, 
            direction: self.direction, 
            before: self.before, 
            after: self.after, 
            first: self.first, 
            last: self.last, 
            per_page: self.per_page, 
        }
    }

    /// A comma-separated list of package names. If specified, only alerts for these packages will be returned.
    pub fn package(self, package: &'req str) -> Self {
        Self {
            state: self.state, 
            severity: self.severity, 
            ecosystem: self.ecosystem, 
            package: Some(package),
            scope: self.scope, 
            sort: self.sort, 
            direction: self.direction, 
            before: self.before, 
            after: self.after, 
            first: self.first, 
            last: self.last, 
            per_page: self.per_page, 
        }
    }

    /// The scope of the vulnerable dependency. If specified, only alerts with this scope will be returned.
    pub fn scope(self, scope: &'req str) -> Self {
        Self {
            state: self.state, 
            severity: self.severity, 
            ecosystem: self.ecosystem, 
            package: self.package, 
            scope: Some(scope),
            sort: self.sort, 
            direction: self.direction, 
            before: self.before, 
            after: self.after, 
            first: self.first, 
            last: self.last, 
            per_page: self.per_page, 
        }
    }

    /// The property by which to sort the results. `created` means when the alert was created. `updated` means when the alert's state last changed.
    pub fn sort(self, sort: &'req str) -> Self {
        Self {
            state: self.state, 
            severity: self.severity, 
            ecosystem: self.ecosystem, 
            package: self.package, 
            scope: self.scope, 
            sort: Some(sort),
            direction: self.direction, 
            before: self.before, 
            after: self.after, 
            first: self.first, 
            last: self.last, 
            per_page: self.per_page, 
        }
    }

    /// The direction to sort the results by.
    pub fn direction(self, direction: &'req str) -> Self {
        Self {
            state: self.state, 
            severity: self.severity, 
            ecosystem: self.ecosystem, 
            package: self.package, 
            scope: self.scope, 
            sort: self.sort, 
            direction: Some(direction),
            before: self.before, 
            after: self.after, 
            first: self.first, 
            last: self.last, 
            per_page: self.per_page, 
        }
    }

    /// A cursor, as given in the [Link header](https://docs.github.com/rest/guides/using-pagination-in-the-rest-api#using-link-headers). If specified, the query only searches for results before this cursor. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    pub fn before(self, before: &'req str) -> Self {
        Self {
            state: self.state, 
            severity: self.severity, 
            ecosystem: self.ecosystem, 
            package: self.package, 
            scope: self.scope, 
            sort: self.sort, 
            direction: self.direction, 
            before: Some(before),
            after: self.after, 
            first: self.first, 
            last: self.last, 
            per_page: self.per_page, 
        }
    }

    /// A cursor, as given in the [Link header](https://docs.github.com/rest/guides/using-pagination-in-the-rest-api#using-link-headers). If specified, the query only searches for results after this cursor. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    pub fn after(self, after: &'req str) -> Self {
        Self {
            state: self.state, 
            severity: self.severity, 
            ecosystem: self.ecosystem, 
            package: self.package, 
            scope: self.scope, 
            sort: self.sort, 
            direction: self.direction, 
            before: self.before, 
            after: Some(after),
            first: self.first, 
            last: self.last, 
            per_page: self.per_page, 
        }
    }

    /// **Deprecated**. The number of results per page (max 100), starting from the first matching result. This parameter must not be used in combination with `last`. Instead, use `per_page` in combination with `after` to fetch the first page of results.
    pub fn first(self, first: i32) -> Self {
        Self {
            state: self.state, 
            severity: self.severity, 
            ecosystem: self.ecosystem, 
            package: self.package, 
            scope: self.scope, 
            sort: self.sort, 
            direction: self.direction, 
            before: self.before, 
            after: self.after, 
            first: Some(first),
            last: self.last, 
            per_page: self.per_page, 
        }
    }

    /// **Deprecated**. The number of results per page (max 100), starting from the last matching result. This parameter must not be used in combination with `first`. Instead, use `per_page` in combination with `before` to fetch the last page of results.
    pub fn last(self, last: i32) -> Self {
        Self {
            state: self.state, 
            severity: self.severity, 
            ecosystem: self.ecosystem, 
            package: self.package, 
            scope: self.scope, 
            sort: self.sort, 
            direction: self.direction, 
            before: self.before, 
            after: self.after, 
            first: self.first, 
            last: Some(last),
            per_page: self.per_page, 
        }
    }

    /// The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    pub fn per_page(self, per_page: u16) -> Self {
        Self {
            state: self.state, 
            severity: self.severity, 
            ecosystem: self.ecosystem, 
            package: self.package, 
            scope: self.scope, 
            sort: self.sort, 
            direction: self.direction, 
            before: self.before, 
            after: self.after, 
            first: self.first, 
            last: self.last, 
            per_page: Some(per_page),
        }
    }
}

/// Query parameters for the [List Dependabot alerts for a repository](Dependabot::list_alerts_for_repo_async()) endpoint.
#[derive(Default, Serialize)]
pub struct DependabotListAlertsForRepoParams<'req> {
    /// A comma-separated list of states. If specified, only alerts with these states will be returned.  Can be: `auto_dismissed`, `dismissed`, `fixed`, `open`
    state: Option<&'req str>, 
    /// A comma-separated list of severities. If specified, only alerts with these severities will be returned.  Can be: `low`, `medium`, `high`, `critical`
    severity: Option<&'req str>, 
    /// A comma-separated list of ecosystems. If specified, only alerts for these ecosystems will be returned.  Can be: `composer`, `go`, `maven`, `npm`, `nuget`, `pip`, `pub`, `rubygems`, `rust`
    ecosystem: Option<&'req str>, 
    /// A comma-separated list of package names. If specified, only alerts for these packages will be returned.
    package: Option<&'req str>, 
    /// A comma-separated list of full manifest paths. If specified, only alerts for these manifests will be returned.
    manifest: Option<&'req str>, 
    /// The scope of the vulnerable dependency. If specified, only alerts with this scope will be returned.
    scope: Option<&'req str>, 
    /// The property by which to sort the results. `created` means when the alert was created. `updated` means when the alert's state last changed.
    sort: Option<&'req str>, 
    /// The direction to sort the results by.
    direction: Option<&'req str>, 
    /// **Closing down notice**. Page number of the results to fetch. Use cursor-based pagination with `before` or `after` instead.
    page: Option<u16>, 
    /// The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    per_page: Option<u16>, 
    /// A cursor, as given in the [Link header](https://docs.github.com/rest/guides/using-pagination-in-the-rest-api#using-link-headers). If specified, the query only searches for results before this cursor. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    before: Option<&'req str>, 
    /// A cursor, as given in the [Link header](https://docs.github.com/rest/guides/using-pagination-in-the-rest-api#using-link-headers). If specified, the query only searches for results after this cursor. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    after: Option<&'req str>, 
    /// **Deprecated**. The number of results per page (max 100), starting from the first matching result. This parameter must not be used in combination with `last`. Instead, use `per_page` in combination with `after` to fetch the first page of results.
    first: Option<i32>, 
    /// **Deprecated**. The number of results per page (max 100), starting from the last matching result. This parameter must not be used in combination with `first`. Instead, use `per_page` in combination with `before` to fetch the last page of results.
    last: Option<i32>
}

impl<'req> DependabotListAlertsForRepoParams<'req> {
    pub fn new() -> Self {
        Self::default()
    }

    /// A comma-separated list of states. If specified, only alerts with these states will be returned.  Can be: `auto_dismissed`, `dismissed`, `fixed`, `open`
    pub fn state(self, state: &'req str) -> Self {
        Self {
            state: Some(state),
            severity: self.severity, 
            ecosystem: self.ecosystem, 
            package: self.package, 
            manifest: self.manifest, 
            scope: self.scope, 
            sort: self.sort, 
            direction: self.direction, 
            page: self.page, 
            per_page: self.per_page, 
            before: self.before, 
            after: self.after, 
            first: self.first, 
            last: self.last, 
        }
    }

    /// A comma-separated list of severities. If specified, only alerts with these severities will be returned.  Can be: `low`, `medium`, `high`, `critical`
    pub fn severity(self, severity: &'req str) -> Self {
        Self {
            state: self.state, 
            severity: Some(severity),
            ecosystem: self.ecosystem, 
            package: self.package, 
            manifest: self.manifest, 
            scope: self.scope, 
            sort: self.sort, 
            direction: self.direction, 
            page: self.page, 
            per_page: self.per_page, 
            before: self.before, 
            after: self.after, 
            first: self.first, 
            last: self.last, 
        }
    }

    /// A comma-separated list of ecosystems. If specified, only alerts for these ecosystems will be returned.  Can be: `composer`, `go`, `maven`, `npm`, `nuget`, `pip`, `pub`, `rubygems`, `rust`
    pub fn ecosystem(self, ecosystem: &'req str) -> Self {
        Self {
            state: self.state, 
            severity: self.severity, 
            ecosystem: Some(ecosystem),
            package: self.package, 
            manifest: self.manifest, 
            scope: self.scope, 
            sort: self.sort, 
            direction: self.direction, 
            page: self.page, 
            per_page: self.per_page, 
            before: self.before, 
            after: self.after, 
            first: self.first, 
            last: self.last, 
        }
    }

    /// A comma-separated list of package names. If specified, only alerts for these packages will be returned.
    pub fn package(self, package: &'req str) -> Self {
        Self {
            state: self.state, 
            severity: self.severity, 
            ecosystem: self.ecosystem, 
            package: Some(package),
            manifest: self.manifest, 
            scope: self.scope, 
            sort: self.sort, 
            direction: self.direction, 
            page: self.page, 
            per_page: self.per_page, 
            before: self.before, 
            after: self.after, 
            first: self.first, 
            last: self.last, 
        }
    }

    /// A comma-separated list of full manifest paths. If specified, only alerts for these manifests will be returned.
    pub fn manifest(self, manifest: &'req str) -> Self {
        Self {
            state: self.state, 
            severity: self.severity, 
            ecosystem: self.ecosystem, 
            package: self.package, 
            manifest: Some(manifest),
            scope: self.scope, 
            sort: self.sort, 
            direction: self.direction, 
            page: self.page, 
            per_page: self.per_page, 
            before: self.before, 
            after: self.after, 
            first: self.first, 
            last: self.last, 
        }
    }

    /// The scope of the vulnerable dependency. If specified, only alerts with this scope will be returned.
    pub fn scope(self, scope: &'req str) -> Self {
        Self {
            state: self.state, 
            severity: self.severity, 
            ecosystem: self.ecosystem, 
            package: self.package, 
            manifest: self.manifest, 
            scope: Some(scope),
            sort: self.sort, 
            direction: self.direction, 
            page: self.page, 
            per_page: self.per_page, 
            before: self.before, 
            after: self.after, 
            first: self.first, 
            last: self.last, 
        }
    }

    /// The property by which to sort the results. `created` means when the alert was created. `updated` means when the alert's state last changed.
    pub fn sort(self, sort: &'req str) -> Self {
        Self {
            state: self.state, 
            severity: self.severity, 
            ecosystem: self.ecosystem, 
            package: self.package, 
            manifest: self.manifest, 
            scope: self.scope, 
            sort: Some(sort),
            direction: self.direction, 
            page: self.page, 
            per_page: self.per_page, 
            before: self.before, 
            after: self.after, 
            first: self.first, 
            last: self.last, 
        }
    }

    /// The direction to sort the results by.
    pub fn direction(self, direction: &'req str) -> Self {
        Self {
            state: self.state, 
            severity: self.severity, 
            ecosystem: self.ecosystem, 
            package: self.package, 
            manifest: self.manifest, 
            scope: self.scope, 
            sort: self.sort, 
            direction: Some(direction),
            page: self.page, 
            per_page: self.per_page, 
            before: self.before, 
            after: self.after, 
            first: self.first, 
            last: self.last, 
        }
    }

    /// **Closing down notice**. Page number of the results to fetch. Use cursor-based pagination with `before` or `after` instead.
    pub fn page(self, page: u16) -> Self {
        Self {
            state: self.state, 
            severity: self.severity, 
            ecosystem: self.ecosystem, 
            package: self.package, 
            manifest: self.manifest, 
            scope: self.scope, 
            sort: self.sort, 
            direction: self.direction, 
            page: Some(page),
            per_page: self.per_page, 
            before: self.before, 
            after: self.after, 
            first: self.first, 
            last: self.last, 
        }
    }

    /// The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    pub fn per_page(self, per_page: u16) -> Self {
        Self {
            state: self.state, 
            severity: self.severity, 
            ecosystem: self.ecosystem, 
            package: self.package, 
            manifest: self.manifest, 
            scope: self.scope, 
            sort: self.sort, 
            direction: self.direction, 
            page: self.page, 
            per_page: Some(per_page),
            before: self.before, 
            after: self.after, 
            first: self.first, 
            last: self.last, 
        }
    }

    /// A cursor, as given in the [Link header](https://docs.github.com/rest/guides/using-pagination-in-the-rest-api#using-link-headers). If specified, the query only searches for results before this cursor. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    pub fn before(self, before: &'req str) -> Self {
        Self {
            state: self.state, 
            severity: self.severity, 
            ecosystem: self.ecosystem, 
            package: self.package, 
            manifest: self.manifest, 
            scope: self.scope, 
            sort: self.sort, 
            direction: self.direction, 
            page: self.page, 
            per_page: self.per_page, 
            before: Some(before),
            after: self.after, 
            first: self.first, 
            last: self.last, 
        }
    }

    /// A cursor, as given in the [Link header](https://docs.github.com/rest/guides/using-pagination-in-the-rest-api#using-link-headers). If specified, the query only searches for results after this cursor. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    pub fn after(self, after: &'req str) -> Self {
        Self {
            state: self.state, 
            severity: self.severity, 
            ecosystem: self.ecosystem, 
            package: self.package, 
            manifest: self.manifest, 
            scope: self.scope, 
            sort: self.sort, 
            direction: self.direction, 
            page: self.page, 
            per_page: self.per_page, 
            before: self.before, 
            after: Some(after),
            first: self.first, 
            last: self.last, 
        }
    }

    /// **Deprecated**. The number of results per page (max 100), starting from the first matching result. This parameter must not be used in combination with `last`. Instead, use `per_page` in combination with `after` to fetch the first page of results.
    pub fn first(self, first: i32) -> Self {
        Self {
            state: self.state, 
            severity: self.severity, 
            ecosystem: self.ecosystem, 
            package: self.package, 
            manifest: self.manifest, 
            scope: self.scope, 
            sort: self.sort, 
            direction: self.direction, 
            page: self.page, 
            per_page: self.per_page, 
            before: self.before, 
            after: self.after, 
            first: Some(first),
            last: self.last, 
        }
    }

    /// **Deprecated**. The number of results per page (max 100), starting from the last matching result. This parameter must not be used in combination with `first`. Instead, use `per_page` in combination with `before` to fetch the last page of results.
    pub fn last(self, last: i32) -> Self {
        Self {
            state: self.state, 
            severity: self.severity, 
            ecosystem: self.ecosystem, 
            package: self.package, 
            manifest: self.manifest, 
            scope: self.scope, 
            sort: self.sort, 
            direction: self.direction, 
            page: self.page, 
            per_page: self.per_page, 
            before: self.before, 
            after: self.after, 
            first: self.first, 
            last: Some(last),
        }
    }
}

impl<'enc> From<&'enc PerPage> for DependabotListAlertsForRepoParams<'enc> {
    fn from(per_page: &'enc PerPage) -> Self {
        Self {
            per_page: Some(per_page.per_page),
            page: Some(per_page.page),
            ..Default::default()
        }
    }
}
/// Query parameters for the [List organization secrets](Dependabot::list_org_secrets_async()) endpoint.
#[derive(Default, Serialize)]
pub struct DependabotListOrgSecretsParams {
    /// The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    per_page: Option<u16>, 
    /// The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    page: Option<u16>
}

impl DependabotListOrgSecretsParams {
    pub fn new() -> Self {
        Self::default()
    }

    /// The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    pub fn per_page(self, per_page: u16) -> Self {
        Self {
            per_page: Some(per_page),
            page: self.page, 
        }
    }

    /// The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    pub fn page(self, page: u16) -> Self {
        Self {
            per_page: self.per_page, 
            page: Some(page),
        }
    }
}

impl<'enc> From<&'enc PerPage> for DependabotListOrgSecretsParams {
    fn from(per_page: &'enc PerPage) -> Self {
        Self {
            per_page: Some(per_page.per_page),
            page: Some(per_page.page),
            ..Default::default()
        }
    }
}
/// Query parameters for the [List repository secrets](Dependabot::list_repo_secrets_async()) endpoint.
#[derive(Default, Serialize)]
pub struct DependabotListRepoSecretsParams {
    /// The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    per_page: Option<u16>, 
    /// The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    page: Option<u16>
}

impl DependabotListRepoSecretsParams {
    pub fn new() -> Self {
        Self::default()
    }

    /// The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    pub fn per_page(self, per_page: u16) -> Self {
        Self {
            per_page: Some(per_page),
            page: self.page, 
        }
    }

    /// The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    pub fn page(self, page: u16) -> Self {
        Self {
            per_page: self.per_page, 
            page: Some(page),
        }
    }
}

impl<'enc> From<&'enc PerPage> for DependabotListRepoSecretsParams {
    fn from(per_page: &'enc PerPage) -> Self {
        Self {
            per_page: Some(per_page.per_page),
            page: Some(per_page.page),
            ..Default::default()
        }
    }
}
/// Query parameters for the [List selected repositories for an organization secret](Dependabot::list_selected_repos_for_org_secret_async()) endpoint.
#[derive(Default, Serialize)]
pub struct DependabotListSelectedReposForOrgSecretParams {
    /// The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    page: Option<u16>, 
    /// The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    per_page: Option<u16>
}

impl DependabotListSelectedReposForOrgSecretParams {
    pub fn new() -> Self {
        Self::default()
    }

    /// The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    pub fn page(self, page: u16) -> Self {
        Self {
            page: Some(page),
            per_page: self.per_page, 
        }
    }

    /// The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    pub fn per_page(self, per_page: u16) -> Self {
        Self {
            page: self.page, 
            per_page: Some(per_page),
        }
    }
}

impl<'enc> From<&'enc PerPage> for DependabotListSelectedReposForOrgSecretParams {
    fn from(per_page: &'enc PerPage) -> Self {
        Self {
            per_page: Some(per_page.per_page),
            page: Some(per_page.page),
            ..Default::default()
        }
    }
}

impl<'api, C: Client> Dependabot<'api, C> where AdapterError: From<<C as Client>::Err> {
    /// ---
    ///
    /// # Add selected repository to an organization secret
    ///
    /// Adds a repository to an organization secret when the `visibility` for
    /// repository access is set to `selected`. The visibility is set when you [Create or
    /// update an organization secret](https://docs.github.com/rest/dependabot/secrets#create-or-update-an-organization-secret).
    /// 
    /// OAuth app tokens and personal access tokens (classic) need the `admin:org` scope to use this endpoint.
    ///
    /// [GitHub API docs for add_selected_repo_to_org_secret](https://docs.github.com/rest/dependabot/secrets#add-selected-repository-to-an-organization-secret)
    ///
    /// ---
    pub async fn add_selected_repo_to_org_secret_async(&self, org: &str, secret_name: &str, repository_id: i32) -> Result<(), AdapterError> {

        let request_uri = format!("{}/orgs/{}/dependabot/secrets/{}/repositories/{}", super::GITHUB_BASE_API_URL, org, secret_name, repository_id);


        let req = GitHubRequest {
            uri: request_uri,
            body: None::<C::Body>,
            method: "PUT",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch_async(request).await?;

        // --

        if github_response.is_success() {
            Ok(())
        } else {
            match github_response.status_code() {
                409 => Err(DependabotAddSelectedRepoToOrgSecretError::Status409.into()),
                code => Err(DependabotAddSelectedRepoToOrgSecretError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # Add selected repository to an organization secret
    ///
    /// Adds a repository to an organization secret when the `visibility` for
    /// repository access is set to `selected`. The visibility is set when you [Create or
    /// update an organization secret](https://docs.github.com/rest/dependabot/secrets#create-or-update-an-organization-secret).
    /// 
    /// OAuth app tokens and personal access tokens (classic) need the `admin:org` scope to use this endpoint.
    ///
    /// [GitHub API docs for add_selected_repo_to_org_secret](https://docs.github.com/rest/dependabot/secrets#add-selected-repository-to-an-organization-secret)
    ///
    /// ---
    #[cfg(not(target_arch = "wasm32"))]
    pub fn add_selected_repo_to_org_secret(&self, org: &str, secret_name: &str, repository_id: i32) -> Result<(), AdapterError> {

        let request_uri = format!("{}/orgs/{}/dependabot/secrets/{}/repositories/{}", super::GITHUB_BASE_API_URL, org, secret_name, repository_id);


        let req = GitHubRequest {
            uri: request_uri,
            body: None,
            method: "PUT",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch(request)?;

        // --

        if github_response.is_success() {
            Ok(())
        } else {
            match github_response.status_code() {
                409 => Err(DependabotAddSelectedRepoToOrgSecretError::Status409.into()),
                code => Err(DependabotAddSelectedRepoToOrgSecretError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # Create or update an organization secret
    ///
    /// Creates or updates an organization secret with an encrypted value. Encrypt your secret using
    /// [LibSodium](https://libsodium.gitbook.io/doc/bindings_for_other_languages). For more information, see "[Encrypting secrets for the REST API](https://docs.github.com/rest/guides/encrypting-secrets-for-the-rest-api)."
    /// 
    /// OAuth app tokens and personal access tokens (classic) need the `admin:org` scope to use this endpoint.
    ///
    /// [GitHub API docs for create_or_update_org_secret](https://docs.github.com/rest/dependabot/secrets#create-or-update-an-organization-secret)
    ///
    /// ---
    pub async fn create_or_update_org_secret_async(&self, org: &str, secret_name: &str, body: PutDependabotCreateOrUpdateOrgSecret) -> Result<EmptyObject, AdapterError> {

        let request_uri = format!("{}/orgs/{}/dependabot/secrets/{}", super::GITHUB_BASE_API_URL, org, secret_name);


        let req = GitHubRequest {
            uri: request_uri,
            body: Some(C::from_json::<PutDependabotCreateOrUpdateOrgSecret>(body)?),
            method: "PUT",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch_async(request).await?;

        // --

        if github_response.is_success() {
            Ok(github_response.to_json_async().await?)
        } else {
            match github_response.status_code() {
                204 => Err(DependabotCreateOrUpdateOrgSecretError::Status204.into()),
                code => Err(DependabotCreateOrUpdateOrgSecretError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # Create or update an organization secret
    ///
    /// Creates or updates an organization secret with an encrypted value. Encrypt your secret using
    /// [LibSodium](https://libsodium.gitbook.io/doc/bindings_for_other_languages). For more information, see "[Encrypting secrets for the REST API](https://docs.github.com/rest/guides/encrypting-secrets-for-the-rest-api)."
    /// 
    /// OAuth app tokens and personal access tokens (classic) need the `admin:org` scope to use this endpoint.
    ///
    /// [GitHub API docs for create_or_update_org_secret](https://docs.github.com/rest/dependabot/secrets#create-or-update-an-organization-secret)
    ///
    /// ---
    #[cfg(not(target_arch = "wasm32"))]
    pub fn create_or_update_org_secret(&self, org: &str, secret_name: &str, body: PutDependabotCreateOrUpdateOrgSecret) -> Result<EmptyObject, AdapterError> {

        let request_uri = format!("{}/orgs/{}/dependabot/secrets/{}", super::GITHUB_BASE_API_URL, org, secret_name);


        let req = GitHubRequest {
            uri: request_uri,
            body: Some(C::from_json::<PutDependabotCreateOrUpdateOrgSecret>(body)?),
            method: "PUT",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch(request)?;

        // --

        if github_response.is_success() {
            Ok(github_response.to_json()?)
        } else {
            match github_response.status_code() {
                204 => Err(DependabotCreateOrUpdateOrgSecretError::Status204.into()),
                code => Err(DependabotCreateOrUpdateOrgSecretError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # Create or update a repository secret
    ///
    /// Creates or updates a repository secret with an encrypted value. Encrypt your secret using
    /// [LibSodium](https://libsodium.gitbook.io/doc/bindings_for_other_languages). For more information, see "[Encrypting secrets for the REST API](https://docs.github.com/rest/guides/encrypting-secrets-for-the-rest-api)."
    /// 
    /// OAuth app tokens and personal access tokens (classic) need the `repo` scope to use this endpoint.
    ///
    /// [GitHub API docs for create_or_update_repo_secret](https://docs.github.com/rest/dependabot/secrets#create-or-update-a-repository-secret)
    ///
    /// ---
    pub async fn create_or_update_repo_secret_async(&self, owner: &str, repo: &str, secret_name: &str, body: PutDependabotCreateOrUpdateRepoSecret) -> Result<EmptyObject, AdapterError> {

        let request_uri = format!("{}/repos/{}/{}/dependabot/secrets/{}", super::GITHUB_BASE_API_URL, owner, repo, secret_name);


        let req = GitHubRequest {
            uri: request_uri,
            body: Some(C::from_json::<PutDependabotCreateOrUpdateRepoSecret>(body)?),
            method: "PUT",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch_async(request).await?;

        // --

        if github_response.is_success() {
            Ok(github_response.to_json_async().await?)
        } else {
            match github_response.status_code() {
                204 => Err(DependabotCreateOrUpdateRepoSecretError::Status204.into()),
                code => Err(DependabotCreateOrUpdateRepoSecretError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # Create or update a repository secret
    ///
    /// Creates or updates a repository secret with an encrypted value. Encrypt your secret using
    /// [LibSodium](https://libsodium.gitbook.io/doc/bindings_for_other_languages). For more information, see "[Encrypting secrets for the REST API](https://docs.github.com/rest/guides/encrypting-secrets-for-the-rest-api)."
    /// 
    /// OAuth app tokens and personal access tokens (classic) need the `repo` scope to use this endpoint.
    ///
    /// [GitHub API docs for create_or_update_repo_secret](https://docs.github.com/rest/dependabot/secrets#create-or-update-a-repository-secret)
    ///
    /// ---
    #[cfg(not(target_arch = "wasm32"))]
    pub fn create_or_update_repo_secret(&self, owner: &str, repo: &str, secret_name: &str, body: PutDependabotCreateOrUpdateRepoSecret) -> Result<EmptyObject, AdapterError> {

        let request_uri = format!("{}/repos/{}/{}/dependabot/secrets/{}", super::GITHUB_BASE_API_URL, owner, repo, secret_name);


        let req = GitHubRequest {
            uri: request_uri,
            body: Some(C::from_json::<PutDependabotCreateOrUpdateRepoSecret>(body)?),
            method: "PUT",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch(request)?;

        // --

        if github_response.is_success() {
            Ok(github_response.to_json()?)
        } else {
            match github_response.status_code() {
                204 => Err(DependabotCreateOrUpdateRepoSecretError::Status204.into()),
                code => Err(DependabotCreateOrUpdateRepoSecretError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # Delete an organization secret
    ///
    /// Deletes a secret in an organization using the secret name.
    /// 
    /// OAuth app tokens and personal access tokens (classic) need the `admin:org` scope to use this endpoint.
    ///
    /// [GitHub API docs for delete_org_secret](https://docs.github.com/rest/dependabot/secrets#delete-an-organization-secret)
    ///
    /// ---
    pub async fn delete_org_secret_async(&self, org: &str, secret_name: &str) -> Result<(), AdapterError> {

        let request_uri = format!("{}/orgs/{}/dependabot/secrets/{}", super::GITHUB_BASE_API_URL, org, secret_name);


        let req = GitHubRequest {
            uri: request_uri,
            body: None::<C::Body>,
            method: "DELETE",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch_async(request).await?;

        // --

        if github_response.is_success() {
            Ok(())
        } else {
            match github_response.status_code() {
                code => Err(DependabotDeleteOrgSecretError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # Delete an organization secret
    ///
    /// Deletes a secret in an organization using the secret name.
    /// 
    /// OAuth app tokens and personal access tokens (classic) need the `admin:org` scope to use this endpoint.
    ///
    /// [GitHub API docs for delete_org_secret](https://docs.github.com/rest/dependabot/secrets#delete-an-organization-secret)
    ///
    /// ---
    #[cfg(not(target_arch = "wasm32"))]
    pub fn delete_org_secret(&self, org: &str, secret_name: &str) -> Result<(), AdapterError> {

        let request_uri = format!("{}/orgs/{}/dependabot/secrets/{}", super::GITHUB_BASE_API_URL, org, secret_name);


        let req = GitHubRequest {
            uri: request_uri,
            body: None,
            method: "DELETE",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch(request)?;

        // --

        if github_response.is_success() {
            Ok(())
        } else {
            match github_response.status_code() {
                code => Err(DependabotDeleteOrgSecretError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # Delete a repository secret
    ///
    /// Deletes a secret in a repository using the secret name.
    /// 
    /// OAuth app tokens and personal access tokens (classic) need the `repo` scope to use this endpoint.
    ///
    /// [GitHub API docs for delete_repo_secret](https://docs.github.com/rest/dependabot/secrets#delete-a-repository-secret)
    ///
    /// ---
    pub async fn delete_repo_secret_async(&self, owner: &str, repo: &str, secret_name: &str) -> Result<(), AdapterError> {

        let request_uri = format!("{}/repos/{}/{}/dependabot/secrets/{}", super::GITHUB_BASE_API_URL, owner, repo, secret_name);


        let req = GitHubRequest {
            uri: request_uri,
            body: None::<C::Body>,
            method: "DELETE",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch_async(request).await?;

        // --

        if github_response.is_success() {
            Ok(())
        } else {
            match github_response.status_code() {
                code => Err(DependabotDeleteRepoSecretError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # Delete a repository secret
    ///
    /// Deletes a secret in a repository using the secret name.
    /// 
    /// OAuth app tokens and personal access tokens (classic) need the `repo` scope to use this endpoint.
    ///
    /// [GitHub API docs for delete_repo_secret](https://docs.github.com/rest/dependabot/secrets#delete-a-repository-secret)
    ///
    /// ---
    #[cfg(not(target_arch = "wasm32"))]
    pub fn delete_repo_secret(&self, owner: &str, repo: &str, secret_name: &str) -> Result<(), AdapterError> {

        let request_uri = format!("{}/repos/{}/{}/dependabot/secrets/{}", super::GITHUB_BASE_API_URL, owner, repo, secret_name);


        let req = GitHubRequest {
            uri: request_uri,
            body: None,
            method: "DELETE",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch(request)?;

        // --

        if github_response.is_success() {
            Ok(())
        } else {
            match github_response.status_code() {
                code => Err(DependabotDeleteRepoSecretError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # Get a Dependabot alert
    ///
    /// OAuth app tokens and personal access tokens (classic) need the `security_events` scope to use this endpoint. If this endpoint is only used with public repositories, the token can use the `public_repo` scope instead.
    ///
    /// [GitHub API docs for get_alert](https://docs.github.com/rest/dependabot/alerts#get-a-dependabot-alert)
    ///
    /// ---
    pub async fn get_alert_async(&self, owner: &str, repo: &str, alert_number: AlertNumber) -> Result<DependabotAlert, AdapterError> {

        let request_uri = format!("{}/repos/{}/{}/dependabot/alerts/{}", super::GITHUB_BASE_API_URL, owner, repo, alert_number);


        let req = GitHubRequest {
            uri: request_uri,
            body: None::<C::Body>,
            method: "GET",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch_async(request).await?;

        // --

        if github_response.is_success() {
            Ok(github_response.to_json_async().await?)
        } else {
            match github_response.status_code() {
                304 => Err(DependabotGetAlertError::Status304.into()),
                403 => Err(DependabotGetAlertError::Status403(github_response.to_json_async().await?).into()),
                404 => Err(DependabotGetAlertError::Status404(github_response.to_json_async().await?).into()),
                code => Err(DependabotGetAlertError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # Get a Dependabot alert
    ///
    /// OAuth app tokens and personal access tokens (classic) need the `security_events` scope to use this endpoint. If this endpoint is only used with public repositories, the token can use the `public_repo` scope instead.
    ///
    /// [GitHub API docs for get_alert](https://docs.github.com/rest/dependabot/alerts#get-a-dependabot-alert)
    ///
    /// ---
    #[cfg(not(target_arch = "wasm32"))]
    pub fn get_alert(&self, owner: &str, repo: &str, alert_number: AlertNumber) -> Result<DependabotAlert, AdapterError> {

        let request_uri = format!("{}/repos/{}/{}/dependabot/alerts/{}", super::GITHUB_BASE_API_URL, owner, repo, alert_number);


        let req = GitHubRequest {
            uri: request_uri,
            body: None,
            method: "GET",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch(request)?;

        // --

        if github_response.is_success() {
            Ok(github_response.to_json()?)
        } else {
            match github_response.status_code() {
                304 => Err(DependabotGetAlertError::Status304.into()),
                403 => Err(DependabotGetAlertError::Status403(github_response.to_json()?).into()),
                404 => Err(DependabotGetAlertError::Status404(github_response.to_json()?).into()),
                code => Err(DependabotGetAlertError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # Get an organization public key
    ///
    /// Gets your public key, which you need to encrypt secrets. You need to
    /// encrypt a secret before you can create or update secrets.
    /// 
    /// OAuth app tokens and personal access tokens (classic) need the `admin:org` scope to use this endpoint.
    ///
    /// [GitHub API docs for get_org_public_key](https://docs.github.com/rest/dependabot/secrets#get-an-organization-public-key)
    ///
    /// ---
    pub async fn get_org_public_key_async(&self, org: &str) -> Result<DependabotPublicKey, AdapterError> {

        let request_uri = format!("{}/orgs/{}/dependabot/secrets/public-key", super::GITHUB_BASE_API_URL, org);


        let req = GitHubRequest {
            uri: request_uri,
            body: None::<C::Body>,
            method: "GET",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch_async(request).await?;

        // --

        if github_response.is_success() {
            Ok(github_response.to_json_async().await?)
        } else {
            match github_response.status_code() {
                code => Err(DependabotGetOrgPublicKeyError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # Get an organization public key
    ///
    /// Gets your public key, which you need to encrypt secrets. You need to
    /// encrypt a secret before you can create or update secrets.
    /// 
    /// OAuth app tokens and personal access tokens (classic) need the `admin:org` scope to use this endpoint.
    ///
    /// [GitHub API docs for get_org_public_key](https://docs.github.com/rest/dependabot/secrets#get-an-organization-public-key)
    ///
    /// ---
    #[cfg(not(target_arch = "wasm32"))]
    pub fn get_org_public_key(&self, org: &str) -> Result<DependabotPublicKey, AdapterError> {

        let request_uri = format!("{}/orgs/{}/dependabot/secrets/public-key", super::GITHUB_BASE_API_URL, org);


        let req = GitHubRequest {
            uri: request_uri,
            body: None,
            method: "GET",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch(request)?;

        // --

        if github_response.is_success() {
            Ok(github_response.to_json()?)
        } else {
            match github_response.status_code() {
                code => Err(DependabotGetOrgPublicKeyError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # Get an organization secret
    ///
    /// Gets a single organization secret without revealing its encrypted value.
    /// 
    /// OAuth app tokens and personal access tokens (classic) need the `admin:org` scope to use this endpoint.
    ///
    /// [GitHub API docs for get_org_secret](https://docs.github.com/rest/dependabot/secrets#get-an-organization-secret)
    ///
    /// ---
    pub async fn get_org_secret_async(&self, org: &str, secret_name: &str) -> Result<OrganizationDependabotSecret, AdapterError> {

        let request_uri = format!("{}/orgs/{}/dependabot/secrets/{}", super::GITHUB_BASE_API_URL, org, secret_name);


        let req = GitHubRequest {
            uri: request_uri,
            body: None::<C::Body>,
            method: "GET",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch_async(request).await?;

        // --

        if github_response.is_success() {
            Ok(github_response.to_json_async().await?)
        } else {
            match github_response.status_code() {
                code => Err(DependabotGetOrgSecretError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # Get an organization secret
    ///
    /// Gets a single organization secret without revealing its encrypted value.
    /// 
    /// OAuth app tokens and personal access tokens (classic) need the `admin:org` scope to use this endpoint.
    ///
    /// [GitHub API docs for get_org_secret](https://docs.github.com/rest/dependabot/secrets#get-an-organization-secret)
    ///
    /// ---
    #[cfg(not(target_arch = "wasm32"))]
    pub fn get_org_secret(&self, org: &str, secret_name: &str) -> Result<OrganizationDependabotSecret, AdapterError> {

        let request_uri = format!("{}/orgs/{}/dependabot/secrets/{}", super::GITHUB_BASE_API_URL, org, secret_name);


        let req = GitHubRequest {
            uri: request_uri,
            body: None,
            method: "GET",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch(request)?;

        // --

        if github_response.is_success() {
            Ok(github_response.to_json()?)
        } else {
            match github_response.status_code() {
                code => Err(DependabotGetOrgSecretError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # Get a repository public key
    ///
    /// Gets your public key, which you need to encrypt secrets. You need to
    /// encrypt a secret before you can create or update secrets. Anyone with read access
    /// to the repository can use this endpoint.
    /// 
    /// OAuth app tokens and personal access tokens (classic) need the `repo` scope to use this endpoint if the repository is private.
    ///
    /// [GitHub API docs for get_repo_public_key](https://docs.github.com/rest/dependabot/secrets#get-a-repository-public-key)
    ///
    /// ---
    pub async fn get_repo_public_key_async(&self, owner: &str, repo: &str) -> Result<DependabotPublicKey, AdapterError> {

        let request_uri = format!("{}/repos/{}/{}/dependabot/secrets/public-key", super::GITHUB_BASE_API_URL, owner, repo);


        let req = GitHubRequest {
            uri: request_uri,
            body: None::<C::Body>,
            method: "GET",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch_async(request).await?;

        // --

        if github_response.is_success() {
            Ok(github_response.to_json_async().await?)
        } else {
            match github_response.status_code() {
                code => Err(DependabotGetRepoPublicKeyError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # Get a repository public key
    ///
    /// Gets your public key, which you need to encrypt secrets. You need to
    /// encrypt a secret before you can create or update secrets. Anyone with read access
    /// to the repository can use this endpoint.
    /// 
    /// OAuth app tokens and personal access tokens (classic) need the `repo` scope to use this endpoint if the repository is private.
    ///
    /// [GitHub API docs for get_repo_public_key](https://docs.github.com/rest/dependabot/secrets#get-a-repository-public-key)
    ///
    /// ---
    #[cfg(not(target_arch = "wasm32"))]
    pub fn get_repo_public_key(&self, owner: &str, repo: &str) -> Result<DependabotPublicKey, AdapterError> {

        let request_uri = format!("{}/repos/{}/{}/dependabot/secrets/public-key", super::GITHUB_BASE_API_URL, owner, repo);


        let req = GitHubRequest {
            uri: request_uri,
            body: None,
            method: "GET",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch(request)?;

        // --

        if github_response.is_success() {
            Ok(github_response.to_json()?)
        } else {
            match github_response.status_code() {
                code => Err(DependabotGetRepoPublicKeyError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # Get a repository secret
    ///
    /// Gets a single repository secret without revealing its encrypted value.
    /// 
    /// OAuth app tokens and personal access tokens (classic) need the `repo` scope to use this endpoint.
    ///
    /// [GitHub API docs for get_repo_secret](https://docs.github.com/rest/dependabot/secrets#get-a-repository-secret)
    ///
    /// ---
    pub async fn get_repo_secret_async(&self, owner: &str, repo: &str, secret_name: &str) -> Result<DependabotSecret, AdapterError> {

        let request_uri = format!("{}/repos/{}/{}/dependabot/secrets/{}", super::GITHUB_BASE_API_URL, owner, repo, secret_name);


        let req = GitHubRequest {
            uri: request_uri,
            body: None::<C::Body>,
            method: "GET",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch_async(request).await?;

        // --

        if github_response.is_success() {
            Ok(github_response.to_json_async().await?)
        } else {
            match github_response.status_code() {
                code => Err(DependabotGetRepoSecretError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # Get a repository secret
    ///
    /// Gets a single repository secret without revealing its encrypted value.
    /// 
    /// OAuth app tokens and personal access tokens (classic) need the `repo` scope to use this endpoint.
    ///
    /// [GitHub API docs for get_repo_secret](https://docs.github.com/rest/dependabot/secrets#get-a-repository-secret)
    ///
    /// ---
    #[cfg(not(target_arch = "wasm32"))]
    pub fn get_repo_secret(&self, owner: &str, repo: &str, secret_name: &str) -> Result<DependabotSecret, AdapterError> {

        let request_uri = format!("{}/repos/{}/{}/dependabot/secrets/{}", super::GITHUB_BASE_API_URL, owner, repo, secret_name);


        let req = GitHubRequest {
            uri: request_uri,
            body: None,
            method: "GET",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch(request)?;

        // --

        if github_response.is_success() {
            Ok(github_response.to_json()?)
        } else {
            match github_response.status_code() {
                code => Err(DependabotGetRepoSecretError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # List Dependabot alerts for an enterprise
    ///
    /// Lists Dependabot alerts for repositories that are owned by the specified enterprise.
    /// 
    /// The authenticated user must be a member of the enterprise to use this endpoint.
    /// 
    /// Alerts are only returned for organizations in the enterprise for which you are an organization owner or a security manager. For more information about security managers, see "[Managing security managers in your organization](https://docs.github.com/organizations/managing-peoples-access-to-your-organization-with-roles/managing-security-managers-in-your-organization)."
    /// 
    /// OAuth app tokens and personal access tokens (classic) need the `repo` or `security_events` scope to use this endpoint.
    ///
    /// [GitHub API docs for list_alerts_for_enterprise](https://docs.github.com/rest/dependabot/alerts#list-dependabot-alerts-for-an-enterprise)
    ///
    /// ---
    pub async fn list_alerts_for_enterprise_async(&self, enterprise: &str, query_params: Option<impl Into<DependabotListAlertsForEnterpriseParams<'api>>>) -> Result<Vec<DependabotAlertWithRepository>, AdapterError> {

        let mut request_uri = format!("{}/enterprises/{}/dependabot/alerts", super::GITHUB_BASE_API_URL, enterprise);

        if let Some(params) = query_params {
            request_uri.push_str("?");
            request_uri.push_str(&serde_urlencoded::to_string(params.into())?);
        }

        let req = GitHubRequest {
            uri: request_uri,
            body: None::<C::Body>,
            method: "GET",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch_async(request).await?;

        // --

        if github_response.is_success() {
            Ok(github_response.to_json_async().await?)
        } else {
            match github_response.status_code() {
                304 => Err(DependabotListAlertsForEnterpriseError::Status304.into()),
                403 => Err(DependabotListAlertsForEnterpriseError::Status403(github_response.to_json_async().await?).into()),
                404 => Err(DependabotListAlertsForEnterpriseError::Status404(github_response.to_json_async().await?).into()),
                422 => Err(DependabotListAlertsForEnterpriseError::Status422(github_response.to_json_async().await?).into()),
                code => Err(DependabotListAlertsForEnterpriseError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # List Dependabot alerts for an enterprise
    ///
    /// Lists Dependabot alerts for repositories that are owned by the specified enterprise.
    /// 
    /// The authenticated user must be a member of the enterprise to use this endpoint.
    /// 
    /// Alerts are only returned for organizations in the enterprise for which you are an organization owner or a security manager. For more information about security managers, see "[Managing security managers in your organization](https://docs.github.com/organizations/managing-peoples-access-to-your-organization-with-roles/managing-security-managers-in-your-organization)."
    /// 
    /// OAuth app tokens and personal access tokens (classic) need the `repo` or `security_events` scope to use this endpoint.
    ///
    /// [GitHub API docs for list_alerts_for_enterprise](https://docs.github.com/rest/dependabot/alerts#list-dependabot-alerts-for-an-enterprise)
    ///
    /// ---
    #[cfg(not(target_arch = "wasm32"))]
    pub fn list_alerts_for_enterprise(&self, enterprise: &str, query_params: Option<impl Into<DependabotListAlertsForEnterpriseParams<'api>>>) -> Result<Vec<DependabotAlertWithRepository>, AdapterError> {

        let mut request_uri = format!("{}/enterprises/{}/dependabot/alerts", super::GITHUB_BASE_API_URL, enterprise);

        if let Some(params) = query_params {
            request_uri.push_str("?");
            let qp: DependabotListAlertsForEnterpriseParams = params.into();
            request_uri.push_str(&serde_urlencoded::to_string(qp)?);
        }

        let req = GitHubRequest {
            uri: request_uri,
            body: None,
            method: "GET",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch(request)?;

        // --

        if github_response.is_success() {
            Ok(github_response.to_json()?)
        } else {
            match github_response.status_code() {
                304 => Err(DependabotListAlertsForEnterpriseError::Status304.into()),
                403 => Err(DependabotListAlertsForEnterpriseError::Status403(github_response.to_json()?).into()),
                404 => Err(DependabotListAlertsForEnterpriseError::Status404(github_response.to_json()?).into()),
                422 => Err(DependabotListAlertsForEnterpriseError::Status422(github_response.to_json()?).into()),
                code => Err(DependabotListAlertsForEnterpriseError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # List Dependabot alerts for an organization
    ///
    /// Lists Dependabot alerts for an organization.
    /// 
    /// The authenticated user must be an owner or security manager for the organization to use this endpoint.
    /// 
    /// OAuth app tokens and personal access tokens (classic) need the `security_events` scope to use this endpoint. If this endpoint is only used with public repositories, the token can use the `public_repo` scope instead.
    ///
    /// [GitHub API docs for list_alerts_for_org](https://docs.github.com/rest/dependabot/alerts#list-dependabot-alerts-for-an-organization)
    ///
    /// ---
    pub async fn list_alerts_for_org_async(&self, org: &str, query_params: Option<impl Into<DependabotListAlertsForOrgParams<'api>>>) -> Result<Vec<DependabotAlertWithRepository>, AdapterError> {

        let mut request_uri = format!("{}/orgs/{}/dependabot/alerts", super::GITHUB_BASE_API_URL, org);

        if let Some(params) = query_params {
            request_uri.push_str("?");
            request_uri.push_str(&serde_urlencoded::to_string(params.into())?);
        }

        let req = GitHubRequest {
            uri: request_uri,
            body: None::<C::Body>,
            method: "GET",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch_async(request).await?;

        // --

        if github_response.is_success() {
            Ok(github_response.to_json_async().await?)
        } else {
            match github_response.status_code() {
                304 => Err(DependabotListAlertsForOrgError::Status304.into()),
                400 => Err(DependabotListAlertsForOrgError::Status400(github_response.to_json_async().await?).into()),
                403 => Err(DependabotListAlertsForOrgError::Status403(github_response.to_json_async().await?).into()),
                404 => Err(DependabotListAlertsForOrgError::Status404(github_response.to_json_async().await?).into()),
                422 => Err(DependabotListAlertsForOrgError::Status422(github_response.to_json_async().await?).into()),
                code => Err(DependabotListAlertsForOrgError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # List Dependabot alerts for an organization
    ///
    /// Lists Dependabot alerts for an organization.
    /// 
    /// The authenticated user must be an owner or security manager for the organization to use this endpoint.
    /// 
    /// OAuth app tokens and personal access tokens (classic) need the `security_events` scope to use this endpoint. If this endpoint is only used with public repositories, the token can use the `public_repo` scope instead.
    ///
    /// [GitHub API docs for list_alerts_for_org](https://docs.github.com/rest/dependabot/alerts#list-dependabot-alerts-for-an-organization)
    ///
    /// ---
    #[cfg(not(target_arch = "wasm32"))]
    pub fn list_alerts_for_org(&self, org: &str, query_params: Option<impl Into<DependabotListAlertsForOrgParams<'api>>>) -> Result<Vec<DependabotAlertWithRepository>, AdapterError> {

        let mut request_uri = format!("{}/orgs/{}/dependabot/alerts", super::GITHUB_BASE_API_URL, org);

        if let Some(params) = query_params {
            request_uri.push_str("?");
            let qp: DependabotListAlertsForOrgParams = params.into();
            request_uri.push_str(&serde_urlencoded::to_string(qp)?);
        }

        let req = GitHubRequest {
            uri: request_uri,
            body: None,
            method: "GET",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch(request)?;

        // --

        if github_response.is_success() {
            Ok(github_response.to_json()?)
        } else {
            match github_response.status_code() {
                304 => Err(DependabotListAlertsForOrgError::Status304.into()),
                400 => Err(DependabotListAlertsForOrgError::Status400(github_response.to_json()?).into()),
                403 => Err(DependabotListAlertsForOrgError::Status403(github_response.to_json()?).into()),
                404 => Err(DependabotListAlertsForOrgError::Status404(github_response.to_json()?).into()),
                422 => Err(DependabotListAlertsForOrgError::Status422(github_response.to_json()?).into()),
                code => Err(DependabotListAlertsForOrgError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # List Dependabot alerts for a repository
    ///
    /// OAuth app tokens and personal access tokens (classic) need the `security_events` scope to use this endpoint. If this endpoint is only used with public repositories, the token can use the `public_repo` scope instead.
    ///
    /// [GitHub API docs for list_alerts_for_repo](https://docs.github.com/rest/dependabot/alerts#list-dependabot-alerts-for-a-repository)
    ///
    /// ---
    pub async fn list_alerts_for_repo_async(&self, owner: &str, repo: &str, query_params: Option<impl Into<DependabotListAlertsForRepoParams<'api>>>) -> Result<Vec<DependabotAlert>, AdapterError> {

        let mut request_uri = format!("{}/repos/{}/{}/dependabot/alerts", super::GITHUB_BASE_API_URL, owner, repo);

        if let Some(params) = query_params {
            request_uri.push_str("?");
            request_uri.push_str(&serde_urlencoded::to_string(params.into())?);
        }

        let req = GitHubRequest {
            uri: request_uri,
            body: None::<C::Body>,
            method: "GET",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch_async(request).await?;

        // --

        if github_response.is_success() {
            Ok(github_response.to_json_async().await?)
        } else {
            match github_response.status_code() {
                304 => Err(DependabotListAlertsForRepoError::Status304.into()),
                400 => Err(DependabotListAlertsForRepoError::Status400(github_response.to_json_async().await?).into()),
                403 => Err(DependabotListAlertsForRepoError::Status403(github_response.to_json_async().await?).into()),
                404 => Err(DependabotListAlertsForRepoError::Status404(github_response.to_json_async().await?).into()),
                422 => Err(DependabotListAlertsForRepoError::Status422(github_response.to_json_async().await?).into()),
                code => Err(DependabotListAlertsForRepoError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # List Dependabot alerts for a repository
    ///
    /// OAuth app tokens and personal access tokens (classic) need the `security_events` scope to use this endpoint. If this endpoint is only used with public repositories, the token can use the `public_repo` scope instead.
    ///
    /// [GitHub API docs for list_alerts_for_repo](https://docs.github.com/rest/dependabot/alerts#list-dependabot-alerts-for-a-repository)
    ///
    /// ---
    #[cfg(not(target_arch = "wasm32"))]
    pub fn list_alerts_for_repo(&self, owner: &str, repo: &str, query_params: Option<impl Into<DependabotListAlertsForRepoParams<'api>>>) -> Result<Vec<DependabotAlert>, AdapterError> {

        let mut request_uri = format!("{}/repos/{}/{}/dependabot/alerts", super::GITHUB_BASE_API_URL, owner, repo);

        if let Some(params) = query_params {
            request_uri.push_str("?");
            let qp: DependabotListAlertsForRepoParams = params.into();
            request_uri.push_str(&serde_urlencoded::to_string(qp)?);
        }

        let req = GitHubRequest {
            uri: request_uri,
            body: None,
            method: "GET",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch(request)?;

        // --

        if github_response.is_success() {
            Ok(github_response.to_json()?)
        } else {
            match github_response.status_code() {
                304 => Err(DependabotListAlertsForRepoError::Status304.into()),
                400 => Err(DependabotListAlertsForRepoError::Status400(github_response.to_json()?).into()),
                403 => Err(DependabotListAlertsForRepoError::Status403(github_response.to_json()?).into()),
                404 => Err(DependabotListAlertsForRepoError::Status404(github_response.to_json()?).into()),
                422 => Err(DependabotListAlertsForRepoError::Status422(github_response.to_json()?).into()),
                code => Err(DependabotListAlertsForRepoError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # List organization secrets
    ///
    /// Lists all secrets available in an organization without revealing their
    /// encrypted values.
    /// 
    /// OAuth app tokens and personal access tokens (classic) need the `admin:org` scope to use this endpoint.
    ///
    /// [GitHub API docs for list_org_secrets](https://docs.github.com/rest/dependabot/secrets#list-organization-secrets)
    ///
    /// ---
    pub async fn list_org_secrets_async(&self, org: &str, query_params: Option<impl Into<DependabotListOrgSecretsParams>>) -> Result<GetDependabotListOrgSecretsResponse200, AdapterError> {

        let mut request_uri = format!("{}/orgs/{}/dependabot/secrets", super::GITHUB_BASE_API_URL, org);

        if let Some(params) = query_params {
            request_uri.push_str("?");
            request_uri.push_str(&serde_urlencoded::to_string(params.into())?);
        }

        let req = GitHubRequest {
            uri: request_uri,
            body: None::<C::Body>,
            method: "GET",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch_async(request).await?;

        // --

        if github_response.is_success() {
            Ok(github_response.to_json_async().await?)
        } else {
            match github_response.status_code() {
                code => Err(DependabotListOrgSecretsError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # List organization secrets
    ///
    /// Lists all secrets available in an organization without revealing their
    /// encrypted values.
    /// 
    /// OAuth app tokens and personal access tokens (classic) need the `admin:org` scope to use this endpoint.
    ///
    /// [GitHub API docs for list_org_secrets](https://docs.github.com/rest/dependabot/secrets#list-organization-secrets)
    ///
    /// ---
    #[cfg(not(target_arch = "wasm32"))]
    pub fn list_org_secrets(&self, org: &str, query_params: Option<impl Into<DependabotListOrgSecretsParams>>) -> Result<GetDependabotListOrgSecretsResponse200, AdapterError> {

        let mut request_uri = format!("{}/orgs/{}/dependabot/secrets", super::GITHUB_BASE_API_URL, org);

        if let Some(params) = query_params {
            request_uri.push_str("?");
            let qp: DependabotListOrgSecretsParams = params.into();
            request_uri.push_str(&serde_urlencoded::to_string(qp)?);
        }

        let req = GitHubRequest {
            uri: request_uri,
            body: None,
            method: "GET",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch(request)?;

        // --

        if github_response.is_success() {
            Ok(github_response.to_json()?)
        } else {
            match github_response.status_code() {
                code => Err(DependabotListOrgSecretsError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # List repository secrets
    ///
    /// Lists all secrets available in a repository without revealing their encrypted
    /// values.
    /// 
    /// OAuth app tokens and personal access tokens (classic) need the `repo` scope to use this endpoint.
    ///
    /// [GitHub API docs for list_repo_secrets](https://docs.github.com/rest/dependabot/secrets#list-repository-secrets)
    ///
    /// ---
    pub async fn list_repo_secrets_async(&self, owner: &str, repo: &str, query_params: Option<impl Into<DependabotListRepoSecretsParams>>) -> Result<GetDependabotListRepoSecretsResponse200, AdapterError> {

        let mut request_uri = format!("{}/repos/{}/{}/dependabot/secrets", super::GITHUB_BASE_API_URL, owner, repo);

        if let Some(params) = query_params {
            request_uri.push_str("?");
            request_uri.push_str(&serde_urlencoded::to_string(params.into())?);
        }

        let req = GitHubRequest {
            uri: request_uri,
            body: None::<C::Body>,
            method: "GET",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch_async(request).await?;

        // --

        if github_response.is_success() {
            Ok(github_response.to_json_async().await?)
        } else {
            match github_response.status_code() {
                code => Err(DependabotListRepoSecretsError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # List repository secrets
    ///
    /// Lists all secrets available in a repository without revealing their encrypted
    /// values.
    /// 
    /// OAuth app tokens and personal access tokens (classic) need the `repo` scope to use this endpoint.
    ///
    /// [GitHub API docs for list_repo_secrets](https://docs.github.com/rest/dependabot/secrets#list-repository-secrets)
    ///
    /// ---
    #[cfg(not(target_arch = "wasm32"))]
    pub fn list_repo_secrets(&self, owner: &str, repo: &str, query_params: Option<impl Into<DependabotListRepoSecretsParams>>) -> Result<GetDependabotListRepoSecretsResponse200, AdapterError> {

        let mut request_uri = format!("{}/repos/{}/{}/dependabot/secrets", super::GITHUB_BASE_API_URL, owner, repo);

        if let Some(params) = query_params {
            request_uri.push_str("?");
            let qp: DependabotListRepoSecretsParams = params.into();
            request_uri.push_str(&serde_urlencoded::to_string(qp)?);
        }

        let req = GitHubRequest {
            uri: request_uri,
            body: None,
            method: "GET",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch(request)?;

        // --

        if github_response.is_success() {
            Ok(github_response.to_json()?)
        } else {
            match github_response.status_code() {
                code => Err(DependabotListRepoSecretsError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # List selected repositories for an organization secret
    ///
    /// Lists all repositories that have been selected when the `visibility`
    /// for repository access to a secret is set to `selected`.
    /// 
    /// OAuth app tokens and personal access tokens (classic) need the `admin:org` scope to use this endpoint.
    ///
    /// [GitHub API docs for list_selected_repos_for_org_secret](https://docs.github.com/rest/dependabot/secrets#list-selected-repositories-for-an-organization-secret)
    ///
    /// ---
    pub async fn list_selected_repos_for_org_secret_async(&self, org: &str, secret_name: &str, query_params: Option<impl Into<DependabotListSelectedReposForOrgSecretParams>>) -> Result<GetCodespacesListRepositoriesForSecretForAuthenticatedUserResponse200, AdapterError> {

        let mut request_uri = format!("{}/orgs/{}/dependabot/secrets/{}/repositories", super::GITHUB_BASE_API_URL, org, secret_name);

        if let Some(params) = query_params {
            request_uri.push_str("?");
            request_uri.push_str(&serde_urlencoded::to_string(params.into())?);
        }

        let req = GitHubRequest {
            uri: request_uri,
            body: None::<C::Body>,
            method: "GET",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch_async(request).await?;

        // --

        if github_response.is_success() {
            Ok(github_response.to_json_async().await?)
        } else {
            match github_response.status_code() {
                code => Err(DependabotListSelectedReposForOrgSecretError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # List selected repositories for an organization secret
    ///
    /// Lists all repositories that have been selected when the `visibility`
    /// for repository access to a secret is set to `selected`.
    /// 
    /// OAuth app tokens and personal access tokens (classic) need the `admin:org` scope to use this endpoint.
    ///
    /// [GitHub API docs for list_selected_repos_for_org_secret](https://docs.github.com/rest/dependabot/secrets#list-selected-repositories-for-an-organization-secret)
    ///
    /// ---
    #[cfg(not(target_arch = "wasm32"))]
    pub fn list_selected_repos_for_org_secret(&self, org: &str, secret_name: &str, query_params: Option<impl Into<DependabotListSelectedReposForOrgSecretParams>>) -> Result<GetCodespacesListRepositoriesForSecretForAuthenticatedUserResponse200, AdapterError> {

        let mut request_uri = format!("{}/orgs/{}/dependabot/secrets/{}/repositories", super::GITHUB_BASE_API_URL, org, secret_name);

        if let Some(params) = query_params {
            request_uri.push_str("?");
            let qp: DependabotListSelectedReposForOrgSecretParams = params.into();
            request_uri.push_str(&serde_urlencoded::to_string(qp)?);
        }

        let req = GitHubRequest {
            uri: request_uri,
            body: None,
            method: "GET",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch(request)?;

        // --

        if github_response.is_success() {
            Ok(github_response.to_json()?)
        } else {
            match github_response.status_code() {
                code => Err(DependabotListSelectedReposForOrgSecretError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # Remove selected repository from an organization secret
    ///
    /// Removes a repository from an organization secret when the `visibility`
    /// for repository access is set to `selected`. The visibility is set when you [Create
    /// or update an organization secret](https://docs.github.com/rest/dependabot/secrets#create-or-update-an-organization-secret).
    /// 
    /// OAuth app tokens and personal access tokens (classic) need the `admin:org` scope to use this endpoint.
    ///
    /// [GitHub API docs for remove_selected_repo_from_org_secret](https://docs.github.com/rest/dependabot/secrets#remove-selected-repository-from-an-organization-secret)
    ///
    /// ---
    pub async fn remove_selected_repo_from_org_secret_async(&self, org: &str, secret_name: &str, repository_id: i32) -> Result<(), AdapterError> {

        let request_uri = format!("{}/orgs/{}/dependabot/secrets/{}/repositories/{}", super::GITHUB_BASE_API_URL, org, secret_name, repository_id);


        let req = GitHubRequest {
            uri: request_uri,
            body: None::<C::Body>,
            method: "DELETE",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch_async(request).await?;

        // --

        if github_response.is_success() {
            Ok(())
        } else {
            match github_response.status_code() {
                409 => Err(DependabotRemoveSelectedRepoFromOrgSecretError::Status409.into()),
                code => Err(DependabotRemoveSelectedRepoFromOrgSecretError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # Remove selected repository from an organization secret
    ///
    /// Removes a repository from an organization secret when the `visibility`
    /// for repository access is set to `selected`. The visibility is set when you [Create
    /// or update an organization secret](https://docs.github.com/rest/dependabot/secrets#create-or-update-an-organization-secret).
    /// 
    /// OAuth app tokens and personal access tokens (classic) need the `admin:org` scope to use this endpoint.
    ///
    /// [GitHub API docs for remove_selected_repo_from_org_secret](https://docs.github.com/rest/dependabot/secrets#remove-selected-repository-from-an-organization-secret)
    ///
    /// ---
    #[cfg(not(target_arch = "wasm32"))]
    pub fn remove_selected_repo_from_org_secret(&self, org: &str, secret_name: &str, repository_id: i32) -> Result<(), AdapterError> {

        let request_uri = format!("{}/orgs/{}/dependabot/secrets/{}/repositories/{}", super::GITHUB_BASE_API_URL, org, secret_name, repository_id);


        let req = GitHubRequest {
            uri: request_uri,
            body: None,
            method: "DELETE",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch(request)?;

        // --

        if github_response.is_success() {
            Ok(())
        } else {
            match github_response.status_code() {
                409 => Err(DependabotRemoveSelectedRepoFromOrgSecretError::Status409.into()),
                code => Err(DependabotRemoveSelectedRepoFromOrgSecretError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # Set selected repositories for an organization secret
    ///
    /// Replaces all repositories for an organization secret when the `visibility`
    /// for repository access is set to `selected`. The visibility is set when you [Create
    /// or update an organization secret](https://docs.github.com/rest/dependabot/secrets#create-or-update-an-organization-secret).
    /// 
    /// OAuth app tokens and personal access tokens (classic) need the `admin:org` scope to use this endpoint.
    ///
    /// [GitHub API docs for set_selected_repos_for_org_secret](https://docs.github.com/rest/dependabot/secrets#set-selected-repositories-for-an-organization-secret)
    ///
    /// ---
    pub async fn set_selected_repos_for_org_secret_async(&self, org: &str, secret_name: &str, body: PutDependabotSetSelectedReposForOrgSecret) -> Result<(), AdapterError> {

        let request_uri = format!("{}/orgs/{}/dependabot/secrets/{}/repositories", super::GITHUB_BASE_API_URL, org, secret_name);


        let req = GitHubRequest {
            uri: request_uri,
            body: Some(C::from_json::<PutDependabotSetSelectedReposForOrgSecret>(body)?),
            method: "PUT",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch_async(request).await?;

        // --

        if github_response.is_success() {
            Ok(())
        } else {
            match github_response.status_code() {
                code => Err(DependabotSetSelectedReposForOrgSecretError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # Set selected repositories for an organization secret
    ///
    /// Replaces all repositories for an organization secret when the `visibility`
    /// for repository access is set to `selected`. The visibility is set when you [Create
    /// or update an organization secret](https://docs.github.com/rest/dependabot/secrets#create-or-update-an-organization-secret).
    /// 
    /// OAuth app tokens and personal access tokens (classic) need the `admin:org` scope to use this endpoint.
    ///
    /// [GitHub API docs for set_selected_repos_for_org_secret](https://docs.github.com/rest/dependabot/secrets#set-selected-repositories-for-an-organization-secret)
    ///
    /// ---
    #[cfg(not(target_arch = "wasm32"))]
    pub fn set_selected_repos_for_org_secret(&self, org: &str, secret_name: &str, body: PutDependabotSetSelectedReposForOrgSecret) -> Result<(), AdapterError> {

        let request_uri = format!("{}/orgs/{}/dependabot/secrets/{}/repositories", super::GITHUB_BASE_API_URL, org, secret_name);


        let req = GitHubRequest {
            uri: request_uri,
            body: Some(C::from_json::<PutDependabotSetSelectedReposForOrgSecret>(body)?),
            method: "PUT",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch(request)?;

        // --

        if github_response.is_success() {
            Ok(())
        } else {
            match github_response.status_code() {
                code => Err(DependabotSetSelectedReposForOrgSecretError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # Update a Dependabot alert
    ///
    /// The authenticated user must have access to security alerts for the repository to use this endpoint. For more information, see "[Granting access to security alerts](https://docs.github.com/repositories/managing-your-repositorys-settings-and-features/enabling-features-for-your-repository/managing-security-and-analysis-settings-for-your-repository#granting-access-to-security-alerts)."
    /// 
    /// OAuth app tokens and personal access tokens (classic) need the `security_events` scope to use this endpoint. If this endpoint is only used with public repositories, the token can use the `public_repo` scope instead.
    ///
    /// [GitHub API docs for update_alert](https://docs.github.com/rest/dependabot/alerts#update-a-dependabot-alert)
    ///
    /// ---
    pub async fn update_alert_async(&self, owner: &str, repo: &str, alert_number: AlertNumber, body: PatchDependabotUpdateAlert) -> Result<DependabotAlert, AdapterError> {

        let request_uri = format!("{}/repos/{}/{}/dependabot/alerts/{}", super::GITHUB_BASE_API_URL, owner, repo, alert_number);


        let req = GitHubRequest {
            uri: request_uri,
            body: Some(C::from_json::<PatchDependabotUpdateAlert>(body)?),
            method: "PATCH",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch_async(request).await?;

        // --

        if github_response.is_success() {
            Ok(github_response.to_json_async().await?)
        } else {
            match github_response.status_code() {
                400 => Err(DependabotUpdateAlertError::Status400(github_response.to_json_async().await?).into()),
                403 => Err(DependabotUpdateAlertError::Status403(github_response.to_json_async().await?).into()),
                404 => Err(DependabotUpdateAlertError::Status404(github_response.to_json_async().await?).into()),
                409 => Err(DependabotUpdateAlertError::Status409(github_response.to_json_async().await?).into()),
                422 => Err(DependabotUpdateAlertError::Status422(github_response.to_json_async().await?).into()),
                code => Err(DependabotUpdateAlertError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # Update a Dependabot alert
    ///
    /// The authenticated user must have access to security alerts for the repository to use this endpoint. For more information, see "[Granting access to security alerts](https://docs.github.com/repositories/managing-your-repositorys-settings-and-features/enabling-features-for-your-repository/managing-security-and-analysis-settings-for-your-repository#granting-access-to-security-alerts)."
    /// 
    /// OAuth app tokens and personal access tokens (classic) need the `security_events` scope to use this endpoint. If this endpoint is only used with public repositories, the token can use the `public_repo` scope instead.
    ///
    /// [GitHub API docs for update_alert](https://docs.github.com/rest/dependabot/alerts#update-a-dependabot-alert)
    ///
    /// ---
    #[cfg(not(target_arch = "wasm32"))]
    pub fn update_alert(&self, owner: &str, repo: &str, alert_number: AlertNumber, body: PatchDependabotUpdateAlert) -> Result<DependabotAlert, AdapterError> {

        let request_uri = format!("{}/repos/{}/{}/dependabot/alerts/{}", super::GITHUB_BASE_API_URL, owner, repo, alert_number);


        let req = GitHubRequest {
            uri: request_uri,
            body: Some(C::from_json::<PatchDependabotUpdateAlert>(body)?),
            method: "PATCH",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch(request)?;

        // --

        if github_response.is_success() {
            Ok(github_response.to_json()?)
        } else {
            match github_response.status_code() {
                400 => Err(DependabotUpdateAlertError::Status400(github_response.to_json()?).into()),
                403 => Err(DependabotUpdateAlertError::Status403(github_response.to_json()?).into()),
                404 => Err(DependabotUpdateAlertError::Status404(github_response.to_json()?).into()),
                409 => Err(DependabotUpdateAlertError::Status409(github_response.to_json()?).into()),
                422 => Err(DependabotUpdateAlertError::Status422(github_response.to_json()?).into()),
                code => Err(DependabotUpdateAlertError::Generic { code }.into()),
            }
        }
    }

}
