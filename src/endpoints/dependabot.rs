//! Method, error and parameter types for the Dependabot endpoint.
#![allow(
    unused_imports,
)]
/* 
 * GitHub v3 REST API
 *
 * GitHub's v3 REST API.
 *
 * OpenAPI spec version: 1.1.4
 * 
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 */

use serde::Deserialize;

use crate::adapters::{AdapterError, FromJson, GitHubRequest, GitHubRequestBuilder, GitHubResponseExt};
use crate::auth::Auth;
use crate::models::*;

use super::PerPage;

use std::collections::HashMap;
use serde_json::value::Value;

pub struct Dependabot<'api> {
    auth: &'api Auth
}

pub fn new(auth: &Auth) -> Dependabot {
    Dependabot { auth }
}

/// Errors for the [Add selected repository to an organization secret](Dependabot::add_selected_repo_to_org_secret_async()) endpoint.
#[derive(Debug, thiserror::Error)]
pub enum DependabotAddSelectedRepoToOrgSecretError {
    #[error(transparent)]
    AdapterError(#[from] AdapterError),
    #[error(transparent)]
    SerdeJson(#[from] serde_json::Error),
    #[error(transparent)]
    SerdeUrl(#[from] serde_urlencoded::ser::Error),


    // -- endpoint errors

    #[error("Conflict when visibility type is not set to selected")]
    Status409,
    #[error("Status code: {}", code)]
    Generic { code: u16 },
}

/// Errors for the [Create or update an organization secret](Dependabot::create_or_update_org_secret_async()) endpoint.
#[derive(Debug, thiserror::Error)]
pub enum DependabotCreateOrUpdateOrgSecretError {
    #[error(transparent)]
    AdapterError(#[from] AdapterError),
    #[error(transparent)]
    SerdeJson(#[from] serde_json::Error),
    #[error(transparent)]
    SerdeUrl(#[from] serde_urlencoded::ser::Error),


    // -- endpoint errors

    #[error("Response when updating a secret")]
    Status204,
    #[error("Status code: {}", code)]
    Generic { code: u16 },
}

/// Errors for the [Create or update a repository secret](Dependabot::create_or_update_repo_secret_async()) endpoint.
#[derive(Debug, thiserror::Error)]
pub enum DependabotCreateOrUpdateRepoSecretError {
    #[error(transparent)]
    AdapterError(#[from] AdapterError),
    #[error(transparent)]
    SerdeJson(#[from] serde_json::Error),
    #[error(transparent)]
    SerdeUrl(#[from] serde_urlencoded::ser::Error),


    // -- endpoint errors

    #[error("Response when updating a secret")]
    Status204,
    #[error("Status code: {}", code)]
    Generic { code: u16 },
}

/// Errors for the [Delete an organization secret](Dependabot::delete_org_secret_async()) endpoint.
#[derive(Debug, thiserror::Error)]
pub enum DependabotDeleteOrgSecretError {
    #[error(transparent)]
    AdapterError(#[from] AdapterError),
    #[error(transparent)]
    SerdeJson(#[from] serde_json::Error),
    #[error(transparent)]
    SerdeUrl(#[from] serde_urlencoded::ser::Error),


    // -- endpoint errors

    #[error("Status code: {}", code)]
    Generic { code: u16 },
}

/// Errors for the [Delete a repository secret](Dependabot::delete_repo_secret_async()) endpoint.
#[derive(Debug, thiserror::Error)]
pub enum DependabotDeleteRepoSecretError {
    #[error(transparent)]
    AdapterError(#[from] AdapterError),
    #[error(transparent)]
    SerdeJson(#[from] serde_json::Error),
    #[error(transparent)]
    SerdeUrl(#[from] serde_urlencoded::ser::Error),


    // -- endpoint errors

    #[error("Status code: {}", code)]
    Generic { code: u16 },
}

/// Errors for the [Get a Dependabot alert](Dependabot::get_alert_async()) endpoint.
#[derive(Debug, thiserror::Error)]
pub enum DependabotGetAlertError {
    #[error(transparent)]
    AdapterError(#[from] AdapterError),
    #[error(transparent)]
    SerdeJson(#[from] serde_json::Error),
    #[error(transparent)]
    SerdeUrl(#[from] serde_urlencoded::ser::Error),


    // -- endpoint errors

    #[error("Not modified")]
    Status304,
    #[error("Forbidden")]
    Status403(BasicError),
    #[error("Resource not found")]
    Status404(BasicError),
    #[error("Status code: {}", code)]
    Generic { code: u16 },
}

/// Errors for the [Get an organization public key](Dependabot::get_org_public_key_async()) endpoint.
#[derive(Debug, thiserror::Error)]
pub enum DependabotGetOrgPublicKeyError {
    #[error(transparent)]
    AdapterError(#[from] AdapterError),
    #[error(transparent)]
    SerdeJson(#[from] serde_json::Error),
    #[error(transparent)]
    SerdeUrl(#[from] serde_urlencoded::ser::Error),


    // -- endpoint errors

    #[error("Status code: {}", code)]
    Generic { code: u16 },
}

/// Errors for the [Get an organization secret](Dependabot::get_org_secret_async()) endpoint.
#[derive(Debug, thiserror::Error)]
pub enum DependabotGetOrgSecretError {
    #[error(transparent)]
    AdapterError(#[from] AdapterError),
    #[error(transparent)]
    SerdeJson(#[from] serde_json::Error),
    #[error(transparent)]
    SerdeUrl(#[from] serde_urlencoded::ser::Error),


    // -- endpoint errors

    #[error("Status code: {}", code)]
    Generic { code: u16 },
}

/// Errors for the [Get a repository public key](Dependabot::get_repo_public_key_async()) endpoint.
#[derive(Debug, thiserror::Error)]
pub enum DependabotGetRepoPublicKeyError {
    #[error(transparent)]
    AdapterError(#[from] AdapterError),
    #[error(transparent)]
    SerdeJson(#[from] serde_json::Error),
    #[error(transparent)]
    SerdeUrl(#[from] serde_urlencoded::ser::Error),


    // -- endpoint errors

    #[error("Status code: {}", code)]
    Generic { code: u16 },
}

/// Errors for the [Get a repository secret](Dependabot::get_repo_secret_async()) endpoint.
#[derive(Debug, thiserror::Error)]
pub enum DependabotGetRepoSecretError {
    #[error(transparent)]
    AdapterError(#[from] AdapterError),
    #[error(transparent)]
    SerdeJson(#[from] serde_json::Error),
    #[error(transparent)]
    SerdeUrl(#[from] serde_urlencoded::ser::Error),


    // -- endpoint errors

    #[error("Status code: {}", code)]
    Generic { code: u16 },
}

/// Errors for the [List Dependabot alerts for an enterprise](Dependabot::list_alerts_for_enterprise_async()) endpoint.
#[derive(Debug, thiserror::Error)]
pub enum DependabotListAlertsForEnterpriseError {
    #[error(transparent)]
    AdapterError(#[from] AdapterError),
    #[error(transparent)]
    SerdeJson(#[from] serde_json::Error),
    #[error(transparent)]
    SerdeUrl(#[from] serde_urlencoded::ser::Error),


    // -- endpoint errors

    #[error("Not modified")]
    Status304,
    #[error("Forbidden")]
    Status403(BasicError),
    #[error("Resource not found")]
    Status404(BasicError),
    #[error("Validation failed, or the endpoint has been spammed.")]
    Status422(ValidationErrorSimple),
    #[error("Status code: {}", code)]
    Generic { code: u16 },
}

/// Errors for the [List Dependabot alerts for an organization](Dependabot::list_alerts_for_org_async()) endpoint.
#[derive(Debug, thiserror::Error)]
pub enum DependabotListAlertsForOrgError {
    #[error(transparent)]
    AdapterError(#[from] AdapterError),
    #[error(transparent)]
    SerdeJson(#[from] serde_json::Error),
    #[error(transparent)]
    SerdeUrl(#[from] serde_urlencoded::ser::Error),


    // -- endpoint errors

    #[error("Not modified")]
    Status304,
    #[error("Bad Request")]
    Status400(BasicError),
    #[error("Forbidden")]
    Status403(BasicError),
    #[error("Resource not found")]
    Status404(BasicError),
    #[error("Validation failed, or the endpoint has been spammed.")]
    Status422(ValidationErrorSimple),
    #[error("Status code: {}", code)]
    Generic { code: u16 },
}

/// Errors for the [List Dependabot alerts for a repository](Dependabot::list_alerts_for_repo_async()) endpoint.
#[derive(Debug, thiserror::Error)]
pub enum DependabotListAlertsForRepoError {
    #[error(transparent)]
    AdapterError(#[from] AdapterError),
    #[error(transparent)]
    SerdeJson(#[from] serde_json::Error),
    #[error(transparent)]
    SerdeUrl(#[from] serde_urlencoded::ser::Error),


    // -- endpoint errors

    #[error("Not modified")]
    Status304,
    #[error("Bad Request")]
    Status400(BasicError),
    #[error("Forbidden")]
    Status403(BasicError),
    #[error("Resource not found")]
    Status404(BasicError),
    #[error("Validation failed, or the endpoint has been spammed.")]
    Status422(ValidationErrorSimple),
    #[error("Status code: {}", code)]
    Generic { code: u16 },
}

/// Errors for the [List organization secrets](Dependabot::list_org_secrets_async()) endpoint.
#[derive(Debug, thiserror::Error)]
pub enum DependabotListOrgSecretsError {
    #[error(transparent)]
    AdapterError(#[from] AdapterError),
    #[error(transparent)]
    SerdeJson(#[from] serde_json::Error),
    #[error(transparent)]
    SerdeUrl(#[from] serde_urlencoded::ser::Error),


    // -- endpoint errors

    #[error("Status code: {}", code)]
    Generic { code: u16 },
}

/// Errors for the [List repository secrets](Dependabot::list_repo_secrets_async()) endpoint.
#[derive(Debug, thiserror::Error)]
pub enum DependabotListRepoSecretsError {
    #[error(transparent)]
    AdapterError(#[from] AdapterError),
    #[error(transparent)]
    SerdeJson(#[from] serde_json::Error),
    #[error(transparent)]
    SerdeUrl(#[from] serde_urlencoded::ser::Error),


    // -- endpoint errors

    #[error("Status code: {}", code)]
    Generic { code: u16 },
}

/// Errors for the [List selected repositories for an organization secret](Dependabot::list_selected_repos_for_org_secret_async()) endpoint.
#[derive(Debug, thiserror::Error)]
pub enum DependabotListSelectedReposForOrgSecretError {
    #[error(transparent)]
    AdapterError(#[from] AdapterError),
    #[error(transparent)]
    SerdeJson(#[from] serde_json::Error),
    #[error(transparent)]
    SerdeUrl(#[from] serde_urlencoded::ser::Error),


    // -- endpoint errors

    #[error("Status code: {}", code)]
    Generic { code: u16 },
}

/// Errors for the [Remove selected repository from an organization secret](Dependabot::remove_selected_repo_from_org_secret_async()) endpoint.
#[derive(Debug, thiserror::Error)]
pub enum DependabotRemoveSelectedRepoFromOrgSecretError {
    #[error(transparent)]
    AdapterError(#[from] AdapterError),
    #[error(transparent)]
    SerdeJson(#[from] serde_json::Error),
    #[error(transparent)]
    SerdeUrl(#[from] serde_urlencoded::ser::Error),


    // -- endpoint errors

    #[error("Conflict when visibility type not set to selected")]
    Status409,
    #[error("Status code: {}", code)]
    Generic { code: u16 },
}

/// Errors for the [Set selected repositories for an organization secret](Dependabot::set_selected_repos_for_org_secret_async()) endpoint.
#[derive(Debug, thiserror::Error)]
pub enum DependabotSetSelectedReposForOrgSecretError {
    #[error(transparent)]
    AdapterError(#[from] AdapterError),
    #[error(transparent)]
    SerdeJson(#[from] serde_json::Error),
    #[error(transparent)]
    SerdeUrl(#[from] serde_urlencoded::ser::Error),


    // -- endpoint errors

    #[error("Status code: {}", code)]
    Generic { code: u16 },
}

/// Errors for the [Update a Dependabot alert](Dependabot::update_alert_async()) endpoint.
#[derive(Debug, thiserror::Error)]
pub enum DependabotUpdateAlertError {
    #[error(transparent)]
    AdapterError(#[from] AdapterError),
    #[error(transparent)]
    SerdeJson(#[from] serde_json::Error),
    #[error(transparent)]
    SerdeUrl(#[from] serde_urlencoded::ser::Error),


    // -- endpoint errors

    #[error("Bad Request")]
    Status400(BasicError),
    #[error("Forbidden")]
    Status403(BasicError),
    #[error("Resource not found")]
    Status404(BasicError),
    #[error("Conflict")]
    Status409(BasicError),
    #[error("Validation failed, or the endpoint has been spammed.")]
    Status422(ValidationErrorSimple),
    #[error("Status code: {}", code)]
    Generic { code: u16 },
}


/// Query parameters for the [List Dependabot alerts for an enterprise](Dependabot::list_alerts_for_enterprise_async()) endpoint.
#[derive(Default, Serialize)]
pub struct DependabotListAlertsForEnterpriseParams<'req> {
    /// A comma-separated list of states. If specified, only alerts with these states will be returned.  Can be: `auto_dismissed`, `dismissed`, `fixed`, `open`
    state: Option<&'req str>, 
    /// A comma-separated list of severities. If specified, only alerts with these severities will be returned.  Can be: `low`, `medium`, `high`, `critical`
    severity: Option<&'req str>, 
    /// A comma-separated list of ecosystems. If specified, only alerts for these ecosystems will be returned.  Can be: `composer`, `go`, `maven`, `npm`, `nuget`, `pip`, `pub`, `rubygems`, `rust`
    ecosystem: Option<&'req str>, 
    /// A comma-separated list of package names. If specified, only alerts for these packages will be returned.
    package: Option<&'req str>, 
    /// The scope of the vulnerable dependency. If specified, only alerts with this scope will be returned.
    scope: Option<&'req str>, 
    /// The property by which to sort the results. `created` means when the alert was created. `updated` means when the alert's state last changed.
    sort: Option<&'req str>, 
    /// The direction to sort the results by.
    direction: Option<&'req str>, 
    /// A cursor, as given in the [Link header](https://docs.github.com/rest/guides/using-pagination-in-the-rest-api#using-link-headers). If specified, the query only searches for results before this cursor. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    before: Option<&'req str>, 
    /// A cursor, as given in the [Link header](https://docs.github.com/rest/guides/using-pagination-in-the-rest-api#using-link-headers). If specified, the query only searches for results after this cursor. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    after: Option<&'req str>, 
    /// **Deprecated**. The number of results per page (max 100), starting from the first matching result. This parameter must not be used in combination with `last`. Instead, use `per_page` in combination with `after` to fetch the first page of results.
    first: Option<i32>, 
    /// **Deprecated**. The number of results per page (max 100), starting from the last matching result. This parameter must not be used in combination with `first`. Instead, use `per_page` in combination with `before` to fetch the last page of results.
    last: Option<i32>, 
    /// The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    per_page: Option<u16>
}

impl<'req> DependabotListAlertsForEnterpriseParams<'req> {
    pub fn new() -> Self {
        Self::default()
    }

    /// A comma-separated list of states. If specified, only alerts with these states will be returned.  Can be: `auto_dismissed`, `dismissed`, `fixed`, `open`
    pub fn state(self, state: &'req str) -> Self {
        Self { 
            state: Some(state),
            severity: self.severity, 
            ecosystem: self.ecosystem, 
            package: self.package, 
            scope: self.scope, 
            sort: self.sort, 
            direction: self.direction, 
            before: self.before, 
            after: self.after, 
            first: self.first, 
            last: self.last, 
            per_page: self.per_page, 
        }
    }

    /// A comma-separated list of severities. If specified, only alerts with these severities will be returned.  Can be: `low`, `medium`, `high`, `critical`
    pub fn severity(self, severity: &'req str) -> Self {
        Self { 
            state: self.state, 
            severity: Some(severity),
            ecosystem: self.ecosystem, 
            package: self.package, 
            scope: self.scope, 
            sort: self.sort, 
            direction: self.direction, 
            before: self.before, 
            after: self.after, 
            first: self.first, 
            last: self.last, 
            per_page: self.per_page, 
        }
    }

    /// A comma-separated list of ecosystems. If specified, only alerts for these ecosystems will be returned.  Can be: `composer`, `go`, `maven`, `npm`, `nuget`, `pip`, `pub`, `rubygems`, `rust`
    pub fn ecosystem(self, ecosystem: &'req str) -> Self {
        Self { 
            state: self.state, 
            severity: self.severity, 
            ecosystem: Some(ecosystem),
            package: self.package, 
            scope: self.scope, 
            sort: self.sort, 
            direction: self.direction, 
            before: self.before, 
            after: self.after, 
            first: self.first, 
            last: self.last, 
            per_page: self.per_page, 
        }
    }

    /// A comma-separated list of package names. If specified, only alerts for these packages will be returned.
    pub fn package(self, package: &'req str) -> Self {
        Self { 
            state: self.state, 
            severity: self.severity, 
            ecosystem: self.ecosystem, 
            package: Some(package),
            scope: self.scope, 
            sort: self.sort, 
            direction: self.direction, 
            before: self.before, 
            after: self.after, 
            first: self.first, 
            last: self.last, 
            per_page: self.per_page, 
        }
    }

    /// The scope of the vulnerable dependency. If specified, only alerts with this scope will be returned.
    pub fn scope(self, scope: &'req str) -> Self {
        Self { 
            state: self.state, 
            severity: self.severity, 
            ecosystem: self.ecosystem, 
            package: self.package, 
            scope: Some(scope),
            sort: self.sort, 
            direction: self.direction, 
            before: self.before, 
            after: self.after, 
            first: self.first, 
            last: self.last, 
            per_page: self.per_page, 
        }
    }

    /// The property by which to sort the results. `created` means when the alert was created. `updated` means when the alert's state last changed.
    pub fn sort(self, sort: &'req str) -> Self {
        Self { 
            state: self.state, 
            severity: self.severity, 
            ecosystem: self.ecosystem, 
            package: self.package, 
            scope: self.scope, 
            sort: Some(sort),
            direction: self.direction, 
            before: self.before, 
            after: self.after, 
            first: self.first, 
            last: self.last, 
            per_page: self.per_page, 
        }
    }

    /// The direction to sort the results by.
    pub fn direction(self, direction: &'req str) -> Self {
        Self { 
            state: self.state, 
            severity: self.severity, 
            ecosystem: self.ecosystem, 
            package: self.package, 
            scope: self.scope, 
            sort: self.sort, 
            direction: Some(direction),
            before: self.before, 
            after: self.after, 
            first: self.first, 
            last: self.last, 
            per_page: self.per_page, 
        }
    }

    /// A cursor, as given in the [Link header](https://docs.github.com/rest/guides/using-pagination-in-the-rest-api#using-link-headers). If specified, the query only searches for results before this cursor. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    pub fn before(self, before: &'req str) -> Self {
        Self { 
            state: self.state, 
            severity: self.severity, 
            ecosystem: self.ecosystem, 
            package: self.package, 
            scope: self.scope, 
            sort: self.sort, 
            direction: self.direction, 
            before: Some(before),
            after: self.after, 
            first: self.first, 
            last: self.last, 
            per_page: self.per_page, 
        }
    }

    /// A cursor, as given in the [Link header](https://docs.github.com/rest/guides/using-pagination-in-the-rest-api#using-link-headers). If specified, the query only searches for results after this cursor. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    pub fn after(self, after: &'req str) -> Self {
        Self { 
            state: self.state, 
            severity: self.severity, 
            ecosystem: self.ecosystem, 
            package: self.package, 
            scope: self.scope, 
            sort: self.sort, 
            direction: self.direction, 
            before: self.before, 
            after: Some(after),
            first: self.first, 
            last: self.last, 
            per_page: self.per_page, 
        }
    }

    /// **Deprecated**. The number of results per page (max 100), starting from the first matching result. This parameter must not be used in combination with `last`. Instead, use `per_page` in combination with `after` to fetch the first page of results.
    pub fn first(self, first: i32) -> Self {
        Self { 
            state: self.state, 
            severity: self.severity, 
            ecosystem: self.ecosystem, 
            package: self.package, 
            scope: self.scope, 
            sort: self.sort, 
            direction: self.direction, 
            before: self.before, 
            after: self.after, 
            first: Some(first),
            last: self.last, 
            per_page: self.per_page, 
        }
    }

    /// **Deprecated**. The number of results per page (max 100), starting from the last matching result. This parameter must not be used in combination with `first`. Instead, use `per_page` in combination with `before` to fetch the last page of results.
    pub fn last(self, last: i32) -> Self {
        Self { 
            state: self.state, 
            severity: self.severity, 
            ecosystem: self.ecosystem, 
            package: self.package, 
            scope: self.scope, 
            sort: self.sort, 
            direction: self.direction, 
            before: self.before, 
            after: self.after, 
            first: self.first, 
            last: Some(last),
            per_page: self.per_page, 
        }
    }

    /// The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    pub fn per_page(self, per_page: u16) -> Self {
        Self { 
            state: self.state, 
            severity: self.severity, 
            ecosystem: self.ecosystem, 
            package: self.package, 
            scope: self.scope, 
            sort: self.sort, 
            direction: self.direction, 
            before: self.before, 
            after: self.after, 
            first: self.first, 
            last: self.last, 
            per_page: Some(per_page),
        }
    }
}

/// Query parameters for the [List Dependabot alerts for an organization](Dependabot::list_alerts_for_org_async()) endpoint.
#[derive(Default, Serialize)]
pub struct DependabotListAlertsForOrgParams<'req> {
    /// A comma-separated list of states. If specified, only alerts with these states will be returned.  Can be: `auto_dismissed`, `dismissed`, `fixed`, `open`
    state: Option<&'req str>, 
    /// A comma-separated list of severities. If specified, only alerts with these severities will be returned.  Can be: `low`, `medium`, `high`, `critical`
    severity: Option<&'req str>, 
    /// A comma-separated list of ecosystems. If specified, only alerts for these ecosystems will be returned.  Can be: `composer`, `go`, `maven`, `npm`, `nuget`, `pip`, `pub`, `rubygems`, `rust`
    ecosystem: Option<&'req str>, 
    /// A comma-separated list of package names. If specified, only alerts for these packages will be returned.
    package: Option<&'req str>, 
    /// The scope of the vulnerable dependency. If specified, only alerts with this scope will be returned.
    scope: Option<&'req str>, 
    /// The property by which to sort the results. `created` means when the alert was created. `updated` means when the alert's state last changed.
    sort: Option<&'req str>, 
    /// The direction to sort the results by.
    direction: Option<&'req str>, 
    /// A cursor, as given in the [Link header](https://docs.github.com/rest/guides/using-pagination-in-the-rest-api#using-link-headers). If specified, the query only searches for results before this cursor. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    before: Option<&'req str>, 
    /// A cursor, as given in the [Link header](https://docs.github.com/rest/guides/using-pagination-in-the-rest-api#using-link-headers). If specified, the query only searches for results after this cursor. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    after: Option<&'req str>, 
    /// **Deprecated**. The number of results per page (max 100), starting from the first matching result. This parameter must not be used in combination with `last`. Instead, use `per_page` in combination with `after` to fetch the first page of results.
    first: Option<i32>, 
    /// **Deprecated**. The number of results per page (max 100), starting from the last matching result. This parameter must not be used in combination with `first`. Instead, use `per_page` in combination with `before` to fetch the last page of results.
    last: Option<i32>, 
    /// The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    per_page: Option<u16>
}

impl<'req> DependabotListAlertsForOrgParams<'req> {
    pub fn new() -> Self {
        Self::default()
    }

    /// A comma-separated list of states. If specified, only alerts with these states will be returned.  Can be: `auto_dismissed`, `dismissed`, `fixed`, `open`
    pub fn state(self, state: &'req str) -> Self {
        Self { 
            state: Some(state),
            severity: self.severity, 
            ecosystem: self.ecosystem, 
            package: self.package, 
            scope: self.scope, 
            sort: self.sort, 
            direction: self.direction, 
            before: self.before, 
            after: self.after, 
            first: self.first, 
            last: self.last, 
            per_page: self.per_page, 
        }
    }

    /// A comma-separated list of severities. If specified, only alerts with these severities will be returned.  Can be: `low`, `medium`, `high`, `critical`
    pub fn severity(self, severity: &'req str) -> Self {
        Self { 
            state: self.state, 
            severity: Some(severity),
            ecosystem: self.ecosystem, 
            package: self.package, 
            scope: self.scope, 
            sort: self.sort, 
            direction: self.direction, 
            before: self.before, 
            after: self.after, 
            first: self.first, 
            last: self.last, 
            per_page: self.per_page, 
        }
    }

    /// A comma-separated list of ecosystems. If specified, only alerts for these ecosystems will be returned.  Can be: `composer`, `go`, `maven`, `npm`, `nuget`, `pip`, `pub`, `rubygems`, `rust`
    pub fn ecosystem(self, ecosystem: &'req str) -> Self {
        Self { 
            state: self.state, 
            severity: self.severity, 
            ecosystem: Some(ecosystem),
            package: self.package, 
            scope: self.scope, 
            sort: self.sort, 
            direction: self.direction, 
            before: self.before, 
            after: self.after, 
            first: self.first, 
            last: self.last, 
            per_page: self.per_page, 
        }
    }

    /// A comma-separated list of package names. If specified, only alerts for these packages will be returned.
    pub fn package(self, package: &'req str) -> Self {
        Self { 
            state: self.state, 
            severity: self.severity, 
            ecosystem: self.ecosystem, 
            package: Some(package),
            scope: self.scope, 
            sort: self.sort, 
            direction: self.direction, 
            before: self.before, 
            after: self.after, 
            first: self.first, 
            last: self.last, 
            per_page: self.per_page, 
        }
    }

    /// The scope of the vulnerable dependency. If specified, only alerts with this scope will be returned.
    pub fn scope(self, scope: &'req str) -> Self {
        Self { 
            state: self.state, 
            severity: self.severity, 
            ecosystem: self.ecosystem, 
            package: self.package, 
            scope: Some(scope),
            sort: self.sort, 
            direction: self.direction, 
            before: self.before, 
            after: self.after, 
            first: self.first, 
            last: self.last, 
            per_page: self.per_page, 
        }
    }

    /// The property by which to sort the results. `created` means when the alert was created. `updated` means when the alert's state last changed.
    pub fn sort(self, sort: &'req str) -> Self {
        Self { 
            state: self.state, 
            severity: self.severity, 
            ecosystem: self.ecosystem, 
            package: self.package, 
            scope: self.scope, 
            sort: Some(sort),
            direction: self.direction, 
            before: self.before, 
            after: self.after, 
            first: self.first, 
            last: self.last, 
            per_page: self.per_page, 
        }
    }

    /// The direction to sort the results by.
    pub fn direction(self, direction: &'req str) -> Self {
        Self { 
            state: self.state, 
            severity: self.severity, 
            ecosystem: self.ecosystem, 
            package: self.package, 
            scope: self.scope, 
            sort: self.sort, 
            direction: Some(direction),
            before: self.before, 
            after: self.after, 
            first: self.first, 
            last: self.last, 
            per_page: self.per_page, 
        }
    }

    /// A cursor, as given in the [Link header](https://docs.github.com/rest/guides/using-pagination-in-the-rest-api#using-link-headers). If specified, the query only searches for results before this cursor. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    pub fn before(self, before: &'req str) -> Self {
        Self { 
            state: self.state, 
            severity: self.severity, 
            ecosystem: self.ecosystem, 
            package: self.package, 
            scope: self.scope, 
            sort: self.sort, 
            direction: self.direction, 
            before: Some(before),
            after: self.after, 
            first: self.first, 
            last: self.last, 
            per_page: self.per_page, 
        }
    }

    /// A cursor, as given in the [Link header](https://docs.github.com/rest/guides/using-pagination-in-the-rest-api#using-link-headers). If specified, the query only searches for results after this cursor. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    pub fn after(self, after: &'req str) -> Self {
        Self { 
            state: self.state, 
            severity: self.severity, 
            ecosystem: self.ecosystem, 
            package: self.package, 
            scope: self.scope, 
            sort: self.sort, 
            direction: self.direction, 
            before: self.before, 
            after: Some(after),
            first: self.first, 
            last: self.last, 
            per_page: self.per_page, 
        }
    }

    /// **Deprecated**. The number of results per page (max 100), starting from the first matching result. This parameter must not be used in combination with `last`. Instead, use `per_page` in combination with `after` to fetch the first page of results.
    pub fn first(self, first: i32) -> Self {
        Self { 
            state: self.state, 
            severity: self.severity, 
            ecosystem: self.ecosystem, 
            package: self.package, 
            scope: self.scope, 
            sort: self.sort, 
            direction: self.direction, 
            before: self.before, 
            after: self.after, 
            first: Some(first),
            last: self.last, 
            per_page: self.per_page, 
        }
    }

    /// **Deprecated**. The number of results per page (max 100), starting from the last matching result. This parameter must not be used in combination with `first`. Instead, use `per_page` in combination with `before` to fetch the last page of results.
    pub fn last(self, last: i32) -> Self {
        Self { 
            state: self.state, 
            severity: self.severity, 
            ecosystem: self.ecosystem, 
            package: self.package, 
            scope: self.scope, 
            sort: self.sort, 
            direction: self.direction, 
            before: self.before, 
            after: self.after, 
            first: self.first, 
            last: Some(last),
            per_page: self.per_page, 
        }
    }

    /// The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    pub fn per_page(self, per_page: u16) -> Self {
        Self { 
            state: self.state, 
            severity: self.severity, 
            ecosystem: self.ecosystem, 
            package: self.package, 
            scope: self.scope, 
            sort: self.sort, 
            direction: self.direction, 
            before: self.before, 
            after: self.after, 
            first: self.first, 
            last: self.last, 
            per_page: Some(per_page),
        }
    }
}

/// Query parameters for the [List Dependabot alerts for a repository](Dependabot::list_alerts_for_repo_async()) endpoint.
#[derive(Default, Serialize)]
pub struct DependabotListAlertsForRepoParams<'req> {
    /// A comma-separated list of states. If specified, only alerts with these states will be returned.  Can be: `auto_dismissed`, `dismissed`, `fixed`, `open`
    state: Option<&'req str>, 
    /// A comma-separated list of severities. If specified, only alerts with these severities will be returned.  Can be: `low`, `medium`, `high`, `critical`
    severity: Option<&'req str>, 
    /// A comma-separated list of ecosystems. If specified, only alerts for these ecosystems will be returned.  Can be: `composer`, `go`, `maven`, `npm`, `nuget`, `pip`, `pub`, `rubygems`, `rust`
    ecosystem: Option<&'req str>, 
    /// A comma-separated list of package names. If specified, only alerts for these packages will be returned.
    package: Option<&'req str>, 
    /// A comma-separated list of full manifest paths. If specified, only alerts for these manifests will be returned.
    manifest: Option<&'req str>, 
    /// The scope of the vulnerable dependency. If specified, only alerts with this scope will be returned.
    scope: Option<&'req str>, 
    /// The property by which to sort the results. `created` means when the alert was created. `updated` means when the alert's state last changed.
    sort: Option<&'req str>, 
    /// The direction to sort the results by.
    direction: Option<&'req str>, 
    /// **Deprecated**. Page number of the results to fetch. Use cursor-based pagination with `before` or `after` instead.
    page: Option<u16>, 
    /// The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    per_page: Option<u16>, 
    /// A cursor, as given in the [Link header](https://docs.github.com/rest/guides/using-pagination-in-the-rest-api#using-link-headers). If specified, the query only searches for results before this cursor. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    before: Option<&'req str>, 
    /// A cursor, as given in the [Link header](https://docs.github.com/rest/guides/using-pagination-in-the-rest-api#using-link-headers). If specified, the query only searches for results after this cursor. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    after: Option<&'req str>, 
    /// **Deprecated**. The number of results per page (max 100), starting from the first matching result. This parameter must not be used in combination with `last`. Instead, use `per_page` in combination with `after` to fetch the first page of results.
    first: Option<i32>, 
    /// **Deprecated**. The number of results per page (max 100), starting from the last matching result. This parameter must not be used in combination with `first`. Instead, use `per_page` in combination with `before` to fetch the last page of results.
    last: Option<i32>
}

impl<'req> DependabotListAlertsForRepoParams<'req> {
    pub fn new() -> Self {
        Self::default()
    }

    /// A comma-separated list of states. If specified, only alerts with these states will be returned.  Can be: `auto_dismissed`, `dismissed`, `fixed`, `open`
    pub fn state(self, state: &'req str) -> Self {
        Self { 
            state: Some(state),
            severity: self.severity, 
            ecosystem: self.ecosystem, 
            package: self.package, 
            manifest: self.manifest, 
            scope: self.scope, 
            sort: self.sort, 
            direction: self.direction, 
            page: self.page, 
            per_page: self.per_page, 
            before: self.before, 
            after: self.after, 
            first: self.first, 
            last: self.last, 
        }
    }

    /// A comma-separated list of severities. If specified, only alerts with these severities will be returned.  Can be: `low`, `medium`, `high`, `critical`
    pub fn severity(self, severity: &'req str) -> Self {
        Self { 
            state: self.state, 
            severity: Some(severity),
            ecosystem: self.ecosystem, 
            package: self.package, 
            manifest: self.manifest, 
            scope: self.scope, 
            sort: self.sort, 
            direction: self.direction, 
            page: self.page, 
            per_page: self.per_page, 
            before: self.before, 
            after: self.after, 
            first: self.first, 
            last: self.last, 
        }
    }

    /// A comma-separated list of ecosystems. If specified, only alerts for these ecosystems will be returned.  Can be: `composer`, `go`, `maven`, `npm`, `nuget`, `pip`, `pub`, `rubygems`, `rust`
    pub fn ecosystem(self, ecosystem: &'req str) -> Self {
        Self { 
            state: self.state, 
            severity: self.severity, 
            ecosystem: Some(ecosystem),
            package: self.package, 
            manifest: self.manifest, 
            scope: self.scope, 
            sort: self.sort, 
            direction: self.direction, 
            page: self.page, 
            per_page: self.per_page, 
            before: self.before, 
            after: self.after, 
            first: self.first, 
            last: self.last, 
        }
    }

    /// A comma-separated list of package names. If specified, only alerts for these packages will be returned.
    pub fn package(self, package: &'req str) -> Self {
        Self { 
            state: self.state, 
            severity: self.severity, 
            ecosystem: self.ecosystem, 
            package: Some(package),
            manifest: self.manifest, 
            scope: self.scope, 
            sort: self.sort, 
            direction: self.direction, 
            page: self.page, 
            per_page: self.per_page, 
            before: self.before, 
            after: self.after, 
            first: self.first, 
            last: self.last, 
        }
    }

    /// A comma-separated list of full manifest paths. If specified, only alerts for these manifests will be returned.
    pub fn manifest(self, manifest: &'req str) -> Self {
        Self { 
            state: self.state, 
            severity: self.severity, 
            ecosystem: self.ecosystem, 
            package: self.package, 
            manifest: Some(manifest),
            scope: self.scope, 
            sort: self.sort, 
            direction: self.direction, 
            page: self.page, 
            per_page: self.per_page, 
            before: self.before, 
            after: self.after, 
            first: self.first, 
            last: self.last, 
        }
    }

    /// The scope of the vulnerable dependency. If specified, only alerts with this scope will be returned.
    pub fn scope(self, scope: &'req str) -> Self {
        Self { 
            state: self.state, 
            severity: self.severity, 
            ecosystem: self.ecosystem, 
            package: self.package, 
            manifest: self.manifest, 
            scope: Some(scope),
            sort: self.sort, 
            direction: self.direction, 
            page: self.page, 
            per_page: self.per_page, 
            before: self.before, 
            after: self.after, 
            first: self.first, 
            last: self.last, 
        }
    }

    /// The property by which to sort the results. `created` means when the alert was created. `updated` means when the alert's state last changed.
    pub fn sort(self, sort: &'req str) -> Self {
        Self { 
            state: self.state, 
            severity: self.severity, 
            ecosystem: self.ecosystem, 
            package: self.package, 
            manifest: self.manifest, 
            scope: self.scope, 
            sort: Some(sort),
            direction: self.direction, 
            page: self.page, 
            per_page: self.per_page, 
            before: self.before, 
            after: self.after, 
            first: self.first, 
            last: self.last, 
        }
    }

    /// The direction to sort the results by.
    pub fn direction(self, direction: &'req str) -> Self {
        Self { 
            state: self.state, 
            severity: self.severity, 
            ecosystem: self.ecosystem, 
            package: self.package, 
            manifest: self.manifest, 
            scope: self.scope, 
            sort: self.sort, 
            direction: Some(direction),
            page: self.page, 
            per_page: self.per_page, 
            before: self.before, 
            after: self.after, 
            first: self.first, 
            last: self.last, 
        }
    }

    /// **Deprecated**. Page number of the results to fetch. Use cursor-based pagination with `before` or `after` instead.
    pub fn page(self, page: u16) -> Self {
        Self { 
            state: self.state, 
            severity: self.severity, 
            ecosystem: self.ecosystem, 
            package: self.package, 
            manifest: self.manifest, 
            scope: self.scope, 
            sort: self.sort, 
            direction: self.direction, 
            page: Some(page),
            per_page: self.per_page, 
            before: self.before, 
            after: self.after, 
            first: self.first, 
            last: self.last, 
        }
    }

    /// The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    pub fn per_page(self, per_page: u16) -> Self {
        Self { 
            state: self.state, 
            severity: self.severity, 
            ecosystem: self.ecosystem, 
            package: self.package, 
            manifest: self.manifest, 
            scope: self.scope, 
            sort: self.sort, 
            direction: self.direction, 
            page: self.page, 
            per_page: Some(per_page),
            before: self.before, 
            after: self.after, 
            first: self.first, 
            last: self.last, 
        }
    }

    /// A cursor, as given in the [Link header](https://docs.github.com/rest/guides/using-pagination-in-the-rest-api#using-link-headers). If specified, the query only searches for results before this cursor. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    pub fn before(self, before: &'req str) -> Self {
        Self { 
            state: self.state, 
            severity: self.severity, 
            ecosystem: self.ecosystem, 
            package: self.package, 
            manifest: self.manifest, 
            scope: self.scope, 
            sort: self.sort, 
            direction: self.direction, 
            page: self.page, 
            per_page: self.per_page, 
            before: Some(before),
            after: self.after, 
            first: self.first, 
            last: self.last, 
        }
    }

    /// A cursor, as given in the [Link header](https://docs.github.com/rest/guides/using-pagination-in-the-rest-api#using-link-headers). If specified, the query only searches for results after this cursor. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    pub fn after(self, after: &'req str) -> Self {
        Self { 
            state: self.state, 
            severity: self.severity, 
            ecosystem: self.ecosystem, 
            package: self.package, 
            manifest: self.manifest, 
            scope: self.scope, 
            sort: self.sort, 
            direction: self.direction, 
            page: self.page, 
            per_page: self.per_page, 
            before: self.before, 
            after: Some(after),
            first: self.first, 
            last: self.last, 
        }
    }

    /// **Deprecated**. The number of results per page (max 100), starting from the first matching result. This parameter must not be used in combination with `last`. Instead, use `per_page` in combination with `after` to fetch the first page of results.
    pub fn first(self, first: i32) -> Self {
        Self { 
            state: self.state, 
            severity: self.severity, 
            ecosystem: self.ecosystem, 
            package: self.package, 
            manifest: self.manifest, 
            scope: self.scope, 
            sort: self.sort, 
            direction: self.direction, 
            page: self.page, 
            per_page: self.per_page, 
            before: self.before, 
            after: self.after, 
            first: Some(first),
            last: self.last, 
        }
    }

    /// **Deprecated**. The number of results per page (max 100), starting from the last matching result. This parameter must not be used in combination with `first`. Instead, use `per_page` in combination with `before` to fetch the last page of results.
    pub fn last(self, last: i32) -> Self {
        Self { 
            state: self.state, 
            severity: self.severity, 
            ecosystem: self.ecosystem, 
            package: self.package, 
            manifest: self.manifest, 
            scope: self.scope, 
            sort: self.sort, 
            direction: self.direction, 
            page: self.page, 
            per_page: self.per_page, 
            before: self.before, 
            after: self.after, 
            first: self.first, 
            last: Some(last),
        }
    }
}

impl<'enc> From<&'enc PerPage> for DependabotListAlertsForRepoParams<'enc> {
    fn from(per_page: &'enc PerPage) -> Self {
        Self {
            per_page: Some(per_page.per_page),
            page: Some(per_page.page),
            ..Default::default()
        }
    }
}
/// Query parameters for the [List organization secrets](Dependabot::list_org_secrets_async()) endpoint.
#[derive(Default, Serialize)]
pub struct DependabotListOrgSecretsParams {
    /// The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    per_page: Option<u16>, 
    /// The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    page: Option<u16>
}

impl DependabotListOrgSecretsParams {
    pub fn new() -> Self {
        Self::default()
    }

    /// The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    pub fn per_page(self, per_page: u16) -> Self {
        Self { 
            per_page: Some(per_page),
            page: self.page, 
        }
    }

    /// The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    pub fn page(self, page: u16) -> Self {
        Self { 
            per_page: self.per_page, 
            page: Some(page),
        }
    }
}

impl<'enc> From<&'enc PerPage> for DependabotListOrgSecretsParams {
    fn from(per_page: &'enc PerPage) -> Self {
        Self {
            per_page: Some(per_page.per_page),
            page: Some(per_page.page),
            ..Default::default()
        }
    }
}
/// Query parameters for the [List repository secrets](Dependabot::list_repo_secrets_async()) endpoint.
#[derive(Default, Serialize)]
pub struct DependabotListRepoSecretsParams {
    /// The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    per_page: Option<u16>, 
    /// The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    page: Option<u16>
}

impl DependabotListRepoSecretsParams {
    pub fn new() -> Self {
        Self::default()
    }

    /// The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    pub fn per_page(self, per_page: u16) -> Self {
        Self { 
            per_page: Some(per_page),
            page: self.page, 
        }
    }

    /// The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    pub fn page(self, page: u16) -> Self {
        Self { 
            per_page: self.per_page, 
            page: Some(page),
        }
    }
}

impl<'enc> From<&'enc PerPage> for DependabotListRepoSecretsParams {
    fn from(per_page: &'enc PerPage) -> Self {
        Self {
            per_page: Some(per_page.per_page),
            page: Some(per_page.page),
            ..Default::default()
        }
    }
}
/// Query parameters for the [List selected repositories for an organization secret](Dependabot::list_selected_repos_for_org_secret_async()) endpoint.
#[derive(Default, Serialize)]
pub struct DependabotListSelectedReposForOrgSecretParams {
    /// The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    page: Option<u16>, 
    /// The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    per_page: Option<u16>
}

impl DependabotListSelectedReposForOrgSecretParams {
    pub fn new() -> Self {
        Self::default()
    }

    /// The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    pub fn page(self, page: u16) -> Self {
        Self { 
            page: Some(page),
            per_page: self.per_page, 
        }
    }

    /// The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    pub fn per_page(self, per_page: u16) -> Self {
        Self { 
            page: self.page, 
            per_page: Some(per_page),
        }
    }
}

impl<'enc> From<&'enc PerPage> for DependabotListSelectedReposForOrgSecretParams {
    fn from(per_page: &'enc PerPage) -> Self {
        Self {
            per_page: Some(per_page.per_page),
            page: Some(per_page.page),
            ..Default::default()
        }
    }
}

impl<'api> Dependabot<'api> {
    /// ---
    ///
    /// # Add selected repository to an organization secret
    ///
    /// Adds a repository to an organization secret when the `visibility` for
    /// repository access is set to `selected`. The visibility is set when you [Create or
    /// update an organization secret](https://docs.github.com/rest/dependabot/secrets#create-or-update-an-organization-secret).
    /// 
    /// OAuth app tokens and personal access tokens (classic) need the `admin:org` scope to use this endpoint.
    /// 
    /// [GitHub API docs for add_selected_repo_to_org_secret](https://docs.github.com/rest/dependabot/secrets#add-selected-repository-to-an-organization-secret)
    ///
    /// ---
    pub async fn add_selected_repo_to_org_secret_async(&self, org: &str, secret_name: &str, repository_id: i32) -> Result<(), DependabotAddSelectedRepoToOrgSecretError> {

        let request_uri = format!("{}/orgs/{}/dependabot/secrets/{}/repositories/{}", super::GITHUB_BASE_API_URL, org, secret_name, repository_id);


        let req = GitHubRequest {
            uri: request_uri,
            body: None,
            method: "PUT",
            headers: vec![]
        };

        let request = GitHubRequestBuilder::build(req, self.auth)?;

        // --

        let github_response = crate::adapters::fetch_async(request).await?;

        // --

        if github_response.is_success() {
            Ok(crate::adapters::to_json_async(github_response).await?)
        } else {
            match github_response.status_code() {
                409 => Err(DependabotAddSelectedRepoToOrgSecretError::Status409),
                code => Err(DependabotAddSelectedRepoToOrgSecretError::Generic { code }),
            }
        }
    }

    /// ---
    ///
    /// # Add selected repository to an organization secret
    ///
    /// Adds a repository to an organization secret when the `visibility` for
    /// repository access is set to `selected`. The visibility is set when you [Create or
    /// update an organization secret](https://docs.github.com/rest/dependabot/secrets#create-or-update-an-organization-secret).
    /// 
    /// OAuth app tokens and personal access tokens (classic) need the `admin:org` scope to use this endpoint.
    /// 
    /// [GitHub API docs for add_selected_repo_to_org_secret](https://docs.github.com/rest/dependabot/secrets#add-selected-repository-to-an-organization-secret)
    ///
    /// ---
    #[cfg(not(target_arch = "wasm32"))]
    pub fn add_selected_repo_to_org_secret(&self, org: &str, secret_name: &str, repository_id: i32) -> Result<(), DependabotAddSelectedRepoToOrgSecretError> {

        let request_uri = format!("{}/orgs/{}/dependabot/secrets/{}/repositories/{}", super::GITHUB_BASE_API_URL, org, secret_name, repository_id);


        let req = GitHubRequest {
            uri: request_uri,
            body: None,
            method: "PUT",
            headers: vec![]
        };

        let request = GitHubRequestBuilder::build(req, self.auth)?;

        // --

        let github_response = crate::adapters::fetch(request)?;

        // --

        if github_response.is_success() {
            Ok(crate::adapters::to_json(github_response)?)
        } else {
            match github_response.status_code() {
                409 => Err(DependabotAddSelectedRepoToOrgSecretError::Status409),
                code => Err(DependabotAddSelectedRepoToOrgSecretError::Generic { code }),
            }
        }
    }

    /// ---
    ///
    /// # Create or update an organization secret
    ///
    /// Creates or updates an organization secret with an encrypted value. Encrypt your secret using
    /// [LibSodium](https://libsodium.gitbook.io/doc/bindings_for_other_languages). For more information, see "[Encrypting secrets for the REST API](https://docs.github.com/rest/guides/encrypting-secrets-for-the-rest-api)."
    /// 
    /// OAuth app tokens and personal access tokens (classic) need the `admin:org` scope to use this endpoint.
    /// 
    /// [GitHub API docs for create_or_update_org_secret](https://docs.github.com/rest/dependabot/secrets#create-or-update-an-organization-secret)
    ///
    /// ---
    pub async fn create_or_update_org_secret_async(&self, org: &str, secret_name: &str, body: PutDependabotCreateOrUpdateOrgSecret) -> Result<EmptyObject, DependabotCreateOrUpdateOrgSecretError> {

        let request_uri = format!("{}/orgs/{}/dependabot/secrets/{}", super::GITHUB_BASE_API_URL, org, secret_name);


        let req = GitHubRequest {
            uri: request_uri,
            body: Some(PutDependabotCreateOrUpdateOrgSecret::from_json(body)?),
            method: "PUT",
            headers: vec![]
        };

        let request = GitHubRequestBuilder::build(req, self.auth)?;

        // --

        let github_response = crate::adapters::fetch_async(request).await?;

        // --

        if github_response.is_success() {
            Ok(crate::adapters::to_json_async(github_response).await?)
        } else {
            match github_response.status_code() {
                204 => Err(DependabotCreateOrUpdateOrgSecretError::Status204),
                code => Err(DependabotCreateOrUpdateOrgSecretError::Generic { code }),
            }
        }
    }

    /// ---
    ///
    /// # Create or update an organization secret
    ///
    /// Creates or updates an organization secret with an encrypted value. Encrypt your secret using
    /// [LibSodium](https://libsodium.gitbook.io/doc/bindings_for_other_languages). For more information, see "[Encrypting secrets for the REST API](https://docs.github.com/rest/guides/encrypting-secrets-for-the-rest-api)."
    /// 
    /// OAuth app tokens and personal access tokens (classic) need the `admin:org` scope to use this endpoint.
    /// 
    /// [GitHub API docs for create_or_update_org_secret](https://docs.github.com/rest/dependabot/secrets#create-or-update-an-organization-secret)
    ///
    /// ---
    #[cfg(not(target_arch = "wasm32"))]
    pub fn create_or_update_org_secret(&self, org: &str, secret_name: &str, body: PutDependabotCreateOrUpdateOrgSecret) -> Result<EmptyObject, DependabotCreateOrUpdateOrgSecretError> {

        let request_uri = format!("{}/orgs/{}/dependabot/secrets/{}", super::GITHUB_BASE_API_URL, org, secret_name);


        let req = GitHubRequest {
            uri: request_uri,
            body: Some(PutDependabotCreateOrUpdateOrgSecret::from_json(body)?),
            method: "PUT",
            headers: vec![]
        };

        let request = GitHubRequestBuilder::build(req, self.auth)?;

        // --

        let github_response = crate::adapters::fetch(request)?;

        // --

        if github_response.is_success() {
            Ok(crate::adapters::to_json(github_response)?)
        } else {
            match github_response.status_code() {
                204 => Err(DependabotCreateOrUpdateOrgSecretError::Status204),
                code => Err(DependabotCreateOrUpdateOrgSecretError::Generic { code }),
            }
        }
    }

    /// ---
    ///
    /// # Create or update a repository secret
    ///
    /// Creates or updates a repository secret with an encrypted value. Encrypt your secret using
    /// [LibSodium](https://libsodium.gitbook.io/doc/bindings_for_other_languages). For more information, see "[Encrypting secrets for the REST API](https://docs.github.com/rest/guides/encrypting-secrets-for-the-rest-api)."
    /// 
    /// OAuth app tokens and personal access tokens (classic) need the `repo` scope to use this endpoint.
    /// 
    /// [GitHub API docs for create_or_update_repo_secret](https://docs.github.com/rest/dependabot/secrets#create-or-update-a-repository-secret)
    ///
    /// ---
    pub async fn create_or_update_repo_secret_async(&self, owner: &str, repo: &str, secret_name: &str, body: PutDependabotCreateOrUpdateRepoSecret) -> Result<EmptyObject, DependabotCreateOrUpdateRepoSecretError> {

        let request_uri = format!("{}/repos/{}/{}/dependabot/secrets/{}", super::GITHUB_BASE_API_URL, owner, repo, secret_name);


        let req = GitHubRequest {
            uri: request_uri,
            body: Some(PutDependabotCreateOrUpdateRepoSecret::from_json(body)?),
            method: "PUT",
            headers: vec![]
        };

        let request = GitHubRequestBuilder::build(req, self.auth)?;

        // --

        let github_response = crate::adapters::fetch_async(request).await?;

        // --

        if github_response.is_success() {
            Ok(crate::adapters::to_json_async(github_response).await?)
        } else {
            match github_response.status_code() {
                204 => Err(DependabotCreateOrUpdateRepoSecretError::Status204),
                code => Err(DependabotCreateOrUpdateRepoSecretError::Generic { code }),
            }
        }
    }

    /// ---
    ///
    /// # Create or update a repository secret
    ///
    /// Creates or updates a repository secret with an encrypted value. Encrypt your secret using
    /// [LibSodium](https://libsodium.gitbook.io/doc/bindings_for_other_languages). For more information, see "[Encrypting secrets for the REST API](https://docs.github.com/rest/guides/encrypting-secrets-for-the-rest-api)."
    /// 
    /// OAuth app tokens and personal access tokens (classic) need the `repo` scope to use this endpoint.
    /// 
    /// [GitHub API docs for create_or_update_repo_secret](https://docs.github.com/rest/dependabot/secrets#create-or-update-a-repository-secret)
    ///
    /// ---
    #[cfg(not(target_arch = "wasm32"))]
    pub fn create_or_update_repo_secret(&self, owner: &str, repo: &str, secret_name: &str, body: PutDependabotCreateOrUpdateRepoSecret) -> Result<EmptyObject, DependabotCreateOrUpdateRepoSecretError> {

        let request_uri = format!("{}/repos/{}/{}/dependabot/secrets/{}", super::GITHUB_BASE_API_URL, owner, repo, secret_name);


        let req = GitHubRequest {
            uri: request_uri,
            body: Some(PutDependabotCreateOrUpdateRepoSecret::from_json(body)?),
            method: "PUT",
            headers: vec![]
        };

        let request = GitHubRequestBuilder::build(req, self.auth)?;

        // --

        let github_response = crate::adapters::fetch(request)?;

        // --

        if github_response.is_success() {
            Ok(crate::adapters::to_json(github_response)?)
        } else {
            match github_response.status_code() {
                204 => Err(DependabotCreateOrUpdateRepoSecretError::Status204),
                code => Err(DependabotCreateOrUpdateRepoSecretError::Generic { code }),
            }
        }
    }

    /// ---
    ///
    /// # Delete an organization secret
    ///
    /// Deletes a secret in an organization using the secret name.
    /// 
    /// OAuth app tokens and personal access tokens (classic) need the `admin:org` scope to use this endpoint.
    /// 
    /// [GitHub API docs for delete_org_secret](https://docs.github.com/rest/dependabot/secrets#delete-an-organization-secret)
    ///
    /// ---
    pub async fn delete_org_secret_async(&self, org: &str, secret_name: &str) -> Result<(), DependabotDeleteOrgSecretError> {

        let request_uri = format!("{}/orgs/{}/dependabot/secrets/{}", super::GITHUB_BASE_API_URL, org, secret_name);


        let req = GitHubRequest {
            uri: request_uri,
            body: None,
            method: "DELETE",
            headers: vec![]
        };

        let request = GitHubRequestBuilder::build(req, self.auth)?;

        // --

        let github_response = crate::adapters::fetch_async(request).await?;

        // --

        if github_response.is_success() {
            Ok(crate::adapters::to_json_async(github_response).await?)
        } else {
            match github_response.status_code() {
                code => Err(DependabotDeleteOrgSecretError::Generic { code }),
            }
        }
    }

    /// ---
    ///
    /// # Delete an organization secret
    ///
    /// Deletes a secret in an organization using the secret name.
    /// 
    /// OAuth app tokens and personal access tokens (classic) need the `admin:org` scope to use this endpoint.
    /// 
    /// [GitHub API docs for delete_org_secret](https://docs.github.com/rest/dependabot/secrets#delete-an-organization-secret)
    ///
    /// ---
    #[cfg(not(target_arch = "wasm32"))]
    pub fn delete_org_secret(&self, org: &str, secret_name: &str) -> Result<(), DependabotDeleteOrgSecretError> {

        let request_uri = format!("{}/orgs/{}/dependabot/secrets/{}", super::GITHUB_BASE_API_URL, org, secret_name);


        let req = GitHubRequest {
            uri: request_uri,
            body: None,
            method: "DELETE",
            headers: vec![]
        };

        let request = GitHubRequestBuilder::build(req, self.auth)?;

        // --

        let github_response = crate::adapters::fetch(request)?;

        // --

        if github_response.is_success() {
            Ok(crate::adapters::to_json(github_response)?)
        } else {
            match github_response.status_code() {
                code => Err(DependabotDeleteOrgSecretError::Generic { code }),
            }
        }
    }

    /// ---
    ///
    /// # Delete a repository secret
    ///
    /// Deletes a secret in a repository using the secret name.
    /// 
    /// OAuth app tokens and personal access tokens (classic) need the `repo` scope to use this endpoint.
    /// 
    /// [GitHub API docs for delete_repo_secret](https://docs.github.com/rest/dependabot/secrets#delete-a-repository-secret)
    ///
    /// ---
    pub async fn delete_repo_secret_async(&self, owner: &str, repo: &str, secret_name: &str) -> Result<(), DependabotDeleteRepoSecretError> {

        let request_uri = format!("{}/repos/{}/{}/dependabot/secrets/{}", super::GITHUB_BASE_API_URL, owner, repo, secret_name);


        let req = GitHubRequest {
            uri: request_uri,
            body: None,
            method: "DELETE",
            headers: vec![]
        };

        let request = GitHubRequestBuilder::build(req, self.auth)?;

        // --

        let github_response = crate::adapters::fetch_async(request).await?;

        // --

        if github_response.is_success() {
            Ok(crate::adapters::to_json_async(github_response).await?)
        } else {
            match github_response.status_code() {
                code => Err(DependabotDeleteRepoSecretError::Generic { code }),
            }
        }
    }

    /// ---
    ///
    /// # Delete a repository secret
    ///
    /// Deletes a secret in a repository using the secret name.
    /// 
    /// OAuth app tokens and personal access tokens (classic) need the `repo` scope to use this endpoint.
    /// 
    /// [GitHub API docs for delete_repo_secret](https://docs.github.com/rest/dependabot/secrets#delete-a-repository-secret)
    ///
    /// ---
    #[cfg(not(target_arch = "wasm32"))]
    pub fn delete_repo_secret(&self, owner: &str, repo: &str, secret_name: &str) -> Result<(), DependabotDeleteRepoSecretError> {

        let request_uri = format!("{}/repos/{}/{}/dependabot/secrets/{}", super::GITHUB_BASE_API_URL, owner, repo, secret_name);


        let req = GitHubRequest {
            uri: request_uri,
            body: None,
            method: "DELETE",
            headers: vec![]
        };

        let request = GitHubRequestBuilder::build(req, self.auth)?;

        // --

        let github_response = crate::adapters::fetch(request)?;

        // --

        if github_response.is_success() {
            Ok(crate::adapters::to_json(github_response)?)
        } else {
            match github_response.status_code() {
                code => Err(DependabotDeleteRepoSecretError::Generic { code }),
            }
        }
    }

    /// ---
    ///
    /// # Get a Dependabot alert
    ///
    /// OAuth app tokens and personal access tokens (classic) need the `security_events` scope to use this endpoint. If this endpoint is only used with public repositories, the token can use the `public_repo` scope instead.
    /// 
    /// [GitHub API docs for get_alert](https://docs.github.com/rest/dependabot/alerts#get-a-dependabot-alert)
    ///
    /// ---
    pub async fn get_alert_async(&self, owner: &str, repo: &str, alert_number: AlertNumber) -> Result<DependabotAlert, DependabotGetAlertError> {

        let request_uri = format!("{}/repos/{}/{}/dependabot/alerts/{}", super::GITHUB_BASE_API_URL, owner, repo, alert_number);


        let req = GitHubRequest {
            uri: request_uri,
            body: None,
            method: "GET",
            headers: vec![]
        };

        let request = GitHubRequestBuilder::build(req, self.auth)?;

        // --

        let github_response = crate::adapters::fetch_async(request).await?;

        // --

        if github_response.is_success() {
            Ok(crate::adapters::to_json_async(github_response).await?)
        } else {
            match github_response.status_code() {
                304 => Err(DependabotGetAlertError::Status304),
                403 => Err(DependabotGetAlertError::Status403(crate::adapters::to_json_async(github_response).await?)),
                404 => Err(DependabotGetAlertError::Status404(crate::adapters::to_json_async(github_response).await?)),
                code => Err(DependabotGetAlertError::Generic { code }),
            }
        }
    }

    /// ---
    ///
    /// # Get a Dependabot alert
    ///
    /// OAuth app tokens and personal access tokens (classic) need the `security_events` scope to use this endpoint. If this endpoint is only used with public repositories, the token can use the `public_repo` scope instead.
    /// 
    /// [GitHub API docs for get_alert](https://docs.github.com/rest/dependabot/alerts#get-a-dependabot-alert)
    ///
    /// ---
    #[cfg(not(target_arch = "wasm32"))]
    pub fn get_alert(&self, owner: &str, repo: &str, alert_number: AlertNumber) -> Result<DependabotAlert, DependabotGetAlertError> {

        let request_uri = format!("{}/repos/{}/{}/dependabot/alerts/{}", super::GITHUB_BASE_API_URL, owner, repo, alert_number);


        let req = GitHubRequest {
            uri: request_uri,
            body: None,
            method: "GET",
            headers: vec![]
        };

        let request = GitHubRequestBuilder::build(req, self.auth)?;

        // --

        let github_response = crate::adapters::fetch(request)?;

        // --

        if github_response.is_success() {
            Ok(crate::adapters::to_json(github_response)?)
        } else {
            match github_response.status_code() {
                304 => Err(DependabotGetAlertError::Status304),
                403 => Err(DependabotGetAlertError::Status403(crate::adapters::to_json(github_response)?)),
                404 => Err(DependabotGetAlertError::Status404(crate::adapters::to_json(github_response)?)),
                code => Err(DependabotGetAlertError::Generic { code }),
            }
        }
    }

    /// ---
    ///
    /// # Get an organization public key
    ///
    /// Gets your public key, which you need to encrypt secrets. You need to
    /// encrypt a secret before you can create or update secrets.
    /// 
    /// OAuth app tokens and personal access tokens (classic) need the `admin:org` scope to use this endpoint.
    /// 
    /// [GitHub API docs for get_org_public_key](https://docs.github.com/rest/dependabot/secrets#get-an-organization-public-key)
    ///
    /// ---
    pub async fn get_org_public_key_async(&self, org: &str) -> Result<DependabotPublicKey, DependabotGetOrgPublicKeyError> {

        let request_uri = format!("{}/orgs/{}/dependabot/secrets/public-key", super::GITHUB_BASE_API_URL, org);


        let req = GitHubRequest {
            uri: request_uri,
            body: None,
            method: "GET",
            headers: vec![]
        };

        let request = GitHubRequestBuilder::build(req, self.auth)?;

        // --

        let github_response = crate::adapters::fetch_async(request).await?;

        // --

        if github_response.is_success() {
            Ok(crate::adapters::to_json_async(github_response).await?)
        } else {
            match github_response.status_code() {
                code => Err(DependabotGetOrgPublicKeyError::Generic { code }),
            }
        }
    }

    /// ---
    ///
    /// # Get an organization public key
    ///
    /// Gets your public key, which you need to encrypt secrets. You need to
    /// encrypt a secret before you can create or update secrets.
    /// 
    /// OAuth app tokens and personal access tokens (classic) need the `admin:org` scope to use this endpoint.
    /// 
    /// [GitHub API docs for get_org_public_key](https://docs.github.com/rest/dependabot/secrets#get-an-organization-public-key)
    ///
    /// ---
    #[cfg(not(target_arch = "wasm32"))]
    pub fn get_org_public_key(&self, org: &str) -> Result<DependabotPublicKey, DependabotGetOrgPublicKeyError> {

        let request_uri = format!("{}/orgs/{}/dependabot/secrets/public-key", super::GITHUB_BASE_API_URL, org);


        let req = GitHubRequest {
            uri: request_uri,
            body: None,
            method: "GET",
            headers: vec![]
        };

        let request = GitHubRequestBuilder::build(req, self.auth)?;

        // --

        let github_response = crate::adapters::fetch(request)?;

        // --

        if github_response.is_success() {
            Ok(crate::adapters::to_json(github_response)?)
        } else {
            match github_response.status_code() {
                code => Err(DependabotGetOrgPublicKeyError::Generic { code }),
            }
        }
    }

    /// ---
    ///
    /// # Get an organization secret
    ///
    /// Gets a single organization secret without revealing its encrypted value.
    /// 
    /// OAuth app tokens and personal access tokens (classic) need the `admin:org` scope to use this endpoint.
    /// 
    /// [GitHub API docs for get_org_secret](https://docs.github.com/rest/dependabot/secrets#get-an-organization-secret)
    ///
    /// ---
    pub async fn get_org_secret_async(&self, org: &str, secret_name: &str) -> Result<OrganizationDependabotSecret, DependabotGetOrgSecretError> {

        let request_uri = format!("{}/orgs/{}/dependabot/secrets/{}", super::GITHUB_BASE_API_URL, org, secret_name);


        let req = GitHubRequest {
            uri: request_uri,
            body: None,
            method: "GET",
            headers: vec![]
        };

        let request = GitHubRequestBuilder::build(req, self.auth)?;

        // --

        let github_response = crate::adapters::fetch_async(request).await?;

        // --

        if github_response.is_success() {
            Ok(crate::adapters::to_json_async(github_response).await?)
        } else {
            match github_response.status_code() {
                code => Err(DependabotGetOrgSecretError::Generic { code }),
            }
        }
    }

    /// ---
    ///
    /// # Get an organization secret
    ///
    /// Gets a single organization secret without revealing its encrypted value.
    /// 
    /// OAuth app tokens and personal access tokens (classic) need the `admin:org` scope to use this endpoint.
    /// 
    /// [GitHub API docs for get_org_secret](https://docs.github.com/rest/dependabot/secrets#get-an-organization-secret)
    ///
    /// ---
    #[cfg(not(target_arch = "wasm32"))]
    pub fn get_org_secret(&self, org: &str, secret_name: &str) -> Result<OrganizationDependabotSecret, DependabotGetOrgSecretError> {

        let request_uri = format!("{}/orgs/{}/dependabot/secrets/{}", super::GITHUB_BASE_API_URL, org, secret_name);


        let req = GitHubRequest {
            uri: request_uri,
            body: None,
            method: "GET",
            headers: vec![]
        };

        let request = GitHubRequestBuilder::build(req, self.auth)?;

        // --

        let github_response = crate::adapters::fetch(request)?;

        // --

        if github_response.is_success() {
            Ok(crate::adapters::to_json(github_response)?)
        } else {
            match github_response.status_code() {
                code => Err(DependabotGetOrgSecretError::Generic { code }),
            }
        }
    }

    /// ---
    ///
    /// # Get a repository public key
    ///
    /// Gets your public key, which you need to encrypt secrets. You need to
    /// encrypt a secret before you can create or update secrets. Anyone with read access
    /// to the repository can use this endpoint.
    /// 
    /// OAuth app tokens and personal access tokens (classic) need the `repo` scope to use this endpoint if the repository is private.
    /// 
    /// [GitHub API docs for get_repo_public_key](https://docs.github.com/rest/dependabot/secrets#get-a-repository-public-key)
    ///
    /// ---
    pub async fn get_repo_public_key_async(&self, owner: &str, repo: &str) -> Result<DependabotPublicKey, DependabotGetRepoPublicKeyError> {

        let request_uri = format!("{}/repos/{}/{}/dependabot/secrets/public-key", super::GITHUB_BASE_API_URL, owner, repo);


        let req = GitHubRequest {
            uri: request_uri,
            body: None,
            method: "GET",
            headers: vec![]
        };

        let request = GitHubRequestBuilder::build(req, self.auth)?;

        // --

        let github_response = crate::adapters::fetch_async(request).await?;

        // --

        if github_response.is_success() {
            Ok(crate::adapters::to_json_async(github_response).await?)
        } else {
            match github_response.status_code() {
                code => Err(DependabotGetRepoPublicKeyError::Generic { code }),
            }
        }
    }

    /// ---
    ///
    /// # Get a repository public key
    ///
    /// Gets your public key, which you need to encrypt secrets. You need to
    /// encrypt a secret before you can create or update secrets. Anyone with read access
    /// to the repository can use this endpoint.
    /// 
    /// OAuth app tokens and personal access tokens (classic) need the `repo` scope to use this endpoint if the repository is private.
    /// 
    /// [GitHub API docs for get_repo_public_key](https://docs.github.com/rest/dependabot/secrets#get-a-repository-public-key)
    ///
    /// ---
    #[cfg(not(target_arch = "wasm32"))]
    pub fn get_repo_public_key(&self, owner: &str, repo: &str) -> Result<DependabotPublicKey, DependabotGetRepoPublicKeyError> {

        let request_uri = format!("{}/repos/{}/{}/dependabot/secrets/public-key", super::GITHUB_BASE_API_URL, owner, repo);


        let req = GitHubRequest {
            uri: request_uri,
            body: None,
            method: "GET",
            headers: vec![]
        };

        let request = GitHubRequestBuilder::build(req, self.auth)?;

        // --

        let github_response = crate::adapters::fetch(request)?;

        // --

        if github_response.is_success() {
            Ok(crate::adapters::to_json(github_response)?)
        } else {
            match github_response.status_code() {
                code => Err(DependabotGetRepoPublicKeyError::Generic { code }),
            }
        }
    }

    /// ---
    ///
    /// # Get a repository secret
    ///
    /// Gets a single repository secret without revealing its encrypted value.
    /// 
    /// OAuth app tokens and personal access tokens (classic) need the `repo` scope to use this endpoint.
    /// 
    /// [GitHub API docs for get_repo_secret](https://docs.github.com/rest/dependabot/secrets#get-a-repository-secret)
    ///
    /// ---
    pub async fn get_repo_secret_async(&self, owner: &str, repo: &str, secret_name: &str) -> Result<DependabotSecret, DependabotGetRepoSecretError> {

        let request_uri = format!("{}/repos/{}/{}/dependabot/secrets/{}", super::GITHUB_BASE_API_URL, owner, repo, secret_name);


        let req = GitHubRequest {
            uri: request_uri,
            body: None,
            method: "GET",
            headers: vec![]
        };

        let request = GitHubRequestBuilder::build(req, self.auth)?;

        // --

        let github_response = crate::adapters::fetch_async(request).await?;

        // --

        if github_response.is_success() {
            Ok(crate::adapters::to_json_async(github_response).await?)
        } else {
            match github_response.status_code() {
                code => Err(DependabotGetRepoSecretError::Generic { code }),
            }
        }
    }

    /// ---
    ///
    /// # Get a repository secret
    ///
    /// Gets a single repository secret without revealing its encrypted value.
    /// 
    /// OAuth app tokens and personal access tokens (classic) need the `repo` scope to use this endpoint.
    /// 
    /// [GitHub API docs for get_repo_secret](https://docs.github.com/rest/dependabot/secrets#get-a-repository-secret)
    ///
    /// ---
    #[cfg(not(target_arch = "wasm32"))]
    pub fn get_repo_secret(&self, owner: &str, repo: &str, secret_name: &str) -> Result<DependabotSecret, DependabotGetRepoSecretError> {

        let request_uri = format!("{}/repos/{}/{}/dependabot/secrets/{}", super::GITHUB_BASE_API_URL, owner, repo, secret_name);


        let req = GitHubRequest {
            uri: request_uri,
            body: None,
            method: "GET",
            headers: vec![]
        };

        let request = GitHubRequestBuilder::build(req, self.auth)?;

        // --

        let github_response = crate::adapters::fetch(request)?;

        // --

        if github_response.is_success() {
            Ok(crate::adapters::to_json(github_response)?)
        } else {
            match github_response.status_code() {
                code => Err(DependabotGetRepoSecretError::Generic { code }),
            }
        }
    }

    /// ---
    ///
    /// # List Dependabot alerts for an enterprise
    ///
    /// Lists Dependabot alerts for repositories that are owned by the specified enterprise.
    /// 
    /// The authenticated user must be a member of the enterprise to use this endpoint.
    /// 
    /// Alerts are only returned for organizations in the enterprise for which you are an organization owner or a security manager. For more information about security managers, see "[Managing security managers in your organization](https://docs.github.com/organizations/managing-peoples-access-to-your-organization-with-roles/managing-security-managers-in-your-organization)."
    /// 
    /// OAuth app tokens and personal access tokens (classic) need the `repo` or `security_events` scope to use this endpoint.
    /// 
    /// [GitHub API docs for list_alerts_for_enterprise](https://docs.github.com/rest/dependabot/alerts#list-dependabot-alerts-for-an-enterprise)
    ///
    /// ---
    pub async fn list_alerts_for_enterprise_async(&self, enterprise: &str, query_params: Option<impl Into<DependabotListAlertsForEnterpriseParams<'api>>>) -> Result<Vec<DependabotAlertWithRepository>, DependabotListAlertsForEnterpriseError> {

        let mut request_uri = format!("{}/enterprises/{}/dependabot/alerts", super::GITHUB_BASE_API_URL, enterprise);

        if let Some(params) = query_params {
            request_uri.push_str("?");
            request_uri.push_str(&serde_urlencoded::to_string(params.into())?);
        }

        let req = GitHubRequest {
            uri: request_uri,
            body: None,
            method: "GET",
            headers: vec![]
        };

        let request = GitHubRequestBuilder::build(req, self.auth)?;

        // --

        let github_response = crate::adapters::fetch_async(request).await?;

        // --

        if github_response.is_success() {
            Ok(crate::adapters::to_json_async(github_response).await?)
        } else {
            match github_response.status_code() {
                304 => Err(DependabotListAlertsForEnterpriseError::Status304),
                403 => Err(DependabotListAlertsForEnterpriseError::Status403(crate::adapters::to_json_async(github_response).await?)),
                404 => Err(DependabotListAlertsForEnterpriseError::Status404(crate::adapters::to_json_async(github_response).await?)),
                422 => Err(DependabotListAlertsForEnterpriseError::Status422(crate::adapters::to_json_async(github_response).await?)),
                code => Err(DependabotListAlertsForEnterpriseError::Generic { code }),
            }
        }
    }

    /// ---
    ///
    /// # List Dependabot alerts for an enterprise
    ///
    /// Lists Dependabot alerts for repositories that are owned by the specified enterprise.
    /// 
    /// The authenticated user must be a member of the enterprise to use this endpoint.
    /// 
    /// Alerts are only returned for organizations in the enterprise for which you are an organization owner or a security manager. For more information about security managers, see "[Managing security managers in your organization](https://docs.github.com/organizations/managing-peoples-access-to-your-organization-with-roles/managing-security-managers-in-your-organization)."
    /// 
    /// OAuth app tokens and personal access tokens (classic) need the `repo` or `security_events` scope to use this endpoint.
    /// 
    /// [GitHub API docs for list_alerts_for_enterprise](https://docs.github.com/rest/dependabot/alerts#list-dependabot-alerts-for-an-enterprise)
    ///
    /// ---
    #[cfg(not(target_arch = "wasm32"))]
    pub fn list_alerts_for_enterprise(&self, enterprise: &str, query_params: Option<impl Into<DependabotListAlertsForEnterpriseParams<'api>>>) -> Result<Vec<DependabotAlertWithRepository>, DependabotListAlertsForEnterpriseError> {

        let mut request_uri = format!("{}/enterprises/{}/dependabot/alerts", super::GITHUB_BASE_API_URL, enterprise);

        if let Some(params) = query_params {
            request_uri.push_str("?");
            let qp: DependabotListAlertsForEnterpriseParams = params.into();
            request_uri.push_str(&serde_urlencoded::to_string(qp)?);
        }

        let req = GitHubRequest {
            uri: request_uri,
            body: None,
            method: "GET",
            headers: vec![]
        };

        let request = GitHubRequestBuilder::build(req, self.auth)?;

        // --

        let github_response = crate::adapters::fetch(request)?;

        // --

        if github_response.is_success() {
            Ok(crate::adapters::to_json(github_response)?)
        } else {
            match github_response.status_code() {
                304 => Err(DependabotListAlertsForEnterpriseError::Status304),
                403 => Err(DependabotListAlertsForEnterpriseError::Status403(crate::adapters::to_json(github_response)?)),
                404 => Err(DependabotListAlertsForEnterpriseError::Status404(crate::adapters::to_json(github_response)?)),
                422 => Err(DependabotListAlertsForEnterpriseError::Status422(crate::adapters::to_json(github_response)?)),
                code => Err(DependabotListAlertsForEnterpriseError::Generic { code }),
            }
        }
    }

    /// ---
    ///
    /// # List Dependabot alerts for an organization
    ///
    /// Lists Dependabot alerts for an organization.
    /// 
    /// The authenticated user must be an owner or security manager for the organization to use this endpoint.
    /// 
    /// OAuth app tokens and personal access tokens (classic) need the `security_events` scope to use this endpoint. If this endpoint is only used with public repositories, the token can use the `public_repo` scope instead.
    /// 
    /// [GitHub API docs for list_alerts_for_org](https://docs.github.com/rest/dependabot/alerts#list-dependabot-alerts-for-an-organization)
    ///
    /// ---
    pub async fn list_alerts_for_org_async(&self, org: &str, query_params: Option<impl Into<DependabotListAlertsForOrgParams<'api>>>) -> Result<Vec<DependabotAlertWithRepository>, DependabotListAlertsForOrgError> {

        let mut request_uri = format!("{}/orgs/{}/dependabot/alerts", super::GITHUB_BASE_API_URL, org);

        if let Some(params) = query_params {
            request_uri.push_str("?");
            request_uri.push_str(&serde_urlencoded::to_string(params.into())?);
        }

        let req = GitHubRequest {
            uri: request_uri,
            body: None,
            method: "GET",
            headers: vec![]
        };

        let request = GitHubRequestBuilder::build(req, self.auth)?;

        // --

        let github_response = crate::adapters::fetch_async(request).await?;

        // --

        if github_response.is_success() {
            Ok(crate::adapters::to_json_async(github_response).await?)
        } else {
            match github_response.status_code() {
                304 => Err(DependabotListAlertsForOrgError::Status304),
                400 => Err(DependabotListAlertsForOrgError::Status400(crate::adapters::to_json_async(github_response).await?)),
                403 => Err(DependabotListAlertsForOrgError::Status403(crate::adapters::to_json_async(github_response).await?)),
                404 => Err(DependabotListAlertsForOrgError::Status404(crate::adapters::to_json_async(github_response).await?)),
                422 => Err(DependabotListAlertsForOrgError::Status422(crate::adapters::to_json_async(github_response).await?)),
                code => Err(DependabotListAlertsForOrgError::Generic { code }),
            }
        }
    }

    /// ---
    ///
    /// # List Dependabot alerts for an organization
    ///
    /// Lists Dependabot alerts for an organization.
    /// 
    /// The authenticated user must be an owner or security manager for the organization to use this endpoint.
    /// 
    /// OAuth app tokens and personal access tokens (classic) need the `security_events` scope to use this endpoint. If this endpoint is only used with public repositories, the token can use the `public_repo` scope instead.
    /// 
    /// [GitHub API docs for list_alerts_for_org](https://docs.github.com/rest/dependabot/alerts#list-dependabot-alerts-for-an-organization)
    ///
    /// ---
    #[cfg(not(target_arch = "wasm32"))]
    pub fn list_alerts_for_org(&self, org: &str, query_params: Option<impl Into<DependabotListAlertsForOrgParams<'api>>>) -> Result<Vec<DependabotAlertWithRepository>, DependabotListAlertsForOrgError> {

        let mut request_uri = format!("{}/orgs/{}/dependabot/alerts", super::GITHUB_BASE_API_URL, org);

        if let Some(params) = query_params {
            request_uri.push_str("?");
            let qp: DependabotListAlertsForOrgParams = params.into();
            request_uri.push_str(&serde_urlencoded::to_string(qp)?);
        }

        let req = GitHubRequest {
            uri: request_uri,
            body: None,
            method: "GET",
            headers: vec![]
        };

        let request = GitHubRequestBuilder::build(req, self.auth)?;

        // --

        let github_response = crate::adapters::fetch(request)?;

        // --

        if github_response.is_success() {
            Ok(crate::adapters::to_json(github_response)?)
        } else {
            match github_response.status_code() {
                304 => Err(DependabotListAlertsForOrgError::Status304),
                400 => Err(DependabotListAlertsForOrgError::Status400(crate::adapters::to_json(github_response)?)),
                403 => Err(DependabotListAlertsForOrgError::Status403(crate::adapters::to_json(github_response)?)),
                404 => Err(DependabotListAlertsForOrgError::Status404(crate::adapters::to_json(github_response)?)),
                422 => Err(DependabotListAlertsForOrgError::Status422(crate::adapters::to_json(github_response)?)),
                code => Err(DependabotListAlertsForOrgError::Generic { code }),
            }
        }
    }

    /// ---
    ///
    /// # List Dependabot alerts for a repository
    ///
    /// OAuth app tokens and personal access tokens (classic) need the `security_events` scope to use this endpoint. If this endpoint is only used with public repositories, the token can use the `public_repo` scope instead.
    /// 
    /// [GitHub API docs for list_alerts_for_repo](https://docs.github.com/rest/dependabot/alerts#list-dependabot-alerts-for-a-repository)
    ///
    /// ---
    pub async fn list_alerts_for_repo_async(&self, owner: &str, repo: &str, query_params: Option<impl Into<DependabotListAlertsForRepoParams<'api>>>) -> Result<Vec<DependabotAlert>, DependabotListAlertsForRepoError> {

        let mut request_uri = format!("{}/repos/{}/{}/dependabot/alerts", super::GITHUB_BASE_API_URL, owner, repo);

        if let Some(params) = query_params {
            request_uri.push_str("?");
            request_uri.push_str(&serde_urlencoded::to_string(params.into())?);
        }

        let req = GitHubRequest {
            uri: request_uri,
            body: None,
            method: "GET",
            headers: vec![]
        };

        let request = GitHubRequestBuilder::build(req, self.auth)?;

        // --

        let github_response = crate::adapters::fetch_async(request).await?;

        // --

        if github_response.is_success() {
            Ok(crate::adapters::to_json_async(github_response).await?)
        } else {
            match github_response.status_code() {
                304 => Err(DependabotListAlertsForRepoError::Status304),
                400 => Err(DependabotListAlertsForRepoError::Status400(crate::adapters::to_json_async(github_response).await?)),
                403 => Err(DependabotListAlertsForRepoError::Status403(crate::adapters::to_json_async(github_response).await?)),
                404 => Err(DependabotListAlertsForRepoError::Status404(crate::adapters::to_json_async(github_response).await?)),
                422 => Err(DependabotListAlertsForRepoError::Status422(crate::adapters::to_json_async(github_response).await?)),
                code => Err(DependabotListAlertsForRepoError::Generic { code }),
            }
        }
    }

    /// ---
    ///
    /// # List Dependabot alerts for a repository
    ///
    /// OAuth app tokens and personal access tokens (classic) need the `security_events` scope to use this endpoint. If this endpoint is only used with public repositories, the token can use the `public_repo` scope instead.
    /// 
    /// [GitHub API docs for list_alerts_for_repo](https://docs.github.com/rest/dependabot/alerts#list-dependabot-alerts-for-a-repository)
    ///
    /// ---
    #[cfg(not(target_arch = "wasm32"))]
    pub fn list_alerts_for_repo(&self, owner: &str, repo: &str, query_params: Option<impl Into<DependabotListAlertsForRepoParams<'api>>>) -> Result<Vec<DependabotAlert>, DependabotListAlertsForRepoError> {

        let mut request_uri = format!("{}/repos/{}/{}/dependabot/alerts", super::GITHUB_BASE_API_URL, owner, repo);

        if let Some(params) = query_params {
            request_uri.push_str("?");
            let qp: DependabotListAlertsForRepoParams = params.into();
            request_uri.push_str(&serde_urlencoded::to_string(qp)?);
        }

        let req = GitHubRequest {
            uri: request_uri,
            body: None,
            method: "GET",
            headers: vec![]
        };

        let request = GitHubRequestBuilder::build(req, self.auth)?;

        // --

        let github_response = crate::adapters::fetch(request)?;

        // --

        if github_response.is_success() {
            Ok(crate::adapters::to_json(github_response)?)
        } else {
            match github_response.status_code() {
                304 => Err(DependabotListAlertsForRepoError::Status304),
                400 => Err(DependabotListAlertsForRepoError::Status400(crate::adapters::to_json(github_response)?)),
                403 => Err(DependabotListAlertsForRepoError::Status403(crate::adapters::to_json(github_response)?)),
                404 => Err(DependabotListAlertsForRepoError::Status404(crate::adapters::to_json(github_response)?)),
                422 => Err(DependabotListAlertsForRepoError::Status422(crate::adapters::to_json(github_response)?)),
                code => Err(DependabotListAlertsForRepoError::Generic { code }),
            }
        }
    }

    /// ---
    ///
    /// # List organization secrets
    ///
    /// Lists all secrets available in an organization without revealing their
    /// encrypted values.
    /// 
    /// OAuth app tokens and personal access tokens (classic) need the `admin:org` scope to use this endpoint.
    /// 
    /// [GitHub API docs for list_org_secrets](https://docs.github.com/rest/dependabot/secrets#list-organization-secrets)
    ///
    /// ---
    pub async fn list_org_secrets_async(&self, org: &str, query_params: Option<impl Into<DependabotListOrgSecretsParams>>) -> Result<GetDependabotListOrgSecretsResponse200, DependabotListOrgSecretsError> {

        let mut request_uri = format!("{}/orgs/{}/dependabot/secrets", super::GITHUB_BASE_API_URL, org);

        if let Some(params) = query_params {
            request_uri.push_str("?");
            request_uri.push_str(&serde_urlencoded::to_string(params.into())?);
        }

        let req = GitHubRequest {
            uri: request_uri,
            body: None,
            method: "GET",
            headers: vec![]
        };

        let request = GitHubRequestBuilder::build(req, self.auth)?;

        // --

        let github_response = crate::adapters::fetch_async(request).await?;

        // --

        if github_response.is_success() {
            Ok(crate::adapters::to_json_async(github_response).await?)
        } else {
            match github_response.status_code() {
                code => Err(DependabotListOrgSecretsError::Generic { code }),
            }
        }
    }

    /// ---
    ///
    /// # List organization secrets
    ///
    /// Lists all secrets available in an organization without revealing their
    /// encrypted values.
    /// 
    /// OAuth app tokens and personal access tokens (classic) need the `admin:org` scope to use this endpoint.
    /// 
    /// [GitHub API docs for list_org_secrets](https://docs.github.com/rest/dependabot/secrets#list-organization-secrets)
    ///
    /// ---
    #[cfg(not(target_arch = "wasm32"))]
    pub fn list_org_secrets(&self, org: &str, query_params: Option<impl Into<DependabotListOrgSecretsParams>>) -> Result<GetDependabotListOrgSecretsResponse200, DependabotListOrgSecretsError> {

        let mut request_uri = format!("{}/orgs/{}/dependabot/secrets", super::GITHUB_BASE_API_URL, org);

        if let Some(params) = query_params {
            request_uri.push_str("?");
            let qp: DependabotListOrgSecretsParams = params.into();
            request_uri.push_str(&serde_urlencoded::to_string(qp)?);
        }

        let req = GitHubRequest {
            uri: request_uri,
            body: None,
            method: "GET",
            headers: vec![]
        };

        let request = GitHubRequestBuilder::build(req, self.auth)?;

        // --

        let github_response = crate::adapters::fetch(request)?;

        // --

        if github_response.is_success() {
            Ok(crate::adapters::to_json(github_response)?)
        } else {
            match github_response.status_code() {
                code => Err(DependabotListOrgSecretsError::Generic { code }),
            }
        }
    }

    /// ---
    ///
    /// # List repository secrets
    ///
    /// Lists all secrets available in a repository without revealing their encrypted
    /// values.
    /// 
    /// OAuth app tokens and personal access tokens (classic) need the `repo` scope to use this endpoint.
    /// 
    /// [GitHub API docs for list_repo_secrets](https://docs.github.com/rest/dependabot/secrets#list-repository-secrets)
    ///
    /// ---
    pub async fn list_repo_secrets_async(&self, owner: &str, repo: &str, query_params: Option<impl Into<DependabotListRepoSecretsParams>>) -> Result<GetDependabotListRepoSecretsResponse200, DependabotListRepoSecretsError> {

        let mut request_uri = format!("{}/repos/{}/{}/dependabot/secrets", super::GITHUB_BASE_API_URL, owner, repo);

        if let Some(params) = query_params {
            request_uri.push_str("?");
            request_uri.push_str(&serde_urlencoded::to_string(params.into())?);
        }

        let req = GitHubRequest {
            uri: request_uri,
            body: None,
            method: "GET",
            headers: vec![]
        };

        let request = GitHubRequestBuilder::build(req, self.auth)?;

        // --

        let github_response = crate::adapters::fetch_async(request).await?;

        // --

        if github_response.is_success() {
            Ok(crate::adapters::to_json_async(github_response).await?)
        } else {
            match github_response.status_code() {
                code => Err(DependabotListRepoSecretsError::Generic { code }),
            }
        }
    }

    /// ---
    ///
    /// # List repository secrets
    ///
    /// Lists all secrets available in a repository without revealing their encrypted
    /// values.
    /// 
    /// OAuth app tokens and personal access tokens (classic) need the `repo` scope to use this endpoint.
    /// 
    /// [GitHub API docs for list_repo_secrets](https://docs.github.com/rest/dependabot/secrets#list-repository-secrets)
    ///
    /// ---
    #[cfg(not(target_arch = "wasm32"))]
    pub fn list_repo_secrets(&self, owner: &str, repo: &str, query_params: Option<impl Into<DependabotListRepoSecretsParams>>) -> Result<GetDependabotListRepoSecretsResponse200, DependabotListRepoSecretsError> {

        let mut request_uri = format!("{}/repos/{}/{}/dependabot/secrets", super::GITHUB_BASE_API_URL, owner, repo);

        if let Some(params) = query_params {
            request_uri.push_str("?");
            let qp: DependabotListRepoSecretsParams = params.into();
            request_uri.push_str(&serde_urlencoded::to_string(qp)?);
        }

        let req = GitHubRequest {
            uri: request_uri,
            body: None,
            method: "GET",
            headers: vec![]
        };

        let request = GitHubRequestBuilder::build(req, self.auth)?;

        // --

        let github_response = crate::adapters::fetch(request)?;

        // --

        if github_response.is_success() {
            Ok(crate::adapters::to_json(github_response)?)
        } else {
            match github_response.status_code() {
                code => Err(DependabotListRepoSecretsError::Generic { code }),
            }
        }
    }

    /// ---
    ///
    /// # List selected repositories for an organization secret
    ///
    /// Lists all repositories that have been selected when the `visibility`
    /// for repository access to a secret is set to `selected`.
    /// 
    /// OAuth app tokens and personal access tokens (classic) need the `admin:org` scope to use this endpoint.
    /// 
    /// [GitHub API docs for list_selected_repos_for_org_secret](https://docs.github.com/rest/dependabot/secrets#list-selected-repositories-for-an-organization-secret)
    ///
    /// ---
    pub async fn list_selected_repos_for_org_secret_async(&self, org: &str, secret_name: &str, query_params: Option<impl Into<DependabotListSelectedReposForOrgSecretParams>>) -> Result<GetCodespacesListRepositoriesForSecretForAuthenticatedUserResponse200, DependabotListSelectedReposForOrgSecretError> {

        let mut request_uri = format!("{}/orgs/{}/dependabot/secrets/{}/repositories", super::GITHUB_BASE_API_URL, org, secret_name);

        if let Some(params) = query_params {
            request_uri.push_str("?");
            request_uri.push_str(&serde_urlencoded::to_string(params.into())?);
        }

        let req = GitHubRequest {
            uri: request_uri,
            body: None,
            method: "GET",
            headers: vec![]
        };

        let request = GitHubRequestBuilder::build(req, self.auth)?;

        // --

        let github_response = crate::adapters::fetch_async(request).await?;

        // --

        if github_response.is_success() {
            Ok(crate::adapters::to_json_async(github_response).await?)
        } else {
            match github_response.status_code() {
                code => Err(DependabotListSelectedReposForOrgSecretError::Generic { code }),
            }
        }
    }

    /// ---
    ///
    /// # List selected repositories for an organization secret
    ///
    /// Lists all repositories that have been selected when the `visibility`
    /// for repository access to a secret is set to `selected`.
    /// 
    /// OAuth app tokens and personal access tokens (classic) need the `admin:org` scope to use this endpoint.
    /// 
    /// [GitHub API docs for list_selected_repos_for_org_secret](https://docs.github.com/rest/dependabot/secrets#list-selected-repositories-for-an-organization-secret)
    ///
    /// ---
    #[cfg(not(target_arch = "wasm32"))]
    pub fn list_selected_repos_for_org_secret(&self, org: &str, secret_name: &str, query_params: Option<impl Into<DependabotListSelectedReposForOrgSecretParams>>) -> Result<GetCodespacesListRepositoriesForSecretForAuthenticatedUserResponse200, DependabotListSelectedReposForOrgSecretError> {

        let mut request_uri = format!("{}/orgs/{}/dependabot/secrets/{}/repositories", super::GITHUB_BASE_API_URL, org, secret_name);

        if let Some(params) = query_params {
            request_uri.push_str("?");
            let qp: DependabotListSelectedReposForOrgSecretParams = params.into();
            request_uri.push_str(&serde_urlencoded::to_string(qp)?);
        }

        let req = GitHubRequest {
            uri: request_uri,
            body: None,
            method: "GET",
            headers: vec![]
        };

        let request = GitHubRequestBuilder::build(req, self.auth)?;

        // --

        let github_response = crate::adapters::fetch(request)?;

        // --

        if github_response.is_success() {
            Ok(crate::adapters::to_json(github_response)?)
        } else {
            match github_response.status_code() {
                code => Err(DependabotListSelectedReposForOrgSecretError::Generic { code }),
            }
        }
    }

    /// ---
    ///
    /// # Remove selected repository from an organization secret
    ///
    /// Removes a repository from an organization secret when the `visibility`
    /// for repository access is set to `selected`. The visibility is set when you [Create
    /// or update an organization secret](https://docs.github.com/rest/dependabot/secrets#create-or-update-an-organization-secret).
    /// 
    /// OAuth app tokens and personal access tokens (classic) need the `admin:org` scope to use this endpoint.
    /// 
    /// [GitHub API docs for remove_selected_repo_from_org_secret](https://docs.github.com/rest/dependabot/secrets#remove-selected-repository-from-an-organization-secret)
    ///
    /// ---
    pub async fn remove_selected_repo_from_org_secret_async(&self, org: &str, secret_name: &str, repository_id: i32) -> Result<(), DependabotRemoveSelectedRepoFromOrgSecretError> {

        let request_uri = format!("{}/orgs/{}/dependabot/secrets/{}/repositories/{}", super::GITHUB_BASE_API_URL, org, secret_name, repository_id);


        let req = GitHubRequest {
            uri: request_uri,
            body: None,
            method: "DELETE",
            headers: vec![]
        };

        let request = GitHubRequestBuilder::build(req, self.auth)?;

        // --

        let github_response = crate::adapters::fetch_async(request).await?;

        // --

        if github_response.is_success() {
            Ok(crate::adapters::to_json_async(github_response).await?)
        } else {
            match github_response.status_code() {
                409 => Err(DependabotRemoveSelectedRepoFromOrgSecretError::Status409),
                code => Err(DependabotRemoveSelectedRepoFromOrgSecretError::Generic { code }),
            }
        }
    }

    /// ---
    ///
    /// # Remove selected repository from an organization secret
    ///
    /// Removes a repository from an organization secret when the `visibility`
    /// for repository access is set to `selected`. The visibility is set when you [Create
    /// or update an organization secret](https://docs.github.com/rest/dependabot/secrets#create-or-update-an-organization-secret).
    /// 
    /// OAuth app tokens and personal access tokens (classic) need the `admin:org` scope to use this endpoint.
    /// 
    /// [GitHub API docs for remove_selected_repo_from_org_secret](https://docs.github.com/rest/dependabot/secrets#remove-selected-repository-from-an-organization-secret)
    ///
    /// ---
    #[cfg(not(target_arch = "wasm32"))]
    pub fn remove_selected_repo_from_org_secret(&self, org: &str, secret_name: &str, repository_id: i32) -> Result<(), DependabotRemoveSelectedRepoFromOrgSecretError> {

        let request_uri = format!("{}/orgs/{}/dependabot/secrets/{}/repositories/{}", super::GITHUB_BASE_API_URL, org, secret_name, repository_id);


        let req = GitHubRequest {
            uri: request_uri,
            body: None,
            method: "DELETE",
            headers: vec![]
        };

        let request = GitHubRequestBuilder::build(req, self.auth)?;

        // --

        let github_response = crate::adapters::fetch(request)?;

        // --

        if github_response.is_success() {
            Ok(crate::adapters::to_json(github_response)?)
        } else {
            match github_response.status_code() {
                409 => Err(DependabotRemoveSelectedRepoFromOrgSecretError::Status409),
                code => Err(DependabotRemoveSelectedRepoFromOrgSecretError::Generic { code }),
            }
        }
    }

    /// ---
    ///
    /// # Set selected repositories for an organization secret
    ///
    /// Replaces all repositories for an organization secret when the `visibility`
    /// for repository access is set to `selected`. The visibility is set when you [Create
    /// or update an organization secret](https://docs.github.com/rest/dependabot/secrets#create-or-update-an-organization-secret).
    /// 
    /// OAuth app tokens and personal access tokens (classic) need the `admin:org` scope to use this endpoint.
    /// 
    /// [GitHub API docs for set_selected_repos_for_org_secret](https://docs.github.com/rest/dependabot/secrets#set-selected-repositories-for-an-organization-secret)
    ///
    /// ---
    pub async fn set_selected_repos_for_org_secret_async(&self, org: &str, secret_name: &str, body: PutDependabotSetSelectedReposForOrgSecret) -> Result<(), DependabotSetSelectedReposForOrgSecretError> {

        let request_uri = format!("{}/orgs/{}/dependabot/secrets/{}/repositories", super::GITHUB_BASE_API_URL, org, secret_name);


        let req = GitHubRequest {
            uri: request_uri,
            body: Some(PutDependabotSetSelectedReposForOrgSecret::from_json(body)?),
            method: "PUT",
            headers: vec![]
        };

        let request = GitHubRequestBuilder::build(req, self.auth)?;

        // --

        let github_response = crate::adapters::fetch_async(request).await?;

        // --

        if github_response.is_success() {
            Ok(crate::adapters::to_json_async(github_response).await?)
        } else {
            match github_response.status_code() {
                code => Err(DependabotSetSelectedReposForOrgSecretError::Generic { code }),
            }
        }
    }

    /// ---
    ///
    /// # Set selected repositories for an organization secret
    ///
    /// Replaces all repositories for an organization secret when the `visibility`
    /// for repository access is set to `selected`. The visibility is set when you [Create
    /// or update an organization secret](https://docs.github.com/rest/dependabot/secrets#create-or-update-an-organization-secret).
    /// 
    /// OAuth app tokens and personal access tokens (classic) need the `admin:org` scope to use this endpoint.
    /// 
    /// [GitHub API docs for set_selected_repos_for_org_secret](https://docs.github.com/rest/dependabot/secrets#set-selected-repositories-for-an-organization-secret)
    ///
    /// ---
    #[cfg(not(target_arch = "wasm32"))]
    pub fn set_selected_repos_for_org_secret(&self, org: &str, secret_name: &str, body: PutDependabotSetSelectedReposForOrgSecret) -> Result<(), DependabotSetSelectedReposForOrgSecretError> {

        let request_uri = format!("{}/orgs/{}/dependabot/secrets/{}/repositories", super::GITHUB_BASE_API_URL, org, secret_name);


        let req = GitHubRequest {
            uri: request_uri,
            body: Some(PutDependabotSetSelectedReposForOrgSecret::from_json(body)?),
            method: "PUT",
            headers: vec![]
        };

        let request = GitHubRequestBuilder::build(req, self.auth)?;

        // --

        let github_response = crate::adapters::fetch(request)?;

        // --

        if github_response.is_success() {
            Ok(crate::adapters::to_json(github_response)?)
        } else {
            match github_response.status_code() {
                code => Err(DependabotSetSelectedReposForOrgSecretError::Generic { code }),
            }
        }
    }

    /// ---
    ///
    /// # Update a Dependabot alert
    ///
    /// The authenticated user must have access to security alerts for the repository to use this endpoint. For more information, see "[Granting access to security alerts](https://docs.github.com/repositories/managing-your-repositorys-settings-and-features/enabling-features-for-your-repository/managing-security-and-analysis-settings-for-your-repository#granting-access-to-security-alerts)."
    /// 
    /// OAuth app tokens and personal access tokens (classic) need the `security_events` scope to use this endpoint. If this endpoint is only used with public repositories, the token can use the `public_repo` scope instead.
    /// 
    /// [GitHub API docs for update_alert](https://docs.github.com/rest/dependabot/alerts#update-a-dependabot-alert)
    ///
    /// ---
    pub async fn update_alert_async(&self, owner: &str, repo: &str, alert_number: AlertNumber, body: PatchDependabotUpdateAlert) -> Result<DependabotAlert, DependabotUpdateAlertError> {

        let request_uri = format!("{}/repos/{}/{}/dependabot/alerts/{}", super::GITHUB_BASE_API_URL, owner, repo, alert_number);


        let req = GitHubRequest {
            uri: request_uri,
            body: Some(PatchDependabotUpdateAlert::from_json(body)?),
            method: "PATCH",
            headers: vec![]
        };

        let request = GitHubRequestBuilder::build(req, self.auth)?;

        // --

        let github_response = crate::adapters::fetch_async(request).await?;

        // --

        if github_response.is_success() {
            Ok(crate::adapters::to_json_async(github_response).await?)
        } else {
            match github_response.status_code() {
                400 => Err(DependabotUpdateAlertError::Status400(crate::adapters::to_json_async(github_response).await?)),
                403 => Err(DependabotUpdateAlertError::Status403(crate::adapters::to_json_async(github_response).await?)),
                404 => Err(DependabotUpdateAlertError::Status404(crate::adapters::to_json_async(github_response).await?)),
                409 => Err(DependabotUpdateAlertError::Status409(crate::adapters::to_json_async(github_response).await?)),
                422 => Err(DependabotUpdateAlertError::Status422(crate::adapters::to_json_async(github_response).await?)),
                code => Err(DependabotUpdateAlertError::Generic { code }),
            }
        }
    }

    /// ---
    ///
    /// # Update a Dependabot alert
    ///
    /// The authenticated user must have access to security alerts for the repository to use this endpoint. For more information, see "[Granting access to security alerts](https://docs.github.com/repositories/managing-your-repositorys-settings-and-features/enabling-features-for-your-repository/managing-security-and-analysis-settings-for-your-repository#granting-access-to-security-alerts)."
    /// 
    /// OAuth app tokens and personal access tokens (classic) need the `security_events` scope to use this endpoint. If this endpoint is only used with public repositories, the token can use the `public_repo` scope instead.
    /// 
    /// [GitHub API docs for update_alert](https://docs.github.com/rest/dependabot/alerts#update-a-dependabot-alert)
    ///
    /// ---
    #[cfg(not(target_arch = "wasm32"))]
    pub fn update_alert(&self, owner: &str, repo: &str, alert_number: AlertNumber, body: PatchDependabotUpdateAlert) -> Result<DependabotAlert, DependabotUpdateAlertError> {

        let request_uri = format!("{}/repos/{}/{}/dependabot/alerts/{}", super::GITHUB_BASE_API_URL, owner, repo, alert_number);


        let req = GitHubRequest {
            uri: request_uri,
            body: Some(PatchDependabotUpdateAlert::from_json(body)?),
            method: "PATCH",
            headers: vec![]
        };

        let request = GitHubRequestBuilder::build(req, self.auth)?;

        // --

        let github_response = crate::adapters::fetch(request)?;

        // --

        if github_response.is_success() {
            Ok(crate::adapters::to_json(github_response)?)
        } else {
            match github_response.status_code() {
                400 => Err(DependabotUpdateAlertError::Status400(crate::adapters::to_json(github_response)?)),
                403 => Err(DependabotUpdateAlertError::Status403(crate::adapters::to_json(github_response)?)),
                404 => Err(DependabotUpdateAlertError::Status404(crate::adapters::to_json(github_response)?)),
                409 => Err(DependabotUpdateAlertError::Status409(crate::adapters::to_json(github_response)?)),
                422 => Err(DependabotUpdateAlertError::Status422(crate::adapters::to_json(github_response)?)),
                code => Err(DependabotUpdateAlertError::Generic { code }),
            }
        }
    }

}
