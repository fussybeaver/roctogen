//! Method, error and parameter types for the Gists endpoint.
#![allow(
    clippy::all
)]
/* 
 * GitHub v3 REST API
 *
 * GitHub's v3 REST API.
 *
 * OpenAPI spec version: 1.1.4
 * 
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 */

use serde::Deserialize;

use crate::adapters::{AdapterError, Client, GitHubRequest, GitHubResponseExt};
use crate::models::*;

use super::PerPage;

use std::collections::HashMap;
use serde_json::value::Value;

pub struct Gists<'api, C: Client> where AdapterError: From<<C as Client>::Err> {
    client: &'api C
}

pub fn new<C: Client>(client: &C) -> Gists<C> where AdapterError: From<<C as Client>::Err> {
    Gists { client }
}

/// Errors for the [Check if a gist is starred](Gists::check_is_starred_async()) endpoint.
#[derive(Debug, thiserror::Error)]
pub enum GistsCheckIsStarredError {
    #[error("Not Found if gist is not starred")]
    Status404(HashMap<String, Value>),
    #[error("Not modified")]
    Status304,
    #[error("Forbidden")]
    Status403(BasicError),
    #[error("Status code: {}", code)]
    Generic { code: u16 },
}

impl From<GistsCheckIsStarredError> for AdapterError {
    fn from(err: GistsCheckIsStarredError) -> Self {
        let (description, status_code) = match err {
            GistsCheckIsStarredError::Status404(_) => (String::from("Not Found if gist is not starred"), 404),
            GistsCheckIsStarredError::Status304 => (String::from("Not modified"), 304),
            GistsCheckIsStarredError::Status403(_) => (String::from("Forbidden"), 403),
            GistsCheckIsStarredError::Generic { code } => (String::from("Generic"), code)
        };

        Self::Endpoint {
            description,
            status_code,
            source: Some(Box::new(err))
        }
    }
}

/// Errors for the [Create a gist](Gists::create_async()) endpoint.
#[derive(Debug, thiserror::Error)]
pub enum GistsCreateError {
    #[error("Validation failed, or the endpoint has been spammed.")]
    Status422(ValidationError),
    #[error("Not modified")]
    Status304,
    #[error("Resource not found")]
    Status404(BasicError),
    #[error("Forbidden")]
    Status403(BasicError),
    #[error("Status code: {}", code)]
    Generic { code: u16 },
}

impl From<GistsCreateError> for AdapterError {
    fn from(err: GistsCreateError) -> Self {
        let (description, status_code) = match err {
            GistsCreateError::Status422(_) => (String::from("Validation failed, or the endpoint has been spammed."), 422),
            GistsCreateError::Status304 => (String::from("Not modified"), 304),
            GistsCreateError::Status404(_) => (String::from("Resource not found"), 404),
            GistsCreateError::Status403(_) => (String::from("Forbidden"), 403),
            GistsCreateError::Generic { code } => (String::from("Generic"), code)
        };

        Self::Endpoint {
            description,
            status_code,
            source: Some(Box::new(err))
        }
    }
}

/// Errors for the [Create a gist comment](Gists::create_comment_async()) endpoint.
#[derive(Debug, thiserror::Error)]
pub enum GistsCreateCommentError {
    #[error("Not modified")]
    Status304,
    #[error("Resource not found")]
    Status404(BasicError),
    #[error("Forbidden")]
    Status403(BasicError),
    #[error("Status code: {}", code)]
    Generic { code: u16 },
}

impl From<GistsCreateCommentError> for AdapterError {
    fn from(err: GistsCreateCommentError) -> Self {
        let (description, status_code) = match err {
            GistsCreateCommentError::Status304 => (String::from("Not modified"), 304),
            GistsCreateCommentError::Status404(_) => (String::from("Resource not found"), 404),
            GistsCreateCommentError::Status403(_) => (String::from("Forbidden"), 403),
            GistsCreateCommentError::Generic { code } => (String::from("Generic"), code)
        };

        Self::Endpoint {
            description,
            status_code,
            source: Some(Box::new(err))
        }
    }
}

/// Errors for the [Delete a gist](Gists::delete_async()) endpoint.
#[derive(Debug, thiserror::Error)]
pub enum GistsDeleteError {
    #[error("Resource not found")]
    Status404(BasicError),
    #[error("Not modified")]
    Status304,
    #[error("Forbidden")]
    Status403(BasicError),
    #[error("Status code: {}", code)]
    Generic { code: u16 },
}

impl From<GistsDeleteError> for AdapterError {
    fn from(err: GistsDeleteError) -> Self {
        let (description, status_code) = match err {
            GistsDeleteError::Status404(_) => (String::from("Resource not found"), 404),
            GistsDeleteError::Status304 => (String::from("Not modified"), 304),
            GistsDeleteError::Status403(_) => (String::from("Forbidden"), 403),
            GistsDeleteError::Generic { code } => (String::from("Generic"), code)
        };

        Self::Endpoint {
            description,
            status_code,
            source: Some(Box::new(err))
        }
    }
}

/// Errors for the [Delete a gist comment](Gists::delete_comment_async()) endpoint.
#[derive(Debug, thiserror::Error)]
pub enum GistsDeleteCommentError {
    #[error("Not modified")]
    Status304,
    #[error("Resource not found")]
    Status404(BasicError),
    #[error("Forbidden")]
    Status403(BasicError),
    #[error("Status code: {}", code)]
    Generic { code: u16 },
}

impl From<GistsDeleteCommentError> for AdapterError {
    fn from(err: GistsDeleteCommentError) -> Self {
        let (description, status_code) = match err {
            GistsDeleteCommentError::Status304 => (String::from("Not modified"), 304),
            GistsDeleteCommentError::Status404(_) => (String::from("Resource not found"), 404),
            GistsDeleteCommentError::Status403(_) => (String::from("Forbidden"), 403),
            GistsDeleteCommentError::Generic { code } => (String::from("Generic"), code)
        };

        Self::Endpoint {
            description,
            status_code,
            source: Some(Box::new(err))
        }
    }
}

/// Errors for the [Fork a gist](Gists::fork_async()) endpoint.
#[derive(Debug, thiserror::Error)]
pub enum GistsForkError {
    #[error("Resource not found")]
    Status404(BasicError),
    #[error("Validation failed, or the endpoint has been spammed.")]
    Status422(ValidationError),
    #[error("Not modified")]
    Status304,
    #[error("Forbidden")]
    Status403(BasicError),
    #[error("Status code: {}", code)]
    Generic { code: u16 },
}

impl From<GistsForkError> for AdapterError {
    fn from(err: GistsForkError) -> Self {
        let (description, status_code) = match err {
            GistsForkError::Status404(_) => (String::from("Resource not found"), 404),
            GistsForkError::Status422(_) => (String::from("Validation failed, or the endpoint has been spammed."), 422),
            GistsForkError::Status304 => (String::from("Not modified"), 304),
            GistsForkError::Status403(_) => (String::from("Forbidden"), 403),
            GistsForkError::Generic { code } => (String::from("Generic"), code)
        };

        Self::Endpoint {
            description,
            status_code,
            source: Some(Box::new(err))
        }
    }
}

/// Errors for the [Get a gist](Gists::get_async()) endpoint.
#[derive(Debug, thiserror::Error)]
pub enum GistsGetError {
    #[error("Forbidden Gist")]
    Status403(GetGistsGetCommentResponse403),
    #[error("Resource not found")]
    Status404(BasicError),
    #[error("Not modified")]
    Status304,
    #[error("Status code: {}", code)]
    Generic { code: u16 },
}

impl From<GistsGetError> for AdapterError {
    fn from(err: GistsGetError) -> Self {
        let (description, status_code) = match err {
            GistsGetError::Status403(_) => (String::from("Forbidden Gist"), 403),
            GistsGetError::Status404(_) => (String::from("Resource not found"), 404),
            GistsGetError::Status304 => (String::from("Not modified"), 304),
            GistsGetError::Generic { code } => (String::from("Generic"), code)
        };

        Self::Endpoint {
            description,
            status_code,
            source: Some(Box::new(err))
        }
    }
}

/// Errors for the [Get a gist comment](Gists::get_comment_async()) endpoint.
#[derive(Debug, thiserror::Error)]
pub enum GistsGetCommentError {
    #[error("Not modified")]
    Status304,
    #[error("Resource not found")]
    Status404(BasicError),
    #[error("Forbidden Gist")]
    Status403(GetGistsGetCommentResponse403),
    #[error("Status code: {}", code)]
    Generic { code: u16 },
}

impl From<GistsGetCommentError> for AdapterError {
    fn from(err: GistsGetCommentError) -> Self {
        let (description, status_code) = match err {
            GistsGetCommentError::Status304 => (String::from("Not modified"), 304),
            GistsGetCommentError::Status404(_) => (String::from("Resource not found"), 404),
            GistsGetCommentError::Status403(_) => (String::from("Forbidden Gist"), 403),
            GistsGetCommentError::Generic { code } => (String::from("Generic"), code)
        };

        Self::Endpoint {
            description,
            status_code,
            source: Some(Box::new(err))
        }
    }
}

/// Errors for the [Get a gist revision](Gists::get_revision_async()) endpoint.
#[derive(Debug, thiserror::Error)]
pub enum GistsGetRevisionError {
    #[error("Validation failed, or the endpoint has been spammed.")]
    Status422(ValidationError),
    #[error("Resource not found")]
    Status404(BasicError),
    #[error("Forbidden")]
    Status403(BasicError),
    #[error("Status code: {}", code)]
    Generic { code: u16 },
}

impl From<GistsGetRevisionError> for AdapterError {
    fn from(err: GistsGetRevisionError) -> Self {
        let (description, status_code) = match err {
            GistsGetRevisionError::Status422(_) => (String::from("Validation failed, or the endpoint has been spammed."), 422),
            GistsGetRevisionError::Status404(_) => (String::from("Resource not found"), 404),
            GistsGetRevisionError::Status403(_) => (String::from("Forbidden"), 403),
            GistsGetRevisionError::Generic { code } => (String::from("Generic"), code)
        };

        Self::Endpoint {
            description,
            status_code,
            source: Some(Box::new(err))
        }
    }
}

/// Errors for the [List gists for the authenticated user](Gists::list_async()) endpoint.
#[derive(Debug, thiserror::Error)]
pub enum GistsListError {
    #[error("Not modified")]
    Status304,
    #[error("Forbidden")]
    Status403(BasicError),
    #[error("Status code: {}", code)]
    Generic { code: u16 },
}

impl From<GistsListError> for AdapterError {
    fn from(err: GistsListError) -> Self {
        let (description, status_code) = match err {
            GistsListError::Status304 => (String::from("Not modified"), 304),
            GistsListError::Status403(_) => (String::from("Forbidden"), 403),
            GistsListError::Generic { code } => (String::from("Generic"), code)
        };

        Self::Endpoint {
            description,
            status_code,
            source: Some(Box::new(err))
        }
    }
}

/// Errors for the [List gist comments](Gists::list_comments_async()) endpoint.
#[derive(Debug, thiserror::Error)]
pub enum GistsListCommentsError {
    #[error("Not modified")]
    Status304,
    #[error("Resource not found")]
    Status404(BasicError),
    #[error("Forbidden")]
    Status403(BasicError),
    #[error("Status code: {}", code)]
    Generic { code: u16 },
}

impl From<GistsListCommentsError> for AdapterError {
    fn from(err: GistsListCommentsError) -> Self {
        let (description, status_code) = match err {
            GistsListCommentsError::Status304 => (String::from("Not modified"), 304),
            GistsListCommentsError::Status404(_) => (String::from("Resource not found"), 404),
            GistsListCommentsError::Status403(_) => (String::from("Forbidden"), 403),
            GistsListCommentsError::Generic { code } => (String::from("Generic"), code)
        };

        Self::Endpoint {
            description,
            status_code,
            source: Some(Box::new(err))
        }
    }
}

/// Errors for the [List gist commits](Gists::list_commits_async()) endpoint.
#[derive(Debug, thiserror::Error)]
pub enum GistsListCommitsError {
    #[error("Resource not found")]
    Status404(BasicError),
    #[error("Not modified")]
    Status304,
    #[error("Forbidden")]
    Status403(BasicError),
    #[error("Status code: {}", code)]
    Generic { code: u16 },
}

impl From<GistsListCommitsError> for AdapterError {
    fn from(err: GistsListCommitsError) -> Self {
        let (description, status_code) = match err {
            GistsListCommitsError::Status404(_) => (String::from("Resource not found"), 404),
            GistsListCommitsError::Status304 => (String::from("Not modified"), 304),
            GistsListCommitsError::Status403(_) => (String::from("Forbidden"), 403),
            GistsListCommitsError::Generic { code } => (String::from("Generic"), code)
        };

        Self::Endpoint {
            description,
            status_code,
            source: Some(Box::new(err))
        }
    }
}

/// Errors for the [List gists for a user](Gists::list_for_user_async()) endpoint.
#[derive(Debug, thiserror::Error)]
pub enum GistsListForUserError {
    #[error("Validation failed, or the endpoint has been spammed.")]
    Status422(ValidationError),
    #[error("Status code: {}", code)]
    Generic { code: u16 },
}

impl From<GistsListForUserError> for AdapterError {
    fn from(err: GistsListForUserError) -> Self {
        let (description, status_code) = match err {
            GistsListForUserError::Status422(_) => (String::from("Validation failed, or the endpoint has been spammed."), 422),
            GistsListForUserError::Generic { code } => (String::from("Generic"), code)
        };

        Self::Endpoint {
            description,
            status_code,
            source: Some(Box::new(err))
        }
    }
}

/// Errors for the [List gist forks](Gists::list_forks_async()) endpoint.
#[derive(Debug, thiserror::Error)]
pub enum GistsListForksError {
    #[error("Resource not found")]
    Status404(BasicError),
    #[error("Not modified")]
    Status304,
    #[error("Forbidden")]
    Status403(BasicError),
    #[error("Status code: {}", code)]
    Generic { code: u16 },
}

impl From<GistsListForksError> for AdapterError {
    fn from(err: GistsListForksError) -> Self {
        let (description, status_code) = match err {
            GistsListForksError::Status404(_) => (String::from("Resource not found"), 404),
            GistsListForksError::Status304 => (String::from("Not modified"), 304),
            GistsListForksError::Status403(_) => (String::from("Forbidden"), 403),
            GistsListForksError::Generic { code } => (String::from("Generic"), code)
        };

        Self::Endpoint {
            description,
            status_code,
            source: Some(Box::new(err))
        }
    }
}

/// Errors for the [List public gists](Gists::list_public_async()) endpoint.
#[derive(Debug, thiserror::Error)]
pub enum GistsListPublicError {
    #[error("Validation failed, or the endpoint has been spammed.")]
    Status422(ValidationError),
    #[error("Not modified")]
    Status304,
    #[error("Forbidden")]
    Status403(BasicError),
    #[error("Status code: {}", code)]
    Generic { code: u16 },
}

impl From<GistsListPublicError> for AdapterError {
    fn from(err: GistsListPublicError) -> Self {
        let (description, status_code) = match err {
            GistsListPublicError::Status422(_) => (String::from("Validation failed, or the endpoint has been spammed."), 422),
            GistsListPublicError::Status304 => (String::from("Not modified"), 304),
            GistsListPublicError::Status403(_) => (String::from("Forbidden"), 403),
            GistsListPublicError::Generic { code } => (String::from("Generic"), code)
        };

        Self::Endpoint {
            description,
            status_code,
            source: Some(Box::new(err))
        }
    }
}

/// Errors for the [List starred gists](Gists::list_starred_async()) endpoint.
#[derive(Debug, thiserror::Error)]
pub enum GistsListStarredError {
    #[error("Requires authentication")]
    Status401(BasicError),
    #[error("Not modified")]
    Status304,
    #[error("Forbidden")]
    Status403(BasicError),
    #[error("Status code: {}", code)]
    Generic { code: u16 },
}

impl From<GistsListStarredError> for AdapterError {
    fn from(err: GistsListStarredError) -> Self {
        let (description, status_code) = match err {
            GistsListStarredError::Status401(_) => (String::from("Requires authentication"), 401),
            GistsListStarredError::Status304 => (String::from("Not modified"), 304),
            GistsListStarredError::Status403(_) => (String::from("Forbidden"), 403),
            GistsListStarredError::Generic { code } => (String::from("Generic"), code)
        };

        Self::Endpoint {
            description,
            status_code,
            source: Some(Box::new(err))
        }
    }
}

/// Errors for the [Star a gist](Gists::star_async()) endpoint.
#[derive(Debug, thiserror::Error)]
pub enum GistsStarError {
    #[error("Resource not found")]
    Status404(BasicError),
    #[error("Not modified")]
    Status304,
    #[error("Forbidden")]
    Status403(BasicError),
    #[error("Status code: {}", code)]
    Generic { code: u16 },
}

impl From<GistsStarError> for AdapterError {
    fn from(err: GistsStarError) -> Self {
        let (description, status_code) = match err {
            GistsStarError::Status404(_) => (String::from("Resource not found"), 404),
            GistsStarError::Status304 => (String::from("Not modified"), 304),
            GistsStarError::Status403(_) => (String::from("Forbidden"), 403),
            GistsStarError::Generic { code } => (String::from("Generic"), code)
        };

        Self::Endpoint {
            description,
            status_code,
            source: Some(Box::new(err))
        }
    }
}

/// Errors for the [Unstar a gist](Gists::unstar_async()) endpoint.
#[derive(Debug, thiserror::Error)]
pub enum GistsUnstarError {
    #[error("Not modified")]
    Status304,
    #[error("Resource not found")]
    Status404(BasicError),
    #[error("Forbidden")]
    Status403(BasicError),
    #[error("Status code: {}", code)]
    Generic { code: u16 },
}

impl From<GistsUnstarError> for AdapterError {
    fn from(err: GistsUnstarError) -> Self {
        let (description, status_code) = match err {
            GistsUnstarError::Status304 => (String::from("Not modified"), 304),
            GistsUnstarError::Status404(_) => (String::from("Resource not found"), 404),
            GistsUnstarError::Status403(_) => (String::from("Forbidden"), 403),
            GistsUnstarError::Generic { code } => (String::from("Generic"), code)
        };

        Self::Endpoint {
            description,
            status_code,
            source: Some(Box::new(err))
        }
    }
}

/// Errors for the [Update a gist](Gists::update_async()) endpoint.
#[derive(Debug, thiserror::Error)]
pub enum GistsUpdateError {
    #[error("Validation failed, or the endpoint has been spammed.")]
    Status422(ValidationError),
    #[error("Resource not found")]
    Status404(BasicError),
    #[error("Status code: {}", code)]
    Generic { code: u16 },
}

impl From<GistsUpdateError> for AdapterError {
    fn from(err: GistsUpdateError) -> Self {
        let (description, status_code) = match err {
            GistsUpdateError::Status422(_) => (String::from("Validation failed, or the endpoint has been spammed."), 422),
            GistsUpdateError::Status404(_) => (String::from("Resource not found"), 404),
            GistsUpdateError::Generic { code } => (String::from("Generic"), code)
        };

        Self::Endpoint {
            description,
            status_code,
            source: Some(Box::new(err))
        }
    }
}

/// Errors for the [Update a gist comment](Gists::update_comment_async()) endpoint.
#[derive(Debug, thiserror::Error)]
pub enum GistsUpdateCommentError {
    #[error("Resource not found")]
    Status404(BasicError),
    #[error("Status code: {}", code)]
    Generic { code: u16 },
}

impl From<GistsUpdateCommentError> for AdapterError {
    fn from(err: GistsUpdateCommentError) -> Self {
        let (description, status_code) = match err {
            GistsUpdateCommentError::Status404(_) => (String::from("Resource not found"), 404),
            GistsUpdateCommentError::Generic { code } => (String::from("Generic"), code)
        };

        Self::Endpoint {
            description,
            status_code,
            source: Some(Box::new(err))
        }
    }
}


/// Query parameters for the [List gists for the authenticated user](Gists::list_async()) endpoint.
#[derive(Default, Serialize)]
pub struct GistsListParams {
    /// Only show results that were last updated after the given time. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.
    since: Option<chrono::DateTime<chrono::Utc>>, 
    /// The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    per_page: Option<u16>, 
    /// The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    page: Option<u16>
}

impl GistsListParams {
    pub fn new() -> Self {
        Self::default()
    }

    /// Only show results that were last updated after the given time. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.
    pub fn since(self, since: chrono::DateTime<chrono::Utc>) -> Self {
        Self {
            since: Some(since),
            per_page: self.per_page, 
            page: self.page, 
        }
    }

    /// The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    pub fn per_page(self, per_page: u16) -> Self {
        Self {
            since: self.since, 
            per_page: Some(per_page),
            page: self.page, 
        }
    }

    /// The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    pub fn page(self, page: u16) -> Self {
        Self {
            since: self.since, 
            per_page: self.per_page, 
            page: Some(page),
        }
    }
}

impl<'enc> From<&'enc PerPage> for GistsListParams {
    fn from(per_page: &'enc PerPage) -> Self {
        Self {
            per_page: Some(per_page.per_page),
            page: Some(per_page.page),
            ..Default::default()
        }
    }
}
/// Query parameters for the [List gist comments](Gists::list_comments_async()) endpoint.
#[derive(Default, Serialize)]
pub struct GistsListCommentsParams {
    /// The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    per_page: Option<u16>, 
    /// The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    page: Option<u16>
}

impl GistsListCommentsParams {
    pub fn new() -> Self {
        Self::default()
    }

    /// The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    pub fn per_page(self, per_page: u16) -> Self {
        Self {
            per_page: Some(per_page),
            page: self.page, 
        }
    }

    /// The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    pub fn page(self, page: u16) -> Self {
        Self {
            per_page: self.per_page, 
            page: Some(page),
        }
    }
}

impl<'enc> From<&'enc PerPage> for GistsListCommentsParams {
    fn from(per_page: &'enc PerPage) -> Self {
        Self {
            per_page: Some(per_page.per_page),
            page: Some(per_page.page),
            ..Default::default()
        }
    }
}
/// Query parameters for the [List gist commits](Gists::list_commits_async()) endpoint.
#[derive(Default, Serialize)]
pub struct GistsListCommitsParams {
    /// The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    per_page: Option<u16>, 
    /// The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    page: Option<u16>
}

impl GistsListCommitsParams {
    pub fn new() -> Self {
        Self::default()
    }

    /// The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    pub fn per_page(self, per_page: u16) -> Self {
        Self {
            per_page: Some(per_page),
            page: self.page, 
        }
    }

    /// The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    pub fn page(self, page: u16) -> Self {
        Self {
            per_page: self.per_page, 
            page: Some(page),
        }
    }
}

impl<'enc> From<&'enc PerPage> for GistsListCommitsParams {
    fn from(per_page: &'enc PerPage) -> Self {
        Self {
            per_page: Some(per_page.per_page),
            page: Some(per_page.page),
            ..Default::default()
        }
    }
}
/// Query parameters for the [List gists for a user](Gists::list_for_user_async()) endpoint.
#[derive(Default, Serialize)]
pub struct GistsListForUserParams {
    /// Only show results that were last updated after the given time. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.
    since: Option<chrono::DateTime<chrono::Utc>>, 
    /// The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    per_page: Option<u16>, 
    /// The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    page: Option<u16>
}

impl GistsListForUserParams {
    pub fn new() -> Self {
        Self::default()
    }

    /// Only show results that were last updated after the given time. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.
    pub fn since(self, since: chrono::DateTime<chrono::Utc>) -> Self {
        Self {
            since: Some(since),
            per_page: self.per_page, 
            page: self.page, 
        }
    }

    /// The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    pub fn per_page(self, per_page: u16) -> Self {
        Self {
            since: self.since, 
            per_page: Some(per_page),
            page: self.page, 
        }
    }

    /// The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    pub fn page(self, page: u16) -> Self {
        Self {
            since: self.since, 
            per_page: self.per_page, 
            page: Some(page),
        }
    }
}

impl<'enc> From<&'enc PerPage> for GistsListForUserParams {
    fn from(per_page: &'enc PerPage) -> Self {
        Self {
            per_page: Some(per_page.per_page),
            page: Some(per_page.page),
            ..Default::default()
        }
    }
}
/// Query parameters for the [List gist forks](Gists::list_forks_async()) endpoint.
#[derive(Default, Serialize)]
pub struct GistsListForksParams {
    /// The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    per_page: Option<u16>, 
    /// The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    page: Option<u16>
}

impl GistsListForksParams {
    pub fn new() -> Self {
        Self::default()
    }

    /// The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    pub fn per_page(self, per_page: u16) -> Self {
        Self {
            per_page: Some(per_page),
            page: self.page, 
        }
    }

    /// The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    pub fn page(self, page: u16) -> Self {
        Self {
            per_page: self.per_page, 
            page: Some(page),
        }
    }
}

impl<'enc> From<&'enc PerPage> for GistsListForksParams {
    fn from(per_page: &'enc PerPage) -> Self {
        Self {
            per_page: Some(per_page.per_page),
            page: Some(per_page.page),
            ..Default::default()
        }
    }
}
/// Query parameters for the [List public gists](Gists::list_public_async()) endpoint.
#[derive(Default, Serialize)]
pub struct GistsListPublicParams {
    /// Only show results that were last updated after the given time. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.
    since: Option<chrono::DateTime<chrono::Utc>>, 
    /// The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    per_page: Option<u16>, 
    /// The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    page: Option<u16>
}

impl GistsListPublicParams {
    pub fn new() -> Self {
        Self::default()
    }

    /// Only show results that were last updated after the given time. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.
    pub fn since(self, since: chrono::DateTime<chrono::Utc>) -> Self {
        Self {
            since: Some(since),
            per_page: self.per_page, 
            page: self.page, 
        }
    }

    /// The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    pub fn per_page(self, per_page: u16) -> Self {
        Self {
            since: self.since, 
            per_page: Some(per_page),
            page: self.page, 
        }
    }

    /// The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    pub fn page(self, page: u16) -> Self {
        Self {
            since: self.since, 
            per_page: self.per_page, 
            page: Some(page),
        }
    }
}

impl<'enc> From<&'enc PerPage> for GistsListPublicParams {
    fn from(per_page: &'enc PerPage) -> Self {
        Self {
            per_page: Some(per_page.per_page),
            page: Some(per_page.page),
            ..Default::default()
        }
    }
}
/// Query parameters for the [List starred gists](Gists::list_starred_async()) endpoint.
#[derive(Default, Serialize)]
pub struct GistsListStarredParams {
    /// Only show results that were last updated after the given time. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.
    since: Option<chrono::DateTime<chrono::Utc>>, 
    /// The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    per_page: Option<u16>, 
    /// The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    page: Option<u16>
}

impl GistsListStarredParams {
    pub fn new() -> Self {
        Self::default()
    }

    /// Only show results that were last updated after the given time. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.
    pub fn since(self, since: chrono::DateTime<chrono::Utc>) -> Self {
        Self {
            since: Some(since),
            per_page: self.per_page, 
            page: self.page, 
        }
    }

    /// The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    pub fn per_page(self, per_page: u16) -> Self {
        Self {
            since: self.since, 
            per_page: Some(per_page),
            page: self.page, 
        }
    }

    /// The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    pub fn page(self, page: u16) -> Self {
        Self {
            since: self.since, 
            per_page: self.per_page, 
            page: Some(page),
        }
    }
}

impl<'enc> From<&'enc PerPage> for GistsListStarredParams {
    fn from(per_page: &'enc PerPage) -> Self {
        Self {
            per_page: Some(per_page.per_page),
            page: Some(per_page.page),
            ..Default::default()
        }
    }
}

impl<'api, C: Client> Gists<'api, C> where AdapterError: From<<C as Client>::Err> {
    /// ---
    ///
    /// # Check if a gist is starred
    ///
    /// [GitHub API docs for check_is_starred](https://docs.github.com/rest/gists/gists#check-if-a-gist-is-starred)
    ///
    /// ---
    pub async fn check_is_starred_async(&self, gist_id: &str) -> Result<(), AdapterError> {

        let request_uri = format!("{}/gists/{}/star", super::GITHUB_BASE_API_URL, gist_id);


        let req = GitHubRequest {
            uri: request_uri,
            body: None::<C::Body>,
            method: "GET",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch_async(request).await?;

        // --

        if github_response.is_success() {
            Ok(())
        } else {
            match github_response.status_code() {
                404 => Err(GistsCheckIsStarredError::Status404(github_response.to_json_async().await?).into()),
                304 => Err(GistsCheckIsStarredError::Status304.into()),
                403 => Err(GistsCheckIsStarredError::Status403(github_response.to_json_async().await?).into()),
                code => Err(GistsCheckIsStarredError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # Check if a gist is starred
    ///
    /// [GitHub API docs for check_is_starred](https://docs.github.com/rest/gists/gists#check-if-a-gist-is-starred)
    ///
    /// ---
    #[cfg(not(target_arch = "wasm32"))]
    pub fn check_is_starred(&self, gist_id: &str) -> Result<(), AdapterError> {

        let request_uri = format!("{}/gists/{}/star", super::GITHUB_BASE_API_URL, gist_id);


        let req = GitHubRequest {
            uri: request_uri,
            body: None,
            method: "GET",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch(request)?;

        // --

        if github_response.is_success() {
            Ok(())
        } else {
            match github_response.status_code() {
                404 => Err(GistsCheckIsStarredError::Status404(github_response.to_json()?).into()),
                304 => Err(GistsCheckIsStarredError::Status304.into()),
                403 => Err(GistsCheckIsStarredError::Status403(github_response.to_json()?).into()),
                code => Err(GistsCheckIsStarredError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # Create a gist
    ///
    /// Allows you to add a new gist with one or more files.
    /// 
    /// > [!NOTE]
    /// > Don't name your files "gistfile" with a numerical suffix. This is the format of the automatic naming scheme that Gist uses internally.
    ///
    /// [GitHub API docs for create](https://docs.github.com/rest/gists/gists#create-a-gist)
    ///
    /// ---
    pub async fn create_async(&self, body: PostGistsCreate) -> Result<GistSimple, AdapterError> {

        let request_uri = format!("{}/gists", super::GITHUB_BASE_API_URL);


        let req = GitHubRequest {
            uri: request_uri,
            body: Some(C::from_json::<PostGistsCreate>(body)?),
            method: "POST",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch_async(request).await?;

        // --

        if github_response.is_success() {
            Ok(github_response.to_json_async().await?)
        } else {
            match github_response.status_code() {
                422 => Err(GistsCreateError::Status422(github_response.to_json_async().await?).into()),
                304 => Err(GistsCreateError::Status304.into()),
                404 => Err(GistsCreateError::Status404(github_response.to_json_async().await?).into()),
                403 => Err(GistsCreateError::Status403(github_response.to_json_async().await?).into()),
                code => Err(GistsCreateError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # Create a gist
    ///
    /// Allows you to add a new gist with one or more files.
    /// 
    /// > [!NOTE]
    /// > Don't name your files "gistfile" with a numerical suffix. This is the format of the automatic naming scheme that Gist uses internally.
    ///
    /// [GitHub API docs for create](https://docs.github.com/rest/gists/gists#create-a-gist)
    ///
    /// ---
    #[cfg(not(target_arch = "wasm32"))]
    pub fn create(&self, body: PostGistsCreate) -> Result<GistSimple, AdapterError> {

        let request_uri = format!("{}/gists", super::GITHUB_BASE_API_URL);


        let req = GitHubRequest {
            uri: request_uri,
            body: Some(C::from_json::<PostGistsCreate>(body)?),
            method: "POST",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch(request)?;

        // --

        if github_response.is_success() {
            Ok(github_response.to_json()?)
        } else {
            match github_response.status_code() {
                422 => Err(GistsCreateError::Status422(github_response.to_json()?).into()),
                304 => Err(GistsCreateError::Status304.into()),
                404 => Err(GistsCreateError::Status404(github_response.to_json()?).into()),
                403 => Err(GistsCreateError::Status403(github_response.to_json()?).into()),
                code => Err(GistsCreateError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # Create a gist comment
    ///
    /// Creates a comment on a gist.
    /// 
    /// This endpoint supports the following custom media types. For more information, see "[Media types](https://docs.github.com/rest/using-the-rest-api/getting-started-with-the-rest-api#media-types)."
    /// 
    /// - **`application/vnd.github.raw+json`**: Returns the raw markdown. This is the default if you do not pass any specific media type.
    /// - **`application/vnd.github.base64+json`**: Returns the base64-encoded contents. This can be useful if your gist contains any invalid UTF-8 sequences.
    ///
    /// [GitHub API docs for create_comment](https://docs.github.com/rest/gists/comments#create-a-gist-comment)
    ///
    /// ---
    pub async fn create_comment_async(&self, gist_id: &str, body: PostGistsCreateComment) -> Result<GistComment, AdapterError> {

        let request_uri = format!("{}/gists/{}/comments", super::GITHUB_BASE_API_URL, gist_id);


        let req = GitHubRequest {
            uri: request_uri,
            body: Some(C::from_json::<PostGistsCreateComment>(body)?),
            method: "POST",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch_async(request).await?;

        // --

        if github_response.is_success() {
            Ok(github_response.to_json_async().await?)
        } else {
            match github_response.status_code() {
                304 => Err(GistsCreateCommentError::Status304.into()),
                404 => Err(GistsCreateCommentError::Status404(github_response.to_json_async().await?).into()),
                403 => Err(GistsCreateCommentError::Status403(github_response.to_json_async().await?).into()),
                code => Err(GistsCreateCommentError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # Create a gist comment
    ///
    /// Creates a comment on a gist.
    /// 
    /// This endpoint supports the following custom media types. For more information, see "[Media types](https://docs.github.com/rest/using-the-rest-api/getting-started-with-the-rest-api#media-types)."
    /// 
    /// - **`application/vnd.github.raw+json`**: Returns the raw markdown. This is the default if you do not pass any specific media type.
    /// - **`application/vnd.github.base64+json`**: Returns the base64-encoded contents. This can be useful if your gist contains any invalid UTF-8 sequences.
    ///
    /// [GitHub API docs for create_comment](https://docs.github.com/rest/gists/comments#create-a-gist-comment)
    ///
    /// ---
    #[cfg(not(target_arch = "wasm32"))]
    pub fn create_comment(&self, gist_id: &str, body: PostGistsCreateComment) -> Result<GistComment, AdapterError> {

        let request_uri = format!("{}/gists/{}/comments", super::GITHUB_BASE_API_URL, gist_id);


        let req = GitHubRequest {
            uri: request_uri,
            body: Some(C::from_json::<PostGistsCreateComment>(body)?),
            method: "POST",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch(request)?;

        // --

        if github_response.is_success() {
            Ok(github_response.to_json()?)
        } else {
            match github_response.status_code() {
                304 => Err(GistsCreateCommentError::Status304.into()),
                404 => Err(GistsCreateCommentError::Status404(github_response.to_json()?).into()),
                403 => Err(GistsCreateCommentError::Status403(github_response.to_json()?).into()),
                code => Err(GistsCreateCommentError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # Delete a gist
    ///
    /// [GitHub API docs for delete](https://docs.github.com/rest/gists/gists#delete-a-gist)
    ///
    /// ---
    pub async fn delete_async(&self, gist_id: &str) -> Result<(), AdapterError> {

        let request_uri = format!("{}/gists/{}", super::GITHUB_BASE_API_URL, gist_id);


        let req = GitHubRequest {
            uri: request_uri,
            body: None::<C::Body>,
            method: "DELETE",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch_async(request).await?;

        // --

        if github_response.is_success() {
            Ok(())
        } else {
            match github_response.status_code() {
                404 => Err(GistsDeleteError::Status404(github_response.to_json_async().await?).into()),
                304 => Err(GistsDeleteError::Status304.into()),
                403 => Err(GistsDeleteError::Status403(github_response.to_json_async().await?).into()),
                code => Err(GistsDeleteError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # Delete a gist
    ///
    /// [GitHub API docs for delete](https://docs.github.com/rest/gists/gists#delete-a-gist)
    ///
    /// ---
    #[cfg(not(target_arch = "wasm32"))]
    pub fn delete(&self, gist_id: &str) -> Result<(), AdapterError> {

        let request_uri = format!("{}/gists/{}", super::GITHUB_BASE_API_URL, gist_id);


        let req = GitHubRequest {
            uri: request_uri,
            body: None,
            method: "DELETE",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch(request)?;

        // --

        if github_response.is_success() {
            Ok(())
        } else {
            match github_response.status_code() {
                404 => Err(GistsDeleteError::Status404(github_response.to_json()?).into()),
                304 => Err(GistsDeleteError::Status304.into()),
                403 => Err(GistsDeleteError::Status403(github_response.to_json()?).into()),
                code => Err(GistsDeleteError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # Delete a gist comment
    ///
    /// [GitHub API docs for delete_comment](https://docs.github.com/rest/gists/comments#delete-a-gist-comment)
    ///
    /// ---
    pub async fn delete_comment_async(&self, gist_id: &str, comment_id: i64) -> Result<(), AdapterError> {

        let request_uri = format!("{}/gists/{}/comments/{}", super::GITHUB_BASE_API_URL, gist_id, comment_id);


        let req = GitHubRequest {
            uri: request_uri,
            body: None::<C::Body>,
            method: "DELETE",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch_async(request).await?;

        // --

        if github_response.is_success() {
            Ok(())
        } else {
            match github_response.status_code() {
                304 => Err(GistsDeleteCommentError::Status304.into()),
                404 => Err(GistsDeleteCommentError::Status404(github_response.to_json_async().await?).into()),
                403 => Err(GistsDeleteCommentError::Status403(github_response.to_json_async().await?).into()),
                code => Err(GistsDeleteCommentError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # Delete a gist comment
    ///
    /// [GitHub API docs for delete_comment](https://docs.github.com/rest/gists/comments#delete-a-gist-comment)
    ///
    /// ---
    #[cfg(not(target_arch = "wasm32"))]
    pub fn delete_comment(&self, gist_id: &str, comment_id: i64) -> Result<(), AdapterError> {

        let request_uri = format!("{}/gists/{}/comments/{}", super::GITHUB_BASE_API_URL, gist_id, comment_id);


        let req = GitHubRequest {
            uri: request_uri,
            body: None,
            method: "DELETE",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch(request)?;

        // --

        if github_response.is_success() {
            Ok(())
        } else {
            match github_response.status_code() {
                304 => Err(GistsDeleteCommentError::Status304.into()),
                404 => Err(GistsDeleteCommentError::Status404(github_response.to_json()?).into()),
                403 => Err(GistsDeleteCommentError::Status403(github_response.to_json()?).into()),
                code => Err(GistsDeleteCommentError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # Fork a gist
    ///
    /// [GitHub API docs for fork](https://docs.github.com/rest/gists/gists#fork-a-gist)
    ///
    /// ---
    pub async fn fork_async(&self, gist_id: &str) -> Result<BaseGist, AdapterError> {

        let request_uri = format!("{}/gists/{}/forks", super::GITHUB_BASE_API_URL, gist_id);


        let req = GitHubRequest {
            uri: request_uri,
            body: None::<C::Body>,
            method: "POST",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch_async(request).await?;

        // --

        if github_response.is_success() {
            Ok(github_response.to_json_async().await?)
        } else {
            match github_response.status_code() {
                404 => Err(GistsForkError::Status404(github_response.to_json_async().await?).into()),
                422 => Err(GistsForkError::Status422(github_response.to_json_async().await?).into()),
                304 => Err(GistsForkError::Status304.into()),
                403 => Err(GistsForkError::Status403(github_response.to_json_async().await?).into()),
                code => Err(GistsForkError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # Fork a gist
    ///
    /// [GitHub API docs for fork](https://docs.github.com/rest/gists/gists#fork-a-gist)
    ///
    /// ---
    #[cfg(not(target_arch = "wasm32"))]
    pub fn fork(&self, gist_id: &str) -> Result<BaseGist, AdapterError> {

        let request_uri = format!("{}/gists/{}/forks", super::GITHUB_BASE_API_URL, gist_id);


        let req = GitHubRequest {
            uri: request_uri,
            body: None,
            method: "POST",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch(request)?;

        // --

        if github_response.is_success() {
            Ok(github_response.to_json()?)
        } else {
            match github_response.status_code() {
                404 => Err(GistsForkError::Status404(github_response.to_json()?).into()),
                422 => Err(GistsForkError::Status422(github_response.to_json()?).into()),
                304 => Err(GistsForkError::Status304.into()),
                403 => Err(GistsForkError::Status403(github_response.to_json()?).into()),
                code => Err(GistsForkError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # Get a gist
    ///
    /// Gets a specified gist.
    /// 
    /// This endpoint supports the following custom media types. For more information, see "[Media types](https://docs.github.com/rest/using-the-rest-api/getting-started-with-the-rest-api#media-types)."
    /// 
    /// - **`application/vnd.github.raw+json`**: Returns the raw markdown. This is the default if you do not pass any specific media type.
    /// - **`application/vnd.github.base64+json`**: Returns the base64-encoded contents. This can be useful if your gist contains any invalid UTF-8 sequences.
    ///
    /// [GitHub API docs for get](https://docs.github.com/rest/gists/gists#get-a-gist)
    ///
    /// ---
    pub async fn get_async(&self, gist_id: &str) -> Result<GistSimple, AdapterError> {

        let request_uri = format!("{}/gists/{}", super::GITHUB_BASE_API_URL, gist_id);


        let req = GitHubRequest {
            uri: request_uri,
            body: None::<C::Body>,
            method: "GET",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch_async(request).await?;

        // --

        if github_response.is_success() {
            Ok(github_response.to_json_async().await?)
        } else {
            match github_response.status_code() {
                403 => Err(GistsGetError::Status403(github_response.to_json_async().await?).into()),
                404 => Err(GistsGetError::Status404(github_response.to_json_async().await?).into()),
                304 => Err(GistsGetError::Status304.into()),
                code => Err(GistsGetError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # Get a gist
    ///
    /// Gets a specified gist.
    /// 
    /// This endpoint supports the following custom media types. For more information, see "[Media types](https://docs.github.com/rest/using-the-rest-api/getting-started-with-the-rest-api#media-types)."
    /// 
    /// - **`application/vnd.github.raw+json`**: Returns the raw markdown. This is the default if you do not pass any specific media type.
    /// - **`application/vnd.github.base64+json`**: Returns the base64-encoded contents. This can be useful if your gist contains any invalid UTF-8 sequences.
    ///
    /// [GitHub API docs for get](https://docs.github.com/rest/gists/gists#get-a-gist)
    ///
    /// ---
    #[cfg(not(target_arch = "wasm32"))]
    pub fn get(&self, gist_id: &str) -> Result<GistSimple, AdapterError> {

        let request_uri = format!("{}/gists/{}", super::GITHUB_BASE_API_URL, gist_id);


        let req = GitHubRequest {
            uri: request_uri,
            body: None,
            method: "GET",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch(request)?;

        // --

        if github_response.is_success() {
            Ok(github_response.to_json()?)
        } else {
            match github_response.status_code() {
                403 => Err(GistsGetError::Status403(github_response.to_json()?).into()),
                404 => Err(GistsGetError::Status404(github_response.to_json()?).into()),
                304 => Err(GistsGetError::Status304.into()),
                code => Err(GistsGetError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # Get a gist comment
    ///
    /// Gets a comment on a gist.
    /// 
    /// This endpoint supports the following custom media types. For more information, see "[Media types](https://docs.github.com/rest/using-the-rest-api/getting-started-with-the-rest-api#media-types)."
    /// 
    /// - **`application/vnd.github.raw+json`**: Returns the raw markdown. This is the default if you do not pass any specific media type.
    /// - **`application/vnd.github.base64+json`**: Returns the base64-encoded contents. This can be useful if your gist contains any invalid UTF-8 sequences.
    ///
    /// [GitHub API docs for get_comment](https://docs.github.com/rest/gists/comments#get-a-gist-comment)
    ///
    /// ---
    pub async fn get_comment_async(&self, gist_id: &str, comment_id: i64) -> Result<GistComment, AdapterError> {

        let request_uri = format!("{}/gists/{}/comments/{}", super::GITHUB_BASE_API_URL, gist_id, comment_id);


        let req = GitHubRequest {
            uri: request_uri,
            body: None::<C::Body>,
            method: "GET",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch_async(request).await?;

        // --

        if github_response.is_success() {
            Ok(github_response.to_json_async().await?)
        } else {
            match github_response.status_code() {
                304 => Err(GistsGetCommentError::Status304.into()),
                404 => Err(GistsGetCommentError::Status404(github_response.to_json_async().await?).into()),
                403 => Err(GistsGetCommentError::Status403(github_response.to_json_async().await?).into()),
                code => Err(GistsGetCommentError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # Get a gist comment
    ///
    /// Gets a comment on a gist.
    /// 
    /// This endpoint supports the following custom media types. For more information, see "[Media types](https://docs.github.com/rest/using-the-rest-api/getting-started-with-the-rest-api#media-types)."
    /// 
    /// - **`application/vnd.github.raw+json`**: Returns the raw markdown. This is the default if you do not pass any specific media type.
    /// - **`application/vnd.github.base64+json`**: Returns the base64-encoded contents. This can be useful if your gist contains any invalid UTF-8 sequences.
    ///
    /// [GitHub API docs for get_comment](https://docs.github.com/rest/gists/comments#get-a-gist-comment)
    ///
    /// ---
    #[cfg(not(target_arch = "wasm32"))]
    pub fn get_comment(&self, gist_id: &str, comment_id: i64) -> Result<GistComment, AdapterError> {

        let request_uri = format!("{}/gists/{}/comments/{}", super::GITHUB_BASE_API_URL, gist_id, comment_id);


        let req = GitHubRequest {
            uri: request_uri,
            body: None,
            method: "GET",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch(request)?;

        // --

        if github_response.is_success() {
            Ok(github_response.to_json()?)
        } else {
            match github_response.status_code() {
                304 => Err(GistsGetCommentError::Status304.into()),
                404 => Err(GistsGetCommentError::Status404(github_response.to_json()?).into()),
                403 => Err(GistsGetCommentError::Status403(github_response.to_json()?).into()),
                code => Err(GistsGetCommentError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # Get a gist revision
    ///
    /// Gets a specified gist revision.
    /// 
    /// This endpoint supports the following custom media types. For more information, see "[Media types](https://docs.github.com/rest/using-the-rest-api/getting-started-with-the-rest-api#media-types)."
    /// 
    /// - **`application/vnd.github.raw+json`**: Returns the raw markdown. This is the default if you do not pass any specific media type.
    /// - **`application/vnd.github.base64+json`**: Returns the base64-encoded contents. This can be useful if your gist contains any invalid UTF-8 sequences.
    ///
    /// [GitHub API docs for get_revision](https://docs.github.com/rest/gists/gists#get-a-gist-revision)
    ///
    /// ---
    pub async fn get_revision_async(&self, gist_id: &str, sha: &str) -> Result<GistSimple, AdapterError> {

        let request_uri = format!("{}/gists/{}/{}", super::GITHUB_BASE_API_URL, gist_id, sha);


        let req = GitHubRequest {
            uri: request_uri,
            body: None::<C::Body>,
            method: "GET",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch_async(request).await?;

        // --

        if github_response.is_success() {
            Ok(github_response.to_json_async().await?)
        } else {
            match github_response.status_code() {
                422 => Err(GistsGetRevisionError::Status422(github_response.to_json_async().await?).into()),
                404 => Err(GistsGetRevisionError::Status404(github_response.to_json_async().await?).into()),
                403 => Err(GistsGetRevisionError::Status403(github_response.to_json_async().await?).into()),
                code => Err(GistsGetRevisionError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # Get a gist revision
    ///
    /// Gets a specified gist revision.
    /// 
    /// This endpoint supports the following custom media types. For more information, see "[Media types](https://docs.github.com/rest/using-the-rest-api/getting-started-with-the-rest-api#media-types)."
    /// 
    /// - **`application/vnd.github.raw+json`**: Returns the raw markdown. This is the default if you do not pass any specific media type.
    /// - **`application/vnd.github.base64+json`**: Returns the base64-encoded contents. This can be useful if your gist contains any invalid UTF-8 sequences.
    ///
    /// [GitHub API docs for get_revision](https://docs.github.com/rest/gists/gists#get-a-gist-revision)
    ///
    /// ---
    #[cfg(not(target_arch = "wasm32"))]
    pub fn get_revision(&self, gist_id: &str, sha: &str) -> Result<GistSimple, AdapterError> {

        let request_uri = format!("{}/gists/{}/{}", super::GITHUB_BASE_API_URL, gist_id, sha);


        let req = GitHubRequest {
            uri: request_uri,
            body: None,
            method: "GET",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch(request)?;

        // --

        if github_response.is_success() {
            Ok(github_response.to_json()?)
        } else {
            match github_response.status_code() {
                422 => Err(GistsGetRevisionError::Status422(github_response.to_json()?).into()),
                404 => Err(GistsGetRevisionError::Status404(github_response.to_json()?).into()),
                403 => Err(GistsGetRevisionError::Status403(github_response.to_json()?).into()),
                code => Err(GistsGetRevisionError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # List gists for the authenticated user
    ///
    /// Lists the authenticated user's gists or if called anonymously, this endpoint returns all public gists:
    ///
    /// [GitHub API docs for list](https://docs.github.com/rest/gists/gists#list-gists-for-the-authenticated-user)
    ///
    /// ---
    pub async fn list_async(&self, query_params: Option<impl Into<GistsListParams>>) -> Result<Vec<BaseGist>, AdapterError> {

        let mut request_uri = format!("{}/gists", super::GITHUB_BASE_API_URL);

        if let Some(params) = query_params {
            request_uri.push_str("?");
            request_uri.push_str(&serde_urlencoded::to_string(params.into())?);
        }

        let req = GitHubRequest {
            uri: request_uri,
            body: None::<C::Body>,
            method: "GET",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch_async(request).await?;

        // --

        if github_response.is_success() {
            Ok(github_response.to_json_async().await?)
        } else {
            match github_response.status_code() {
                304 => Err(GistsListError::Status304.into()),
                403 => Err(GistsListError::Status403(github_response.to_json_async().await?).into()),
                code => Err(GistsListError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # List gists for the authenticated user
    ///
    /// Lists the authenticated user's gists or if called anonymously, this endpoint returns all public gists:
    ///
    /// [GitHub API docs for list](https://docs.github.com/rest/gists/gists#list-gists-for-the-authenticated-user)
    ///
    /// ---
    #[cfg(not(target_arch = "wasm32"))]
    pub fn list(&self, query_params: Option<impl Into<GistsListParams>>) -> Result<Vec<BaseGist>, AdapterError> {

        let mut request_uri = format!("{}/gists", super::GITHUB_BASE_API_URL);

        if let Some(params) = query_params {
            request_uri.push_str("?");
            let qp: GistsListParams = params.into();
            request_uri.push_str(&serde_urlencoded::to_string(qp)?);
        }

        let req = GitHubRequest {
            uri: request_uri,
            body: None,
            method: "GET",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch(request)?;

        // --

        if github_response.is_success() {
            Ok(github_response.to_json()?)
        } else {
            match github_response.status_code() {
                304 => Err(GistsListError::Status304.into()),
                403 => Err(GistsListError::Status403(github_response.to_json()?).into()),
                code => Err(GistsListError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # List gist comments
    ///
    /// Lists the comments on a gist.
    /// 
    /// This endpoint supports the following custom media types. For more information, see "[Media types](https://docs.github.com/rest/using-the-rest-api/getting-started-with-the-rest-api#media-types)."
    /// 
    /// - **`application/vnd.github.raw+json`**: Returns the raw markdown. This is the default if you do not pass any specific media type.
    /// - **`application/vnd.github.base64+json`**: Returns the base64-encoded contents. This can be useful if your gist contains any invalid UTF-8 sequences.
    ///
    /// [GitHub API docs for list_comments](https://docs.github.com/rest/gists/comments#list-gist-comments)
    ///
    /// ---
    pub async fn list_comments_async(&self, gist_id: &str, query_params: Option<impl Into<GistsListCommentsParams>>) -> Result<Vec<GistComment>, AdapterError> {

        let mut request_uri = format!("{}/gists/{}/comments", super::GITHUB_BASE_API_URL, gist_id);

        if let Some(params) = query_params {
            request_uri.push_str("?");
            request_uri.push_str(&serde_urlencoded::to_string(params.into())?);
        }

        let req = GitHubRequest {
            uri: request_uri,
            body: None::<C::Body>,
            method: "GET",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch_async(request).await?;

        // --

        if github_response.is_success() {
            Ok(github_response.to_json_async().await?)
        } else {
            match github_response.status_code() {
                304 => Err(GistsListCommentsError::Status304.into()),
                404 => Err(GistsListCommentsError::Status404(github_response.to_json_async().await?).into()),
                403 => Err(GistsListCommentsError::Status403(github_response.to_json_async().await?).into()),
                code => Err(GistsListCommentsError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # List gist comments
    ///
    /// Lists the comments on a gist.
    /// 
    /// This endpoint supports the following custom media types. For more information, see "[Media types](https://docs.github.com/rest/using-the-rest-api/getting-started-with-the-rest-api#media-types)."
    /// 
    /// - **`application/vnd.github.raw+json`**: Returns the raw markdown. This is the default if you do not pass any specific media type.
    /// - **`application/vnd.github.base64+json`**: Returns the base64-encoded contents. This can be useful if your gist contains any invalid UTF-8 sequences.
    ///
    /// [GitHub API docs for list_comments](https://docs.github.com/rest/gists/comments#list-gist-comments)
    ///
    /// ---
    #[cfg(not(target_arch = "wasm32"))]
    pub fn list_comments(&self, gist_id: &str, query_params: Option<impl Into<GistsListCommentsParams>>) -> Result<Vec<GistComment>, AdapterError> {

        let mut request_uri = format!("{}/gists/{}/comments", super::GITHUB_BASE_API_URL, gist_id);

        if let Some(params) = query_params {
            request_uri.push_str("?");
            let qp: GistsListCommentsParams = params.into();
            request_uri.push_str(&serde_urlencoded::to_string(qp)?);
        }

        let req = GitHubRequest {
            uri: request_uri,
            body: None,
            method: "GET",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch(request)?;

        // --

        if github_response.is_success() {
            Ok(github_response.to_json()?)
        } else {
            match github_response.status_code() {
                304 => Err(GistsListCommentsError::Status304.into()),
                404 => Err(GistsListCommentsError::Status404(github_response.to_json()?).into()),
                403 => Err(GistsListCommentsError::Status403(github_response.to_json()?).into()),
                code => Err(GistsListCommentsError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # List gist commits
    ///
    /// [GitHub API docs for list_commits](https://docs.github.com/rest/gists/gists#list-gist-commits)
    ///
    /// ---
    pub async fn list_commits_async(&self, gist_id: &str, query_params: Option<impl Into<GistsListCommitsParams>>) -> Result<Vec<GistCommit>, AdapterError> {

        let mut request_uri = format!("{}/gists/{}/commits", super::GITHUB_BASE_API_URL, gist_id);

        if let Some(params) = query_params {
            request_uri.push_str("?");
            request_uri.push_str(&serde_urlencoded::to_string(params.into())?);
        }

        let req = GitHubRequest {
            uri: request_uri,
            body: None::<C::Body>,
            method: "GET",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch_async(request).await?;

        // --

        if github_response.is_success() {
            Ok(github_response.to_json_async().await?)
        } else {
            match github_response.status_code() {
                404 => Err(GistsListCommitsError::Status404(github_response.to_json_async().await?).into()),
                304 => Err(GistsListCommitsError::Status304.into()),
                403 => Err(GistsListCommitsError::Status403(github_response.to_json_async().await?).into()),
                code => Err(GistsListCommitsError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # List gist commits
    ///
    /// [GitHub API docs for list_commits](https://docs.github.com/rest/gists/gists#list-gist-commits)
    ///
    /// ---
    #[cfg(not(target_arch = "wasm32"))]
    pub fn list_commits(&self, gist_id: &str, query_params: Option<impl Into<GistsListCommitsParams>>) -> Result<Vec<GistCommit>, AdapterError> {

        let mut request_uri = format!("{}/gists/{}/commits", super::GITHUB_BASE_API_URL, gist_id);

        if let Some(params) = query_params {
            request_uri.push_str("?");
            let qp: GistsListCommitsParams = params.into();
            request_uri.push_str(&serde_urlencoded::to_string(qp)?);
        }

        let req = GitHubRequest {
            uri: request_uri,
            body: None,
            method: "GET",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch(request)?;

        // --

        if github_response.is_success() {
            Ok(github_response.to_json()?)
        } else {
            match github_response.status_code() {
                404 => Err(GistsListCommitsError::Status404(github_response.to_json()?).into()),
                304 => Err(GistsListCommitsError::Status304.into()),
                403 => Err(GistsListCommitsError::Status403(github_response.to_json()?).into()),
                code => Err(GistsListCommitsError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # List gists for a user
    ///
    /// Lists public gists for the specified user:
    ///
    /// [GitHub API docs for list_for_user](https://docs.github.com/rest/gists/gists#list-gists-for-a-user)
    ///
    /// ---
    pub async fn list_for_user_async(&self, username: &str, query_params: Option<impl Into<GistsListForUserParams>>) -> Result<Vec<BaseGist>, AdapterError> {

        let mut request_uri = format!("{}/users/{}/gists", super::GITHUB_BASE_API_URL, username);

        if let Some(params) = query_params {
            request_uri.push_str("?");
            request_uri.push_str(&serde_urlencoded::to_string(params.into())?);
        }

        let req = GitHubRequest {
            uri: request_uri,
            body: None::<C::Body>,
            method: "GET",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch_async(request).await?;

        // --

        if github_response.is_success() {
            Ok(github_response.to_json_async().await?)
        } else {
            match github_response.status_code() {
                422 => Err(GistsListForUserError::Status422(github_response.to_json_async().await?).into()),
                code => Err(GistsListForUserError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # List gists for a user
    ///
    /// Lists public gists for the specified user:
    ///
    /// [GitHub API docs for list_for_user](https://docs.github.com/rest/gists/gists#list-gists-for-a-user)
    ///
    /// ---
    #[cfg(not(target_arch = "wasm32"))]
    pub fn list_for_user(&self, username: &str, query_params: Option<impl Into<GistsListForUserParams>>) -> Result<Vec<BaseGist>, AdapterError> {

        let mut request_uri = format!("{}/users/{}/gists", super::GITHUB_BASE_API_URL, username);

        if let Some(params) = query_params {
            request_uri.push_str("?");
            let qp: GistsListForUserParams = params.into();
            request_uri.push_str(&serde_urlencoded::to_string(qp)?);
        }

        let req = GitHubRequest {
            uri: request_uri,
            body: None,
            method: "GET",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch(request)?;

        // --

        if github_response.is_success() {
            Ok(github_response.to_json()?)
        } else {
            match github_response.status_code() {
                422 => Err(GistsListForUserError::Status422(github_response.to_json()?).into()),
                code => Err(GistsListForUserError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # List gist forks
    ///
    /// [GitHub API docs for list_forks](https://docs.github.com/rest/gists/gists#list-gist-forks)
    ///
    /// ---
    pub async fn list_forks_async(&self, gist_id: &str, query_params: Option<impl Into<GistsListForksParams>>) -> Result<Vec<GistSimple>, AdapterError> {

        let mut request_uri = format!("{}/gists/{}/forks", super::GITHUB_BASE_API_URL, gist_id);

        if let Some(params) = query_params {
            request_uri.push_str("?");
            request_uri.push_str(&serde_urlencoded::to_string(params.into())?);
        }

        let req = GitHubRequest {
            uri: request_uri,
            body: None::<C::Body>,
            method: "GET",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch_async(request).await?;

        // --

        if github_response.is_success() {
            Ok(github_response.to_json_async().await?)
        } else {
            match github_response.status_code() {
                404 => Err(GistsListForksError::Status404(github_response.to_json_async().await?).into()),
                304 => Err(GistsListForksError::Status304.into()),
                403 => Err(GistsListForksError::Status403(github_response.to_json_async().await?).into()),
                code => Err(GistsListForksError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # List gist forks
    ///
    /// [GitHub API docs for list_forks](https://docs.github.com/rest/gists/gists#list-gist-forks)
    ///
    /// ---
    #[cfg(not(target_arch = "wasm32"))]
    pub fn list_forks(&self, gist_id: &str, query_params: Option<impl Into<GistsListForksParams>>) -> Result<Vec<GistSimple>, AdapterError> {

        let mut request_uri = format!("{}/gists/{}/forks", super::GITHUB_BASE_API_URL, gist_id);

        if let Some(params) = query_params {
            request_uri.push_str("?");
            let qp: GistsListForksParams = params.into();
            request_uri.push_str(&serde_urlencoded::to_string(qp)?);
        }

        let req = GitHubRequest {
            uri: request_uri,
            body: None,
            method: "GET",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch(request)?;

        // --

        if github_response.is_success() {
            Ok(github_response.to_json()?)
        } else {
            match github_response.status_code() {
                404 => Err(GistsListForksError::Status404(github_response.to_json()?).into()),
                304 => Err(GistsListForksError::Status304.into()),
                403 => Err(GistsListForksError::Status403(github_response.to_json()?).into()),
                code => Err(GistsListForksError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # List public gists
    ///
    /// List public gists sorted by most recently updated to least recently updated.
    /// 
    /// Note: With [pagination](https://docs.github.com/rest/guides/using-pagination-in-the-rest-api), you can fetch up to 3000 gists. For example, you can fetch 100 pages with 30 gists per page or 30 pages with 100 gists per page.
    ///
    /// [GitHub API docs for list_public](https://docs.github.com/rest/gists/gists#list-public-gists)
    ///
    /// ---
    pub async fn list_public_async(&self, query_params: Option<impl Into<GistsListPublicParams>>) -> Result<Vec<BaseGist>, AdapterError> {

        let mut request_uri = format!("{}/gists/public", super::GITHUB_BASE_API_URL);

        if let Some(params) = query_params {
            request_uri.push_str("?");
            request_uri.push_str(&serde_urlencoded::to_string(params.into())?);
        }

        let req = GitHubRequest {
            uri: request_uri,
            body: None::<C::Body>,
            method: "GET",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch_async(request).await?;

        // --

        if github_response.is_success() {
            Ok(github_response.to_json_async().await?)
        } else {
            match github_response.status_code() {
                422 => Err(GistsListPublicError::Status422(github_response.to_json_async().await?).into()),
                304 => Err(GistsListPublicError::Status304.into()),
                403 => Err(GistsListPublicError::Status403(github_response.to_json_async().await?).into()),
                code => Err(GistsListPublicError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # List public gists
    ///
    /// List public gists sorted by most recently updated to least recently updated.
    /// 
    /// Note: With [pagination](https://docs.github.com/rest/guides/using-pagination-in-the-rest-api), you can fetch up to 3000 gists. For example, you can fetch 100 pages with 30 gists per page or 30 pages with 100 gists per page.
    ///
    /// [GitHub API docs for list_public](https://docs.github.com/rest/gists/gists#list-public-gists)
    ///
    /// ---
    #[cfg(not(target_arch = "wasm32"))]
    pub fn list_public(&self, query_params: Option<impl Into<GistsListPublicParams>>) -> Result<Vec<BaseGist>, AdapterError> {

        let mut request_uri = format!("{}/gists/public", super::GITHUB_BASE_API_URL);

        if let Some(params) = query_params {
            request_uri.push_str("?");
            let qp: GistsListPublicParams = params.into();
            request_uri.push_str(&serde_urlencoded::to_string(qp)?);
        }

        let req = GitHubRequest {
            uri: request_uri,
            body: None,
            method: "GET",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch(request)?;

        // --

        if github_response.is_success() {
            Ok(github_response.to_json()?)
        } else {
            match github_response.status_code() {
                422 => Err(GistsListPublicError::Status422(github_response.to_json()?).into()),
                304 => Err(GistsListPublicError::Status304.into()),
                403 => Err(GistsListPublicError::Status403(github_response.to_json()?).into()),
                code => Err(GistsListPublicError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # List starred gists
    ///
    /// List the authenticated user's starred gists:
    ///
    /// [GitHub API docs for list_starred](https://docs.github.com/rest/gists/gists#list-starred-gists)
    ///
    /// ---
    pub async fn list_starred_async(&self, query_params: Option<impl Into<GistsListStarredParams>>) -> Result<Vec<BaseGist>, AdapterError> {

        let mut request_uri = format!("{}/gists/starred", super::GITHUB_BASE_API_URL);

        if let Some(params) = query_params {
            request_uri.push_str("?");
            request_uri.push_str(&serde_urlencoded::to_string(params.into())?);
        }

        let req = GitHubRequest {
            uri: request_uri,
            body: None::<C::Body>,
            method: "GET",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch_async(request).await?;

        // --

        if github_response.is_success() {
            Ok(github_response.to_json_async().await?)
        } else {
            match github_response.status_code() {
                401 => Err(GistsListStarredError::Status401(github_response.to_json_async().await?).into()),
                304 => Err(GistsListStarredError::Status304.into()),
                403 => Err(GistsListStarredError::Status403(github_response.to_json_async().await?).into()),
                code => Err(GistsListStarredError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # List starred gists
    ///
    /// List the authenticated user's starred gists:
    ///
    /// [GitHub API docs for list_starred](https://docs.github.com/rest/gists/gists#list-starred-gists)
    ///
    /// ---
    #[cfg(not(target_arch = "wasm32"))]
    pub fn list_starred(&self, query_params: Option<impl Into<GistsListStarredParams>>) -> Result<Vec<BaseGist>, AdapterError> {

        let mut request_uri = format!("{}/gists/starred", super::GITHUB_BASE_API_URL);

        if let Some(params) = query_params {
            request_uri.push_str("?");
            let qp: GistsListStarredParams = params.into();
            request_uri.push_str(&serde_urlencoded::to_string(qp)?);
        }

        let req = GitHubRequest {
            uri: request_uri,
            body: None,
            method: "GET",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch(request)?;

        // --

        if github_response.is_success() {
            Ok(github_response.to_json()?)
        } else {
            match github_response.status_code() {
                401 => Err(GistsListStarredError::Status401(github_response.to_json()?).into()),
                304 => Err(GistsListStarredError::Status304.into()),
                403 => Err(GistsListStarredError::Status403(github_response.to_json()?).into()),
                code => Err(GistsListStarredError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # Star a gist
    ///
    /// Note that you'll need to set `Content-Length` to zero when calling out to this endpoint. For more information, see "[HTTP method](https://docs.github.com/rest/guides/getting-started-with-the-rest-api#http-method)."
    ///
    /// [GitHub API docs for star](https://docs.github.com/rest/gists/gists#star-a-gist)
    ///
    /// ---
    pub async fn star_async(&self, gist_id: &str) -> Result<(), AdapterError> {

        let request_uri = format!("{}/gists/{}/star", super::GITHUB_BASE_API_URL, gist_id);


        let req = GitHubRequest {
            uri: request_uri,
            body: None::<C::Body>,
            method: "PUT",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch_async(request).await?;

        // --

        if github_response.is_success() {
            Ok(())
        } else {
            match github_response.status_code() {
                404 => Err(GistsStarError::Status404(github_response.to_json_async().await?).into()),
                304 => Err(GistsStarError::Status304.into()),
                403 => Err(GistsStarError::Status403(github_response.to_json_async().await?).into()),
                code => Err(GistsStarError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # Star a gist
    ///
    /// Note that you'll need to set `Content-Length` to zero when calling out to this endpoint. For more information, see "[HTTP method](https://docs.github.com/rest/guides/getting-started-with-the-rest-api#http-method)."
    ///
    /// [GitHub API docs for star](https://docs.github.com/rest/gists/gists#star-a-gist)
    ///
    /// ---
    #[cfg(not(target_arch = "wasm32"))]
    pub fn star(&self, gist_id: &str) -> Result<(), AdapterError> {

        let request_uri = format!("{}/gists/{}/star", super::GITHUB_BASE_API_URL, gist_id);


        let req = GitHubRequest {
            uri: request_uri,
            body: None,
            method: "PUT",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch(request)?;

        // --

        if github_response.is_success() {
            Ok(())
        } else {
            match github_response.status_code() {
                404 => Err(GistsStarError::Status404(github_response.to_json()?).into()),
                304 => Err(GistsStarError::Status304.into()),
                403 => Err(GistsStarError::Status403(github_response.to_json()?).into()),
                code => Err(GistsStarError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # Unstar a gist
    ///
    /// [GitHub API docs for unstar](https://docs.github.com/rest/gists/gists#unstar-a-gist)
    ///
    /// ---
    pub async fn unstar_async(&self, gist_id: &str) -> Result<(), AdapterError> {

        let request_uri = format!("{}/gists/{}/star", super::GITHUB_BASE_API_URL, gist_id);


        let req = GitHubRequest {
            uri: request_uri,
            body: None::<C::Body>,
            method: "DELETE",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch_async(request).await?;

        // --

        if github_response.is_success() {
            Ok(())
        } else {
            match github_response.status_code() {
                304 => Err(GistsUnstarError::Status304.into()),
                404 => Err(GistsUnstarError::Status404(github_response.to_json_async().await?).into()),
                403 => Err(GistsUnstarError::Status403(github_response.to_json_async().await?).into()),
                code => Err(GistsUnstarError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # Unstar a gist
    ///
    /// [GitHub API docs for unstar](https://docs.github.com/rest/gists/gists#unstar-a-gist)
    ///
    /// ---
    #[cfg(not(target_arch = "wasm32"))]
    pub fn unstar(&self, gist_id: &str) -> Result<(), AdapterError> {

        let request_uri = format!("{}/gists/{}/star", super::GITHUB_BASE_API_URL, gist_id);


        let req = GitHubRequest {
            uri: request_uri,
            body: None,
            method: "DELETE",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch(request)?;

        // --

        if github_response.is_success() {
            Ok(())
        } else {
            match github_response.status_code() {
                304 => Err(GistsUnstarError::Status304.into()),
                404 => Err(GistsUnstarError::Status404(github_response.to_json()?).into()),
                403 => Err(GistsUnstarError::Status403(github_response.to_json()?).into()),
                code => Err(GistsUnstarError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # Update a gist
    ///
    /// Allows you to update a gist's description and to update, delete, or rename gist files. Files
    /// from the previous version of the gist that aren't explicitly changed during an edit
    /// are unchanged.
    /// 
    /// At least one of `description` or `files` is required.
    /// 
    /// This endpoint supports the following custom media types. For more information, see "[Media types](https://docs.github.com/rest/using-the-rest-api/getting-started-with-the-rest-api#media-types)."
    /// 
    /// - **`application/vnd.github.raw+json`**: Returns the raw markdown. This is the default if you do not pass any specific media type.
    /// - **`application/vnd.github.base64+json`**: Returns the base64-encoded contents. This can be useful if your gist contains any invalid UTF-8 sequences.
    ///
    /// [GitHub API docs for update](https://docs.github.com/rest/gists/gists#update-a-gist)
    ///
    /// ---
    pub async fn update_async(&self, gist_id: &str, body: PatchGistsUpdate) -> Result<GistSimple, AdapterError> {

        let request_uri = format!("{}/gists/{}", super::GITHUB_BASE_API_URL, gist_id);


        let req = GitHubRequest {
            uri: request_uri,
            body: Some(C::from_json::<PatchGistsUpdate>(body)?),
            method: "PATCH",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch_async(request).await?;

        // --

        if github_response.is_success() {
            Ok(github_response.to_json_async().await?)
        } else {
            match github_response.status_code() {
                422 => Err(GistsUpdateError::Status422(github_response.to_json_async().await?).into()),
                404 => Err(GistsUpdateError::Status404(github_response.to_json_async().await?).into()),
                code => Err(GistsUpdateError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # Update a gist
    ///
    /// Allows you to update a gist's description and to update, delete, or rename gist files. Files
    /// from the previous version of the gist that aren't explicitly changed during an edit
    /// are unchanged.
    /// 
    /// At least one of `description` or `files` is required.
    /// 
    /// This endpoint supports the following custom media types. For more information, see "[Media types](https://docs.github.com/rest/using-the-rest-api/getting-started-with-the-rest-api#media-types)."
    /// 
    /// - **`application/vnd.github.raw+json`**: Returns the raw markdown. This is the default if you do not pass any specific media type.
    /// - **`application/vnd.github.base64+json`**: Returns the base64-encoded contents. This can be useful if your gist contains any invalid UTF-8 sequences.
    ///
    /// [GitHub API docs for update](https://docs.github.com/rest/gists/gists#update-a-gist)
    ///
    /// ---
    #[cfg(not(target_arch = "wasm32"))]
    pub fn update(&self, gist_id: &str, body: PatchGistsUpdate) -> Result<GistSimple, AdapterError> {

        let request_uri = format!("{}/gists/{}", super::GITHUB_BASE_API_URL, gist_id);


        let req = GitHubRequest {
            uri: request_uri,
            body: Some(C::from_json::<PatchGistsUpdate>(body)?),
            method: "PATCH",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch(request)?;

        // --

        if github_response.is_success() {
            Ok(github_response.to_json()?)
        } else {
            match github_response.status_code() {
                422 => Err(GistsUpdateError::Status422(github_response.to_json()?).into()),
                404 => Err(GistsUpdateError::Status404(github_response.to_json()?).into()),
                code => Err(GistsUpdateError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # Update a gist comment
    ///
    /// Updates a comment on a gist.
    /// 
    /// This endpoint supports the following custom media types. For more information, see "[Media types](https://docs.github.com/rest/using-the-rest-api/getting-started-with-the-rest-api#media-types)."
    /// 
    /// - **`application/vnd.github.raw+json`**: Returns the raw markdown. This is the default if you do not pass any specific media type.
    /// - **`application/vnd.github.base64+json`**: Returns the base64-encoded contents. This can be useful if your gist contains any invalid UTF-8 sequences.
    ///
    /// [GitHub API docs for update_comment](https://docs.github.com/rest/gists/comments#update-a-gist-comment)
    ///
    /// ---
    pub async fn update_comment_async(&self, gist_id: &str, comment_id: i64, body: PatchGistsUpdateComment) -> Result<GistComment, AdapterError> {

        let request_uri = format!("{}/gists/{}/comments/{}", super::GITHUB_BASE_API_URL, gist_id, comment_id);


        let req = GitHubRequest {
            uri: request_uri,
            body: Some(C::from_json::<PatchGistsUpdateComment>(body)?),
            method: "PATCH",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch_async(request).await?;

        // --

        if github_response.is_success() {
            Ok(github_response.to_json_async().await?)
        } else {
            match github_response.status_code() {
                404 => Err(GistsUpdateCommentError::Status404(github_response.to_json_async().await?).into()),
                code => Err(GistsUpdateCommentError::Generic { code }.into()),
            }
        }
    }

    /// ---
    ///
    /// # Update a gist comment
    ///
    /// Updates a comment on a gist.
    /// 
    /// This endpoint supports the following custom media types. For more information, see "[Media types](https://docs.github.com/rest/using-the-rest-api/getting-started-with-the-rest-api#media-types)."
    /// 
    /// - **`application/vnd.github.raw+json`**: Returns the raw markdown. This is the default if you do not pass any specific media type.
    /// - **`application/vnd.github.base64+json`**: Returns the base64-encoded contents. This can be useful if your gist contains any invalid UTF-8 sequences.
    ///
    /// [GitHub API docs for update_comment](https://docs.github.com/rest/gists/comments#update-a-gist-comment)
    ///
    /// ---
    #[cfg(not(target_arch = "wasm32"))]
    pub fn update_comment(&self, gist_id: &str, comment_id: i64, body: PatchGistsUpdateComment) -> Result<GistComment, AdapterError> {

        let request_uri = format!("{}/gists/{}/comments/{}", super::GITHUB_BASE_API_URL, gist_id, comment_id);


        let req = GitHubRequest {
            uri: request_uri,
            body: Some(C::from_json::<PatchGistsUpdateComment>(body)?),
            method: "PATCH",
            headers: vec![]
        };

        let request = self.client.build(req)?;

        // --

        let github_response = self.client.fetch(request)?;

        // --

        if github_response.is_success() {
            Ok(github_response.to_json()?)
        } else {
            match github_response.status_code() {
                404 => Err(GistsUpdateCommentError::Status404(github_response.to_json()?).into()),
                code => Err(GistsUpdateCommentError::Generic { code }.into()),
            }
        }
    }

}
