//! Method, error and parameter types for the Users endpoint.
#![allow(
    unused_imports,
)]
/* 
 * GitHub v3 REST API
 *
 * GitHub's v3 REST API.
 *
 * OpenAPI spec version: 1.1.4
 * 
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 */

use serde::Deserialize;

use crate::adapters::{AdapterError, FromJson, GitHubRequest, GitHubRequestBuilder, GitHubResponseExt};
use crate::auth::Auth;
use crate::models::*;

use super::PerPage;

use std::collections::HashMap;
use serde_json::value::Value;

pub struct Users<'api> {
    auth: &'api Auth
}

pub fn new(auth: &Auth) -> Users {
    Users { auth }
}

/// Errors for the [Add an email address for the authenticated user](Users::add_email_for_authenticated_user_async()) endpoint.
#[derive(Debug, thiserror::Error)]
pub enum UsersAddEmailForAuthenticatedUserError {
    #[error(transparent)]
    AdapterError(#[from] AdapterError),
    #[error(transparent)]
    SerdeJson(#[from] serde_json::Error),
    #[error(transparent)]
    SerdeUrl(#[from] serde_urlencoded::ser::Error),


    // -- endpoint errors

    #[error("Validation failed, or the endpoint has been spammed.")]
    Status422(ValidationError),
    #[error("Not modified")]
    Status304,
    #[error("Resource not found")]
    Status404(BasicError),
    #[error("Forbidden")]
    Status403(BasicError),
    #[error("Requires authentication")]
    Status401(BasicError),
    #[error("Status code: {}", code)]
    Generic { code: u16 },
}

/// Errors for the [Add social accounts for the authenticated user](Users::add_social_account_for_authenticated_user_async()) endpoint.
#[derive(Debug, thiserror::Error)]
pub enum UsersAddSocialAccountForAuthenticatedUserError {
    #[error(transparent)]
    AdapterError(#[from] AdapterError),
    #[error(transparent)]
    SerdeJson(#[from] serde_json::Error),
    #[error(transparent)]
    SerdeUrl(#[from] serde_urlencoded::ser::Error),


    // -- endpoint errors

    #[error("Validation failed, or the endpoint has been spammed.")]
    Status422(ValidationError),
    #[error("Not modified")]
    Status304,
    #[error("Resource not found")]
    Status404(BasicError),
    #[error("Forbidden")]
    Status403(BasicError),
    #[error("Requires authentication")]
    Status401(BasicError),
    #[error("Status code: {}", code)]
    Generic { code: u16 },
}

/// Errors for the [Block a user](Users::block_async()) endpoint.
#[derive(Debug, thiserror::Error)]
pub enum UsersBlockError {
    #[error(transparent)]
    AdapterError(#[from] AdapterError),
    #[error(transparent)]
    SerdeJson(#[from] serde_json::Error),
    #[error(transparent)]
    SerdeUrl(#[from] serde_urlencoded::ser::Error),


    // -- endpoint errors

    #[error("Not modified")]
    Status304,
    #[error("Resource not found")]
    Status404(BasicError),
    #[error("Forbidden")]
    Status403(BasicError),
    #[error("Requires authentication")]
    Status401(BasicError),
    #[error("Validation failed, or the endpoint has been spammed.")]
    Status422(ValidationError),
    #[error("Status code: {}", code)]
    Generic { code: u16 },
}

/// Errors for the [Check if a user is blocked by the authenticated user](Users::check_blocked_async()) endpoint.
#[derive(Debug, thiserror::Error)]
pub enum UsersCheckBlockedError {
    #[error(transparent)]
    AdapterError(#[from] AdapterError),
    #[error(transparent)]
    SerdeJson(#[from] serde_json::Error),
    #[error(transparent)]
    SerdeUrl(#[from] serde_urlencoded::ser::Error),


    // -- endpoint errors

    #[error("If the user is not blocked")]
    Status404(BasicError),
    #[error("Not modified")]
    Status304,
    #[error("Forbidden")]
    Status403(BasicError),
    #[error("Requires authentication")]
    Status401(BasicError),
    #[error("Status code: {}", code)]
    Generic { code: u16 },
}

/// Errors for the [Check if a user follows another user](Users::check_following_for_user_async()) endpoint.
#[derive(Debug, thiserror::Error)]
pub enum UsersCheckFollowingForUserError {
    #[error(transparent)]
    AdapterError(#[from] AdapterError),
    #[error(transparent)]
    SerdeJson(#[from] serde_json::Error),
    #[error(transparent)]
    SerdeUrl(#[from] serde_urlencoded::ser::Error),


    // -- endpoint errors

    #[error("if the user does not follow the target user")]
    Status404,
    #[error("Status code: {}", code)]
    Generic { code: u16 },
}

/// Errors for the [Check if a person is followed by the authenticated user](Users::check_person_is_followed_by_authenticated_async()) endpoint.
#[derive(Debug, thiserror::Error)]
pub enum UsersCheckPersonIsFollowedByAuthenticatedError {
    #[error(transparent)]
    AdapterError(#[from] AdapterError),
    #[error(transparent)]
    SerdeJson(#[from] serde_json::Error),
    #[error(transparent)]
    SerdeUrl(#[from] serde_urlencoded::ser::Error),


    // -- endpoint errors

    #[error("if the person is not followed by the authenticated user")]
    Status404(BasicError),
    #[error("Not modified")]
    Status304,
    #[error("Forbidden")]
    Status403(BasicError),
    #[error("Requires authentication")]
    Status401(BasicError),
    #[error("Status code: {}", code)]
    Generic { code: u16 },
}

/// Errors for the [Create a GPG key for the authenticated user](Users::create_gpg_key_for_authenticated_user_async()) endpoint.
#[derive(Debug, thiserror::Error)]
pub enum UsersCreateGpgKeyForAuthenticatedUserError {
    #[error(transparent)]
    AdapterError(#[from] AdapterError),
    #[error(transparent)]
    SerdeJson(#[from] serde_json::Error),
    #[error(transparent)]
    SerdeUrl(#[from] serde_urlencoded::ser::Error),


    // -- endpoint errors

    #[error("Validation failed, or the endpoint has been spammed.")]
    Status422(ValidationError),
    #[error("Not modified")]
    Status304,
    #[error("Resource not found")]
    Status404(BasicError),
    #[error("Forbidden")]
    Status403(BasicError),
    #[error("Requires authentication")]
    Status401(BasicError),
    #[error("Status code: {}", code)]
    Generic { code: u16 },
}

/// Errors for the [Create a public SSH key for the authenticated user](Users::create_public_ssh_key_for_authenticated_user_async()) endpoint.
#[derive(Debug, thiserror::Error)]
pub enum UsersCreatePublicSshKeyForAuthenticatedUserError {
    #[error(transparent)]
    AdapterError(#[from] AdapterError),
    #[error(transparent)]
    SerdeJson(#[from] serde_json::Error),
    #[error(transparent)]
    SerdeUrl(#[from] serde_urlencoded::ser::Error),


    // -- endpoint errors

    #[error("Validation failed, or the endpoint has been spammed.")]
    Status422(ValidationError),
    #[error("Not modified")]
    Status304,
    #[error("Resource not found")]
    Status404(BasicError),
    #[error("Forbidden")]
    Status403(BasicError),
    #[error("Requires authentication")]
    Status401(BasicError),
    #[error("Status code: {}", code)]
    Generic { code: u16 },
}

/// Errors for the [Create a SSH signing key for the authenticated user](Users::create_ssh_signing_key_for_authenticated_user_async()) endpoint.
#[derive(Debug, thiserror::Error)]
pub enum UsersCreateSshSigningKeyForAuthenticatedUserError {
    #[error(transparent)]
    AdapterError(#[from] AdapterError),
    #[error(transparent)]
    SerdeJson(#[from] serde_json::Error),
    #[error(transparent)]
    SerdeUrl(#[from] serde_urlencoded::ser::Error),


    // -- endpoint errors

    #[error("Validation failed, or the endpoint has been spammed.")]
    Status422(ValidationError),
    #[error("Not modified")]
    Status304,
    #[error("Resource not found")]
    Status404(BasicError),
    #[error("Forbidden")]
    Status403(BasicError),
    #[error("Requires authentication")]
    Status401(BasicError),
    #[error("Status code: {}", code)]
    Generic { code: u16 },
}

/// Errors for the [Delete an email address for the authenticated user](Users::delete_email_for_authenticated_user_async()) endpoint.
#[derive(Debug, thiserror::Error)]
pub enum UsersDeleteEmailForAuthenticatedUserError {
    #[error(transparent)]
    AdapterError(#[from] AdapterError),
    #[error(transparent)]
    SerdeJson(#[from] serde_json::Error),
    #[error(transparent)]
    SerdeUrl(#[from] serde_urlencoded::ser::Error),


    // -- endpoint errors

    #[error("Not modified")]
    Status304,
    #[error("Resource not found")]
    Status404(BasicError),
    #[error("Forbidden")]
    Status403(BasicError),
    #[error("Requires authentication")]
    Status401(BasicError),
    #[error("Validation failed, or the endpoint has been spammed.")]
    Status422(ValidationError),
    #[error("Status code: {}", code)]
    Generic { code: u16 },
}

/// Errors for the [Delete a GPG key for the authenticated user](Users::delete_gpg_key_for_authenticated_user_async()) endpoint.
#[derive(Debug, thiserror::Error)]
pub enum UsersDeleteGpgKeyForAuthenticatedUserError {
    #[error(transparent)]
    AdapterError(#[from] AdapterError),
    #[error(transparent)]
    SerdeJson(#[from] serde_json::Error),
    #[error(transparent)]
    SerdeUrl(#[from] serde_urlencoded::ser::Error),


    // -- endpoint errors

    #[error("Resource not found")]
    Status404(BasicError),
    #[error("Validation failed, or the endpoint has been spammed.")]
    Status422(ValidationError),
    #[error("Not modified")]
    Status304,
    #[error("Forbidden")]
    Status403(BasicError),
    #[error("Requires authentication")]
    Status401(BasicError),
    #[error("Status code: {}", code)]
    Generic { code: u16 },
}

/// Errors for the [Delete a public SSH key for the authenticated user](Users::delete_public_ssh_key_for_authenticated_user_async()) endpoint.
#[derive(Debug, thiserror::Error)]
pub enum UsersDeletePublicSshKeyForAuthenticatedUserError {
    #[error(transparent)]
    AdapterError(#[from] AdapterError),
    #[error(transparent)]
    SerdeJson(#[from] serde_json::Error),
    #[error(transparent)]
    SerdeUrl(#[from] serde_urlencoded::ser::Error),


    // -- endpoint errors

    #[error("Not modified")]
    Status304,
    #[error("Resource not found")]
    Status404(BasicError),
    #[error("Forbidden")]
    Status403(BasicError),
    #[error("Requires authentication")]
    Status401(BasicError),
    #[error("Status code: {}", code)]
    Generic { code: u16 },
}

/// Errors for the [Delete social accounts for the authenticated user](Users::delete_social_account_for_authenticated_user_async()) endpoint.
#[derive(Debug, thiserror::Error)]
pub enum UsersDeleteSocialAccountForAuthenticatedUserError {
    #[error(transparent)]
    AdapterError(#[from] AdapterError),
    #[error(transparent)]
    SerdeJson(#[from] serde_json::Error),
    #[error(transparent)]
    SerdeUrl(#[from] serde_urlencoded::ser::Error),


    // -- endpoint errors

    #[error("Validation failed, or the endpoint has been spammed.")]
    Status422(ValidationError),
    #[error("Not modified")]
    Status304,
    #[error("Resource not found")]
    Status404(BasicError),
    #[error("Forbidden")]
    Status403(BasicError),
    #[error("Requires authentication")]
    Status401(BasicError),
    #[error("Status code: {}", code)]
    Generic { code: u16 },
}

/// Errors for the [Delete an SSH signing key for the authenticated user](Users::delete_ssh_signing_key_for_authenticated_user_async()) endpoint.
#[derive(Debug, thiserror::Error)]
pub enum UsersDeleteSshSigningKeyForAuthenticatedUserError {
    #[error(transparent)]
    AdapterError(#[from] AdapterError),
    #[error(transparent)]
    SerdeJson(#[from] serde_json::Error),
    #[error(transparent)]
    SerdeUrl(#[from] serde_urlencoded::ser::Error),


    // -- endpoint errors

    #[error("Not modified")]
    Status304,
    #[error("Resource not found")]
    Status404(BasicError),
    #[error("Forbidden")]
    Status403(BasicError),
    #[error("Requires authentication")]
    Status401(BasicError),
    #[error("Status code: {}", code)]
    Generic { code: u16 },
}

/// Errors for the [Follow a user](Users::follow_async()) endpoint.
#[derive(Debug, thiserror::Error)]
pub enum UsersFollowError {
    #[error(transparent)]
    AdapterError(#[from] AdapterError),
    #[error(transparent)]
    SerdeJson(#[from] serde_json::Error),
    #[error(transparent)]
    SerdeUrl(#[from] serde_urlencoded::ser::Error),


    // -- endpoint errors

    #[error("Not modified")]
    Status304,
    #[error("Resource not found")]
    Status404(BasicError),
    #[error("Forbidden")]
    Status403(BasicError),
    #[error("Requires authentication")]
    Status401(BasicError),
    #[error("Status code: {}", code)]
    Generic { code: u16 },
}

/// Errors for the [Get the authenticated user](Users::get_authenticated_async()) endpoint.
#[derive(Debug, thiserror::Error)]
pub enum UsersGetAuthenticatedError {
    #[error(transparent)]
    AdapterError(#[from] AdapterError),
    #[error(transparent)]
    SerdeJson(#[from] serde_json::Error),
    #[error(transparent)]
    SerdeUrl(#[from] serde_urlencoded::ser::Error),


    // -- endpoint errors

    #[error("Not modified")]
    Status304,
    #[error("Forbidden")]
    Status403(BasicError),
    #[error("Requires authentication")]
    Status401(BasicError),
    #[error("Status code: {}", code)]
    Generic { code: u16 },
}

/// Errors for the [Get a user using their ID](Users::get_by_id_async()) endpoint.
#[derive(Debug, thiserror::Error)]
pub enum UsersGetByIdError {
    #[error(transparent)]
    AdapterError(#[from] AdapterError),
    #[error(transparent)]
    SerdeJson(#[from] serde_json::Error),
    #[error(transparent)]
    SerdeUrl(#[from] serde_urlencoded::ser::Error),


    // -- endpoint errors

    #[error("Resource not found")]
    Status404(BasicError),
    #[error("Status code: {}", code)]
    Generic { code: u16 },
}

/// Errors for the [Get a user](Users::get_by_username_async()) endpoint.
#[derive(Debug, thiserror::Error)]
pub enum UsersGetByUsernameError {
    #[error(transparent)]
    AdapterError(#[from] AdapterError),
    #[error(transparent)]
    SerdeJson(#[from] serde_json::Error),
    #[error(transparent)]
    SerdeUrl(#[from] serde_urlencoded::ser::Error),


    // -- endpoint errors

    #[error("Resource not found")]
    Status404(BasicError),
    #[error("Status code: {}", code)]
    Generic { code: u16 },
}

/// Errors for the [Get contextual information for a user](Users::get_context_for_user_async()) endpoint.
#[derive(Debug, thiserror::Error)]
pub enum UsersGetContextForUserError {
    #[error(transparent)]
    AdapterError(#[from] AdapterError),
    #[error(transparent)]
    SerdeJson(#[from] serde_json::Error),
    #[error(transparent)]
    SerdeUrl(#[from] serde_urlencoded::ser::Error),


    // -- endpoint errors

    #[error("Resource not found")]
    Status404(BasicError),
    #[error("Validation failed, or the endpoint has been spammed.")]
    Status422(ValidationError),
    #[error("Status code: {}", code)]
    Generic { code: u16 },
}

/// Errors for the [Get a GPG key for the authenticated user](Users::get_gpg_key_for_authenticated_user_async()) endpoint.
#[derive(Debug, thiserror::Error)]
pub enum UsersGetGpgKeyForAuthenticatedUserError {
    #[error(transparent)]
    AdapterError(#[from] AdapterError),
    #[error(transparent)]
    SerdeJson(#[from] serde_json::Error),
    #[error(transparent)]
    SerdeUrl(#[from] serde_urlencoded::ser::Error),


    // -- endpoint errors

    #[error("Resource not found")]
    Status404(BasicError),
    #[error("Not modified")]
    Status304,
    #[error("Forbidden")]
    Status403(BasicError),
    #[error("Requires authentication")]
    Status401(BasicError),
    #[error("Status code: {}", code)]
    Generic { code: u16 },
}

/// Errors for the [Get a public SSH key for the authenticated user](Users::get_public_ssh_key_for_authenticated_user_async()) endpoint.
#[derive(Debug, thiserror::Error)]
pub enum UsersGetPublicSshKeyForAuthenticatedUserError {
    #[error(transparent)]
    AdapterError(#[from] AdapterError),
    #[error(transparent)]
    SerdeJson(#[from] serde_json::Error),
    #[error(transparent)]
    SerdeUrl(#[from] serde_urlencoded::ser::Error),


    // -- endpoint errors

    #[error("Resource not found")]
    Status404(BasicError),
    #[error("Not modified")]
    Status304,
    #[error("Forbidden")]
    Status403(BasicError),
    #[error("Requires authentication")]
    Status401(BasicError),
    #[error("Status code: {}", code)]
    Generic { code: u16 },
}

/// Errors for the [Get an SSH signing key for the authenticated user](Users::get_ssh_signing_key_for_authenticated_user_async()) endpoint.
#[derive(Debug, thiserror::Error)]
pub enum UsersGetSshSigningKeyForAuthenticatedUserError {
    #[error(transparent)]
    AdapterError(#[from] AdapterError),
    #[error(transparent)]
    SerdeJson(#[from] serde_json::Error),
    #[error(transparent)]
    SerdeUrl(#[from] serde_urlencoded::ser::Error),


    // -- endpoint errors

    #[error("Resource not found")]
    Status404(BasicError),
    #[error("Not modified")]
    Status304,
    #[error("Forbidden")]
    Status403(BasicError),
    #[error("Requires authentication")]
    Status401(BasicError),
    #[error("Status code: {}", code)]
    Generic { code: u16 },
}

/// Errors for the [List users](Users::list_async()) endpoint.
#[derive(Debug, thiserror::Error)]
pub enum UsersListError {
    #[error(transparent)]
    AdapterError(#[from] AdapterError),
    #[error(transparent)]
    SerdeJson(#[from] serde_json::Error),
    #[error(transparent)]
    SerdeUrl(#[from] serde_urlencoded::ser::Error),


    // -- endpoint errors

    #[error("Not modified")]
    Status304,
    #[error("Status code: {}", code)]
    Generic { code: u16 },
}

/// Errors for the [List attestations](Users::list_attestations_async()) endpoint.
#[derive(Debug, thiserror::Error)]
pub enum UsersListAttestationsError {
    #[error(transparent)]
    AdapterError(#[from] AdapterError),
    #[error(transparent)]
    SerdeJson(#[from] serde_json::Error),
    #[error(transparent)]
    SerdeUrl(#[from] serde_urlencoded::ser::Error),


    // -- endpoint errors

    #[error("Response")]
    Status201(EmptyObject),
    #[error("Response")]
    Status204,
    #[error("Resource not found")]
    Status404(BasicError),
    #[error("Status code: {}", code)]
    Generic { code: u16 },
}

/// Errors for the [List users blocked by the authenticated user](Users::list_blocked_by_authenticated_user_async()) endpoint.
#[derive(Debug, thiserror::Error)]
pub enum UsersListBlockedByAuthenticatedUserError {
    #[error(transparent)]
    AdapterError(#[from] AdapterError),
    #[error(transparent)]
    SerdeJson(#[from] serde_json::Error),
    #[error(transparent)]
    SerdeUrl(#[from] serde_urlencoded::ser::Error),


    // -- endpoint errors

    #[error("Not modified")]
    Status304,
    #[error("Resource not found")]
    Status404(BasicError),
    #[error("Forbidden")]
    Status403(BasicError),
    #[error("Requires authentication")]
    Status401(BasicError),
    #[error("Status code: {}", code)]
    Generic { code: u16 },
}

/// Errors for the [List email addresses for the authenticated user](Users::list_emails_for_authenticated_user_async()) endpoint.
#[derive(Debug, thiserror::Error)]
pub enum UsersListEmailsForAuthenticatedUserError {
    #[error(transparent)]
    AdapterError(#[from] AdapterError),
    #[error(transparent)]
    SerdeJson(#[from] serde_json::Error),
    #[error(transparent)]
    SerdeUrl(#[from] serde_urlencoded::ser::Error),


    // -- endpoint errors

    #[error("Not modified")]
    Status304,
    #[error("Resource not found")]
    Status404(BasicError),
    #[error("Forbidden")]
    Status403(BasicError),
    #[error("Requires authentication")]
    Status401(BasicError),
    #[error("Status code: {}", code)]
    Generic { code: u16 },
}

/// Errors for the [List the people the authenticated user follows](Users::list_followed_by_authenticated_user_async()) endpoint.
#[derive(Debug, thiserror::Error)]
pub enum UsersListFollowedByAuthenticatedUserError {
    #[error(transparent)]
    AdapterError(#[from] AdapterError),
    #[error(transparent)]
    SerdeJson(#[from] serde_json::Error),
    #[error(transparent)]
    SerdeUrl(#[from] serde_urlencoded::ser::Error),


    // -- endpoint errors

    #[error("Not modified")]
    Status304,
    #[error("Forbidden")]
    Status403(BasicError),
    #[error("Requires authentication")]
    Status401(BasicError),
    #[error("Status code: {}", code)]
    Generic { code: u16 },
}

/// Errors for the [List followers of the authenticated user](Users::list_followers_for_authenticated_user_async()) endpoint.
#[derive(Debug, thiserror::Error)]
pub enum UsersListFollowersForAuthenticatedUserError {
    #[error(transparent)]
    AdapterError(#[from] AdapterError),
    #[error(transparent)]
    SerdeJson(#[from] serde_json::Error),
    #[error(transparent)]
    SerdeUrl(#[from] serde_urlencoded::ser::Error),


    // -- endpoint errors

    #[error("Not modified")]
    Status304,
    #[error("Forbidden")]
    Status403(BasicError),
    #[error("Requires authentication")]
    Status401(BasicError),
    #[error("Status code: {}", code)]
    Generic { code: u16 },
}

/// Errors for the [List followers of a user](Users::list_followers_for_user_async()) endpoint.
#[derive(Debug, thiserror::Error)]
pub enum UsersListFollowersForUserError {
    #[error(transparent)]
    AdapterError(#[from] AdapterError),
    #[error(transparent)]
    SerdeJson(#[from] serde_json::Error),
    #[error(transparent)]
    SerdeUrl(#[from] serde_urlencoded::ser::Error),


    // -- endpoint errors

    #[error("Status code: {}", code)]
    Generic { code: u16 },
}

/// Errors for the [List the people a user follows](Users::list_following_for_user_async()) endpoint.
#[derive(Debug, thiserror::Error)]
pub enum UsersListFollowingForUserError {
    #[error(transparent)]
    AdapterError(#[from] AdapterError),
    #[error(transparent)]
    SerdeJson(#[from] serde_json::Error),
    #[error(transparent)]
    SerdeUrl(#[from] serde_urlencoded::ser::Error),


    // -- endpoint errors

    #[error("Status code: {}", code)]
    Generic { code: u16 },
}

/// Errors for the [List GPG keys for the authenticated user](Users::list_gpg_keys_for_authenticated_user_async()) endpoint.
#[derive(Debug, thiserror::Error)]
pub enum UsersListGpgKeysForAuthenticatedUserError {
    #[error(transparent)]
    AdapterError(#[from] AdapterError),
    #[error(transparent)]
    SerdeJson(#[from] serde_json::Error),
    #[error(transparent)]
    SerdeUrl(#[from] serde_urlencoded::ser::Error),


    // -- endpoint errors

    #[error("Not modified")]
    Status304,
    #[error("Resource not found")]
    Status404(BasicError),
    #[error("Forbidden")]
    Status403(BasicError),
    #[error("Requires authentication")]
    Status401(BasicError),
    #[error("Status code: {}", code)]
    Generic { code: u16 },
}

/// Errors for the [List GPG keys for a user](Users::list_gpg_keys_for_user_async()) endpoint.
#[derive(Debug, thiserror::Error)]
pub enum UsersListGpgKeysForUserError {
    #[error(transparent)]
    AdapterError(#[from] AdapterError),
    #[error(transparent)]
    SerdeJson(#[from] serde_json::Error),
    #[error(transparent)]
    SerdeUrl(#[from] serde_urlencoded::ser::Error),


    // -- endpoint errors

    #[error("Status code: {}", code)]
    Generic { code: u16 },
}

/// Errors for the [List public email addresses for the authenticated user](Users::list_public_emails_for_authenticated_user_async()) endpoint.
#[derive(Debug, thiserror::Error)]
pub enum UsersListPublicEmailsForAuthenticatedUserError {
    #[error(transparent)]
    AdapterError(#[from] AdapterError),
    #[error(transparent)]
    SerdeJson(#[from] serde_json::Error),
    #[error(transparent)]
    SerdeUrl(#[from] serde_urlencoded::ser::Error),


    // -- endpoint errors

    #[error("Not modified")]
    Status304,
    #[error("Resource not found")]
    Status404(BasicError),
    #[error("Forbidden")]
    Status403(BasicError),
    #[error("Requires authentication")]
    Status401(BasicError),
    #[error("Status code: {}", code)]
    Generic { code: u16 },
}

/// Errors for the [List public keys for a user](Users::list_public_keys_for_user_async()) endpoint.
#[derive(Debug, thiserror::Error)]
pub enum UsersListPublicKeysForUserError {
    #[error(transparent)]
    AdapterError(#[from] AdapterError),
    #[error(transparent)]
    SerdeJson(#[from] serde_json::Error),
    #[error(transparent)]
    SerdeUrl(#[from] serde_urlencoded::ser::Error),


    // -- endpoint errors

    #[error("Status code: {}", code)]
    Generic { code: u16 },
}

/// Errors for the [List public SSH keys for the authenticated user](Users::list_public_ssh_keys_for_authenticated_user_async()) endpoint.
#[derive(Debug, thiserror::Error)]
pub enum UsersListPublicSshKeysForAuthenticatedUserError {
    #[error(transparent)]
    AdapterError(#[from] AdapterError),
    #[error(transparent)]
    SerdeJson(#[from] serde_json::Error),
    #[error(transparent)]
    SerdeUrl(#[from] serde_urlencoded::ser::Error),


    // -- endpoint errors

    #[error("Not modified")]
    Status304,
    #[error("Resource not found")]
    Status404(BasicError),
    #[error("Forbidden")]
    Status403(BasicError),
    #[error("Requires authentication")]
    Status401(BasicError),
    #[error("Status code: {}", code)]
    Generic { code: u16 },
}

/// Errors for the [List social accounts for the authenticated user](Users::list_social_accounts_for_authenticated_user_async()) endpoint.
#[derive(Debug, thiserror::Error)]
pub enum UsersListSocialAccountsForAuthenticatedUserError {
    #[error(transparent)]
    AdapterError(#[from] AdapterError),
    #[error(transparent)]
    SerdeJson(#[from] serde_json::Error),
    #[error(transparent)]
    SerdeUrl(#[from] serde_urlencoded::ser::Error),


    // -- endpoint errors

    #[error("Not modified")]
    Status304,
    #[error("Resource not found")]
    Status404(BasicError),
    #[error("Forbidden")]
    Status403(BasicError),
    #[error("Requires authentication")]
    Status401(BasicError),
    #[error("Status code: {}", code)]
    Generic { code: u16 },
}

/// Errors for the [List social accounts for a user](Users::list_social_accounts_for_user_async()) endpoint.
#[derive(Debug, thiserror::Error)]
pub enum UsersListSocialAccountsForUserError {
    #[error(transparent)]
    AdapterError(#[from] AdapterError),
    #[error(transparent)]
    SerdeJson(#[from] serde_json::Error),
    #[error(transparent)]
    SerdeUrl(#[from] serde_urlencoded::ser::Error),


    // -- endpoint errors

    #[error("Status code: {}", code)]
    Generic { code: u16 },
}

/// Errors for the [List SSH signing keys for the authenticated user](Users::list_ssh_signing_keys_for_authenticated_user_async()) endpoint.
#[derive(Debug, thiserror::Error)]
pub enum UsersListSshSigningKeysForAuthenticatedUserError {
    #[error(transparent)]
    AdapterError(#[from] AdapterError),
    #[error(transparent)]
    SerdeJson(#[from] serde_json::Error),
    #[error(transparent)]
    SerdeUrl(#[from] serde_urlencoded::ser::Error),


    // -- endpoint errors

    #[error("Not modified")]
    Status304,
    #[error("Resource not found")]
    Status404(BasicError),
    #[error("Forbidden")]
    Status403(BasicError),
    #[error("Requires authentication")]
    Status401(BasicError),
    #[error("Status code: {}", code)]
    Generic { code: u16 },
}

/// Errors for the [List SSH signing keys for a user](Users::list_ssh_signing_keys_for_user_async()) endpoint.
#[derive(Debug, thiserror::Error)]
pub enum UsersListSshSigningKeysForUserError {
    #[error(transparent)]
    AdapterError(#[from] AdapterError),
    #[error(transparent)]
    SerdeJson(#[from] serde_json::Error),
    #[error(transparent)]
    SerdeUrl(#[from] serde_urlencoded::ser::Error),


    // -- endpoint errors

    #[error("Status code: {}", code)]
    Generic { code: u16 },
}

/// Errors for the [Set primary email visibility for the authenticated user](Users::set_primary_email_visibility_for_authenticated_user_async()) endpoint.
#[derive(Debug, thiserror::Error)]
pub enum UsersSetPrimaryEmailVisibilityForAuthenticatedUserError {
    #[error(transparent)]
    AdapterError(#[from] AdapterError),
    #[error(transparent)]
    SerdeJson(#[from] serde_json::Error),
    #[error(transparent)]
    SerdeUrl(#[from] serde_urlencoded::ser::Error),


    // -- endpoint errors

    #[error("Not modified")]
    Status304,
    #[error("Resource not found")]
    Status404(BasicError),
    #[error("Forbidden")]
    Status403(BasicError),
    #[error("Requires authentication")]
    Status401(BasicError),
    #[error("Validation failed, or the endpoint has been spammed.")]
    Status422(ValidationError),
    #[error("Status code: {}", code)]
    Generic { code: u16 },
}

/// Errors for the [Unblock a user](Users::unblock_async()) endpoint.
#[derive(Debug, thiserror::Error)]
pub enum UsersUnblockError {
    #[error(transparent)]
    AdapterError(#[from] AdapterError),
    #[error(transparent)]
    SerdeJson(#[from] serde_json::Error),
    #[error(transparent)]
    SerdeUrl(#[from] serde_urlencoded::ser::Error),


    // -- endpoint errors

    #[error("Not modified")]
    Status304,
    #[error("Forbidden")]
    Status403(BasicError),
    #[error("Requires authentication")]
    Status401(BasicError),
    #[error("Resource not found")]
    Status404(BasicError),
    #[error("Status code: {}", code)]
    Generic { code: u16 },
}

/// Errors for the [Unfollow a user](Users::unfollow_async()) endpoint.
#[derive(Debug, thiserror::Error)]
pub enum UsersUnfollowError {
    #[error(transparent)]
    AdapterError(#[from] AdapterError),
    #[error(transparent)]
    SerdeJson(#[from] serde_json::Error),
    #[error(transparent)]
    SerdeUrl(#[from] serde_urlencoded::ser::Error),


    // -- endpoint errors

    #[error("Not modified")]
    Status304,
    #[error("Resource not found")]
    Status404(BasicError),
    #[error("Forbidden")]
    Status403(BasicError),
    #[error("Requires authentication")]
    Status401(BasicError),
    #[error("Status code: {}", code)]
    Generic { code: u16 },
}

/// Errors for the [Update the authenticated user](Users::update_authenticated_async()) endpoint.
#[derive(Debug, thiserror::Error)]
pub enum UsersUpdateAuthenticatedError {
    #[error(transparent)]
    AdapterError(#[from] AdapterError),
    #[error(transparent)]
    SerdeJson(#[from] serde_json::Error),
    #[error(transparent)]
    SerdeUrl(#[from] serde_urlencoded::ser::Error),


    // -- endpoint errors

    #[error("Not modified")]
    Status304,
    #[error("Resource not found")]
    Status404(BasicError),
    #[error("Forbidden")]
    Status403(BasicError),
    #[error("Requires authentication")]
    Status401(BasicError),
    #[error("Validation failed, or the endpoint has been spammed.")]
    Status422(ValidationError),
    #[error("Status code: {}", code)]
    Generic { code: u16 },
}


/// Query parameters for the [Get contextual information for a user](Users::get_context_for_user_async()) endpoint.
#[derive(Default, Serialize)]
pub struct UsersGetContextForUserParams<'req> {
    /// Identifies which additional information you'd like to receive about the person's hovercard. Can be `organization`, `repository`, `issue`, `pull_request`. **Required** when using `subject_id`.
    subject_type: Option<&'req str>, 
    /// Uses the ID for the `subject_type` you specified. **Required** when using `subject_type`.
    subject_id: Option<&'req str>
}

impl<'req> UsersGetContextForUserParams<'req> {
    pub fn new() -> Self {
        Self::default()
    }

    /// Identifies which additional information you'd like to receive about the person's hovercard. Can be `organization`, `repository`, `issue`, `pull_request`. **Required** when using `subject_id`.
    pub fn subject_type(self, subject_type: &'req str) -> Self {
        Self {
            subject_type: Some(subject_type),
            subject_id: self.subject_id, 
        }
    }

    /// Uses the ID for the `subject_type` you specified. **Required** when using `subject_type`.
    pub fn subject_id(self, subject_id: &'req str) -> Self {
        Self {
            subject_type: self.subject_type, 
            subject_id: Some(subject_id),
        }
    }
}

/// Query parameters for the [List users](Users::list_async()) endpoint.
#[derive(Default, Serialize)]
pub struct UsersListParams {
    /// A user ID. Only return users with an ID greater than this ID.
    since: Option<i32>, 
    /// The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    per_page: Option<u16>
}

impl UsersListParams {
    pub fn new() -> Self {
        Self::default()
    }

    /// A user ID. Only return users with an ID greater than this ID.
    pub fn since(self, since: i32) -> Self {
        Self {
            since: Some(since),
            per_page: self.per_page, 
        }
    }

    /// The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    pub fn per_page(self, per_page: u16) -> Self {
        Self {
            since: self.since, 
            per_page: Some(per_page),
        }
    }
}

/// Query parameters for the [List attestations](Users::list_attestations_async()) endpoint.
#[derive(Default, Serialize)]
pub struct UsersListAttestationsParams<'req> {
    /// The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    per_page: Option<u16>, 
    /// A cursor, as given in the [Link header](https://docs.github.com/rest/guides/using-pagination-in-the-rest-api#using-link-headers). If specified, the query only searches for results before this cursor. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    before: Option<&'req str>, 
    /// A cursor, as given in the [Link header](https://docs.github.com/rest/guides/using-pagination-in-the-rest-api#using-link-headers). If specified, the query only searches for results after this cursor. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    after: Option<&'req str>
}

impl<'req> UsersListAttestationsParams<'req> {
    pub fn new() -> Self {
        Self::default()
    }

    /// The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    pub fn per_page(self, per_page: u16) -> Self {
        Self {
            per_page: Some(per_page),
            before: self.before, 
            after: self.after, 
        }
    }

    /// A cursor, as given in the [Link header](https://docs.github.com/rest/guides/using-pagination-in-the-rest-api#using-link-headers). If specified, the query only searches for results before this cursor. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    pub fn before(self, before: &'req str) -> Self {
        Self {
            per_page: self.per_page, 
            before: Some(before),
            after: self.after, 
        }
    }

    /// A cursor, as given in the [Link header](https://docs.github.com/rest/guides/using-pagination-in-the-rest-api#using-link-headers). If specified, the query only searches for results after this cursor. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    pub fn after(self, after: &'req str) -> Self {
        Self {
            per_page: self.per_page, 
            before: self.before, 
            after: Some(after),
        }
    }
}

/// Query parameters for the [List users blocked by the authenticated user](Users::list_blocked_by_authenticated_user_async()) endpoint.
#[derive(Default, Serialize)]
pub struct UsersListBlockedByAuthenticatedUserParams {
    /// The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    per_page: Option<u16>, 
    /// The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    page: Option<u16>
}

impl UsersListBlockedByAuthenticatedUserParams {
    pub fn new() -> Self {
        Self::default()
    }

    /// The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    pub fn per_page(self, per_page: u16) -> Self {
        Self {
            per_page: Some(per_page),
            page: self.page, 
        }
    }

    /// The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    pub fn page(self, page: u16) -> Self {
        Self {
            per_page: self.per_page, 
            page: Some(page),
        }
    }
}

impl<'enc> From<&'enc PerPage> for UsersListBlockedByAuthenticatedUserParams {
    fn from(per_page: &'enc PerPage) -> Self {
        Self {
            per_page: Some(per_page.per_page),
            page: Some(per_page.page),
            ..Default::default()
        }
    }
}
/// Query parameters for the [List email addresses for the authenticated user](Users::list_emails_for_authenticated_user_async()) endpoint.
#[derive(Default, Serialize)]
pub struct UsersListEmailsForAuthenticatedUserParams {
    /// The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    per_page: Option<u16>, 
    /// The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    page: Option<u16>
}

impl UsersListEmailsForAuthenticatedUserParams {
    pub fn new() -> Self {
        Self::default()
    }

    /// The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    pub fn per_page(self, per_page: u16) -> Self {
        Self {
            per_page: Some(per_page),
            page: self.page, 
        }
    }

    /// The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    pub fn page(self, page: u16) -> Self {
        Self {
            per_page: self.per_page, 
            page: Some(page),
        }
    }
}

impl<'enc> From<&'enc PerPage> for UsersListEmailsForAuthenticatedUserParams {
    fn from(per_page: &'enc PerPage) -> Self {
        Self {
            per_page: Some(per_page.per_page),
            page: Some(per_page.page),
            ..Default::default()
        }
    }
}
/// Query parameters for the [List the people the authenticated user follows](Users::list_followed_by_authenticated_user_async()) endpoint.
#[derive(Default, Serialize)]
pub struct UsersListFollowedByAuthenticatedUserParams {
    /// The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    per_page: Option<u16>, 
    /// The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    page: Option<u16>
}

impl UsersListFollowedByAuthenticatedUserParams {
    pub fn new() -> Self {
        Self::default()
    }

    /// The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    pub fn per_page(self, per_page: u16) -> Self {
        Self {
            per_page: Some(per_page),
            page: self.page, 
        }
    }

    /// The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    pub fn page(self, page: u16) -> Self {
        Self {
            per_page: self.per_page, 
            page: Some(page),
        }
    }
}

impl<'enc> From<&'enc PerPage> for UsersListFollowedByAuthenticatedUserParams {
    fn from(per_page: &'enc PerPage) -> Self {
        Self {
            per_page: Some(per_page.per_page),
            page: Some(per_page.page),
            ..Default::default()
        }
    }
}
/// Query parameters for the [List followers of the authenticated user](Users::list_followers_for_authenticated_user_async()) endpoint.
#[derive(Default, Serialize)]
pub struct UsersListFollowersForAuthenticatedUserParams {
    /// The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    per_page: Option<u16>, 
    /// The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    page: Option<u16>
}

impl UsersListFollowersForAuthenticatedUserParams {
    pub fn new() -> Self {
        Self::default()
    }

    /// The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    pub fn per_page(self, per_page: u16) -> Self {
        Self {
            per_page: Some(per_page),
            page: self.page, 
        }
    }

    /// The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    pub fn page(self, page: u16) -> Self {
        Self {
            per_page: self.per_page, 
            page: Some(page),
        }
    }
}

impl<'enc> From<&'enc PerPage> for UsersListFollowersForAuthenticatedUserParams {
    fn from(per_page: &'enc PerPage) -> Self {
        Self {
            per_page: Some(per_page.per_page),
            page: Some(per_page.page),
            ..Default::default()
        }
    }
}
/// Query parameters for the [List followers of a user](Users::list_followers_for_user_async()) endpoint.
#[derive(Default, Serialize)]
pub struct UsersListFollowersForUserParams {
    /// The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    per_page: Option<u16>, 
    /// The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    page: Option<u16>
}

impl UsersListFollowersForUserParams {
    pub fn new() -> Self {
        Self::default()
    }

    /// The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    pub fn per_page(self, per_page: u16) -> Self {
        Self {
            per_page: Some(per_page),
            page: self.page, 
        }
    }

    /// The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    pub fn page(self, page: u16) -> Self {
        Self {
            per_page: self.per_page, 
            page: Some(page),
        }
    }
}

impl<'enc> From<&'enc PerPage> for UsersListFollowersForUserParams {
    fn from(per_page: &'enc PerPage) -> Self {
        Self {
            per_page: Some(per_page.per_page),
            page: Some(per_page.page),
            ..Default::default()
        }
    }
}
/// Query parameters for the [List the people a user follows](Users::list_following_for_user_async()) endpoint.
#[derive(Default, Serialize)]
pub struct UsersListFollowingForUserParams {
    /// The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    per_page: Option<u16>, 
    /// The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    page: Option<u16>
}

impl UsersListFollowingForUserParams {
    pub fn new() -> Self {
        Self::default()
    }

    /// The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    pub fn per_page(self, per_page: u16) -> Self {
        Self {
            per_page: Some(per_page),
            page: self.page, 
        }
    }

    /// The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    pub fn page(self, page: u16) -> Self {
        Self {
            per_page: self.per_page, 
            page: Some(page),
        }
    }
}

impl<'enc> From<&'enc PerPage> for UsersListFollowingForUserParams {
    fn from(per_page: &'enc PerPage) -> Self {
        Self {
            per_page: Some(per_page.per_page),
            page: Some(per_page.page),
            ..Default::default()
        }
    }
}
/// Query parameters for the [List GPG keys for the authenticated user](Users::list_gpg_keys_for_authenticated_user_async()) endpoint.
#[derive(Default, Serialize)]
pub struct UsersListGpgKeysForAuthenticatedUserParams {
    /// The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    per_page: Option<u16>, 
    /// The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    page: Option<u16>
}

impl UsersListGpgKeysForAuthenticatedUserParams {
    pub fn new() -> Self {
        Self::default()
    }

    /// The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    pub fn per_page(self, per_page: u16) -> Self {
        Self {
            per_page: Some(per_page),
            page: self.page, 
        }
    }

    /// The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    pub fn page(self, page: u16) -> Self {
        Self {
            per_page: self.per_page, 
            page: Some(page),
        }
    }
}

impl<'enc> From<&'enc PerPage> for UsersListGpgKeysForAuthenticatedUserParams {
    fn from(per_page: &'enc PerPage) -> Self {
        Self {
            per_page: Some(per_page.per_page),
            page: Some(per_page.page),
            ..Default::default()
        }
    }
}
/// Query parameters for the [List GPG keys for a user](Users::list_gpg_keys_for_user_async()) endpoint.
#[derive(Default, Serialize)]
pub struct UsersListGpgKeysForUserParams {
    /// The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    per_page: Option<u16>, 
    /// The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    page: Option<u16>
}

impl UsersListGpgKeysForUserParams {
    pub fn new() -> Self {
        Self::default()
    }

    /// The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    pub fn per_page(self, per_page: u16) -> Self {
        Self {
            per_page: Some(per_page),
            page: self.page, 
        }
    }

    /// The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    pub fn page(self, page: u16) -> Self {
        Self {
            per_page: self.per_page, 
            page: Some(page),
        }
    }
}

impl<'enc> From<&'enc PerPage> for UsersListGpgKeysForUserParams {
    fn from(per_page: &'enc PerPage) -> Self {
        Self {
            per_page: Some(per_page.per_page),
            page: Some(per_page.page),
            ..Default::default()
        }
    }
}
/// Query parameters for the [List public email addresses for the authenticated user](Users::list_public_emails_for_authenticated_user_async()) endpoint.
#[derive(Default, Serialize)]
pub struct UsersListPublicEmailsForAuthenticatedUserParams {
    /// The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    per_page: Option<u16>, 
    /// The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    page: Option<u16>
}

impl UsersListPublicEmailsForAuthenticatedUserParams {
    pub fn new() -> Self {
        Self::default()
    }

    /// The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    pub fn per_page(self, per_page: u16) -> Self {
        Self {
            per_page: Some(per_page),
            page: self.page, 
        }
    }

    /// The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    pub fn page(self, page: u16) -> Self {
        Self {
            per_page: self.per_page, 
            page: Some(page),
        }
    }
}

impl<'enc> From<&'enc PerPage> for UsersListPublicEmailsForAuthenticatedUserParams {
    fn from(per_page: &'enc PerPage) -> Self {
        Self {
            per_page: Some(per_page.per_page),
            page: Some(per_page.page),
            ..Default::default()
        }
    }
}
/// Query parameters for the [List public keys for a user](Users::list_public_keys_for_user_async()) endpoint.
#[derive(Default, Serialize)]
pub struct UsersListPublicKeysForUserParams {
    /// The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    per_page: Option<u16>, 
    /// The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    page: Option<u16>
}

impl UsersListPublicKeysForUserParams {
    pub fn new() -> Self {
        Self::default()
    }

    /// The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    pub fn per_page(self, per_page: u16) -> Self {
        Self {
            per_page: Some(per_page),
            page: self.page, 
        }
    }

    /// The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    pub fn page(self, page: u16) -> Self {
        Self {
            per_page: self.per_page, 
            page: Some(page),
        }
    }
}

impl<'enc> From<&'enc PerPage> for UsersListPublicKeysForUserParams {
    fn from(per_page: &'enc PerPage) -> Self {
        Self {
            per_page: Some(per_page.per_page),
            page: Some(per_page.page),
            ..Default::default()
        }
    }
}
/// Query parameters for the [List public SSH keys for the authenticated user](Users::list_public_ssh_keys_for_authenticated_user_async()) endpoint.
#[derive(Default, Serialize)]
pub struct UsersListPublicSshKeysForAuthenticatedUserParams {
    /// The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    per_page: Option<u16>, 
    /// The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    page: Option<u16>
}

impl UsersListPublicSshKeysForAuthenticatedUserParams {
    pub fn new() -> Self {
        Self::default()
    }

    /// The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    pub fn per_page(self, per_page: u16) -> Self {
        Self {
            per_page: Some(per_page),
            page: self.page, 
        }
    }

    /// The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    pub fn page(self, page: u16) -> Self {
        Self {
            per_page: self.per_page, 
            page: Some(page),
        }
    }
}

impl<'enc> From<&'enc PerPage> for UsersListPublicSshKeysForAuthenticatedUserParams {
    fn from(per_page: &'enc PerPage) -> Self {
        Self {
            per_page: Some(per_page.per_page),
            page: Some(per_page.page),
            ..Default::default()
        }
    }
}
/// Query parameters for the [List social accounts for the authenticated user](Users::list_social_accounts_for_authenticated_user_async()) endpoint.
#[derive(Default, Serialize)]
pub struct UsersListSocialAccountsForAuthenticatedUserParams {
    /// The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    per_page: Option<u16>, 
    /// The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    page: Option<u16>
}

impl UsersListSocialAccountsForAuthenticatedUserParams {
    pub fn new() -> Self {
        Self::default()
    }

    /// The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    pub fn per_page(self, per_page: u16) -> Self {
        Self {
            per_page: Some(per_page),
            page: self.page, 
        }
    }

    /// The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    pub fn page(self, page: u16) -> Self {
        Self {
            per_page: self.per_page, 
            page: Some(page),
        }
    }
}

impl<'enc> From<&'enc PerPage> for UsersListSocialAccountsForAuthenticatedUserParams {
    fn from(per_page: &'enc PerPage) -> Self {
        Self {
            per_page: Some(per_page.per_page),
            page: Some(per_page.page),
            ..Default::default()
        }
    }
}
/// Query parameters for the [List social accounts for a user](Users::list_social_accounts_for_user_async()) endpoint.
#[derive(Default, Serialize)]
pub struct UsersListSocialAccountsForUserParams {
    /// The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    per_page: Option<u16>, 
    /// The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    page: Option<u16>
}

impl UsersListSocialAccountsForUserParams {
    pub fn new() -> Self {
        Self::default()
    }

    /// The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    pub fn per_page(self, per_page: u16) -> Self {
        Self {
            per_page: Some(per_page),
            page: self.page, 
        }
    }

    /// The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    pub fn page(self, page: u16) -> Self {
        Self {
            per_page: self.per_page, 
            page: Some(page),
        }
    }
}

impl<'enc> From<&'enc PerPage> for UsersListSocialAccountsForUserParams {
    fn from(per_page: &'enc PerPage) -> Self {
        Self {
            per_page: Some(per_page.per_page),
            page: Some(per_page.page),
            ..Default::default()
        }
    }
}
/// Query parameters for the [List SSH signing keys for the authenticated user](Users::list_ssh_signing_keys_for_authenticated_user_async()) endpoint.
#[derive(Default, Serialize)]
pub struct UsersListSshSigningKeysForAuthenticatedUserParams {
    /// The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    per_page: Option<u16>, 
    /// The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    page: Option<u16>
}

impl UsersListSshSigningKeysForAuthenticatedUserParams {
    pub fn new() -> Self {
        Self::default()
    }

    /// The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    pub fn per_page(self, per_page: u16) -> Self {
        Self {
            per_page: Some(per_page),
            page: self.page, 
        }
    }

    /// The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    pub fn page(self, page: u16) -> Self {
        Self {
            per_page: self.per_page, 
            page: Some(page),
        }
    }
}

impl<'enc> From<&'enc PerPage> for UsersListSshSigningKeysForAuthenticatedUserParams {
    fn from(per_page: &'enc PerPage) -> Self {
        Self {
            per_page: Some(per_page.per_page),
            page: Some(per_page.page),
            ..Default::default()
        }
    }
}
/// Query parameters for the [List SSH signing keys for a user](Users::list_ssh_signing_keys_for_user_async()) endpoint.
#[derive(Default, Serialize)]
pub struct UsersListSshSigningKeysForUserParams {
    /// The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    per_page: Option<u16>, 
    /// The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    page: Option<u16>
}

impl UsersListSshSigningKeysForUserParams {
    pub fn new() -> Self {
        Self::default()
    }

    /// The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    pub fn per_page(self, per_page: u16) -> Self {
        Self {
            per_page: Some(per_page),
            page: self.page, 
        }
    }

    /// The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api).\"
    pub fn page(self, page: u16) -> Self {
        Self {
            per_page: self.per_page, 
            page: Some(page),
        }
    }
}

impl<'enc> From<&'enc PerPage> for UsersListSshSigningKeysForUserParams {
    fn from(per_page: &'enc PerPage) -> Self {
        Self {
            per_page: Some(per_page.per_page),
            page: Some(per_page.page),
            ..Default::default()
        }
    }
}

impl<'api> Users<'api> {
    /// ---
    ///
    /// # Add an email address for the authenticated user
    ///
    /// OAuth app tokens and personal access tokens (classic) need the `user` scope to use this endpoint.
    ///
    /// [GitHub API docs for add_email_for_authenticated_user](https://docs.github.com/rest/users/emails#add-an-email-address-for-the-authenticated-user)
    ///
    /// ---
    pub async fn add_email_for_authenticated_user_async(&self, body: PostUsersAddEmailForAuthenticatedUser) -> Result<Vec<Email>, UsersAddEmailForAuthenticatedUserError> {

        let request_uri = format!("{}/user/emails", super::GITHUB_BASE_API_URL);


        let req = GitHubRequest {
            uri: request_uri,
            body: Some(PostUsersAddEmailForAuthenticatedUser::from_json(body)?),
            method: "POST",
            headers: vec![]
        };

        let request = GitHubRequestBuilder::build(req, self.auth)?;

        // --

        let github_response = crate::adapters::fetch_async(request).await?;

        // --

        if github_response.is_success() {
            Ok(crate::adapters::to_json_async(github_response).await?)
        } else {
            match github_response.status_code() {
                422 => Err(UsersAddEmailForAuthenticatedUserError::Status422(crate::adapters::to_json_async(github_response).await?)),
                304 => Err(UsersAddEmailForAuthenticatedUserError::Status304),
                404 => Err(UsersAddEmailForAuthenticatedUserError::Status404(crate::adapters::to_json_async(github_response).await?)),
                403 => Err(UsersAddEmailForAuthenticatedUserError::Status403(crate::adapters::to_json_async(github_response).await?)),
                401 => Err(UsersAddEmailForAuthenticatedUserError::Status401(crate::adapters::to_json_async(github_response).await?)),
                code => Err(UsersAddEmailForAuthenticatedUserError::Generic { code }),
            }
        }
    }

    /// ---
    ///
    /// # Add an email address for the authenticated user
    ///
    /// OAuth app tokens and personal access tokens (classic) need the `user` scope to use this endpoint.
    ///
    /// [GitHub API docs for add_email_for_authenticated_user](https://docs.github.com/rest/users/emails#add-an-email-address-for-the-authenticated-user)
    ///
    /// ---
    #[cfg(not(target_arch = "wasm32"))]
    pub fn add_email_for_authenticated_user(&self, body: PostUsersAddEmailForAuthenticatedUser) -> Result<Vec<Email>, UsersAddEmailForAuthenticatedUserError> {

        let request_uri = format!("{}/user/emails", super::GITHUB_BASE_API_URL);


        let req = GitHubRequest {
            uri: request_uri,
            body: Some(PostUsersAddEmailForAuthenticatedUser::from_json(body)?),
            method: "POST",
            headers: vec![]
        };

        let request = GitHubRequestBuilder::build(req, self.auth)?;

        // --

        let github_response = crate::adapters::fetch(request)?;

        // --

        if github_response.is_success() {
            Ok(crate::adapters::to_json(github_response)?)
        } else {
            match github_response.status_code() {
                422 => Err(UsersAddEmailForAuthenticatedUserError::Status422(crate::adapters::to_json(github_response)?)),
                304 => Err(UsersAddEmailForAuthenticatedUserError::Status304),
                404 => Err(UsersAddEmailForAuthenticatedUserError::Status404(crate::adapters::to_json(github_response)?)),
                403 => Err(UsersAddEmailForAuthenticatedUserError::Status403(crate::adapters::to_json(github_response)?)),
                401 => Err(UsersAddEmailForAuthenticatedUserError::Status401(crate::adapters::to_json(github_response)?)),
                code => Err(UsersAddEmailForAuthenticatedUserError::Generic { code }),
            }
        }
    }

    /// ---
    ///
    /// # Add social accounts for the authenticated user
    ///
    /// Add one or more social accounts to the authenticated user's profile.
    /// 
    /// OAuth app tokens and personal access tokens (classic) need the `user` scope to use this endpoint.
    ///
    /// [GitHub API docs for add_social_account_for_authenticated_user](https://docs.github.com/rest/users/social-accounts#add-social-accounts-for-the-authenticated-user)
    ///
    /// ---
    pub async fn add_social_account_for_authenticated_user_async(&self, body: PostUsersAddSocialAccountForAuthenticatedUser) -> Result<Vec<SocialAccount>, UsersAddSocialAccountForAuthenticatedUserError> {

        let request_uri = format!("{}/user/social_accounts", super::GITHUB_BASE_API_URL);


        let req = GitHubRequest {
            uri: request_uri,
            body: Some(PostUsersAddSocialAccountForAuthenticatedUser::from_json(body)?),
            method: "POST",
            headers: vec![]
        };

        let request = GitHubRequestBuilder::build(req, self.auth)?;

        // --

        let github_response = crate::adapters::fetch_async(request).await?;

        // --

        if github_response.is_success() {
            Ok(crate::adapters::to_json_async(github_response).await?)
        } else {
            match github_response.status_code() {
                422 => Err(UsersAddSocialAccountForAuthenticatedUserError::Status422(crate::adapters::to_json_async(github_response).await?)),
                304 => Err(UsersAddSocialAccountForAuthenticatedUserError::Status304),
                404 => Err(UsersAddSocialAccountForAuthenticatedUserError::Status404(crate::adapters::to_json_async(github_response).await?)),
                403 => Err(UsersAddSocialAccountForAuthenticatedUserError::Status403(crate::adapters::to_json_async(github_response).await?)),
                401 => Err(UsersAddSocialAccountForAuthenticatedUserError::Status401(crate::adapters::to_json_async(github_response).await?)),
                code => Err(UsersAddSocialAccountForAuthenticatedUserError::Generic { code }),
            }
        }
    }

    /// ---
    ///
    /// # Add social accounts for the authenticated user
    ///
    /// Add one or more social accounts to the authenticated user's profile.
    /// 
    /// OAuth app tokens and personal access tokens (classic) need the `user` scope to use this endpoint.
    ///
    /// [GitHub API docs for add_social_account_for_authenticated_user](https://docs.github.com/rest/users/social-accounts#add-social-accounts-for-the-authenticated-user)
    ///
    /// ---
    #[cfg(not(target_arch = "wasm32"))]
    pub fn add_social_account_for_authenticated_user(&self, body: PostUsersAddSocialAccountForAuthenticatedUser) -> Result<Vec<SocialAccount>, UsersAddSocialAccountForAuthenticatedUserError> {

        let request_uri = format!("{}/user/social_accounts", super::GITHUB_BASE_API_URL);


        let req = GitHubRequest {
            uri: request_uri,
            body: Some(PostUsersAddSocialAccountForAuthenticatedUser::from_json(body)?),
            method: "POST",
            headers: vec![]
        };

        let request = GitHubRequestBuilder::build(req, self.auth)?;

        // --

        let github_response = crate::adapters::fetch(request)?;

        // --

        if github_response.is_success() {
            Ok(crate::adapters::to_json(github_response)?)
        } else {
            match github_response.status_code() {
                422 => Err(UsersAddSocialAccountForAuthenticatedUserError::Status422(crate::adapters::to_json(github_response)?)),
                304 => Err(UsersAddSocialAccountForAuthenticatedUserError::Status304),
                404 => Err(UsersAddSocialAccountForAuthenticatedUserError::Status404(crate::adapters::to_json(github_response)?)),
                403 => Err(UsersAddSocialAccountForAuthenticatedUserError::Status403(crate::adapters::to_json(github_response)?)),
                401 => Err(UsersAddSocialAccountForAuthenticatedUserError::Status401(crate::adapters::to_json(github_response)?)),
                code => Err(UsersAddSocialAccountForAuthenticatedUserError::Generic { code }),
            }
        }
    }

    /// ---
    ///
    /// # Block a user
    ///
    /// Blocks the given user and returns a 204. If the authenticated user cannot block the given user a 422 is returned.
    ///
    /// [GitHub API docs for block](https://docs.github.com/rest/users/blocking#block-a-user)
    ///
    /// ---
    pub async fn block_async(&self, username: &str) -> Result<(), UsersBlockError> {

        let request_uri = format!("{}/user/blocks/{}", super::GITHUB_BASE_API_URL, username);


        let req = GitHubRequest {
            uri: request_uri,
            body: None,
            method: "PUT",
            headers: vec![]
        };

        let request = GitHubRequestBuilder::build(req, self.auth)?;

        // --

        let github_response = crate::adapters::fetch_async(request).await?;

        // --

        if github_response.is_success() {
            Ok(crate::adapters::to_json_async(github_response).await?)
        } else {
            match github_response.status_code() {
                304 => Err(UsersBlockError::Status304),
                404 => Err(UsersBlockError::Status404(crate::adapters::to_json_async(github_response).await?)),
                403 => Err(UsersBlockError::Status403(crate::adapters::to_json_async(github_response).await?)),
                401 => Err(UsersBlockError::Status401(crate::adapters::to_json_async(github_response).await?)),
                422 => Err(UsersBlockError::Status422(crate::adapters::to_json_async(github_response).await?)),
                code => Err(UsersBlockError::Generic { code }),
            }
        }
    }

    /// ---
    ///
    /// # Block a user
    ///
    /// Blocks the given user and returns a 204. If the authenticated user cannot block the given user a 422 is returned.
    ///
    /// [GitHub API docs for block](https://docs.github.com/rest/users/blocking#block-a-user)
    ///
    /// ---
    #[cfg(not(target_arch = "wasm32"))]
    pub fn block(&self, username: &str) -> Result<(), UsersBlockError> {

        let request_uri = format!("{}/user/blocks/{}", super::GITHUB_BASE_API_URL, username);


        let req = GitHubRequest {
            uri: request_uri,
            body: None,
            method: "PUT",
            headers: vec![]
        };

        let request = GitHubRequestBuilder::build(req, self.auth)?;

        // --

        let github_response = crate::adapters::fetch(request)?;

        // --

        if github_response.is_success() {
            Ok(crate::adapters::to_json(github_response)?)
        } else {
            match github_response.status_code() {
                304 => Err(UsersBlockError::Status304),
                404 => Err(UsersBlockError::Status404(crate::adapters::to_json(github_response)?)),
                403 => Err(UsersBlockError::Status403(crate::adapters::to_json(github_response)?)),
                401 => Err(UsersBlockError::Status401(crate::adapters::to_json(github_response)?)),
                422 => Err(UsersBlockError::Status422(crate::adapters::to_json(github_response)?)),
                code => Err(UsersBlockError::Generic { code }),
            }
        }
    }

    /// ---
    ///
    /// # Check if a user is blocked by the authenticated user
    ///
    /// Returns a 204 if the given user is blocked by the authenticated user. Returns a 404 if the given user is not blocked by the authenticated user, or if the given user account has been identified as spam by GitHub.
    ///
    /// [GitHub API docs for check_blocked](https://docs.github.com/rest/users/blocking#check-if-a-user-is-blocked-by-the-authenticated-user)
    ///
    /// ---
    pub async fn check_blocked_async(&self, username: &str) -> Result<(), UsersCheckBlockedError> {

        let request_uri = format!("{}/user/blocks/{}", super::GITHUB_BASE_API_URL, username);


        let req = GitHubRequest {
            uri: request_uri,
            body: None,
            method: "GET",
            headers: vec![]
        };

        let request = GitHubRequestBuilder::build(req, self.auth)?;

        // --

        let github_response = crate::adapters::fetch_async(request).await?;

        // --

        if github_response.is_success() {
            Ok(crate::adapters::to_json_async(github_response).await?)
        } else {
            match github_response.status_code() {
                404 => Err(UsersCheckBlockedError::Status404(crate::adapters::to_json_async(github_response).await?)),
                304 => Err(UsersCheckBlockedError::Status304),
                403 => Err(UsersCheckBlockedError::Status403(crate::adapters::to_json_async(github_response).await?)),
                401 => Err(UsersCheckBlockedError::Status401(crate::adapters::to_json_async(github_response).await?)),
                code => Err(UsersCheckBlockedError::Generic { code }),
            }
        }
    }

    /// ---
    ///
    /// # Check if a user is blocked by the authenticated user
    ///
    /// Returns a 204 if the given user is blocked by the authenticated user. Returns a 404 if the given user is not blocked by the authenticated user, or if the given user account has been identified as spam by GitHub.
    ///
    /// [GitHub API docs for check_blocked](https://docs.github.com/rest/users/blocking#check-if-a-user-is-blocked-by-the-authenticated-user)
    ///
    /// ---
    #[cfg(not(target_arch = "wasm32"))]
    pub fn check_blocked(&self, username: &str) -> Result<(), UsersCheckBlockedError> {

        let request_uri = format!("{}/user/blocks/{}", super::GITHUB_BASE_API_URL, username);


        let req = GitHubRequest {
            uri: request_uri,
            body: None,
            method: "GET",
            headers: vec![]
        };

        let request = GitHubRequestBuilder::build(req, self.auth)?;

        // --

        let github_response = crate::adapters::fetch(request)?;

        // --

        if github_response.is_success() {
            Ok(crate::adapters::to_json(github_response)?)
        } else {
            match github_response.status_code() {
                404 => Err(UsersCheckBlockedError::Status404(crate::adapters::to_json(github_response)?)),
                304 => Err(UsersCheckBlockedError::Status304),
                403 => Err(UsersCheckBlockedError::Status403(crate::adapters::to_json(github_response)?)),
                401 => Err(UsersCheckBlockedError::Status401(crate::adapters::to_json(github_response)?)),
                code => Err(UsersCheckBlockedError::Generic { code }),
            }
        }
    }

    /// ---
    ///
    /// # Check if a user follows another user
    ///
    /// [GitHub API docs for check_following_for_user](https://docs.github.com/rest/users/followers#check-if-a-user-follows-another-user)
    ///
    /// ---
    pub async fn check_following_for_user_async(&self, username: &str, target_user: &str) -> Result<(), UsersCheckFollowingForUserError> {

        let request_uri = format!("{}/users/{}/following/{}", super::GITHUB_BASE_API_URL, username, target_user);


        let req = GitHubRequest {
            uri: request_uri,
            body: None,
            method: "GET",
            headers: vec![]
        };

        let request = GitHubRequestBuilder::build(req, self.auth)?;

        // --

        let github_response = crate::adapters::fetch_async(request).await?;

        // --

        if github_response.is_success() {
            Ok(crate::adapters::to_json_async(github_response).await?)
        } else {
            match github_response.status_code() {
                404 => Err(UsersCheckFollowingForUserError::Status404),
                code => Err(UsersCheckFollowingForUserError::Generic { code }),
            }
        }
    }

    /// ---
    ///
    /// # Check if a user follows another user
    ///
    /// [GitHub API docs for check_following_for_user](https://docs.github.com/rest/users/followers#check-if-a-user-follows-another-user)
    ///
    /// ---
    #[cfg(not(target_arch = "wasm32"))]
    pub fn check_following_for_user(&self, username: &str, target_user: &str) -> Result<(), UsersCheckFollowingForUserError> {

        let request_uri = format!("{}/users/{}/following/{}", super::GITHUB_BASE_API_URL, username, target_user);


        let req = GitHubRequest {
            uri: request_uri,
            body: None,
            method: "GET",
            headers: vec![]
        };

        let request = GitHubRequestBuilder::build(req, self.auth)?;

        // --

        let github_response = crate::adapters::fetch(request)?;

        // --

        if github_response.is_success() {
            Ok(crate::adapters::to_json(github_response)?)
        } else {
            match github_response.status_code() {
                404 => Err(UsersCheckFollowingForUserError::Status404),
                code => Err(UsersCheckFollowingForUserError::Generic { code }),
            }
        }
    }

    /// ---
    ///
    /// # Check if a person is followed by the authenticated user
    ///
    /// [GitHub API docs for check_person_is_followed_by_authenticated](https://docs.github.com/rest/users/followers#check-if-a-person-is-followed-by-the-authenticated-user)
    ///
    /// ---
    pub async fn check_person_is_followed_by_authenticated_async(&self, username: &str) -> Result<(), UsersCheckPersonIsFollowedByAuthenticatedError> {

        let request_uri = format!("{}/user/following/{}", super::GITHUB_BASE_API_URL, username);


        let req = GitHubRequest {
            uri: request_uri,
            body: None,
            method: "GET",
            headers: vec![]
        };

        let request = GitHubRequestBuilder::build(req, self.auth)?;

        // --

        let github_response = crate::adapters::fetch_async(request).await?;

        // --

        if github_response.is_success() {
            Ok(crate::adapters::to_json_async(github_response).await?)
        } else {
            match github_response.status_code() {
                404 => Err(UsersCheckPersonIsFollowedByAuthenticatedError::Status404(crate::adapters::to_json_async(github_response).await?)),
                304 => Err(UsersCheckPersonIsFollowedByAuthenticatedError::Status304),
                403 => Err(UsersCheckPersonIsFollowedByAuthenticatedError::Status403(crate::adapters::to_json_async(github_response).await?)),
                401 => Err(UsersCheckPersonIsFollowedByAuthenticatedError::Status401(crate::adapters::to_json_async(github_response).await?)),
                code => Err(UsersCheckPersonIsFollowedByAuthenticatedError::Generic { code }),
            }
        }
    }

    /// ---
    ///
    /// # Check if a person is followed by the authenticated user
    ///
    /// [GitHub API docs for check_person_is_followed_by_authenticated](https://docs.github.com/rest/users/followers#check-if-a-person-is-followed-by-the-authenticated-user)
    ///
    /// ---
    #[cfg(not(target_arch = "wasm32"))]
    pub fn check_person_is_followed_by_authenticated(&self, username: &str) -> Result<(), UsersCheckPersonIsFollowedByAuthenticatedError> {

        let request_uri = format!("{}/user/following/{}", super::GITHUB_BASE_API_URL, username);


        let req = GitHubRequest {
            uri: request_uri,
            body: None,
            method: "GET",
            headers: vec![]
        };

        let request = GitHubRequestBuilder::build(req, self.auth)?;

        // --

        let github_response = crate::adapters::fetch(request)?;

        // --

        if github_response.is_success() {
            Ok(crate::adapters::to_json(github_response)?)
        } else {
            match github_response.status_code() {
                404 => Err(UsersCheckPersonIsFollowedByAuthenticatedError::Status404(crate::adapters::to_json(github_response)?)),
                304 => Err(UsersCheckPersonIsFollowedByAuthenticatedError::Status304),
                403 => Err(UsersCheckPersonIsFollowedByAuthenticatedError::Status403(crate::adapters::to_json(github_response)?)),
                401 => Err(UsersCheckPersonIsFollowedByAuthenticatedError::Status401(crate::adapters::to_json(github_response)?)),
                code => Err(UsersCheckPersonIsFollowedByAuthenticatedError::Generic { code }),
            }
        }
    }

    /// ---
    ///
    /// # Create a GPG key for the authenticated user
    ///
    /// Adds a GPG key to the authenticated user's GitHub account.
    /// 
    /// OAuth app tokens and personal access tokens (classic) need the `write:gpg_key` scope to use this endpoint.
    ///
    /// [GitHub API docs for create_gpg_key_for_authenticated_user](https://docs.github.com/rest/users/gpg-keys#create-a-gpg-key-for-the-authenticated-user)
    ///
    /// ---
    pub async fn create_gpg_key_for_authenticated_user_async(&self, body: PostUsersCreateGpgKeyForAuthenticatedUser) -> Result<GpgKey, UsersCreateGpgKeyForAuthenticatedUserError> {

        let request_uri = format!("{}/user/gpg_keys", super::GITHUB_BASE_API_URL);


        let req = GitHubRequest {
            uri: request_uri,
            body: Some(PostUsersCreateGpgKeyForAuthenticatedUser::from_json(body)?),
            method: "POST",
            headers: vec![]
        };

        let request = GitHubRequestBuilder::build(req, self.auth)?;

        // --

        let github_response = crate::adapters::fetch_async(request).await?;

        // --

        if github_response.is_success() {
            Ok(crate::adapters::to_json_async(github_response).await?)
        } else {
            match github_response.status_code() {
                422 => Err(UsersCreateGpgKeyForAuthenticatedUserError::Status422(crate::adapters::to_json_async(github_response).await?)),
                304 => Err(UsersCreateGpgKeyForAuthenticatedUserError::Status304),
                404 => Err(UsersCreateGpgKeyForAuthenticatedUserError::Status404(crate::adapters::to_json_async(github_response).await?)),
                403 => Err(UsersCreateGpgKeyForAuthenticatedUserError::Status403(crate::adapters::to_json_async(github_response).await?)),
                401 => Err(UsersCreateGpgKeyForAuthenticatedUserError::Status401(crate::adapters::to_json_async(github_response).await?)),
                code => Err(UsersCreateGpgKeyForAuthenticatedUserError::Generic { code }),
            }
        }
    }

    /// ---
    ///
    /// # Create a GPG key for the authenticated user
    ///
    /// Adds a GPG key to the authenticated user's GitHub account.
    /// 
    /// OAuth app tokens and personal access tokens (classic) need the `write:gpg_key` scope to use this endpoint.
    ///
    /// [GitHub API docs for create_gpg_key_for_authenticated_user](https://docs.github.com/rest/users/gpg-keys#create-a-gpg-key-for-the-authenticated-user)
    ///
    /// ---
    #[cfg(not(target_arch = "wasm32"))]
    pub fn create_gpg_key_for_authenticated_user(&self, body: PostUsersCreateGpgKeyForAuthenticatedUser) -> Result<GpgKey, UsersCreateGpgKeyForAuthenticatedUserError> {

        let request_uri = format!("{}/user/gpg_keys", super::GITHUB_BASE_API_URL);


        let req = GitHubRequest {
            uri: request_uri,
            body: Some(PostUsersCreateGpgKeyForAuthenticatedUser::from_json(body)?),
            method: "POST",
            headers: vec![]
        };

        let request = GitHubRequestBuilder::build(req, self.auth)?;

        // --

        let github_response = crate::adapters::fetch(request)?;

        // --

        if github_response.is_success() {
            Ok(crate::adapters::to_json(github_response)?)
        } else {
            match github_response.status_code() {
                422 => Err(UsersCreateGpgKeyForAuthenticatedUserError::Status422(crate::adapters::to_json(github_response)?)),
                304 => Err(UsersCreateGpgKeyForAuthenticatedUserError::Status304),
                404 => Err(UsersCreateGpgKeyForAuthenticatedUserError::Status404(crate::adapters::to_json(github_response)?)),
                403 => Err(UsersCreateGpgKeyForAuthenticatedUserError::Status403(crate::adapters::to_json(github_response)?)),
                401 => Err(UsersCreateGpgKeyForAuthenticatedUserError::Status401(crate::adapters::to_json(github_response)?)),
                code => Err(UsersCreateGpgKeyForAuthenticatedUserError::Generic { code }),
            }
        }
    }

    /// ---
    ///
    /// # Create a public SSH key for the authenticated user
    ///
    /// Adds a public SSH key to the authenticated user's GitHub account.
    /// 
    /// OAuth app tokens and personal access tokens (classic) need the `write:gpg_key` scope to use this endpoint.
    ///
    /// [GitHub API docs for create_public_ssh_key_for_authenticated_user](https://docs.github.com/rest/users/keys#create-a-public-ssh-key-for-the-authenticated-user)
    ///
    /// ---
    pub async fn create_public_ssh_key_for_authenticated_user_async(&self, body: PostUsersCreatePublicSshKeyForAuthenticatedUser) -> Result<Key, UsersCreatePublicSshKeyForAuthenticatedUserError> {

        let request_uri = format!("{}/user/keys", super::GITHUB_BASE_API_URL);


        let req = GitHubRequest {
            uri: request_uri,
            body: Some(PostUsersCreatePublicSshKeyForAuthenticatedUser::from_json(body)?),
            method: "POST",
            headers: vec![]
        };

        let request = GitHubRequestBuilder::build(req, self.auth)?;

        // --

        let github_response = crate::adapters::fetch_async(request).await?;

        // --

        if github_response.is_success() {
            Ok(crate::adapters::to_json_async(github_response).await?)
        } else {
            match github_response.status_code() {
                422 => Err(UsersCreatePublicSshKeyForAuthenticatedUserError::Status422(crate::adapters::to_json_async(github_response).await?)),
                304 => Err(UsersCreatePublicSshKeyForAuthenticatedUserError::Status304),
                404 => Err(UsersCreatePublicSshKeyForAuthenticatedUserError::Status404(crate::adapters::to_json_async(github_response).await?)),
                403 => Err(UsersCreatePublicSshKeyForAuthenticatedUserError::Status403(crate::adapters::to_json_async(github_response).await?)),
                401 => Err(UsersCreatePublicSshKeyForAuthenticatedUserError::Status401(crate::adapters::to_json_async(github_response).await?)),
                code => Err(UsersCreatePublicSshKeyForAuthenticatedUserError::Generic { code }),
            }
        }
    }

    /// ---
    ///
    /// # Create a public SSH key for the authenticated user
    ///
    /// Adds a public SSH key to the authenticated user's GitHub account.
    /// 
    /// OAuth app tokens and personal access tokens (classic) need the `write:gpg_key` scope to use this endpoint.
    ///
    /// [GitHub API docs for create_public_ssh_key_for_authenticated_user](https://docs.github.com/rest/users/keys#create-a-public-ssh-key-for-the-authenticated-user)
    ///
    /// ---
    #[cfg(not(target_arch = "wasm32"))]
    pub fn create_public_ssh_key_for_authenticated_user(&self, body: PostUsersCreatePublicSshKeyForAuthenticatedUser) -> Result<Key, UsersCreatePublicSshKeyForAuthenticatedUserError> {

        let request_uri = format!("{}/user/keys", super::GITHUB_BASE_API_URL);


        let req = GitHubRequest {
            uri: request_uri,
            body: Some(PostUsersCreatePublicSshKeyForAuthenticatedUser::from_json(body)?),
            method: "POST",
            headers: vec![]
        };

        let request = GitHubRequestBuilder::build(req, self.auth)?;

        // --

        let github_response = crate::adapters::fetch(request)?;

        // --

        if github_response.is_success() {
            Ok(crate::adapters::to_json(github_response)?)
        } else {
            match github_response.status_code() {
                422 => Err(UsersCreatePublicSshKeyForAuthenticatedUserError::Status422(crate::adapters::to_json(github_response)?)),
                304 => Err(UsersCreatePublicSshKeyForAuthenticatedUserError::Status304),
                404 => Err(UsersCreatePublicSshKeyForAuthenticatedUserError::Status404(crate::adapters::to_json(github_response)?)),
                403 => Err(UsersCreatePublicSshKeyForAuthenticatedUserError::Status403(crate::adapters::to_json(github_response)?)),
                401 => Err(UsersCreatePublicSshKeyForAuthenticatedUserError::Status401(crate::adapters::to_json(github_response)?)),
                code => Err(UsersCreatePublicSshKeyForAuthenticatedUserError::Generic { code }),
            }
        }
    }

    /// ---
    ///
    /// # Create a SSH signing key for the authenticated user
    ///
    /// Creates an SSH signing key for the authenticated user's GitHub account.
    /// 
    /// OAuth app tokens and personal access tokens (classic) need the `write:ssh_signing_key` scope to use this endpoint.
    ///
    /// [GitHub API docs for create_ssh_signing_key_for_authenticated_user](https://docs.github.com/rest/users/ssh-signing-keys#create-a-ssh-signing-key-for-the-authenticated-user)
    ///
    /// ---
    pub async fn create_ssh_signing_key_for_authenticated_user_async(&self, body: PostUsersCreateSshSigningKeyForAuthenticatedUser) -> Result<SshSigningKey, UsersCreateSshSigningKeyForAuthenticatedUserError> {

        let request_uri = format!("{}/user/ssh_signing_keys", super::GITHUB_BASE_API_URL);


        let req = GitHubRequest {
            uri: request_uri,
            body: Some(PostUsersCreateSshSigningKeyForAuthenticatedUser::from_json(body)?),
            method: "POST",
            headers: vec![]
        };

        let request = GitHubRequestBuilder::build(req, self.auth)?;

        // --

        let github_response = crate::adapters::fetch_async(request).await?;

        // --

        if github_response.is_success() {
            Ok(crate::adapters::to_json_async(github_response).await?)
        } else {
            match github_response.status_code() {
                422 => Err(UsersCreateSshSigningKeyForAuthenticatedUserError::Status422(crate::adapters::to_json_async(github_response).await?)),
                304 => Err(UsersCreateSshSigningKeyForAuthenticatedUserError::Status304),
                404 => Err(UsersCreateSshSigningKeyForAuthenticatedUserError::Status404(crate::adapters::to_json_async(github_response).await?)),
                403 => Err(UsersCreateSshSigningKeyForAuthenticatedUserError::Status403(crate::adapters::to_json_async(github_response).await?)),
                401 => Err(UsersCreateSshSigningKeyForAuthenticatedUserError::Status401(crate::adapters::to_json_async(github_response).await?)),
                code => Err(UsersCreateSshSigningKeyForAuthenticatedUserError::Generic { code }),
            }
        }
    }

    /// ---
    ///
    /// # Create a SSH signing key for the authenticated user
    ///
    /// Creates an SSH signing key for the authenticated user's GitHub account.
    /// 
    /// OAuth app tokens and personal access tokens (classic) need the `write:ssh_signing_key` scope to use this endpoint.
    ///
    /// [GitHub API docs for create_ssh_signing_key_for_authenticated_user](https://docs.github.com/rest/users/ssh-signing-keys#create-a-ssh-signing-key-for-the-authenticated-user)
    ///
    /// ---
    #[cfg(not(target_arch = "wasm32"))]
    pub fn create_ssh_signing_key_for_authenticated_user(&self, body: PostUsersCreateSshSigningKeyForAuthenticatedUser) -> Result<SshSigningKey, UsersCreateSshSigningKeyForAuthenticatedUserError> {

        let request_uri = format!("{}/user/ssh_signing_keys", super::GITHUB_BASE_API_URL);


        let req = GitHubRequest {
            uri: request_uri,
            body: Some(PostUsersCreateSshSigningKeyForAuthenticatedUser::from_json(body)?),
            method: "POST",
            headers: vec![]
        };

        let request = GitHubRequestBuilder::build(req, self.auth)?;

        // --

        let github_response = crate::adapters::fetch(request)?;

        // --

        if github_response.is_success() {
            Ok(crate::adapters::to_json(github_response)?)
        } else {
            match github_response.status_code() {
                422 => Err(UsersCreateSshSigningKeyForAuthenticatedUserError::Status422(crate::adapters::to_json(github_response)?)),
                304 => Err(UsersCreateSshSigningKeyForAuthenticatedUserError::Status304),
                404 => Err(UsersCreateSshSigningKeyForAuthenticatedUserError::Status404(crate::adapters::to_json(github_response)?)),
                403 => Err(UsersCreateSshSigningKeyForAuthenticatedUserError::Status403(crate::adapters::to_json(github_response)?)),
                401 => Err(UsersCreateSshSigningKeyForAuthenticatedUserError::Status401(crate::adapters::to_json(github_response)?)),
                code => Err(UsersCreateSshSigningKeyForAuthenticatedUserError::Generic { code }),
            }
        }
    }

    /// ---
    ///
    /// # Delete an email address for the authenticated user
    ///
    /// OAuth app tokens and personal access tokens (classic) need the `user` scope to use this endpoint.
    ///
    /// [GitHub API docs for delete_email_for_authenticated_user](https://docs.github.com/rest/users/emails#delete-an-email-address-for-the-authenticated-user)
    ///
    /// ---
    pub async fn delete_email_for_authenticated_user_async(&self, body: DeleteUsersDeleteEmailForAuthenticatedUser) -> Result<(), UsersDeleteEmailForAuthenticatedUserError> {

        let request_uri = format!("{}/user/emails", super::GITHUB_BASE_API_URL);


        let req = GitHubRequest {
            uri: request_uri,
            body: Some(DeleteUsersDeleteEmailForAuthenticatedUser::from_json(body)?),
            method: "DELETE",
            headers: vec![]
        };

        let request = GitHubRequestBuilder::build(req, self.auth)?;

        // --

        let github_response = crate::adapters::fetch_async(request).await?;

        // --

        if github_response.is_success() {
            Ok(crate::adapters::to_json_async(github_response).await?)
        } else {
            match github_response.status_code() {
                304 => Err(UsersDeleteEmailForAuthenticatedUserError::Status304),
                404 => Err(UsersDeleteEmailForAuthenticatedUserError::Status404(crate::adapters::to_json_async(github_response).await?)),
                403 => Err(UsersDeleteEmailForAuthenticatedUserError::Status403(crate::adapters::to_json_async(github_response).await?)),
                401 => Err(UsersDeleteEmailForAuthenticatedUserError::Status401(crate::adapters::to_json_async(github_response).await?)),
                422 => Err(UsersDeleteEmailForAuthenticatedUserError::Status422(crate::adapters::to_json_async(github_response).await?)),
                code => Err(UsersDeleteEmailForAuthenticatedUserError::Generic { code }),
            }
        }
    }

    /// ---
    ///
    /// # Delete an email address for the authenticated user
    ///
    /// OAuth app tokens and personal access tokens (classic) need the `user` scope to use this endpoint.
    ///
    /// [GitHub API docs for delete_email_for_authenticated_user](https://docs.github.com/rest/users/emails#delete-an-email-address-for-the-authenticated-user)
    ///
    /// ---
    #[cfg(not(target_arch = "wasm32"))]
    pub fn delete_email_for_authenticated_user(&self, body: DeleteUsersDeleteEmailForAuthenticatedUser) -> Result<(), UsersDeleteEmailForAuthenticatedUserError> {

        let request_uri = format!("{}/user/emails", super::GITHUB_BASE_API_URL);


        let req = GitHubRequest {
            uri: request_uri,
            body: Some(DeleteUsersDeleteEmailForAuthenticatedUser::from_json(body)?),
            method: "DELETE",
            headers: vec![]
        };

        let request = GitHubRequestBuilder::build(req, self.auth)?;

        // --

        let github_response = crate::adapters::fetch(request)?;

        // --

        if github_response.is_success() {
            Ok(crate::adapters::to_json(github_response)?)
        } else {
            match github_response.status_code() {
                304 => Err(UsersDeleteEmailForAuthenticatedUserError::Status304),
                404 => Err(UsersDeleteEmailForAuthenticatedUserError::Status404(crate::adapters::to_json(github_response)?)),
                403 => Err(UsersDeleteEmailForAuthenticatedUserError::Status403(crate::adapters::to_json(github_response)?)),
                401 => Err(UsersDeleteEmailForAuthenticatedUserError::Status401(crate::adapters::to_json(github_response)?)),
                422 => Err(UsersDeleteEmailForAuthenticatedUserError::Status422(crate::adapters::to_json(github_response)?)),
                code => Err(UsersDeleteEmailForAuthenticatedUserError::Generic { code }),
            }
        }
    }

    /// ---
    ///
    /// # Delete a GPG key for the authenticated user
    ///
    /// Removes a GPG key from the authenticated user's GitHub account.
    /// 
    /// OAuth app tokens and personal access tokens (classic) need the `admin:gpg_key` scope to use this endpoint.
    ///
    /// [GitHub API docs for delete_gpg_key_for_authenticated_user](https://docs.github.com/rest/users/gpg-keys#delete-a-gpg-key-for-the-authenticated-user)
    ///
    /// ---
    pub async fn delete_gpg_key_for_authenticated_user_async(&self, gpg_key_id: i32) -> Result<(), UsersDeleteGpgKeyForAuthenticatedUserError> {

        let request_uri = format!("{}/user/gpg_keys/{}", super::GITHUB_BASE_API_URL, gpg_key_id);


        let req = GitHubRequest {
            uri: request_uri,
            body: None,
            method: "DELETE",
            headers: vec![]
        };

        let request = GitHubRequestBuilder::build(req, self.auth)?;

        // --

        let github_response = crate::adapters::fetch_async(request).await?;

        // --

        if github_response.is_success() {
            Ok(crate::adapters::to_json_async(github_response).await?)
        } else {
            match github_response.status_code() {
                404 => Err(UsersDeleteGpgKeyForAuthenticatedUserError::Status404(crate::adapters::to_json_async(github_response).await?)),
                422 => Err(UsersDeleteGpgKeyForAuthenticatedUserError::Status422(crate::adapters::to_json_async(github_response).await?)),
                304 => Err(UsersDeleteGpgKeyForAuthenticatedUserError::Status304),
                403 => Err(UsersDeleteGpgKeyForAuthenticatedUserError::Status403(crate::adapters::to_json_async(github_response).await?)),
                401 => Err(UsersDeleteGpgKeyForAuthenticatedUserError::Status401(crate::adapters::to_json_async(github_response).await?)),
                code => Err(UsersDeleteGpgKeyForAuthenticatedUserError::Generic { code }),
            }
        }
    }

    /// ---
    ///
    /// # Delete a GPG key for the authenticated user
    ///
    /// Removes a GPG key from the authenticated user's GitHub account.
    /// 
    /// OAuth app tokens and personal access tokens (classic) need the `admin:gpg_key` scope to use this endpoint.
    ///
    /// [GitHub API docs for delete_gpg_key_for_authenticated_user](https://docs.github.com/rest/users/gpg-keys#delete-a-gpg-key-for-the-authenticated-user)
    ///
    /// ---
    #[cfg(not(target_arch = "wasm32"))]
    pub fn delete_gpg_key_for_authenticated_user(&self, gpg_key_id: i32) -> Result<(), UsersDeleteGpgKeyForAuthenticatedUserError> {

        let request_uri = format!("{}/user/gpg_keys/{}", super::GITHUB_BASE_API_URL, gpg_key_id);


        let req = GitHubRequest {
            uri: request_uri,
            body: None,
            method: "DELETE",
            headers: vec![]
        };

        let request = GitHubRequestBuilder::build(req, self.auth)?;

        // --

        let github_response = crate::adapters::fetch(request)?;

        // --

        if github_response.is_success() {
            Ok(crate::adapters::to_json(github_response)?)
        } else {
            match github_response.status_code() {
                404 => Err(UsersDeleteGpgKeyForAuthenticatedUserError::Status404(crate::adapters::to_json(github_response)?)),
                422 => Err(UsersDeleteGpgKeyForAuthenticatedUserError::Status422(crate::adapters::to_json(github_response)?)),
                304 => Err(UsersDeleteGpgKeyForAuthenticatedUserError::Status304),
                403 => Err(UsersDeleteGpgKeyForAuthenticatedUserError::Status403(crate::adapters::to_json(github_response)?)),
                401 => Err(UsersDeleteGpgKeyForAuthenticatedUserError::Status401(crate::adapters::to_json(github_response)?)),
                code => Err(UsersDeleteGpgKeyForAuthenticatedUserError::Generic { code }),
            }
        }
    }

    /// ---
    ///
    /// # Delete a public SSH key for the authenticated user
    ///
    /// Removes a public SSH key from the authenticated user's GitHub account.
    /// 
    /// OAuth app tokens and personal access tokens (classic) need the `admin:public_key` scope to use this endpoint.
    ///
    /// [GitHub API docs for delete_public_ssh_key_for_authenticated_user](https://docs.github.com/rest/users/keys#delete-a-public-ssh-key-for-the-authenticated-user)
    ///
    /// ---
    pub async fn delete_public_ssh_key_for_authenticated_user_async(&self, key_id: i32) -> Result<(), UsersDeletePublicSshKeyForAuthenticatedUserError> {

        let request_uri = format!("{}/user/keys/{}", super::GITHUB_BASE_API_URL, key_id);


        let req = GitHubRequest {
            uri: request_uri,
            body: None,
            method: "DELETE",
            headers: vec![]
        };

        let request = GitHubRequestBuilder::build(req, self.auth)?;

        // --

        let github_response = crate::adapters::fetch_async(request).await?;

        // --

        if github_response.is_success() {
            Ok(crate::adapters::to_json_async(github_response).await?)
        } else {
            match github_response.status_code() {
                304 => Err(UsersDeletePublicSshKeyForAuthenticatedUserError::Status304),
                404 => Err(UsersDeletePublicSshKeyForAuthenticatedUserError::Status404(crate::adapters::to_json_async(github_response).await?)),
                403 => Err(UsersDeletePublicSshKeyForAuthenticatedUserError::Status403(crate::adapters::to_json_async(github_response).await?)),
                401 => Err(UsersDeletePublicSshKeyForAuthenticatedUserError::Status401(crate::adapters::to_json_async(github_response).await?)),
                code => Err(UsersDeletePublicSshKeyForAuthenticatedUserError::Generic { code }),
            }
        }
    }

    /// ---
    ///
    /// # Delete a public SSH key for the authenticated user
    ///
    /// Removes a public SSH key from the authenticated user's GitHub account.
    /// 
    /// OAuth app tokens and personal access tokens (classic) need the `admin:public_key` scope to use this endpoint.
    ///
    /// [GitHub API docs for delete_public_ssh_key_for_authenticated_user](https://docs.github.com/rest/users/keys#delete-a-public-ssh-key-for-the-authenticated-user)
    ///
    /// ---
    #[cfg(not(target_arch = "wasm32"))]
    pub fn delete_public_ssh_key_for_authenticated_user(&self, key_id: i32) -> Result<(), UsersDeletePublicSshKeyForAuthenticatedUserError> {

        let request_uri = format!("{}/user/keys/{}", super::GITHUB_BASE_API_URL, key_id);


        let req = GitHubRequest {
            uri: request_uri,
            body: None,
            method: "DELETE",
            headers: vec![]
        };

        let request = GitHubRequestBuilder::build(req, self.auth)?;

        // --

        let github_response = crate::adapters::fetch(request)?;

        // --

        if github_response.is_success() {
            Ok(crate::adapters::to_json(github_response)?)
        } else {
            match github_response.status_code() {
                304 => Err(UsersDeletePublicSshKeyForAuthenticatedUserError::Status304),
                404 => Err(UsersDeletePublicSshKeyForAuthenticatedUserError::Status404(crate::adapters::to_json(github_response)?)),
                403 => Err(UsersDeletePublicSshKeyForAuthenticatedUserError::Status403(crate::adapters::to_json(github_response)?)),
                401 => Err(UsersDeletePublicSshKeyForAuthenticatedUserError::Status401(crate::adapters::to_json(github_response)?)),
                code => Err(UsersDeletePublicSshKeyForAuthenticatedUserError::Generic { code }),
            }
        }
    }

    /// ---
    ///
    /// # Delete social accounts for the authenticated user
    ///
    /// Deletes one or more social accounts from the authenticated user's profile.
    /// 
    /// OAuth app tokens and personal access tokens (classic) need the `user` scope to use this endpoint.
    ///
    /// [GitHub API docs for delete_social_account_for_authenticated_user](https://docs.github.com/rest/users/social-accounts#delete-social-accounts-for-the-authenticated-user)
    ///
    /// ---
    pub async fn delete_social_account_for_authenticated_user_async(&self, body: DeleteUsersDeleteSocialAccountForAuthenticatedUser) -> Result<(), UsersDeleteSocialAccountForAuthenticatedUserError> {

        let request_uri = format!("{}/user/social_accounts", super::GITHUB_BASE_API_URL);


        let req = GitHubRequest {
            uri: request_uri,
            body: Some(DeleteUsersDeleteSocialAccountForAuthenticatedUser::from_json(body)?),
            method: "DELETE",
            headers: vec![]
        };

        let request = GitHubRequestBuilder::build(req, self.auth)?;

        // --

        let github_response = crate::adapters::fetch_async(request).await?;

        // --

        if github_response.is_success() {
            Ok(crate::adapters::to_json_async(github_response).await?)
        } else {
            match github_response.status_code() {
                422 => Err(UsersDeleteSocialAccountForAuthenticatedUserError::Status422(crate::adapters::to_json_async(github_response).await?)),
                304 => Err(UsersDeleteSocialAccountForAuthenticatedUserError::Status304),
                404 => Err(UsersDeleteSocialAccountForAuthenticatedUserError::Status404(crate::adapters::to_json_async(github_response).await?)),
                403 => Err(UsersDeleteSocialAccountForAuthenticatedUserError::Status403(crate::adapters::to_json_async(github_response).await?)),
                401 => Err(UsersDeleteSocialAccountForAuthenticatedUserError::Status401(crate::adapters::to_json_async(github_response).await?)),
                code => Err(UsersDeleteSocialAccountForAuthenticatedUserError::Generic { code }),
            }
        }
    }

    /// ---
    ///
    /// # Delete social accounts for the authenticated user
    ///
    /// Deletes one or more social accounts from the authenticated user's profile.
    /// 
    /// OAuth app tokens and personal access tokens (classic) need the `user` scope to use this endpoint.
    ///
    /// [GitHub API docs for delete_social_account_for_authenticated_user](https://docs.github.com/rest/users/social-accounts#delete-social-accounts-for-the-authenticated-user)
    ///
    /// ---
    #[cfg(not(target_arch = "wasm32"))]
    pub fn delete_social_account_for_authenticated_user(&self, body: DeleteUsersDeleteSocialAccountForAuthenticatedUser) -> Result<(), UsersDeleteSocialAccountForAuthenticatedUserError> {

        let request_uri = format!("{}/user/social_accounts", super::GITHUB_BASE_API_URL);


        let req = GitHubRequest {
            uri: request_uri,
            body: Some(DeleteUsersDeleteSocialAccountForAuthenticatedUser::from_json(body)?),
            method: "DELETE",
            headers: vec![]
        };

        let request = GitHubRequestBuilder::build(req, self.auth)?;

        // --

        let github_response = crate::adapters::fetch(request)?;

        // --

        if github_response.is_success() {
            Ok(crate::adapters::to_json(github_response)?)
        } else {
            match github_response.status_code() {
                422 => Err(UsersDeleteSocialAccountForAuthenticatedUserError::Status422(crate::adapters::to_json(github_response)?)),
                304 => Err(UsersDeleteSocialAccountForAuthenticatedUserError::Status304),
                404 => Err(UsersDeleteSocialAccountForAuthenticatedUserError::Status404(crate::adapters::to_json(github_response)?)),
                403 => Err(UsersDeleteSocialAccountForAuthenticatedUserError::Status403(crate::adapters::to_json(github_response)?)),
                401 => Err(UsersDeleteSocialAccountForAuthenticatedUserError::Status401(crate::adapters::to_json(github_response)?)),
                code => Err(UsersDeleteSocialAccountForAuthenticatedUserError::Generic { code }),
            }
        }
    }

    /// ---
    ///
    /// # Delete an SSH signing key for the authenticated user
    ///
    /// Deletes an SSH signing key from the authenticated user's GitHub account.
    /// 
    /// OAuth app tokens and personal access tokens (classic) need the `admin:ssh_signing_key` scope to use this endpoint.
    ///
    /// [GitHub API docs for delete_ssh_signing_key_for_authenticated_user](https://docs.github.com/rest/users/ssh-signing-keys#delete-an-ssh-signing-key-for-the-authenticated-user)
    ///
    /// ---
    pub async fn delete_ssh_signing_key_for_authenticated_user_async(&self, ssh_signing_key_id: i32) -> Result<(), UsersDeleteSshSigningKeyForAuthenticatedUserError> {

        let request_uri = format!("{}/user/ssh_signing_keys/{}", super::GITHUB_BASE_API_URL, ssh_signing_key_id);


        let req = GitHubRequest {
            uri: request_uri,
            body: None,
            method: "DELETE",
            headers: vec![]
        };

        let request = GitHubRequestBuilder::build(req, self.auth)?;

        // --

        let github_response = crate::adapters::fetch_async(request).await?;

        // --

        if github_response.is_success() {
            Ok(crate::adapters::to_json_async(github_response).await?)
        } else {
            match github_response.status_code() {
                304 => Err(UsersDeleteSshSigningKeyForAuthenticatedUserError::Status304),
                404 => Err(UsersDeleteSshSigningKeyForAuthenticatedUserError::Status404(crate::adapters::to_json_async(github_response).await?)),
                403 => Err(UsersDeleteSshSigningKeyForAuthenticatedUserError::Status403(crate::adapters::to_json_async(github_response).await?)),
                401 => Err(UsersDeleteSshSigningKeyForAuthenticatedUserError::Status401(crate::adapters::to_json_async(github_response).await?)),
                code => Err(UsersDeleteSshSigningKeyForAuthenticatedUserError::Generic { code }),
            }
        }
    }

    /// ---
    ///
    /// # Delete an SSH signing key for the authenticated user
    ///
    /// Deletes an SSH signing key from the authenticated user's GitHub account.
    /// 
    /// OAuth app tokens and personal access tokens (classic) need the `admin:ssh_signing_key` scope to use this endpoint.
    ///
    /// [GitHub API docs for delete_ssh_signing_key_for_authenticated_user](https://docs.github.com/rest/users/ssh-signing-keys#delete-an-ssh-signing-key-for-the-authenticated-user)
    ///
    /// ---
    #[cfg(not(target_arch = "wasm32"))]
    pub fn delete_ssh_signing_key_for_authenticated_user(&self, ssh_signing_key_id: i32) -> Result<(), UsersDeleteSshSigningKeyForAuthenticatedUserError> {

        let request_uri = format!("{}/user/ssh_signing_keys/{}", super::GITHUB_BASE_API_URL, ssh_signing_key_id);


        let req = GitHubRequest {
            uri: request_uri,
            body: None,
            method: "DELETE",
            headers: vec![]
        };

        let request = GitHubRequestBuilder::build(req, self.auth)?;

        // --

        let github_response = crate::adapters::fetch(request)?;

        // --

        if github_response.is_success() {
            Ok(crate::adapters::to_json(github_response)?)
        } else {
            match github_response.status_code() {
                304 => Err(UsersDeleteSshSigningKeyForAuthenticatedUserError::Status304),
                404 => Err(UsersDeleteSshSigningKeyForAuthenticatedUserError::Status404(crate::adapters::to_json(github_response)?)),
                403 => Err(UsersDeleteSshSigningKeyForAuthenticatedUserError::Status403(crate::adapters::to_json(github_response)?)),
                401 => Err(UsersDeleteSshSigningKeyForAuthenticatedUserError::Status401(crate::adapters::to_json(github_response)?)),
                code => Err(UsersDeleteSshSigningKeyForAuthenticatedUserError::Generic { code }),
            }
        }
    }

    /// ---
    ///
    /// # Follow a user
    ///
    /// Note that you'll need to set `Content-Length` to zero when calling out to this endpoint. For more information, see "[HTTP verbs](https://docs.github.com/rest/guides/getting-started-with-the-rest-api#http-method)."
    /// 
    /// OAuth app tokens and personal access tokens (classic) need the `user:follow` scope to use this endpoint.
    ///
    /// [GitHub API docs for follow](https://docs.github.com/rest/users/followers#follow-a-user)
    ///
    /// ---
    pub async fn follow_async(&self, username: &str) -> Result<(), UsersFollowError> {

        let request_uri = format!("{}/user/following/{}", super::GITHUB_BASE_API_URL, username);


        let req = GitHubRequest {
            uri: request_uri,
            body: None,
            method: "PUT",
            headers: vec![]
        };

        let request = GitHubRequestBuilder::build(req, self.auth)?;

        // --

        let github_response = crate::adapters::fetch_async(request).await?;

        // --

        if github_response.is_success() {
            Ok(crate::adapters::to_json_async(github_response).await?)
        } else {
            match github_response.status_code() {
                304 => Err(UsersFollowError::Status304),
                404 => Err(UsersFollowError::Status404(crate::adapters::to_json_async(github_response).await?)),
                403 => Err(UsersFollowError::Status403(crate::adapters::to_json_async(github_response).await?)),
                401 => Err(UsersFollowError::Status401(crate::adapters::to_json_async(github_response).await?)),
                code => Err(UsersFollowError::Generic { code }),
            }
        }
    }

    /// ---
    ///
    /// # Follow a user
    ///
    /// Note that you'll need to set `Content-Length` to zero when calling out to this endpoint. For more information, see "[HTTP verbs](https://docs.github.com/rest/guides/getting-started-with-the-rest-api#http-method)."
    /// 
    /// OAuth app tokens and personal access tokens (classic) need the `user:follow` scope to use this endpoint.
    ///
    /// [GitHub API docs for follow](https://docs.github.com/rest/users/followers#follow-a-user)
    ///
    /// ---
    #[cfg(not(target_arch = "wasm32"))]
    pub fn follow(&self, username: &str) -> Result<(), UsersFollowError> {

        let request_uri = format!("{}/user/following/{}", super::GITHUB_BASE_API_URL, username);


        let req = GitHubRequest {
            uri: request_uri,
            body: None,
            method: "PUT",
            headers: vec![]
        };

        let request = GitHubRequestBuilder::build(req, self.auth)?;

        // --

        let github_response = crate::adapters::fetch(request)?;

        // --

        if github_response.is_success() {
            Ok(crate::adapters::to_json(github_response)?)
        } else {
            match github_response.status_code() {
                304 => Err(UsersFollowError::Status304),
                404 => Err(UsersFollowError::Status404(crate::adapters::to_json(github_response)?)),
                403 => Err(UsersFollowError::Status403(crate::adapters::to_json(github_response)?)),
                401 => Err(UsersFollowError::Status401(crate::adapters::to_json(github_response)?)),
                code => Err(UsersFollowError::Generic { code }),
            }
        }
    }

    /// ---
    ///
    /// # Get the authenticated user
    ///
    /// OAuth app tokens and personal access tokens (classic) need the `user` scope in order for the response to include private profile information.
    ///
    /// [GitHub API docs for get_authenticated](https://docs.github.com/rest/users/users#get-the-authenticated-user)
    ///
    /// ---
    pub async fn get_authenticated_async(&self) -> Result<GetUsersGetByUsernameResponse200, UsersGetAuthenticatedError> {

        let request_uri = format!("{}/user", super::GITHUB_BASE_API_URL);


        let req = GitHubRequest {
            uri: request_uri,
            body: None,
            method: "GET",
            headers: vec![]
        };

        let request = GitHubRequestBuilder::build(req, self.auth)?;

        // --

        let github_response = crate::adapters::fetch_async(request).await?;

        // --

        if github_response.is_success() {
            Ok(crate::adapters::to_json_async(github_response).await?)
        } else {
            match github_response.status_code() {
                304 => Err(UsersGetAuthenticatedError::Status304),
                403 => Err(UsersGetAuthenticatedError::Status403(crate::adapters::to_json_async(github_response).await?)),
                401 => Err(UsersGetAuthenticatedError::Status401(crate::adapters::to_json_async(github_response).await?)),
                code => Err(UsersGetAuthenticatedError::Generic { code }),
            }
        }
    }

    /// ---
    ///
    /// # Get the authenticated user
    ///
    /// OAuth app tokens and personal access tokens (classic) need the `user` scope in order for the response to include private profile information.
    ///
    /// [GitHub API docs for get_authenticated](https://docs.github.com/rest/users/users#get-the-authenticated-user)
    ///
    /// ---
    #[cfg(not(target_arch = "wasm32"))]
    pub fn get_authenticated(&self) -> Result<GetUsersGetByUsernameResponse200, UsersGetAuthenticatedError> {

        let request_uri = format!("{}/user", super::GITHUB_BASE_API_URL);


        let req = GitHubRequest {
            uri: request_uri,
            body: None,
            method: "GET",
            headers: vec![]
        };

        let request = GitHubRequestBuilder::build(req, self.auth)?;

        // --

        let github_response = crate::adapters::fetch(request)?;

        // --

        if github_response.is_success() {
            Ok(crate::adapters::to_json(github_response)?)
        } else {
            match github_response.status_code() {
                304 => Err(UsersGetAuthenticatedError::Status304),
                403 => Err(UsersGetAuthenticatedError::Status403(crate::adapters::to_json(github_response)?)),
                401 => Err(UsersGetAuthenticatedError::Status401(crate::adapters::to_json(github_response)?)),
                code => Err(UsersGetAuthenticatedError::Generic { code }),
            }
        }
    }

    /// ---
    ///
    /// # Get a user using their ID
    ///
    /// Provides publicly available information about someone with a GitHub account. This method takes their durable user `ID` instead of their `login`, which can change over time.
    /// 
    /// The `email` key in the following response is the publicly visible email address from your GitHub [profile page](https://github.com/settings/profile). When setting up your profile, you can select a primary email address to be “public” which provides an email entry for this endpoint. If you do not set a public email address for `email`, then it will have a value of `null`. You only see publicly visible email addresses when authenticated with GitHub. For more information, see [Authentication](https://docs.github.com/rest/guides/getting-started-with-the-rest-api#authentication).
    /// 
    /// The Emails API enables you to list all of your email addresses, and toggle a primary email to be visible publicly. For more information, see "[Emails API](https://docs.github.com/rest/users/emails)".
    ///
    /// [GitHub API docs for get_by_id](https://docs.github.com/rest/users/users#get-a-user-using-their-id)
    ///
    /// ---
    pub async fn get_by_id_async(&self, account_id: i32) -> Result<GetUsersGetByUsernameResponse200, UsersGetByIdError> {

        let request_uri = format!("{}/user/{}", super::GITHUB_BASE_API_URL, account_id);


        let req = GitHubRequest {
            uri: request_uri,
            body: None,
            method: "GET",
            headers: vec![]
        };

        let request = GitHubRequestBuilder::build(req, self.auth)?;

        // --

        let github_response = crate::adapters::fetch_async(request).await?;

        // --

        if github_response.is_success() {
            Ok(crate::adapters::to_json_async(github_response).await?)
        } else {
            match github_response.status_code() {
                404 => Err(UsersGetByIdError::Status404(crate::adapters::to_json_async(github_response).await?)),
                code => Err(UsersGetByIdError::Generic { code }),
            }
        }
    }

    /// ---
    ///
    /// # Get a user using their ID
    ///
    /// Provides publicly available information about someone with a GitHub account. This method takes their durable user `ID` instead of their `login`, which can change over time.
    /// 
    /// The `email` key in the following response is the publicly visible email address from your GitHub [profile page](https://github.com/settings/profile). When setting up your profile, you can select a primary email address to be “public” which provides an email entry for this endpoint. If you do not set a public email address for `email`, then it will have a value of `null`. You only see publicly visible email addresses when authenticated with GitHub. For more information, see [Authentication](https://docs.github.com/rest/guides/getting-started-with-the-rest-api#authentication).
    /// 
    /// The Emails API enables you to list all of your email addresses, and toggle a primary email to be visible publicly. For more information, see "[Emails API](https://docs.github.com/rest/users/emails)".
    ///
    /// [GitHub API docs for get_by_id](https://docs.github.com/rest/users/users#get-a-user-using-their-id)
    ///
    /// ---
    #[cfg(not(target_arch = "wasm32"))]
    pub fn get_by_id(&self, account_id: i32) -> Result<GetUsersGetByUsernameResponse200, UsersGetByIdError> {

        let request_uri = format!("{}/user/{}", super::GITHUB_BASE_API_URL, account_id);


        let req = GitHubRequest {
            uri: request_uri,
            body: None,
            method: "GET",
            headers: vec![]
        };

        let request = GitHubRequestBuilder::build(req, self.auth)?;

        // --

        let github_response = crate::adapters::fetch(request)?;

        // --

        if github_response.is_success() {
            Ok(crate::adapters::to_json(github_response)?)
        } else {
            match github_response.status_code() {
                404 => Err(UsersGetByIdError::Status404(crate::adapters::to_json(github_response)?)),
                code => Err(UsersGetByIdError::Generic { code }),
            }
        }
    }

    /// ---
    ///
    /// # Get a user
    ///
    /// Provides publicly available information about someone with a GitHub account.
    /// 
    /// The `email` key in the following response is the publicly visible email address from your GitHub [profile page](https://github.com/settings/profile). When setting up your profile, you can select a primary email address to be “public” which provides an email entry for this endpoint. If you do not set a public email address for `email`, then it will have a value of `null`. You only see publicly visible email addresses when authenticated with GitHub. For more information, see [Authentication](https://docs.github.com/rest/guides/getting-started-with-the-rest-api#authentication).
    /// 
    /// The Emails API enables you to list all of your email addresses, and toggle a primary email to be visible publicly. For more information, see "[Emails API](https://docs.github.com/rest/users/emails)".
    ///
    /// [GitHub API docs for get_by_username](https://docs.github.com/rest/users/users#get-a-user)
    ///
    /// ---
    pub async fn get_by_username_async(&self, username: &str) -> Result<GetUsersGetByUsernameResponse200, UsersGetByUsernameError> {

        let request_uri = format!("{}/users/{}", super::GITHUB_BASE_API_URL, username);


        let req = GitHubRequest {
            uri: request_uri,
            body: None,
            method: "GET",
            headers: vec![]
        };

        let request = GitHubRequestBuilder::build(req, self.auth)?;

        // --

        let github_response = crate::adapters::fetch_async(request).await?;

        // --

        if github_response.is_success() {
            Ok(crate::adapters::to_json_async(github_response).await?)
        } else {
            match github_response.status_code() {
                404 => Err(UsersGetByUsernameError::Status404(crate::adapters::to_json_async(github_response).await?)),
                code => Err(UsersGetByUsernameError::Generic { code }),
            }
        }
    }

    /// ---
    ///
    /// # Get a user
    ///
    /// Provides publicly available information about someone with a GitHub account.
    /// 
    /// The `email` key in the following response is the publicly visible email address from your GitHub [profile page](https://github.com/settings/profile). When setting up your profile, you can select a primary email address to be “public” which provides an email entry for this endpoint. If you do not set a public email address for `email`, then it will have a value of `null`. You only see publicly visible email addresses when authenticated with GitHub. For more information, see [Authentication](https://docs.github.com/rest/guides/getting-started-with-the-rest-api#authentication).
    /// 
    /// The Emails API enables you to list all of your email addresses, and toggle a primary email to be visible publicly. For more information, see "[Emails API](https://docs.github.com/rest/users/emails)".
    ///
    /// [GitHub API docs for get_by_username](https://docs.github.com/rest/users/users#get-a-user)
    ///
    /// ---
    #[cfg(not(target_arch = "wasm32"))]
    pub fn get_by_username(&self, username: &str) -> Result<GetUsersGetByUsernameResponse200, UsersGetByUsernameError> {

        let request_uri = format!("{}/users/{}", super::GITHUB_BASE_API_URL, username);


        let req = GitHubRequest {
            uri: request_uri,
            body: None,
            method: "GET",
            headers: vec![]
        };

        let request = GitHubRequestBuilder::build(req, self.auth)?;

        // --

        let github_response = crate::adapters::fetch(request)?;

        // --

        if github_response.is_success() {
            Ok(crate::adapters::to_json(github_response)?)
        } else {
            match github_response.status_code() {
                404 => Err(UsersGetByUsernameError::Status404(crate::adapters::to_json(github_response)?)),
                code => Err(UsersGetByUsernameError::Generic { code }),
            }
        }
    }

    /// ---
    ///
    /// # Get contextual information for a user
    ///
    /// Provides hovercard information. You can find out more about someone in relation to their pull requests, issues, repositories, and organizations.
    /// 
    ///   The `subject_type` and `subject_id` parameters provide context for the person's hovercard, which returns more information than without the parameters. For example, if you wanted to find out more about `octocat` who owns the `Spoon-Knife` repository, you would use a `subject_type` value of `repository` and a `subject_id` value of `1300192` (the ID of the `Spoon-Knife` repository).
    /// 
    /// OAuth app tokens and personal access tokens (classic) need the `repo` scope to use this endpoint.
    ///
    /// [GitHub API docs for get_context_for_user](https://docs.github.com/rest/users/users#get-contextual-information-for-a-user)
    ///
    /// ---
    pub async fn get_context_for_user_async(&self, username: &str, query_params: Option<impl Into<UsersGetContextForUserParams<'api>>>) -> Result<Hovercard, UsersGetContextForUserError> {

        let mut request_uri = format!("{}/users/{}/hovercard", super::GITHUB_BASE_API_URL, username);

        if let Some(params) = query_params {
            request_uri.push_str("?");
            request_uri.push_str(&serde_urlencoded::to_string(params.into())?);
        }

        let req = GitHubRequest {
            uri: request_uri,
            body: None,
            method: "GET",
            headers: vec![]
        };

        let request = GitHubRequestBuilder::build(req, self.auth)?;

        // --

        let github_response = crate::adapters::fetch_async(request).await?;

        // --

        if github_response.is_success() {
            Ok(crate::adapters::to_json_async(github_response).await?)
        } else {
            match github_response.status_code() {
                404 => Err(UsersGetContextForUserError::Status404(crate::adapters::to_json_async(github_response).await?)),
                422 => Err(UsersGetContextForUserError::Status422(crate::adapters::to_json_async(github_response).await?)),
                code => Err(UsersGetContextForUserError::Generic { code }),
            }
        }
    }

    /// ---
    ///
    /// # Get contextual information for a user
    ///
    /// Provides hovercard information. You can find out more about someone in relation to their pull requests, issues, repositories, and organizations.
    /// 
    ///   The `subject_type` and `subject_id` parameters provide context for the person's hovercard, which returns more information than without the parameters. For example, if you wanted to find out more about `octocat` who owns the `Spoon-Knife` repository, you would use a `subject_type` value of `repository` and a `subject_id` value of `1300192` (the ID of the `Spoon-Knife` repository).
    /// 
    /// OAuth app tokens and personal access tokens (classic) need the `repo` scope to use this endpoint.
    ///
    /// [GitHub API docs for get_context_for_user](https://docs.github.com/rest/users/users#get-contextual-information-for-a-user)
    ///
    /// ---
    #[cfg(not(target_arch = "wasm32"))]
    pub fn get_context_for_user(&self, username: &str, query_params: Option<impl Into<UsersGetContextForUserParams<'api>>>) -> Result<Hovercard, UsersGetContextForUserError> {

        let mut request_uri = format!("{}/users/{}/hovercard", super::GITHUB_BASE_API_URL, username);

        if let Some(params) = query_params {
            request_uri.push_str("?");
            let qp: UsersGetContextForUserParams = params.into();
            request_uri.push_str(&serde_urlencoded::to_string(qp)?);
        }

        let req = GitHubRequest {
            uri: request_uri,
            body: None,
            method: "GET",
            headers: vec![]
        };

        let request = GitHubRequestBuilder::build(req, self.auth)?;

        // --

        let github_response = crate::adapters::fetch(request)?;

        // --

        if github_response.is_success() {
            Ok(crate::adapters::to_json(github_response)?)
        } else {
            match github_response.status_code() {
                404 => Err(UsersGetContextForUserError::Status404(crate::adapters::to_json(github_response)?)),
                422 => Err(UsersGetContextForUserError::Status422(crate::adapters::to_json(github_response)?)),
                code => Err(UsersGetContextForUserError::Generic { code }),
            }
        }
    }

    /// ---
    ///
    /// # Get a GPG key for the authenticated user
    ///
    /// View extended details for a single GPG key.
    /// 
    /// OAuth app tokens and personal access tokens (classic) need the `read:gpg_key` scope to use this endpoint.
    ///
    /// [GitHub API docs for get_gpg_key_for_authenticated_user](https://docs.github.com/rest/users/gpg-keys#get-a-gpg-key-for-the-authenticated-user)
    ///
    /// ---
    pub async fn get_gpg_key_for_authenticated_user_async(&self, gpg_key_id: i32) -> Result<GpgKey, UsersGetGpgKeyForAuthenticatedUserError> {

        let request_uri = format!("{}/user/gpg_keys/{}", super::GITHUB_BASE_API_URL, gpg_key_id);


        let req = GitHubRequest {
            uri: request_uri,
            body: None,
            method: "GET",
            headers: vec![]
        };

        let request = GitHubRequestBuilder::build(req, self.auth)?;

        // --

        let github_response = crate::adapters::fetch_async(request).await?;

        // --

        if github_response.is_success() {
            Ok(crate::adapters::to_json_async(github_response).await?)
        } else {
            match github_response.status_code() {
                404 => Err(UsersGetGpgKeyForAuthenticatedUserError::Status404(crate::adapters::to_json_async(github_response).await?)),
                304 => Err(UsersGetGpgKeyForAuthenticatedUserError::Status304),
                403 => Err(UsersGetGpgKeyForAuthenticatedUserError::Status403(crate::adapters::to_json_async(github_response).await?)),
                401 => Err(UsersGetGpgKeyForAuthenticatedUserError::Status401(crate::adapters::to_json_async(github_response).await?)),
                code => Err(UsersGetGpgKeyForAuthenticatedUserError::Generic { code }),
            }
        }
    }

    /// ---
    ///
    /// # Get a GPG key for the authenticated user
    ///
    /// View extended details for a single GPG key.
    /// 
    /// OAuth app tokens and personal access tokens (classic) need the `read:gpg_key` scope to use this endpoint.
    ///
    /// [GitHub API docs for get_gpg_key_for_authenticated_user](https://docs.github.com/rest/users/gpg-keys#get-a-gpg-key-for-the-authenticated-user)
    ///
    /// ---
    #[cfg(not(target_arch = "wasm32"))]
    pub fn get_gpg_key_for_authenticated_user(&self, gpg_key_id: i32) -> Result<GpgKey, UsersGetGpgKeyForAuthenticatedUserError> {

        let request_uri = format!("{}/user/gpg_keys/{}", super::GITHUB_BASE_API_URL, gpg_key_id);


        let req = GitHubRequest {
            uri: request_uri,
            body: None,
            method: "GET",
            headers: vec![]
        };

        let request = GitHubRequestBuilder::build(req, self.auth)?;

        // --

        let github_response = crate::adapters::fetch(request)?;

        // --

        if github_response.is_success() {
            Ok(crate::adapters::to_json(github_response)?)
        } else {
            match github_response.status_code() {
                404 => Err(UsersGetGpgKeyForAuthenticatedUserError::Status404(crate::adapters::to_json(github_response)?)),
                304 => Err(UsersGetGpgKeyForAuthenticatedUserError::Status304),
                403 => Err(UsersGetGpgKeyForAuthenticatedUserError::Status403(crate::adapters::to_json(github_response)?)),
                401 => Err(UsersGetGpgKeyForAuthenticatedUserError::Status401(crate::adapters::to_json(github_response)?)),
                code => Err(UsersGetGpgKeyForAuthenticatedUserError::Generic { code }),
            }
        }
    }

    /// ---
    ///
    /// # Get a public SSH key for the authenticated user
    ///
    /// View extended details for a single public SSH key.
    /// 
    /// OAuth app tokens and personal access tokens (classic) need the `read:public_key` scope to use this endpoint.
    ///
    /// [GitHub API docs for get_public_ssh_key_for_authenticated_user](https://docs.github.com/rest/users/keys#get-a-public-ssh-key-for-the-authenticated-user)
    ///
    /// ---
    pub async fn get_public_ssh_key_for_authenticated_user_async(&self, key_id: i32) -> Result<Key, UsersGetPublicSshKeyForAuthenticatedUserError> {

        let request_uri = format!("{}/user/keys/{}", super::GITHUB_BASE_API_URL, key_id);


        let req = GitHubRequest {
            uri: request_uri,
            body: None,
            method: "GET",
            headers: vec![]
        };

        let request = GitHubRequestBuilder::build(req, self.auth)?;

        // --

        let github_response = crate::adapters::fetch_async(request).await?;

        // --

        if github_response.is_success() {
            Ok(crate::adapters::to_json_async(github_response).await?)
        } else {
            match github_response.status_code() {
                404 => Err(UsersGetPublicSshKeyForAuthenticatedUserError::Status404(crate::adapters::to_json_async(github_response).await?)),
                304 => Err(UsersGetPublicSshKeyForAuthenticatedUserError::Status304),
                403 => Err(UsersGetPublicSshKeyForAuthenticatedUserError::Status403(crate::adapters::to_json_async(github_response).await?)),
                401 => Err(UsersGetPublicSshKeyForAuthenticatedUserError::Status401(crate::adapters::to_json_async(github_response).await?)),
                code => Err(UsersGetPublicSshKeyForAuthenticatedUserError::Generic { code }),
            }
        }
    }

    /// ---
    ///
    /// # Get a public SSH key for the authenticated user
    ///
    /// View extended details for a single public SSH key.
    /// 
    /// OAuth app tokens and personal access tokens (classic) need the `read:public_key` scope to use this endpoint.
    ///
    /// [GitHub API docs for get_public_ssh_key_for_authenticated_user](https://docs.github.com/rest/users/keys#get-a-public-ssh-key-for-the-authenticated-user)
    ///
    /// ---
    #[cfg(not(target_arch = "wasm32"))]
    pub fn get_public_ssh_key_for_authenticated_user(&self, key_id: i32) -> Result<Key, UsersGetPublicSshKeyForAuthenticatedUserError> {

        let request_uri = format!("{}/user/keys/{}", super::GITHUB_BASE_API_URL, key_id);


        let req = GitHubRequest {
            uri: request_uri,
            body: None,
            method: "GET",
            headers: vec![]
        };

        let request = GitHubRequestBuilder::build(req, self.auth)?;

        // --

        let github_response = crate::adapters::fetch(request)?;

        // --

        if github_response.is_success() {
            Ok(crate::adapters::to_json(github_response)?)
        } else {
            match github_response.status_code() {
                404 => Err(UsersGetPublicSshKeyForAuthenticatedUserError::Status404(crate::adapters::to_json(github_response)?)),
                304 => Err(UsersGetPublicSshKeyForAuthenticatedUserError::Status304),
                403 => Err(UsersGetPublicSshKeyForAuthenticatedUserError::Status403(crate::adapters::to_json(github_response)?)),
                401 => Err(UsersGetPublicSshKeyForAuthenticatedUserError::Status401(crate::adapters::to_json(github_response)?)),
                code => Err(UsersGetPublicSshKeyForAuthenticatedUserError::Generic { code }),
            }
        }
    }

    /// ---
    ///
    /// # Get an SSH signing key for the authenticated user
    ///
    /// Gets extended details for an SSH signing key.
    /// 
    /// OAuth app tokens and personal access tokens (classic) need the `read:ssh_signing_key` scope to use this endpoint.
    ///
    /// [GitHub API docs for get_ssh_signing_key_for_authenticated_user](https://docs.github.com/rest/users/ssh-signing-keys#get-an-ssh-signing-key-for-the-authenticated-user)
    ///
    /// ---
    pub async fn get_ssh_signing_key_for_authenticated_user_async(&self, ssh_signing_key_id: i32) -> Result<SshSigningKey, UsersGetSshSigningKeyForAuthenticatedUserError> {

        let request_uri = format!("{}/user/ssh_signing_keys/{}", super::GITHUB_BASE_API_URL, ssh_signing_key_id);


        let req = GitHubRequest {
            uri: request_uri,
            body: None,
            method: "GET",
            headers: vec![]
        };

        let request = GitHubRequestBuilder::build(req, self.auth)?;

        // --

        let github_response = crate::adapters::fetch_async(request).await?;

        // --

        if github_response.is_success() {
            Ok(crate::adapters::to_json_async(github_response).await?)
        } else {
            match github_response.status_code() {
                404 => Err(UsersGetSshSigningKeyForAuthenticatedUserError::Status404(crate::adapters::to_json_async(github_response).await?)),
                304 => Err(UsersGetSshSigningKeyForAuthenticatedUserError::Status304),
                403 => Err(UsersGetSshSigningKeyForAuthenticatedUserError::Status403(crate::adapters::to_json_async(github_response).await?)),
                401 => Err(UsersGetSshSigningKeyForAuthenticatedUserError::Status401(crate::adapters::to_json_async(github_response).await?)),
                code => Err(UsersGetSshSigningKeyForAuthenticatedUserError::Generic { code }),
            }
        }
    }

    /// ---
    ///
    /// # Get an SSH signing key for the authenticated user
    ///
    /// Gets extended details for an SSH signing key.
    /// 
    /// OAuth app tokens and personal access tokens (classic) need the `read:ssh_signing_key` scope to use this endpoint.
    ///
    /// [GitHub API docs for get_ssh_signing_key_for_authenticated_user](https://docs.github.com/rest/users/ssh-signing-keys#get-an-ssh-signing-key-for-the-authenticated-user)
    ///
    /// ---
    #[cfg(not(target_arch = "wasm32"))]
    pub fn get_ssh_signing_key_for_authenticated_user(&self, ssh_signing_key_id: i32) -> Result<SshSigningKey, UsersGetSshSigningKeyForAuthenticatedUserError> {

        let request_uri = format!("{}/user/ssh_signing_keys/{}", super::GITHUB_BASE_API_URL, ssh_signing_key_id);


        let req = GitHubRequest {
            uri: request_uri,
            body: None,
            method: "GET",
            headers: vec![]
        };

        let request = GitHubRequestBuilder::build(req, self.auth)?;

        // --

        let github_response = crate::adapters::fetch(request)?;

        // --

        if github_response.is_success() {
            Ok(crate::adapters::to_json(github_response)?)
        } else {
            match github_response.status_code() {
                404 => Err(UsersGetSshSigningKeyForAuthenticatedUserError::Status404(crate::adapters::to_json(github_response)?)),
                304 => Err(UsersGetSshSigningKeyForAuthenticatedUserError::Status304),
                403 => Err(UsersGetSshSigningKeyForAuthenticatedUserError::Status403(crate::adapters::to_json(github_response)?)),
                401 => Err(UsersGetSshSigningKeyForAuthenticatedUserError::Status401(crate::adapters::to_json(github_response)?)),
                code => Err(UsersGetSshSigningKeyForAuthenticatedUserError::Generic { code }),
            }
        }
    }

    /// ---
    ///
    /// # List users
    ///
    /// Lists all users, in the order that they signed up on GitHub. This list includes personal user accounts and organization accounts.
    /// 
    /// Note: Pagination is powered exclusively by the `since` parameter. Use the [Link header](https://docs.github.com/rest/guides/using-pagination-in-the-rest-api#using-link-headers) to get the URL for the next page of users.
    ///
    /// [GitHub API docs for list](https://docs.github.com/rest/users/users#list-users)
    ///
    /// ---
    pub async fn list_async(&self, query_params: Option<impl Into<UsersListParams>>) -> Result<Vec<SimpleUser>, UsersListError> {

        let mut request_uri = format!("{}/users", super::GITHUB_BASE_API_URL);

        if let Some(params) = query_params {
            request_uri.push_str("?");
            request_uri.push_str(&serde_urlencoded::to_string(params.into())?);
        }

        let req = GitHubRequest {
            uri: request_uri,
            body: None,
            method: "GET",
            headers: vec![]
        };

        let request = GitHubRequestBuilder::build(req, self.auth)?;

        // --

        let github_response = crate::adapters::fetch_async(request).await?;

        // --

        if github_response.is_success() {
            Ok(crate::adapters::to_json_async(github_response).await?)
        } else {
            match github_response.status_code() {
                304 => Err(UsersListError::Status304),
                code => Err(UsersListError::Generic { code }),
            }
        }
    }

    /// ---
    ///
    /// # List users
    ///
    /// Lists all users, in the order that they signed up on GitHub. This list includes personal user accounts and organization accounts.
    /// 
    /// Note: Pagination is powered exclusively by the `since` parameter. Use the [Link header](https://docs.github.com/rest/guides/using-pagination-in-the-rest-api#using-link-headers) to get the URL for the next page of users.
    ///
    /// [GitHub API docs for list](https://docs.github.com/rest/users/users#list-users)
    ///
    /// ---
    #[cfg(not(target_arch = "wasm32"))]
    pub fn list(&self, query_params: Option<impl Into<UsersListParams>>) -> Result<Vec<SimpleUser>, UsersListError> {

        let mut request_uri = format!("{}/users", super::GITHUB_BASE_API_URL);

        if let Some(params) = query_params {
            request_uri.push_str("?");
            let qp: UsersListParams = params.into();
            request_uri.push_str(&serde_urlencoded::to_string(qp)?);
        }

        let req = GitHubRequest {
            uri: request_uri,
            body: None,
            method: "GET",
            headers: vec![]
        };

        let request = GitHubRequestBuilder::build(req, self.auth)?;

        // --

        let github_response = crate::adapters::fetch(request)?;

        // --

        if github_response.is_success() {
            Ok(crate::adapters::to_json(github_response)?)
        } else {
            match github_response.status_code() {
                304 => Err(UsersListError::Status304),
                code => Err(UsersListError::Generic { code }),
            }
        }
    }

    /// ---
    ///
    /// # List attestations
    ///
    /// List a collection of artifact attestations with a given subject digest that are associated with repositories owned by a user.
    /// 
    /// The collection of attestations returned by this endpoint is filtered according to the authenticated user's permissions; if the authenticated user cannot read a repository, the attestations associated with that repository will not be included in the response. In addition, when using a fine-grained access token the `attestations:read` permission is required.
    /// 
    /// **Please note:** in order to offer meaningful security benefits, an attestation's signature and timestamps **must** be cryptographically verified, and the identity of the attestation signer **must** be validated. Attestations can be verified using the [GitHub CLI `attestation verify` command](https://cli.github.com/manual/gh_attestation_verify). For more information, see [our guide on how to use artifact attestations to establish a build's provenance](https://docs.github.com/actions/security-guides/using-artifact-attestations-to-establish-provenance-for-builds).
    ///
    /// [GitHub API docs for list_attestations](https://docs.github.com/rest/users/attestations#list-attestations)
    ///
    /// ---
    pub async fn list_attestations_async(&self, username: &str, subject_digest: &str, query_params: Option<impl Into<UsersListAttestationsParams<'api>>>) -> Result<GetUsersListAttestationsResponse200, UsersListAttestationsError> {

        let mut request_uri = format!("{}/users/{}/attestations/{}", super::GITHUB_BASE_API_URL, username, subject_digest);

        if let Some(params) = query_params {
            request_uri.push_str("?");
            request_uri.push_str(&serde_urlencoded::to_string(params.into())?);
        }

        let req = GitHubRequest {
            uri: request_uri,
            body: None,
            method: "GET",
            headers: vec![]
        };

        let request = GitHubRequestBuilder::build(req, self.auth)?;

        // --

        let github_response = crate::adapters::fetch_async(request).await?;

        // --

        if github_response.is_success() {
            Ok(crate::adapters::to_json_async(github_response).await?)
        } else {
            match github_response.status_code() {
                201 => Err(UsersListAttestationsError::Status201(crate::adapters::to_json_async(github_response).await?)),
                204 => Err(UsersListAttestationsError::Status204),
                404 => Err(UsersListAttestationsError::Status404(crate::adapters::to_json_async(github_response).await?)),
                code => Err(UsersListAttestationsError::Generic { code }),
            }
        }
    }

    /// ---
    ///
    /// # List attestations
    ///
    /// List a collection of artifact attestations with a given subject digest that are associated with repositories owned by a user.
    /// 
    /// The collection of attestations returned by this endpoint is filtered according to the authenticated user's permissions; if the authenticated user cannot read a repository, the attestations associated with that repository will not be included in the response. In addition, when using a fine-grained access token the `attestations:read` permission is required.
    /// 
    /// **Please note:** in order to offer meaningful security benefits, an attestation's signature and timestamps **must** be cryptographically verified, and the identity of the attestation signer **must** be validated. Attestations can be verified using the [GitHub CLI `attestation verify` command](https://cli.github.com/manual/gh_attestation_verify). For more information, see [our guide on how to use artifact attestations to establish a build's provenance](https://docs.github.com/actions/security-guides/using-artifact-attestations-to-establish-provenance-for-builds).
    ///
    /// [GitHub API docs for list_attestations](https://docs.github.com/rest/users/attestations#list-attestations)
    ///
    /// ---
    #[cfg(not(target_arch = "wasm32"))]
    pub fn list_attestations(&self, username: &str, subject_digest: &str, query_params: Option<impl Into<UsersListAttestationsParams<'api>>>) -> Result<GetUsersListAttestationsResponse200, UsersListAttestationsError> {

        let mut request_uri = format!("{}/users/{}/attestations/{}", super::GITHUB_BASE_API_URL, username, subject_digest);

        if let Some(params) = query_params {
            request_uri.push_str("?");
            let qp: UsersListAttestationsParams = params.into();
            request_uri.push_str(&serde_urlencoded::to_string(qp)?);
        }

        let req = GitHubRequest {
            uri: request_uri,
            body: None,
            method: "GET",
            headers: vec![]
        };

        let request = GitHubRequestBuilder::build(req, self.auth)?;

        // --

        let github_response = crate::adapters::fetch(request)?;

        // --

        if github_response.is_success() {
            Ok(crate::adapters::to_json(github_response)?)
        } else {
            match github_response.status_code() {
                201 => Err(UsersListAttestationsError::Status201(crate::adapters::to_json(github_response)?)),
                204 => Err(UsersListAttestationsError::Status204),
                404 => Err(UsersListAttestationsError::Status404(crate::adapters::to_json(github_response)?)),
                code => Err(UsersListAttestationsError::Generic { code }),
            }
        }
    }

    /// ---
    ///
    /// # List users blocked by the authenticated user
    ///
    /// List the users you've blocked on your personal account.
    ///
    /// [GitHub API docs for list_blocked_by_authenticated_user](https://docs.github.com/rest/users/blocking#list-users-blocked-by-the-authenticated-user)
    ///
    /// ---
    pub async fn list_blocked_by_authenticated_user_async(&self, query_params: Option<impl Into<UsersListBlockedByAuthenticatedUserParams>>) -> Result<Vec<SimpleUser>, UsersListBlockedByAuthenticatedUserError> {

        let mut request_uri = format!("{}/user/blocks", super::GITHUB_BASE_API_URL);

        if let Some(params) = query_params {
            request_uri.push_str("?");
            request_uri.push_str(&serde_urlencoded::to_string(params.into())?);
        }

        let req = GitHubRequest {
            uri: request_uri,
            body: None,
            method: "GET",
            headers: vec![]
        };

        let request = GitHubRequestBuilder::build(req, self.auth)?;

        // --

        let github_response = crate::adapters::fetch_async(request).await?;

        // --

        if github_response.is_success() {
            Ok(crate::adapters::to_json_async(github_response).await?)
        } else {
            match github_response.status_code() {
                304 => Err(UsersListBlockedByAuthenticatedUserError::Status304),
                404 => Err(UsersListBlockedByAuthenticatedUserError::Status404(crate::adapters::to_json_async(github_response).await?)),
                403 => Err(UsersListBlockedByAuthenticatedUserError::Status403(crate::adapters::to_json_async(github_response).await?)),
                401 => Err(UsersListBlockedByAuthenticatedUserError::Status401(crate::adapters::to_json_async(github_response).await?)),
                code => Err(UsersListBlockedByAuthenticatedUserError::Generic { code }),
            }
        }
    }

    /// ---
    ///
    /// # List users blocked by the authenticated user
    ///
    /// List the users you've blocked on your personal account.
    ///
    /// [GitHub API docs for list_blocked_by_authenticated_user](https://docs.github.com/rest/users/blocking#list-users-blocked-by-the-authenticated-user)
    ///
    /// ---
    #[cfg(not(target_arch = "wasm32"))]
    pub fn list_blocked_by_authenticated_user(&self, query_params: Option<impl Into<UsersListBlockedByAuthenticatedUserParams>>) -> Result<Vec<SimpleUser>, UsersListBlockedByAuthenticatedUserError> {

        let mut request_uri = format!("{}/user/blocks", super::GITHUB_BASE_API_URL);

        if let Some(params) = query_params {
            request_uri.push_str("?");
            let qp: UsersListBlockedByAuthenticatedUserParams = params.into();
            request_uri.push_str(&serde_urlencoded::to_string(qp)?);
        }

        let req = GitHubRequest {
            uri: request_uri,
            body: None,
            method: "GET",
            headers: vec![]
        };

        let request = GitHubRequestBuilder::build(req, self.auth)?;

        // --

        let github_response = crate::adapters::fetch(request)?;

        // --

        if github_response.is_success() {
            Ok(crate::adapters::to_json(github_response)?)
        } else {
            match github_response.status_code() {
                304 => Err(UsersListBlockedByAuthenticatedUserError::Status304),
                404 => Err(UsersListBlockedByAuthenticatedUserError::Status404(crate::adapters::to_json(github_response)?)),
                403 => Err(UsersListBlockedByAuthenticatedUserError::Status403(crate::adapters::to_json(github_response)?)),
                401 => Err(UsersListBlockedByAuthenticatedUserError::Status401(crate::adapters::to_json(github_response)?)),
                code => Err(UsersListBlockedByAuthenticatedUserError::Generic { code }),
            }
        }
    }

    /// ---
    ///
    /// # List email addresses for the authenticated user
    ///
    /// Lists all of your email addresses, and specifies which one is visible
    /// to the public.
    /// 
    /// OAuth app tokens and personal access tokens (classic) need the `user:email` scope to use this endpoint.
    ///
    /// [GitHub API docs for list_emails_for_authenticated_user](https://docs.github.com/rest/users/emails#list-email-addresses-for-the-authenticated-user)
    ///
    /// ---
    pub async fn list_emails_for_authenticated_user_async(&self, query_params: Option<impl Into<UsersListEmailsForAuthenticatedUserParams>>) -> Result<Vec<Email>, UsersListEmailsForAuthenticatedUserError> {

        let mut request_uri = format!("{}/user/emails", super::GITHUB_BASE_API_URL);

        if let Some(params) = query_params {
            request_uri.push_str("?");
            request_uri.push_str(&serde_urlencoded::to_string(params.into())?);
        }

        let req = GitHubRequest {
            uri: request_uri,
            body: None,
            method: "GET",
            headers: vec![]
        };

        let request = GitHubRequestBuilder::build(req, self.auth)?;

        // --

        let github_response = crate::adapters::fetch_async(request).await?;

        // --

        if github_response.is_success() {
            Ok(crate::adapters::to_json_async(github_response).await?)
        } else {
            match github_response.status_code() {
                304 => Err(UsersListEmailsForAuthenticatedUserError::Status304),
                404 => Err(UsersListEmailsForAuthenticatedUserError::Status404(crate::adapters::to_json_async(github_response).await?)),
                403 => Err(UsersListEmailsForAuthenticatedUserError::Status403(crate::adapters::to_json_async(github_response).await?)),
                401 => Err(UsersListEmailsForAuthenticatedUserError::Status401(crate::adapters::to_json_async(github_response).await?)),
                code => Err(UsersListEmailsForAuthenticatedUserError::Generic { code }),
            }
        }
    }

    /// ---
    ///
    /// # List email addresses for the authenticated user
    ///
    /// Lists all of your email addresses, and specifies which one is visible
    /// to the public.
    /// 
    /// OAuth app tokens and personal access tokens (classic) need the `user:email` scope to use this endpoint.
    ///
    /// [GitHub API docs for list_emails_for_authenticated_user](https://docs.github.com/rest/users/emails#list-email-addresses-for-the-authenticated-user)
    ///
    /// ---
    #[cfg(not(target_arch = "wasm32"))]
    pub fn list_emails_for_authenticated_user(&self, query_params: Option<impl Into<UsersListEmailsForAuthenticatedUserParams>>) -> Result<Vec<Email>, UsersListEmailsForAuthenticatedUserError> {

        let mut request_uri = format!("{}/user/emails", super::GITHUB_BASE_API_URL);

        if let Some(params) = query_params {
            request_uri.push_str("?");
            let qp: UsersListEmailsForAuthenticatedUserParams = params.into();
            request_uri.push_str(&serde_urlencoded::to_string(qp)?);
        }

        let req = GitHubRequest {
            uri: request_uri,
            body: None,
            method: "GET",
            headers: vec![]
        };

        let request = GitHubRequestBuilder::build(req, self.auth)?;

        // --

        let github_response = crate::adapters::fetch(request)?;

        // --

        if github_response.is_success() {
            Ok(crate::adapters::to_json(github_response)?)
        } else {
            match github_response.status_code() {
                304 => Err(UsersListEmailsForAuthenticatedUserError::Status304),
                404 => Err(UsersListEmailsForAuthenticatedUserError::Status404(crate::adapters::to_json(github_response)?)),
                403 => Err(UsersListEmailsForAuthenticatedUserError::Status403(crate::adapters::to_json(github_response)?)),
                401 => Err(UsersListEmailsForAuthenticatedUserError::Status401(crate::adapters::to_json(github_response)?)),
                code => Err(UsersListEmailsForAuthenticatedUserError::Generic { code }),
            }
        }
    }

    /// ---
    ///
    /// # List the people the authenticated user follows
    ///
    /// Lists the people who the authenticated user follows.
    ///
    /// [GitHub API docs for list_followed_by_authenticated_user](https://docs.github.com/rest/users/followers#list-the-people-the-authenticated-user-follows)
    ///
    /// ---
    pub async fn list_followed_by_authenticated_user_async(&self, query_params: Option<impl Into<UsersListFollowedByAuthenticatedUserParams>>) -> Result<Vec<SimpleUser>, UsersListFollowedByAuthenticatedUserError> {

        let mut request_uri = format!("{}/user/following", super::GITHUB_BASE_API_URL);

        if let Some(params) = query_params {
            request_uri.push_str("?");
            request_uri.push_str(&serde_urlencoded::to_string(params.into())?);
        }

        let req = GitHubRequest {
            uri: request_uri,
            body: None,
            method: "GET",
            headers: vec![]
        };

        let request = GitHubRequestBuilder::build(req, self.auth)?;

        // --

        let github_response = crate::adapters::fetch_async(request).await?;

        // --

        if github_response.is_success() {
            Ok(crate::adapters::to_json_async(github_response).await?)
        } else {
            match github_response.status_code() {
                304 => Err(UsersListFollowedByAuthenticatedUserError::Status304),
                403 => Err(UsersListFollowedByAuthenticatedUserError::Status403(crate::adapters::to_json_async(github_response).await?)),
                401 => Err(UsersListFollowedByAuthenticatedUserError::Status401(crate::adapters::to_json_async(github_response).await?)),
                code => Err(UsersListFollowedByAuthenticatedUserError::Generic { code }),
            }
        }
    }

    /// ---
    ///
    /// # List the people the authenticated user follows
    ///
    /// Lists the people who the authenticated user follows.
    ///
    /// [GitHub API docs for list_followed_by_authenticated_user](https://docs.github.com/rest/users/followers#list-the-people-the-authenticated-user-follows)
    ///
    /// ---
    #[cfg(not(target_arch = "wasm32"))]
    pub fn list_followed_by_authenticated_user(&self, query_params: Option<impl Into<UsersListFollowedByAuthenticatedUserParams>>) -> Result<Vec<SimpleUser>, UsersListFollowedByAuthenticatedUserError> {

        let mut request_uri = format!("{}/user/following", super::GITHUB_BASE_API_URL);

        if let Some(params) = query_params {
            request_uri.push_str("?");
            let qp: UsersListFollowedByAuthenticatedUserParams = params.into();
            request_uri.push_str(&serde_urlencoded::to_string(qp)?);
        }

        let req = GitHubRequest {
            uri: request_uri,
            body: None,
            method: "GET",
            headers: vec![]
        };

        let request = GitHubRequestBuilder::build(req, self.auth)?;

        // --

        let github_response = crate::adapters::fetch(request)?;

        // --

        if github_response.is_success() {
            Ok(crate::adapters::to_json(github_response)?)
        } else {
            match github_response.status_code() {
                304 => Err(UsersListFollowedByAuthenticatedUserError::Status304),
                403 => Err(UsersListFollowedByAuthenticatedUserError::Status403(crate::adapters::to_json(github_response)?)),
                401 => Err(UsersListFollowedByAuthenticatedUserError::Status401(crate::adapters::to_json(github_response)?)),
                code => Err(UsersListFollowedByAuthenticatedUserError::Generic { code }),
            }
        }
    }

    /// ---
    ///
    /// # List followers of the authenticated user
    ///
    /// Lists the people following the authenticated user.
    ///
    /// [GitHub API docs for list_followers_for_authenticated_user](https://docs.github.com/rest/users/followers#list-followers-of-the-authenticated-user)
    ///
    /// ---
    pub async fn list_followers_for_authenticated_user_async(&self, query_params: Option<impl Into<UsersListFollowersForAuthenticatedUserParams>>) -> Result<Vec<SimpleUser>, UsersListFollowersForAuthenticatedUserError> {

        let mut request_uri = format!("{}/user/followers", super::GITHUB_BASE_API_URL);

        if let Some(params) = query_params {
            request_uri.push_str("?");
            request_uri.push_str(&serde_urlencoded::to_string(params.into())?);
        }

        let req = GitHubRequest {
            uri: request_uri,
            body: None,
            method: "GET",
            headers: vec![]
        };

        let request = GitHubRequestBuilder::build(req, self.auth)?;

        // --

        let github_response = crate::adapters::fetch_async(request).await?;

        // --

        if github_response.is_success() {
            Ok(crate::adapters::to_json_async(github_response).await?)
        } else {
            match github_response.status_code() {
                304 => Err(UsersListFollowersForAuthenticatedUserError::Status304),
                403 => Err(UsersListFollowersForAuthenticatedUserError::Status403(crate::adapters::to_json_async(github_response).await?)),
                401 => Err(UsersListFollowersForAuthenticatedUserError::Status401(crate::adapters::to_json_async(github_response).await?)),
                code => Err(UsersListFollowersForAuthenticatedUserError::Generic { code }),
            }
        }
    }

    /// ---
    ///
    /// # List followers of the authenticated user
    ///
    /// Lists the people following the authenticated user.
    ///
    /// [GitHub API docs for list_followers_for_authenticated_user](https://docs.github.com/rest/users/followers#list-followers-of-the-authenticated-user)
    ///
    /// ---
    #[cfg(not(target_arch = "wasm32"))]
    pub fn list_followers_for_authenticated_user(&self, query_params: Option<impl Into<UsersListFollowersForAuthenticatedUserParams>>) -> Result<Vec<SimpleUser>, UsersListFollowersForAuthenticatedUserError> {

        let mut request_uri = format!("{}/user/followers", super::GITHUB_BASE_API_URL);

        if let Some(params) = query_params {
            request_uri.push_str("?");
            let qp: UsersListFollowersForAuthenticatedUserParams = params.into();
            request_uri.push_str(&serde_urlencoded::to_string(qp)?);
        }

        let req = GitHubRequest {
            uri: request_uri,
            body: None,
            method: "GET",
            headers: vec![]
        };

        let request = GitHubRequestBuilder::build(req, self.auth)?;

        // --

        let github_response = crate::adapters::fetch(request)?;

        // --

        if github_response.is_success() {
            Ok(crate::adapters::to_json(github_response)?)
        } else {
            match github_response.status_code() {
                304 => Err(UsersListFollowersForAuthenticatedUserError::Status304),
                403 => Err(UsersListFollowersForAuthenticatedUserError::Status403(crate::adapters::to_json(github_response)?)),
                401 => Err(UsersListFollowersForAuthenticatedUserError::Status401(crate::adapters::to_json(github_response)?)),
                code => Err(UsersListFollowersForAuthenticatedUserError::Generic { code }),
            }
        }
    }

    /// ---
    ///
    /// # List followers of a user
    ///
    /// Lists the people following the specified user.
    ///
    /// [GitHub API docs for list_followers_for_user](https://docs.github.com/rest/users/followers#list-followers-of-a-user)
    ///
    /// ---
    pub async fn list_followers_for_user_async(&self, username: &str, query_params: Option<impl Into<UsersListFollowersForUserParams>>) -> Result<Vec<SimpleUser>, UsersListFollowersForUserError> {

        let mut request_uri = format!("{}/users/{}/followers", super::GITHUB_BASE_API_URL, username);

        if let Some(params) = query_params {
            request_uri.push_str("?");
            request_uri.push_str(&serde_urlencoded::to_string(params.into())?);
        }

        let req = GitHubRequest {
            uri: request_uri,
            body: None,
            method: "GET",
            headers: vec![]
        };

        let request = GitHubRequestBuilder::build(req, self.auth)?;

        // --

        let github_response = crate::adapters::fetch_async(request).await?;

        // --

        if github_response.is_success() {
            Ok(crate::adapters::to_json_async(github_response).await?)
        } else {
            match github_response.status_code() {
                code => Err(UsersListFollowersForUserError::Generic { code }),
            }
        }
    }

    /// ---
    ///
    /// # List followers of a user
    ///
    /// Lists the people following the specified user.
    ///
    /// [GitHub API docs for list_followers_for_user](https://docs.github.com/rest/users/followers#list-followers-of-a-user)
    ///
    /// ---
    #[cfg(not(target_arch = "wasm32"))]
    pub fn list_followers_for_user(&self, username: &str, query_params: Option<impl Into<UsersListFollowersForUserParams>>) -> Result<Vec<SimpleUser>, UsersListFollowersForUserError> {

        let mut request_uri = format!("{}/users/{}/followers", super::GITHUB_BASE_API_URL, username);

        if let Some(params) = query_params {
            request_uri.push_str("?");
            let qp: UsersListFollowersForUserParams = params.into();
            request_uri.push_str(&serde_urlencoded::to_string(qp)?);
        }

        let req = GitHubRequest {
            uri: request_uri,
            body: None,
            method: "GET",
            headers: vec![]
        };

        let request = GitHubRequestBuilder::build(req, self.auth)?;

        // --

        let github_response = crate::adapters::fetch(request)?;

        // --

        if github_response.is_success() {
            Ok(crate::adapters::to_json(github_response)?)
        } else {
            match github_response.status_code() {
                code => Err(UsersListFollowersForUserError::Generic { code }),
            }
        }
    }

    /// ---
    ///
    /// # List the people a user follows
    ///
    /// Lists the people who the specified user follows.
    ///
    /// [GitHub API docs for list_following_for_user](https://docs.github.com/rest/users/followers#list-the-people-a-user-follows)
    ///
    /// ---
    pub async fn list_following_for_user_async(&self, username: &str, query_params: Option<impl Into<UsersListFollowingForUserParams>>) -> Result<Vec<SimpleUser>, UsersListFollowingForUserError> {

        let mut request_uri = format!("{}/users/{}/following", super::GITHUB_BASE_API_URL, username);

        if let Some(params) = query_params {
            request_uri.push_str("?");
            request_uri.push_str(&serde_urlencoded::to_string(params.into())?);
        }

        let req = GitHubRequest {
            uri: request_uri,
            body: None,
            method: "GET",
            headers: vec![]
        };

        let request = GitHubRequestBuilder::build(req, self.auth)?;

        // --

        let github_response = crate::adapters::fetch_async(request).await?;

        // --

        if github_response.is_success() {
            Ok(crate::adapters::to_json_async(github_response).await?)
        } else {
            match github_response.status_code() {
                code => Err(UsersListFollowingForUserError::Generic { code }),
            }
        }
    }

    /// ---
    ///
    /// # List the people a user follows
    ///
    /// Lists the people who the specified user follows.
    ///
    /// [GitHub API docs for list_following_for_user](https://docs.github.com/rest/users/followers#list-the-people-a-user-follows)
    ///
    /// ---
    #[cfg(not(target_arch = "wasm32"))]
    pub fn list_following_for_user(&self, username: &str, query_params: Option<impl Into<UsersListFollowingForUserParams>>) -> Result<Vec<SimpleUser>, UsersListFollowingForUserError> {

        let mut request_uri = format!("{}/users/{}/following", super::GITHUB_BASE_API_URL, username);

        if let Some(params) = query_params {
            request_uri.push_str("?");
            let qp: UsersListFollowingForUserParams = params.into();
            request_uri.push_str(&serde_urlencoded::to_string(qp)?);
        }

        let req = GitHubRequest {
            uri: request_uri,
            body: None,
            method: "GET",
            headers: vec![]
        };

        let request = GitHubRequestBuilder::build(req, self.auth)?;

        // --

        let github_response = crate::adapters::fetch(request)?;

        // --

        if github_response.is_success() {
            Ok(crate::adapters::to_json(github_response)?)
        } else {
            match github_response.status_code() {
                code => Err(UsersListFollowingForUserError::Generic { code }),
            }
        }
    }

    /// ---
    ///
    /// # List GPG keys for the authenticated user
    ///
    /// Lists the current user's GPG keys.
    /// 
    /// OAuth app tokens and personal access tokens (classic) need the `read:gpg_key` scope to use this endpoint.
    ///
    /// [GitHub API docs for list_gpg_keys_for_authenticated_user](https://docs.github.com/rest/users/gpg-keys#list-gpg-keys-for-the-authenticated-user)
    ///
    /// ---
    pub async fn list_gpg_keys_for_authenticated_user_async(&self, query_params: Option<impl Into<UsersListGpgKeysForAuthenticatedUserParams>>) -> Result<Vec<GpgKey>, UsersListGpgKeysForAuthenticatedUserError> {

        let mut request_uri = format!("{}/user/gpg_keys", super::GITHUB_BASE_API_URL);

        if let Some(params) = query_params {
            request_uri.push_str("?");
            request_uri.push_str(&serde_urlencoded::to_string(params.into())?);
        }

        let req = GitHubRequest {
            uri: request_uri,
            body: None,
            method: "GET",
            headers: vec![]
        };

        let request = GitHubRequestBuilder::build(req, self.auth)?;

        // --

        let github_response = crate::adapters::fetch_async(request).await?;

        // --

        if github_response.is_success() {
            Ok(crate::adapters::to_json_async(github_response).await?)
        } else {
            match github_response.status_code() {
                304 => Err(UsersListGpgKeysForAuthenticatedUserError::Status304),
                404 => Err(UsersListGpgKeysForAuthenticatedUserError::Status404(crate::adapters::to_json_async(github_response).await?)),
                403 => Err(UsersListGpgKeysForAuthenticatedUserError::Status403(crate::adapters::to_json_async(github_response).await?)),
                401 => Err(UsersListGpgKeysForAuthenticatedUserError::Status401(crate::adapters::to_json_async(github_response).await?)),
                code => Err(UsersListGpgKeysForAuthenticatedUserError::Generic { code }),
            }
        }
    }

    /// ---
    ///
    /// # List GPG keys for the authenticated user
    ///
    /// Lists the current user's GPG keys.
    /// 
    /// OAuth app tokens and personal access tokens (classic) need the `read:gpg_key` scope to use this endpoint.
    ///
    /// [GitHub API docs for list_gpg_keys_for_authenticated_user](https://docs.github.com/rest/users/gpg-keys#list-gpg-keys-for-the-authenticated-user)
    ///
    /// ---
    #[cfg(not(target_arch = "wasm32"))]
    pub fn list_gpg_keys_for_authenticated_user(&self, query_params: Option<impl Into<UsersListGpgKeysForAuthenticatedUserParams>>) -> Result<Vec<GpgKey>, UsersListGpgKeysForAuthenticatedUserError> {

        let mut request_uri = format!("{}/user/gpg_keys", super::GITHUB_BASE_API_URL);

        if let Some(params) = query_params {
            request_uri.push_str("?");
            let qp: UsersListGpgKeysForAuthenticatedUserParams = params.into();
            request_uri.push_str(&serde_urlencoded::to_string(qp)?);
        }

        let req = GitHubRequest {
            uri: request_uri,
            body: None,
            method: "GET",
            headers: vec![]
        };

        let request = GitHubRequestBuilder::build(req, self.auth)?;

        // --

        let github_response = crate::adapters::fetch(request)?;

        // --

        if github_response.is_success() {
            Ok(crate::adapters::to_json(github_response)?)
        } else {
            match github_response.status_code() {
                304 => Err(UsersListGpgKeysForAuthenticatedUserError::Status304),
                404 => Err(UsersListGpgKeysForAuthenticatedUserError::Status404(crate::adapters::to_json(github_response)?)),
                403 => Err(UsersListGpgKeysForAuthenticatedUserError::Status403(crate::adapters::to_json(github_response)?)),
                401 => Err(UsersListGpgKeysForAuthenticatedUserError::Status401(crate::adapters::to_json(github_response)?)),
                code => Err(UsersListGpgKeysForAuthenticatedUserError::Generic { code }),
            }
        }
    }

    /// ---
    ///
    /// # List GPG keys for a user
    ///
    /// Lists the GPG keys for a user. This information is accessible by anyone.
    ///
    /// [GitHub API docs for list_gpg_keys_for_user](https://docs.github.com/rest/users/gpg-keys#list-gpg-keys-for-a-user)
    ///
    /// ---
    pub async fn list_gpg_keys_for_user_async(&self, username: &str, query_params: Option<impl Into<UsersListGpgKeysForUserParams>>) -> Result<Vec<GpgKey>, UsersListGpgKeysForUserError> {

        let mut request_uri = format!("{}/users/{}/gpg_keys", super::GITHUB_BASE_API_URL, username);

        if let Some(params) = query_params {
            request_uri.push_str("?");
            request_uri.push_str(&serde_urlencoded::to_string(params.into())?);
        }

        let req = GitHubRequest {
            uri: request_uri,
            body: None,
            method: "GET",
            headers: vec![]
        };

        let request = GitHubRequestBuilder::build(req, self.auth)?;

        // --

        let github_response = crate::adapters::fetch_async(request).await?;

        // --

        if github_response.is_success() {
            Ok(crate::adapters::to_json_async(github_response).await?)
        } else {
            match github_response.status_code() {
                code => Err(UsersListGpgKeysForUserError::Generic { code }),
            }
        }
    }

    /// ---
    ///
    /// # List GPG keys for a user
    ///
    /// Lists the GPG keys for a user. This information is accessible by anyone.
    ///
    /// [GitHub API docs for list_gpg_keys_for_user](https://docs.github.com/rest/users/gpg-keys#list-gpg-keys-for-a-user)
    ///
    /// ---
    #[cfg(not(target_arch = "wasm32"))]
    pub fn list_gpg_keys_for_user(&self, username: &str, query_params: Option<impl Into<UsersListGpgKeysForUserParams>>) -> Result<Vec<GpgKey>, UsersListGpgKeysForUserError> {

        let mut request_uri = format!("{}/users/{}/gpg_keys", super::GITHUB_BASE_API_URL, username);

        if let Some(params) = query_params {
            request_uri.push_str("?");
            let qp: UsersListGpgKeysForUserParams = params.into();
            request_uri.push_str(&serde_urlencoded::to_string(qp)?);
        }

        let req = GitHubRequest {
            uri: request_uri,
            body: None,
            method: "GET",
            headers: vec![]
        };

        let request = GitHubRequestBuilder::build(req, self.auth)?;

        // --

        let github_response = crate::adapters::fetch(request)?;

        // --

        if github_response.is_success() {
            Ok(crate::adapters::to_json(github_response)?)
        } else {
            match github_response.status_code() {
                code => Err(UsersListGpgKeysForUserError::Generic { code }),
            }
        }
    }

    /// ---
    ///
    /// # List public email addresses for the authenticated user
    ///
    /// Lists your publicly visible email address, which you can set with the
    /// [Set primary email visibility for the authenticated user](https://docs.github.com/rest/users/emails#set-primary-email-visibility-for-the-authenticated-user)
    /// endpoint.
    /// 
    /// OAuth app tokens and personal access tokens (classic) need the `user:email` scope to use this endpoint.
    ///
    /// [GitHub API docs for list_public_emails_for_authenticated_user](https://docs.github.com/rest/users/emails#list-public-email-addresses-for-the-authenticated-user)
    ///
    /// ---
    pub async fn list_public_emails_for_authenticated_user_async(&self, query_params: Option<impl Into<UsersListPublicEmailsForAuthenticatedUserParams>>) -> Result<Vec<Email>, UsersListPublicEmailsForAuthenticatedUserError> {

        let mut request_uri = format!("{}/user/public_emails", super::GITHUB_BASE_API_URL);

        if let Some(params) = query_params {
            request_uri.push_str("?");
            request_uri.push_str(&serde_urlencoded::to_string(params.into())?);
        }

        let req = GitHubRequest {
            uri: request_uri,
            body: None,
            method: "GET",
            headers: vec![]
        };

        let request = GitHubRequestBuilder::build(req, self.auth)?;

        // --

        let github_response = crate::adapters::fetch_async(request).await?;

        // --

        if github_response.is_success() {
            Ok(crate::adapters::to_json_async(github_response).await?)
        } else {
            match github_response.status_code() {
                304 => Err(UsersListPublicEmailsForAuthenticatedUserError::Status304),
                404 => Err(UsersListPublicEmailsForAuthenticatedUserError::Status404(crate::adapters::to_json_async(github_response).await?)),
                403 => Err(UsersListPublicEmailsForAuthenticatedUserError::Status403(crate::adapters::to_json_async(github_response).await?)),
                401 => Err(UsersListPublicEmailsForAuthenticatedUserError::Status401(crate::adapters::to_json_async(github_response).await?)),
                code => Err(UsersListPublicEmailsForAuthenticatedUserError::Generic { code }),
            }
        }
    }

    /// ---
    ///
    /// # List public email addresses for the authenticated user
    ///
    /// Lists your publicly visible email address, which you can set with the
    /// [Set primary email visibility for the authenticated user](https://docs.github.com/rest/users/emails#set-primary-email-visibility-for-the-authenticated-user)
    /// endpoint.
    /// 
    /// OAuth app tokens and personal access tokens (classic) need the `user:email` scope to use this endpoint.
    ///
    /// [GitHub API docs for list_public_emails_for_authenticated_user](https://docs.github.com/rest/users/emails#list-public-email-addresses-for-the-authenticated-user)
    ///
    /// ---
    #[cfg(not(target_arch = "wasm32"))]
    pub fn list_public_emails_for_authenticated_user(&self, query_params: Option<impl Into<UsersListPublicEmailsForAuthenticatedUserParams>>) -> Result<Vec<Email>, UsersListPublicEmailsForAuthenticatedUserError> {

        let mut request_uri = format!("{}/user/public_emails", super::GITHUB_BASE_API_URL);

        if let Some(params) = query_params {
            request_uri.push_str("?");
            let qp: UsersListPublicEmailsForAuthenticatedUserParams = params.into();
            request_uri.push_str(&serde_urlencoded::to_string(qp)?);
        }

        let req = GitHubRequest {
            uri: request_uri,
            body: None,
            method: "GET",
            headers: vec![]
        };

        let request = GitHubRequestBuilder::build(req, self.auth)?;

        // --

        let github_response = crate::adapters::fetch(request)?;

        // --

        if github_response.is_success() {
            Ok(crate::adapters::to_json(github_response)?)
        } else {
            match github_response.status_code() {
                304 => Err(UsersListPublicEmailsForAuthenticatedUserError::Status304),
                404 => Err(UsersListPublicEmailsForAuthenticatedUserError::Status404(crate::adapters::to_json(github_response)?)),
                403 => Err(UsersListPublicEmailsForAuthenticatedUserError::Status403(crate::adapters::to_json(github_response)?)),
                401 => Err(UsersListPublicEmailsForAuthenticatedUserError::Status401(crate::adapters::to_json(github_response)?)),
                code => Err(UsersListPublicEmailsForAuthenticatedUserError::Generic { code }),
            }
        }
    }

    /// ---
    ///
    /// # List public keys for a user
    ///
    /// Lists the _verified_ public SSH keys for a user. This is accessible by anyone.
    ///
    /// [GitHub API docs for list_public_keys_for_user](https://docs.github.com/rest/users/keys#list-public-keys-for-a-user)
    ///
    /// ---
    pub async fn list_public_keys_for_user_async(&self, username: &str, query_params: Option<impl Into<UsersListPublicKeysForUserParams>>) -> Result<Vec<KeySimple>, UsersListPublicKeysForUserError> {

        let mut request_uri = format!("{}/users/{}/keys", super::GITHUB_BASE_API_URL, username);

        if let Some(params) = query_params {
            request_uri.push_str("?");
            request_uri.push_str(&serde_urlencoded::to_string(params.into())?);
        }

        let req = GitHubRequest {
            uri: request_uri,
            body: None,
            method: "GET",
            headers: vec![]
        };

        let request = GitHubRequestBuilder::build(req, self.auth)?;

        // --

        let github_response = crate::adapters::fetch_async(request).await?;

        // --

        if github_response.is_success() {
            Ok(crate::adapters::to_json_async(github_response).await?)
        } else {
            match github_response.status_code() {
                code => Err(UsersListPublicKeysForUserError::Generic { code }),
            }
        }
    }

    /// ---
    ///
    /// # List public keys for a user
    ///
    /// Lists the _verified_ public SSH keys for a user. This is accessible by anyone.
    ///
    /// [GitHub API docs for list_public_keys_for_user](https://docs.github.com/rest/users/keys#list-public-keys-for-a-user)
    ///
    /// ---
    #[cfg(not(target_arch = "wasm32"))]
    pub fn list_public_keys_for_user(&self, username: &str, query_params: Option<impl Into<UsersListPublicKeysForUserParams>>) -> Result<Vec<KeySimple>, UsersListPublicKeysForUserError> {

        let mut request_uri = format!("{}/users/{}/keys", super::GITHUB_BASE_API_URL, username);

        if let Some(params) = query_params {
            request_uri.push_str("?");
            let qp: UsersListPublicKeysForUserParams = params.into();
            request_uri.push_str(&serde_urlencoded::to_string(qp)?);
        }

        let req = GitHubRequest {
            uri: request_uri,
            body: None,
            method: "GET",
            headers: vec![]
        };

        let request = GitHubRequestBuilder::build(req, self.auth)?;

        // --

        let github_response = crate::adapters::fetch(request)?;

        // --

        if github_response.is_success() {
            Ok(crate::adapters::to_json(github_response)?)
        } else {
            match github_response.status_code() {
                code => Err(UsersListPublicKeysForUserError::Generic { code }),
            }
        }
    }

    /// ---
    ///
    /// # List public SSH keys for the authenticated user
    ///
    /// Lists the public SSH keys for the authenticated user's GitHub account.
    /// 
    /// OAuth app tokens and personal access tokens (classic) need the `read:public_key` scope to use this endpoint.
    ///
    /// [GitHub API docs for list_public_ssh_keys_for_authenticated_user](https://docs.github.com/rest/users/keys#list-public-ssh-keys-for-the-authenticated-user)
    ///
    /// ---
    pub async fn list_public_ssh_keys_for_authenticated_user_async(&self, query_params: Option<impl Into<UsersListPublicSshKeysForAuthenticatedUserParams>>) -> Result<Vec<Key>, UsersListPublicSshKeysForAuthenticatedUserError> {

        let mut request_uri = format!("{}/user/keys", super::GITHUB_BASE_API_URL);

        if let Some(params) = query_params {
            request_uri.push_str("?");
            request_uri.push_str(&serde_urlencoded::to_string(params.into())?);
        }

        let req = GitHubRequest {
            uri: request_uri,
            body: None,
            method: "GET",
            headers: vec![]
        };

        let request = GitHubRequestBuilder::build(req, self.auth)?;

        // --

        let github_response = crate::adapters::fetch_async(request).await?;

        // --

        if github_response.is_success() {
            Ok(crate::adapters::to_json_async(github_response).await?)
        } else {
            match github_response.status_code() {
                304 => Err(UsersListPublicSshKeysForAuthenticatedUserError::Status304),
                404 => Err(UsersListPublicSshKeysForAuthenticatedUserError::Status404(crate::adapters::to_json_async(github_response).await?)),
                403 => Err(UsersListPublicSshKeysForAuthenticatedUserError::Status403(crate::adapters::to_json_async(github_response).await?)),
                401 => Err(UsersListPublicSshKeysForAuthenticatedUserError::Status401(crate::adapters::to_json_async(github_response).await?)),
                code => Err(UsersListPublicSshKeysForAuthenticatedUserError::Generic { code }),
            }
        }
    }

    /// ---
    ///
    /// # List public SSH keys for the authenticated user
    ///
    /// Lists the public SSH keys for the authenticated user's GitHub account.
    /// 
    /// OAuth app tokens and personal access tokens (classic) need the `read:public_key` scope to use this endpoint.
    ///
    /// [GitHub API docs for list_public_ssh_keys_for_authenticated_user](https://docs.github.com/rest/users/keys#list-public-ssh-keys-for-the-authenticated-user)
    ///
    /// ---
    #[cfg(not(target_arch = "wasm32"))]
    pub fn list_public_ssh_keys_for_authenticated_user(&self, query_params: Option<impl Into<UsersListPublicSshKeysForAuthenticatedUserParams>>) -> Result<Vec<Key>, UsersListPublicSshKeysForAuthenticatedUserError> {

        let mut request_uri = format!("{}/user/keys", super::GITHUB_BASE_API_URL);

        if let Some(params) = query_params {
            request_uri.push_str("?");
            let qp: UsersListPublicSshKeysForAuthenticatedUserParams = params.into();
            request_uri.push_str(&serde_urlencoded::to_string(qp)?);
        }

        let req = GitHubRequest {
            uri: request_uri,
            body: None,
            method: "GET",
            headers: vec![]
        };

        let request = GitHubRequestBuilder::build(req, self.auth)?;

        // --

        let github_response = crate::adapters::fetch(request)?;

        // --

        if github_response.is_success() {
            Ok(crate::adapters::to_json(github_response)?)
        } else {
            match github_response.status_code() {
                304 => Err(UsersListPublicSshKeysForAuthenticatedUserError::Status304),
                404 => Err(UsersListPublicSshKeysForAuthenticatedUserError::Status404(crate::adapters::to_json(github_response)?)),
                403 => Err(UsersListPublicSshKeysForAuthenticatedUserError::Status403(crate::adapters::to_json(github_response)?)),
                401 => Err(UsersListPublicSshKeysForAuthenticatedUserError::Status401(crate::adapters::to_json(github_response)?)),
                code => Err(UsersListPublicSshKeysForAuthenticatedUserError::Generic { code }),
            }
        }
    }

    /// ---
    ///
    /// # List social accounts for the authenticated user
    ///
    /// Lists all of your social accounts.
    ///
    /// [GitHub API docs for list_social_accounts_for_authenticated_user](https://docs.github.com/rest/users/social-accounts#list-social-accounts-for-the-authenticated-user)
    ///
    /// ---
    pub async fn list_social_accounts_for_authenticated_user_async(&self, query_params: Option<impl Into<UsersListSocialAccountsForAuthenticatedUserParams>>) -> Result<Vec<SocialAccount>, UsersListSocialAccountsForAuthenticatedUserError> {

        let mut request_uri = format!("{}/user/social_accounts", super::GITHUB_BASE_API_URL);

        if let Some(params) = query_params {
            request_uri.push_str("?");
            request_uri.push_str(&serde_urlencoded::to_string(params.into())?);
        }

        let req = GitHubRequest {
            uri: request_uri,
            body: None,
            method: "GET",
            headers: vec![]
        };

        let request = GitHubRequestBuilder::build(req, self.auth)?;

        // --

        let github_response = crate::adapters::fetch_async(request).await?;

        // --

        if github_response.is_success() {
            Ok(crate::adapters::to_json_async(github_response).await?)
        } else {
            match github_response.status_code() {
                304 => Err(UsersListSocialAccountsForAuthenticatedUserError::Status304),
                404 => Err(UsersListSocialAccountsForAuthenticatedUserError::Status404(crate::adapters::to_json_async(github_response).await?)),
                403 => Err(UsersListSocialAccountsForAuthenticatedUserError::Status403(crate::adapters::to_json_async(github_response).await?)),
                401 => Err(UsersListSocialAccountsForAuthenticatedUserError::Status401(crate::adapters::to_json_async(github_response).await?)),
                code => Err(UsersListSocialAccountsForAuthenticatedUserError::Generic { code }),
            }
        }
    }

    /// ---
    ///
    /// # List social accounts for the authenticated user
    ///
    /// Lists all of your social accounts.
    ///
    /// [GitHub API docs for list_social_accounts_for_authenticated_user](https://docs.github.com/rest/users/social-accounts#list-social-accounts-for-the-authenticated-user)
    ///
    /// ---
    #[cfg(not(target_arch = "wasm32"))]
    pub fn list_social_accounts_for_authenticated_user(&self, query_params: Option<impl Into<UsersListSocialAccountsForAuthenticatedUserParams>>) -> Result<Vec<SocialAccount>, UsersListSocialAccountsForAuthenticatedUserError> {

        let mut request_uri = format!("{}/user/social_accounts", super::GITHUB_BASE_API_URL);

        if let Some(params) = query_params {
            request_uri.push_str("?");
            let qp: UsersListSocialAccountsForAuthenticatedUserParams = params.into();
            request_uri.push_str(&serde_urlencoded::to_string(qp)?);
        }

        let req = GitHubRequest {
            uri: request_uri,
            body: None,
            method: "GET",
            headers: vec![]
        };

        let request = GitHubRequestBuilder::build(req, self.auth)?;

        // --

        let github_response = crate::adapters::fetch(request)?;

        // --

        if github_response.is_success() {
            Ok(crate::adapters::to_json(github_response)?)
        } else {
            match github_response.status_code() {
                304 => Err(UsersListSocialAccountsForAuthenticatedUserError::Status304),
                404 => Err(UsersListSocialAccountsForAuthenticatedUserError::Status404(crate::adapters::to_json(github_response)?)),
                403 => Err(UsersListSocialAccountsForAuthenticatedUserError::Status403(crate::adapters::to_json(github_response)?)),
                401 => Err(UsersListSocialAccountsForAuthenticatedUserError::Status401(crate::adapters::to_json(github_response)?)),
                code => Err(UsersListSocialAccountsForAuthenticatedUserError::Generic { code }),
            }
        }
    }

    /// ---
    ///
    /// # List social accounts for a user
    ///
    /// Lists social media accounts for a user. This endpoint is accessible by anyone.
    ///
    /// [GitHub API docs for list_social_accounts_for_user](https://docs.github.com/rest/users/social-accounts#list-social-accounts-for-a-user)
    ///
    /// ---
    pub async fn list_social_accounts_for_user_async(&self, username: &str, query_params: Option<impl Into<UsersListSocialAccountsForUserParams>>) -> Result<Vec<SocialAccount>, UsersListSocialAccountsForUserError> {

        let mut request_uri = format!("{}/users/{}/social_accounts", super::GITHUB_BASE_API_URL, username);

        if let Some(params) = query_params {
            request_uri.push_str("?");
            request_uri.push_str(&serde_urlencoded::to_string(params.into())?);
        }

        let req = GitHubRequest {
            uri: request_uri,
            body: None,
            method: "GET",
            headers: vec![]
        };

        let request = GitHubRequestBuilder::build(req, self.auth)?;

        // --

        let github_response = crate::adapters::fetch_async(request).await?;

        // --

        if github_response.is_success() {
            Ok(crate::adapters::to_json_async(github_response).await?)
        } else {
            match github_response.status_code() {
                code => Err(UsersListSocialAccountsForUserError::Generic { code }),
            }
        }
    }

    /// ---
    ///
    /// # List social accounts for a user
    ///
    /// Lists social media accounts for a user. This endpoint is accessible by anyone.
    ///
    /// [GitHub API docs for list_social_accounts_for_user](https://docs.github.com/rest/users/social-accounts#list-social-accounts-for-a-user)
    ///
    /// ---
    #[cfg(not(target_arch = "wasm32"))]
    pub fn list_social_accounts_for_user(&self, username: &str, query_params: Option<impl Into<UsersListSocialAccountsForUserParams>>) -> Result<Vec<SocialAccount>, UsersListSocialAccountsForUserError> {

        let mut request_uri = format!("{}/users/{}/social_accounts", super::GITHUB_BASE_API_URL, username);

        if let Some(params) = query_params {
            request_uri.push_str("?");
            let qp: UsersListSocialAccountsForUserParams = params.into();
            request_uri.push_str(&serde_urlencoded::to_string(qp)?);
        }

        let req = GitHubRequest {
            uri: request_uri,
            body: None,
            method: "GET",
            headers: vec![]
        };

        let request = GitHubRequestBuilder::build(req, self.auth)?;

        // --

        let github_response = crate::adapters::fetch(request)?;

        // --

        if github_response.is_success() {
            Ok(crate::adapters::to_json(github_response)?)
        } else {
            match github_response.status_code() {
                code => Err(UsersListSocialAccountsForUserError::Generic { code }),
            }
        }
    }

    /// ---
    ///
    /// # List SSH signing keys for the authenticated user
    ///
    /// Lists the SSH signing keys for the authenticated user's GitHub account.
    /// 
    /// OAuth app tokens and personal access tokens (classic) need the `read:ssh_signing_key` scope to use this endpoint.
    ///
    /// [GitHub API docs for list_ssh_signing_keys_for_authenticated_user](https://docs.github.com/rest/users/ssh-signing-keys#list-ssh-signing-keys-for-the-authenticated-user)
    ///
    /// ---
    pub async fn list_ssh_signing_keys_for_authenticated_user_async(&self, query_params: Option<impl Into<UsersListSshSigningKeysForAuthenticatedUserParams>>) -> Result<Vec<SshSigningKey>, UsersListSshSigningKeysForAuthenticatedUserError> {

        let mut request_uri = format!("{}/user/ssh_signing_keys", super::GITHUB_BASE_API_URL);

        if let Some(params) = query_params {
            request_uri.push_str("?");
            request_uri.push_str(&serde_urlencoded::to_string(params.into())?);
        }

        let req = GitHubRequest {
            uri: request_uri,
            body: None,
            method: "GET",
            headers: vec![]
        };

        let request = GitHubRequestBuilder::build(req, self.auth)?;

        // --

        let github_response = crate::adapters::fetch_async(request).await?;

        // --

        if github_response.is_success() {
            Ok(crate::adapters::to_json_async(github_response).await?)
        } else {
            match github_response.status_code() {
                304 => Err(UsersListSshSigningKeysForAuthenticatedUserError::Status304),
                404 => Err(UsersListSshSigningKeysForAuthenticatedUserError::Status404(crate::adapters::to_json_async(github_response).await?)),
                403 => Err(UsersListSshSigningKeysForAuthenticatedUserError::Status403(crate::adapters::to_json_async(github_response).await?)),
                401 => Err(UsersListSshSigningKeysForAuthenticatedUserError::Status401(crate::adapters::to_json_async(github_response).await?)),
                code => Err(UsersListSshSigningKeysForAuthenticatedUserError::Generic { code }),
            }
        }
    }

    /// ---
    ///
    /// # List SSH signing keys for the authenticated user
    ///
    /// Lists the SSH signing keys for the authenticated user's GitHub account.
    /// 
    /// OAuth app tokens and personal access tokens (classic) need the `read:ssh_signing_key` scope to use this endpoint.
    ///
    /// [GitHub API docs for list_ssh_signing_keys_for_authenticated_user](https://docs.github.com/rest/users/ssh-signing-keys#list-ssh-signing-keys-for-the-authenticated-user)
    ///
    /// ---
    #[cfg(not(target_arch = "wasm32"))]
    pub fn list_ssh_signing_keys_for_authenticated_user(&self, query_params: Option<impl Into<UsersListSshSigningKeysForAuthenticatedUserParams>>) -> Result<Vec<SshSigningKey>, UsersListSshSigningKeysForAuthenticatedUserError> {

        let mut request_uri = format!("{}/user/ssh_signing_keys", super::GITHUB_BASE_API_URL);

        if let Some(params) = query_params {
            request_uri.push_str("?");
            let qp: UsersListSshSigningKeysForAuthenticatedUserParams = params.into();
            request_uri.push_str(&serde_urlencoded::to_string(qp)?);
        }

        let req = GitHubRequest {
            uri: request_uri,
            body: None,
            method: "GET",
            headers: vec![]
        };

        let request = GitHubRequestBuilder::build(req, self.auth)?;

        // --

        let github_response = crate::adapters::fetch(request)?;

        // --

        if github_response.is_success() {
            Ok(crate::adapters::to_json(github_response)?)
        } else {
            match github_response.status_code() {
                304 => Err(UsersListSshSigningKeysForAuthenticatedUserError::Status304),
                404 => Err(UsersListSshSigningKeysForAuthenticatedUserError::Status404(crate::adapters::to_json(github_response)?)),
                403 => Err(UsersListSshSigningKeysForAuthenticatedUserError::Status403(crate::adapters::to_json(github_response)?)),
                401 => Err(UsersListSshSigningKeysForAuthenticatedUserError::Status401(crate::adapters::to_json(github_response)?)),
                code => Err(UsersListSshSigningKeysForAuthenticatedUserError::Generic { code }),
            }
        }
    }

    /// ---
    ///
    /// # List SSH signing keys for a user
    ///
    /// Lists the SSH signing keys for a user. This operation is accessible by anyone.
    ///
    /// [GitHub API docs for list_ssh_signing_keys_for_user](https://docs.github.com/rest/users/ssh-signing-keys#list-ssh-signing-keys-for-a-user)
    ///
    /// ---
    pub async fn list_ssh_signing_keys_for_user_async(&self, username: &str, query_params: Option<impl Into<UsersListSshSigningKeysForUserParams>>) -> Result<Vec<SshSigningKey>, UsersListSshSigningKeysForUserError> {

        let mut request_uri = format!("{}/users/{}/ssh_signing_keys", super::GITHUB_BASE_API_URL, username);

        if let Some(params) = query_params {
            request_uri.push_str("?");
            request_uri.push_str(&serde_urlencoded::to_string(params.into())?);
        }

        let req = GitHubRequest {
            uri: request_uri,
            body: None,
            method: "GET",
            headers: vec![]
        };

        let request = GitHubRequestBuilder::build(req, self.auth)?;

        // --

        let github_response = crate::adapters::fetch_async(request).await?;

        // --

        if github_response.is_success() {
            Ok(crate::adapters::to_json_async(github_response).await?)
        } else {
            match github_response.status_code() {
                code => Err(UsersListSshSigningKeysForUserError::Generic { code }),
            }
        }
    }

    /// ---
    ///
    /// # List SSH signing keys for a user
    ///
    /// Lists the SSH signing keys for a user. This operation is accessible by anyone.
    ///
    /// [GitHub API docs for list_ssh_signing_keys_for_user](https://docs.github.com/rest/users/ssh-signing-keys#list-ssh-signing-keys-for-a-user)
    ///
    /// ---
    #[cfg(not(target_arch = "wasm32"))]
    pub fn list_ssh_signing_keys_for_user(&self, username: &str, query_params: Option<impl Into<UsersListSshSigningKeysForUserParams>>) -> Result<Vec<SshSigningKey>, UsersListSshSigningKeysForUserError> {

        let mut request_uri = format!("{}/users/{}/ssh_signing_keys", super::GITHUB_BASE_API_URL, username);

        if let Some(params) = query_params {
            request_uri.push_str("?");
            let qp: UsersListSshSigningKeysForUserParams = params.into();
            request_uri.push_str(&serde_urlencoded::to_string(qp)?);
        }

        let req = GitHubRequest {
            uri: request_uri,
            body: None,
            method: "GET",
            headers: vec![]
        };

        let request = GitHubRequestBuilder::build(req, self.auth)?;

        // --

        let github_response = crate::adapters::fetch(request)?;

        // --

        if github_response.is_success() {
            Ok(crate::adapters::to_json(github_response)?)
        } else {
            match github_response.status_code() {
                code => Err(UsersListSshSigningKeysForUserError::Generic { code }),
            }
        }
    }

    /// ---
    ///
    /// # Set primary email visibility for the authenticated user
    ///
    /// Sets the visibility for your primary email addresses.
    ///
    /// [GitHub API docs for set_primary_email_visibility_for_authenticated_user](https://docs.github.com/rest/users/emails#set-primary-email-visibility-for-the-authenticated-user)
    ///
    /// ---
    pub async fn set_primary_email_visibility_for_authenticated_user_async(&self, body: PatchUsersSetPrimaryEmailVisibilityForAuthenticatedUser) -> Result<Vec<Email>, UsersSetPrimaryEmailVisibilityForAuthenticatedUserError> {

        let request_uri = format!("{}/user/email/visibility", super::GITHUB_BASE_API_URL);


        let req = GitHubRequest {
            uri: request_uri,
            body: Some(PatchUsersSetPrimaryEmailVisibilityForAuthenticatedUser::from_json(body)?),
            method: "PATCH",
            headers: vec![]
        };

        let request = GitHubRequestBuilder::build(req, self.auth)?;

        // --

        let github_response = crate::adapters::fetch_async(request).await?;

        // --

        if github_response.is_success() {
            Ok(crate::adapters::to_json_async(github_response).await?)
        } else {
            match github_response.status_code() {
                304 => Err(UsersSetPrimaryEmailVisibilityForAuthenticatedUserError::Status304),
                404 => Err(UsersSetPrimaryEmailVisibilityForAuthenticatedUserError::Status404(crate::adapters::to_json_async(github_response).await?)),
                403 => Err(UsersSetPrimaryEmailVisibilityForAuthenticatedUserError::Status403(crate::adapters::to_json_async(github_response).await?)),
                401 => Err(UsersSetPrimaryEmailVisibilityForAuthenticatedUserError::Status401(crate::adapters::to_json_async(github_response).await?)),
                422 => Err(UsersSetPrimaryEmailVisibilityForAuthenticatedUserError::Status422(crate::adapters::to_json_async(github_response).await?)),
                code => Err(UsersSetPrimaryEmailVisibilityForAuthenticatedUserError::Generic { code }),
            }
        }
    }

    /// ---
    ///
    /// # Set primary email visibility for the authenticated user
    ///
    /// Sets the visibility for your primary email addresses.
    ///
    /// [GitHub API docs for set_primary_email_visibility_for_authenticated_user](https://docs.github.com/rest/users/emails#set-primary-email-visibility-for-the-authenticated-user)
    ///
    /// ---
    #[cfg(not(target_arch = "wasm32"))]
    pub fn set_primary_email_visibility_for_authenticated_user(&self, body: PatchUsersSetPrimaryEmailVisibilityForAuthenticatedUser) -> Result<Vec<Email>, UsersSetPrimaryEmailVisibilityForAuthenticatedUserError> {

        let request_uri = format!("{}/user/email/visibility", super::GITHUB_BASE_API_URL);


        let req = GitHubRequest {
            uri: request_uri,
            body: Some(PatchUsersSetPrimaryEmailVisibilityForAuthenticatedUser::from_json(body)?),
            method: "PATCH",
            headers: vec![]
        };

        let request = GitHubRequestBuilder::build(req, self.auth)?;

        // --

        let github_response = crate::adapters::fetch(request)?;

        // --

        if github_response.is_success() {
            Ok(crate::adapters::to_json(github_response)?)
        } else {
            match github_response.status_code() {
                304 => Err(UsersSetPrimaryEmailVisibilityForAuthenticatedUserError::Status304),
                404 => Err(UsersSetPrimaryEmailVisibilityForAuthenticatedUserError::Status404(crate::adapters::to_json(github_response)?)),
                403 => Err(UsersSetPrimaryEmailVisibilityForAuthenticatedUserError::Status403(crate::adapters::to_json(github_response)?)),
                401 => Err(UsersSetPrimaryEmailVisibilityForAuthenticatedUserError::Status401(crate::adapters::to_json(github_response)?)),
                422 => Err(UsersSetPrimaryEmailVisibilityForAuthenticatedUserError::Status422(crate::adapters::to_json(github_response)?)),
                code => Err(UsersSetPrimaryEmailVisibilityForAuthenticatedUserError::Generic { code }),
            }
        }
    }

    /// ---
    ///
    /// # Unblock a user
    ///
    /// Unblocks the given user and returns a 204.
    ///
    /// [GitHub API docs for unblock](https://docs.github.com/rest/users/blocking#unblock-a-user)
    ///
    /// ---
    pub async fn unblock_async(&self, username: &str) -> Result<(), UsersUnblockError> {

        let request_uri = format!("{}/user/blocks/{}", super::GITHUB_BASE_API_URL, username);


        let req = GitHubRequest {
            uri: request_uri,
            body: None,
            method: "DELETE",
            headers: vec![]
        };

        let request = GitHubRequestBuilder::build(req, self.auth)?;

        // --

        let github_response = crate::adapters::fetch_async(request).await?;

        // --

        if github_response.is_success() {
            Ok(crate::adapters::to_json_async(github_response).await?)
        } else {
            match github_response.status_code() {
                304 => Err(UsersUnblockError::Status304),
                403 => Err(UsersUnblockError::Status403(crate::adapters::to_json_async(github_response).await?)),
                401 => Err(UsersUnblockError::Status401(crate::adapters::to_json_async(github_response).await?)),
                404 => Err(UsersUnblockError::Status404(crate::adapters::to_json_async(github_response).await?)),
                code => Err(UsersUnblockError::Generic { code }),
            }
        }
    }

    /// ---
    ///
    /// # Unblock a user
    ///
    /// Unblocks the given user and returns a 204.
    ///
    /// [GitHub API docs for unblock](https://docs.github.com/rest/users/blocking#unblock-a-user)
    ///
    /// ---
    #[cfg(not(target_arch = "wasm32"))]
    pub fn unblock(&self, username: &str) -> Result<(), UsersUnblockError> {

        let request_uri = format!("{}/user/blocks/{}", super::GITHUB_BASE_API_URL, username);


        let req = GitHubRequest {
            uri: request_uri,
            body: None,
            method: "DELETE",
            headers: vec![]
        };

        let request = GitHubRequestBuilder::build(req, self.auth)?;

        // --

        let github_response = crate::adapters::fetch(request)?;

        // --

        if github_response.is_success() {
            Ok(crate::adapters::to_json(github_response)?)
        } else {
            match github_response.status_code() {
                304 => Err(UsersUnblockError::Status304),
                403 => Err(UsersUnblockError::Status403(crate::adapters::to_json(github_response)?)),
                401 => Err(UsersUnblockError::Status401(crate::adapters::to_json(github_response)?)),
                404 => Err(UsersUnblockError::Status404(crate::adapters::to_json(github_response)?)),
                code => Err(UsersUnblockError::Generic { code }),
            }
        }
    }

    /// ---
    ///
    /// # Unfollow a user
    ///
    /// OAuth app tokens and personal access tokens (classic) need the `user:follow` scope to use this endpoint.
    ///
    /// [GitHub API docs for unfollow](https://docs.github.com/rest/users/followers#unfollow-a-user)
    ///
    /// ---
    pub async fn unfollow_async(&self, username: &str) -> Result<(), UsersUnfollowError> {

        let request_uri = format!("{}/user/following/{}", super::GITHUB_BASE_API_URL, username);


        let req = GitHubRequest {
            uri: request_uri,
            body: None,
            method: "DELETE",
            headers: vec![]
        };

        let request = GitHubRequestBuilder::build(req, self.auth)?;

        // --

        let github_response = crate::adapters::fetch_async(request).await?;

        // --

        if github_response.is_success() {
            Ok(crate::adapters::to_json_async(github_response).await?)
        } else {
            match github_response.status_code() {
                304 => Err(UsersUnfollowError::Status304),
                404 => Err(UsersUnfollowError::Status404(crate::adapters::to_json_async(github_response).await?)),
                403 => Err(UsersUnfollowError::Status403(crate::adapters::to_json_async(github_response).await?)),
                401 => Err(UsersUnfollowError::Status401(crate::adapters::to_json_async(github_response).await?)),
                code => Err(UsersUnfollowError::Generic { code }),
            }
        }
    }

    /// ---
    ///
    /// # Unfollow a user
    ///
    /// OAuth app tokens and personal access tokens (classic) need the `user:follow` scope to use this endpoint.
    ///
    /// [GitHub API docs for unfollow](https://docs.github.com/rest/users/followers#unfollow-a-user)
    ///
    /// ---
    #[cfg(not(target_arch = "wasm32"))]
    pub fn unfollow(&self, username: &str) -> Result<(), UsersUnfollowError> {

        let request_uri = format!("{}/user/following/{}", super::GITHUB_BASE_API_URL, username);


        let req = GitHubRequest {
            uri: request_uri,
            body: None,
            method: "DELETE",
            headers: vec![]
        };

        let request = GitHubRequestBuilder::build(req, self.auth)?;

        // --

        let github_response = crate::adapters::fetch(request)?;

        // --

        if github_response.is_success() {
            Ok(crate::adapters::to_json(github_response)?)
        } else {
            match github_response.status_code() {
                304 => Err(UsersUnfollowError::Status304),
                404 => Err(UsersUnfollowError::Status404(crate::adapters::to_json(github_response)?)),
                403 => Err(UsersUnfollowError::Status403(crate::adapters::to_json(github_response)?)),
                401 => Err(UsersUnfollowError::Status401(crate::adapters::to_json(github_response)?)),
                code => Err(UsersUnfollowError::Generic { code }),
            }
        }
    }

    /// ---
    ///
    /// # Update the authenticated user
    ///
    /// **Note:** If your email is set to private and you send an `email` parameter as part of this request to update your profile, your privacy settings are still enforced: the email address will not be displayed on your public profile or via the API.
    ///
    /// [GitHub API docs for update_authenticated](https://docs.github.com/rest/users/users#update-the-authenticated-user)
    ///
    /// ---
    pub async fn update_authenticated_async(&self, body: PatchUsersUpdateAuthenticated) -> Result<PrivateUser, UsersUpdateAuthenticatedError> {

        let request_uri = format!("{}/user", super::GITHUB_BASE_API_URL);


        let req = GitHubRequest {
            uri: request_uri,
            body: Some(PatchUsersUpdateAuthenticated::from_json(body)?),
            method: "PATCH",
            headers: vec![]
        };

        let request = GitHubRequestBuilder::build(req, self.auth)?;

        // --

        let github_response = crate::adapters::fetch_async(request).await?;

        // --

        if github_response.is_success() {
            Ok(crate::adapters::to_json_async(github_response).await?)
        } else {
            match github_response.status_code() {
                304 => Err(UsersUpdateAuthenticatedError::Status304),
                404 => Err(UsersUpdateAuthenticatedError::Status404(crate::adapters::to_json_async(github_response).await?)),
                403 => Err(UsersUpdateAuthenticatedError::Status403(crate::adapters::to_json_async(github_response).await?)),
                401 => Err(UsersUpdateAuthenticatedError::Status401(crate::adapters::to_json_async(github_response).await?)),
                422 => Err(UsersUpdateAuthenticatedError::Status422(crate::adapters::to_json_async(github_response).await?)),
                code => Err(UsersUpdateAuthenticatedError::Generic { code }),
            }
        }
    }

    /// ---
    ///
    /// # Update the authenticated user
    ///
    /// **Note:** If your email is set to private and you send an `email` parameter as part of this request to update your profile, your privacy settings are still enforced: the email address will not be displayed on your public profile or via the API.
    ///
    /// [GitHub API docs for update_authenticated](https://docs.github.com/rest/users/users#update-the-authenticated-user)
    ///
    /// ---
    #[cfg(not(target_arch = "wasm32"))]
    pub fn update_authenticated(&self, body: PatchUsersUpdateAuthenticated) -> Result<PrivateUser, UsersUpdateAuthenticatedError> {

        let request_uri = format!("{}/user", super::GITHUB_BASE_API_URL);


        let req = GitHubRequest {
            uri: request_uri,
            body: Some(PatchUsersUpdateAuthenticated::from_json(body)?),
            method: "PATCH",
            headers: vec![]
        };

        let request = GitHubRequestBuilder::build(req, self.auth)?;

        // --

        let github_response = crate::adapters::fetch(request)?;

        // --

        if github_response.is_success() {
            Ok(crate::adapters::to_json(github_response)?)
        } else {
            match github_response.status_code() {
                304 => Err(UsersUpdateAuthenticatedError::Status304),
                404 => Err(UsersUpdateAuthenticatedError::Status404(crate::adapters::to_json(github_response)?)),
                403 => Err(UsersUpdateAuthenticatedError::Status403(crate::adapters::to_json(github_response)?)),
                401 => Err(UsersUpdateAuthenticatedError::Status401(crate::adapters::to_json(github_response)?)),
                422 => Err(UsersUpdateAuthenticatedError::Status422(crate::adapters::to_json(github_response)?)),
                code => Err(UsersUpdateAuthenticatedError::Generic { code }),
            }
        }
    }

}
